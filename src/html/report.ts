export const report = '<!doctype html>\n<head>\n    <title>CPUpro</title>\n    <meta charset="utf-8"/>\n    <meta name="viewport">\n    <meta name="format-detection" content="telephone=no">\n    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAAC1ay+zAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgoZXuEHAAAMyUlEQVR4Ae2bechWVRPAz+ua5laapQipqYWgaBkUkr5I5kKClaJi2R+moqBgKvSHGQVqKu4gaqaIRn+4FYGVCopri6WSivtOuedSVpre5jd8cznPfe72+tmHr34D57n3njNnzsycOXPmLE+Jcy6QFEJpaakbMWKEa9mypXvkkUdc5cqVw7Ly+HLjxg137tw5t3fvXjdr1iy3YcOGAjFK5CtUwKpVq9yLL77oatSo4f744w939epVd+vWLVdSUuKCIEQrIHC3fhjPFSpUcDVr1nTVqlVzv/32m1u3bp175ZVXCthGsuCbb74RGYPgwoULwSeffBI8//zzmk9ZeU/IgkzIBiCrJ5MLpOe14NChQ0GLFi38wnvqHdmQEUBmVYKM+UBMPTh//vw9Lbz1OEpAVmRGdrdy5UrVCCZiSPf6E1kBZHf79u0Lrl27Fjz33HP3jQKQFZmRvQTH8Pfff7tHH31UOv7+gTNnzrhKlSq5Sszz169fL5PkY8aMcW3atNE4gWlSxpT78ccf3bRp0xLp9OnTxz344IPaFnV84Fs6wq1du9bPLngfNmyYO3r0qPvyyy8L8uM++vbt62rXru3mzZsXV6x5tKkxzpUrV4Jffvkll/m///77gTARiMJ0DPk/f/31V3D8+PFgwoQJsbTOnj2rZofpUR98P8kcrXzIPF1U/9NPP9WmDhw4UFQm0hTl0ZYIGLz33ntFZYaPzMheKVFFkYLly5e7l19+2VWsWNGdOnXKff/999ojBBrNmjVz7dq1cw0aNHCjRo1yjz/+uOvfv38BBSKymzdvalQmDSsdkUqDLGg+/PDD7qGHHnIdO3Z0+/fvd08++WRYnyFKj0EjD4Bv7WXi57GAGTNmaG/RS2KCiVrduHFjAM7vv/8eDB06tADv5MmT2vNTpkwpyBcGw+8VK1YEly5dUryPP/44zF+yZEkgygv27NkT5vn1ou8///yz8jt27NhEfLOACpkaEgTGFPDdd9+5bt266XvcT4cOHdQ6HnjgATd48OACFEJTAMeTBK+99po7cuSIWkXbtm1DNOpaCjNzvFibaaiZCvjoo4/UPH/99VfXqVOnNFpa9tlnnzkZ565OnTqxuFlM/fTTTzo8iN0NsuoY3u08MxXwzDPPaK/t3r07F/133nlHFx9NmjSJxc8SpkqVKloP//C/gEwFsCTGeeVVQBbTWY4MZ4oTw1Ea/JvKyFQA4xmGZIozfv6rJ0vTOOjXr5/bvn27BmQI7McE/6YCkj2ScNm+fXs1f6YgmbPj+M6dx3T5559/Ohwd63F/KFBGkMR0iLBbtmxx7777bkjbxw0z79BLqgJgBJPFITFH3wlAQOtRe6JgCV7cxYsX3fr1693IkSOLmjLcooKUjDx1UhUAbXoN4Zs2bZrSVGHRsmXLHM6MoEjW31qIkAwnWYk5iREKK2R85REkjkQey8n0AeynYaKtWrWKa6Moj/n/1VdfdV26dHFxM4EESUV1sjJwwijBZogsfGIN8LMcLnQyFYBjwgk2b97cvfTSS1ltu+7du+uscezYsQJHZhVvZ5P19OnTykOeYfjWW2+pP8FnHTx40JpNfuYJhQkbZZM0MxTt2rVrIBajoWx0g0XWD5o/ffr0xPBUuIwtE+sLJBDTxdTnn38ei2N1N23apGHwiRMnUvHKFAovXrxYvXbjxo01HoizhOHDhzuixlq1ajkhXrQYut1xTNcRHbKtjWkTbi9dupTsIpC1hGvdurUO2a1btxaVx2bksQCpGMyfP18XOjKudBm5c+fOQObqgOWrMKe9I0MlYCESt6NMPguamTNnpvYMbSUllsO0zzKaxRW9DQ8swvgmn3JZqSbSMNpmAURcufcD3njjjWDHjh1qjghrwPpexmmwZs2axIbZjaWtDz/8MBHHmEt7yrI8wLzZV5CZxVjQb/YjWDmm1bcyU0AJTOGZWcvnBdb7eHrMHQcpvesWLVqUt/odwSOYYs+AmQFvL9bhGAJ5gWFK8HVbCsjbyN2MZwrInAbvZiHuBG//V8Cd0GJ5pnHfW4AuhvxFAyFs9erVNZwtzz0b5Z2lNlt1BHOAyVy0GkR4U4AhaY1y/EMUigLioEgBrLwsoQAqk7IA3DiFsQzOA0n1o3XT+EmiYfwjVxSKFGBETBjib1ZwELE8n4gxREBEA1YfHMrYA2A5nVWfutDw6/vt8A4OvNiyGJqA8cURH0FRXG8n0S1SgFKUH4gjvESKutcPUWvIcHiSz45R3bp1dTeYqzU+Y3KUpldToBUHKIf6nAxxnscGTFRZfJOI3C5fvuwkHNelLrtIQP369XW5/tRTTykNxnqSwEU8EAoTx0uBJt7J49RYmAnkUlFYZjhJT9kJ0osHnO7I9pa+y52j3PUXLFig6wwRUp/QYRnMk9Omr776KpPW119/rbh+XWgkyRnfLf9RE1r3zYmDEXoaMzMNHz582O3atUtr9O7d282dO9cNGDBAL1mRyba6ASfEbFT4loSPkDW+orCZIWf2bty4cfpN+wDWI6vRgr1C2mnUqJGWy0ow3GZjJ0pWnG7gwIHKp9FQxLifJM1gAWyCsOSUeppkitQ8eoh6JLTLMrVnz54hHhcPOCMEjxUk9SdNmqQbIn5do8Fp7gcffBDWl81YbYfNFazQ31xhNWn5lFkizz+Z5kSZMiwxzQLKFAjhhCzRc+bhmVunTp0a6tc2L8IMebF69rT6OD6u5Q0ZMiREN4uqWrWqo3ftpFmO59UKyGcF6yfy3n777dB6OGfgFBuHaXyGDXgvZVKAb068W5Le1qEhW2JKWnojdIReW/pqNKwuw0F6SmeL119/XXGgB9OYvozpkMSgQYP0goV5eoanJfJIviJlf0JphARiXsqkAOob4/7T8rkpAvh+QzPkB3yE8p+8YxE2TVrPc10H4fHmjGdA9hJ1pmCqi6NPHmX4KLPGOXPmKA3oJ0GqE4xWgqm4mIDpiSsy7CADDRs2jFZ1mCgRpjlPc4QoAeZXr16te39U5PoN5TJ2w51d8sDNA3a0znkmNJgmk4ZBmRQgTktNFU1br2F227ZtK9gy5wyBfISghwH8wrfffqvmbkqADjTl5qabPHmy4s2ePds98cQTWp+hYMBsghCmOMv3n5SB48880HjsscdCPnx83jMV4GudHdcsYNzVq1dPTQ8HhJDAwoULNaXV59SoV69eekcZq7K61Ml7ngC/Pm502o22n6mAaIWkbzwwToxojGjQxp2NV77l0lIYB8AoeeDamMXbc9+Im+pYDkPGAEeZ1vuGBw40DaDhd6Ll2zNTAX6jmDHjyczbiCAkPQbAqA0Pvi1ulzhAzwphzqcJDoeh9DxDgQBGYg/tRf8onY1XNkHThDGlst9nAA2UGW3TypPdo2F4T7SJoDz9hJAIbsJ7VUKGMWfKUYDh8sTT4/UnTpyo1XBc3BkEuGZjU+vmzZtDWpT5ivDf8QFyTgCK69Gjhx7s2iJLMyM/ZVIAhOKSOScz+0gb+kkPkMCxd/tGERbWgoxjBJg53nzzTX0fP368k/MAVXxUIOiQR6eAI9Gi1mFI0jm+grTA+ymTAqKMI4wvkEc389VogQiDRIMGKAS6OLDS0lLLdqNHj1aLwQpRup/Iw5r8uwUco2F5tJUEmQpIq5xE1M9HECCJDvkogBjDrICpi3r4GoaBmfQXX3yhYTELMDw9y2j2G3jnHgLX+ewqLUOGulF/5fPGe6oThDm0bJBmSoYTfdKbACaaBNBFCBRA/I4f4MYoSsBnPPvssxoSs9KTJbEmTqaefvppJfnDDz84/u5jwFTM7TYsAgedxneqBRhjRth6077zPO3IjWO0JEZQMgrgKi7AtVwiOKyCTkAJmDNXaJluAbnr7+QmqCYTnhspHJG98MILWicPv3o0hqaIlgAuI+BMbOrgaeMIhwJRBEkyaSUiP4bDOIYGApIs3/B4Wp61hUJwgCjAyiwPfBZb8GmRIv4D/pmiwadNX3jysIQ4OVOHgFW0OR4mjCEYSQMb24xRe6d+nOKs3I8nom0hEIIBLHiYOo0WPDHEbLj5wqfxSFmlqJPwx6oxRs8AfFujmpHxAy6CGKTVpQxBrC3qRPFNMHj0w2RwKbNyvuMgKhuyV8CciJbsHvAxORjB/ECGIR/4LmsqS30fl/ektigzge2Zho8syHRMZAOQFZmRvQLhLdMJmw0A/xrlvh5OC5O8FxKyIBOyAciKzMheUip/HWN+ZXx17txZt5yZXvibaWPZ6sIRlWeg9+l5hGfPgr0CruFiEYTKQMEfJwUh3Jyk7F5KyFb0x0kT0P46y58K2VGVcXLPCI8syIRsgP/XWYLk0NMRUET/PI0jKs/ATILDY8wTN0T/PF2gAAQVn3Bf/X3+H1hhRyO6zAIaAAAAAElFTkSuQmCC">\n    <style type="discovery/style" src="model.css">/* node_modules/@discoveryjs/discovery/src/views/controls/button.css */\n.view-button {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n  padding: 8px 12px;\n  outline: none;\n  margin: 0;\n  color: var(--discovery-view-button-color);\n  background-color: var(--discovery-view-button-background-color);\n  border: 1px solid var(--discovery-view-button-border-color);\n  border-radius: 3px;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: 1.2;\n  text-align: center;\n  cursor: pointer;\n  --discovery-view-button-color: var(--discovery-color);\n  --discovery-view-button-background-color: rgba(255, 255, 255, .1);\n  --discovery-view-button-border-color: rgba(127, 127, 127, 0.4);\n  --discovery-view-button-hover-background-color: rgba(221, 221, 221, 0.3);\n  --discovery-view-button-hover-border-color: rgba(170, 170, 170, 0.6);\n  --discovery-view-button-active-background-color: rgba(131, 131, 131, 0.25);\n  --discovery-view-button-active-border-color: var(--discovery-view-button-border-color);\n  --discovery-view-button-focus-background-color: var(--discovery-view-button-background-color);\n  --discovery-view-button-focus-border-color: rgba(128, 128, 128, 0.6);\n}\n.view-button:empty::before {\n  content: "|";\n  width: 0;\n  visibility: hidden;\n}\n.view-button:focus-visible {\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, 0.2);\n  background-color: var(--discovery-view-button-focus-background-color);\n  border-color: var(--discovery-view-button-focus-border-color);\n  z-index: 1;\n}\n.view-button:hover,\n.view-button.discovery-view-popup-active {\n  background-color: var(--discovery-view-button-hover-background-color);\n  border-color: var(--discovery-view-button-hover-border-color);\n}\n.view-button:active {\n  background-color: var(--discovery-view-button-active-background-color);\n  border-color: var(--discovery-view-button-active-border-color);\n}\n.view-button[disabled] {\n  opacity: .5;\n  pointer-events: none;\n  cursor: default;\n}\n.view-button + .view-button {\n  margin-left: 1ex;\n}\n.view-button-primary {\n  --discovery-view-button-color: white;\n  --discovery-view-button-background-color: #00aaff;\n  --discovery-view-button-border-color: transparent;\n  --discovery-view-button-hover-background-color: #009cf0;\n  --discovery-view-button-hover-border-color: transparent;\n  --discovery-view-button-active-background-color: #008ee0;\n  --discovery-view-button-focus-border-color: transparent;\n}\n.discovery-root-darkmode .view-button-primary {\n  --discovery-view-button-color: #fffd;\n  --discovery-view-button-background-color: #006aa3e6;\n  --discovery-view-button-hover-background-color: #0074b3e6;\n  --discovery-view-button-active-background-color: #006aa3d0;\n}\n.view-button-danger {\n  --discovery-view-button-color: white;\n  --discovery-view-button-background-color: #ff6163;\n  --discovery-view-button-border-color: transparent;\n  --discovery-view-button-hover-background-color: #f05456;\n  --discovery-view-button-hover-border-color: transparent;\n  --discovery-view-button-active-background-color: #e34449;\n  --discovery-view-button-focus-border-color: transparent;\n}\n.discovery-root-darkmode .view-button-danger {\n  --discovery-view-button-color: #fffd;\n  --discovery-view-button-background-color: #c32224bf;\n  --discovery-view-button-hover-background-color: #d02528bf;\n  --discovery-view-button-active-background-color: #c32224a6;\n}\n.view-button-warning {\n  --discovery-view-button-color: rgba(0, 0, 0, .84);\n  --discovery-view-button-background-color: #ffcf21;\n  --discovery-view-button-border-color: transparent;\n  --discovery-view-button-hover-background-color: #fcbd00;\n  --discovery-view-button-hover-border-color: transparent;\n  --discovery-view-button-active-background-color: #f7ad00;\n  --discovery-view-button-focus-border-color: transparent;\n}\n.discovery-root-darkmode .view-button-warning {\n  --discovery-view-button-color: #eeee;\n  --discovery-view-button-background-color: #ffd40199;\n  --discovery-view-button-hover-background-color: #ffd91aa6;\n  --discovery-view-button-active-background-color: #ffd4018e;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/checkbox-list.css */\n.view-checkbox-list > .view-checkbox {\n  display: block;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/checkbox.css */\n.view-checkbox {\n  --discovery-checkbox-size: max(1em, 14px);\n  padding-left: var(--discovery-checkbox-size);\n}\n.view-checkbox > input {\n  -webkit-appearance: none;\n  appearance: none;\n  content: "";\n  font-size: inherit;\n  display: inline-block;\n  position: relative;\n  top: 2px;\n  box-sizing: border-box;\n  height: var(--discovery-checkbox-size);\n  width: var(--discovery-checkbox-size);\n  margin: 0;\n  margin-left: calc(-1 * var(--discovery-checkbox-size));\n  background-color: rgba(255, 255, 255, .2);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: calc(.57 * var(--discovery-checkbox-size));\n  border: 1px solid rgba(151, 162, 172, 0.65);\n  border-radius: 3px;\n  outline: none;\n  transition:\n    background-color 0.15s ease-in-out,\n    border-color 0.15s ease-in-out,\n    box-shadow 0.15s ease-in-out;\n}\n.view-checkbox > input:checked {\n  border-color: transparent;\n  background-color: rgba(0, 121, 232, 0.68);\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 8">%0A    <path fill="%23fff" d="M6.564.75l-3.59 3.612-1.538-1.55L0 4.26l2.974 2.99L8 2.193z"/>%0A</svg>%0A\');\n}\n.view-checkbox > input:focus-visible {\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, .2);\n}\n.view-checkbox > input:focus-visible:not(:checked) {\n  border-color: rgba(0, 141, 255, 0.75);\n}\n.view-checkbox > input:active {\n  border-color: transparent;\n  background-color: rgba(25, 139, 236, .6);\n}\n.view-checkbox > input[readonly],\n.view-checkbox > input:disabled {\n  box-shadow: none;\n  border-color: rgba(165, 165, 165, 0.1);\n  background-color: rgba(165, 165, 165, 0.3);\n}\n.view-checkbox__label {\n  margin-left: 5px;\n  margin-right: 15px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/content-filter.css */\n.view-content-filter > .view-input {\n  position: relative;\n  z-index: 9;\n  line-height: 1;\n  margin-bottom: 1em;\n}\n.view-content-filter > .view-input input {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50">%0A    <path fill="rgba(150, 150, 150, 0.65)" d="M 21 3 C 11.601563 3 4 10.601563 4 20 C 4 29.398438 11.601563 37 21 37 C 24.355469 37 27.460938 36.015625 30.09375 34.34375 L 42.375 46.625 L 46.625 42.375 L 34.5 30.28125 C 36.679688 27.421875 38 23.878906 38 20 C 38 10.601563 30.398438 3 21 3 Z M 21 7 C 28.199219 7 34 12.800781 34 20 C 34 27.199219 28.199219 33 21 33 C 13.800781 33 8 27.199219 8 20 C 8 12.800781 13.800781 7 21 7 Z "></path>%0A</svg>%0A\');\n  background-repeat: no-repeat;\n  background-size: 32px 16px;\n  background-position: right center;\n  padding-right: 30px;\n}\n.view-content-filter > .content {\n  overflow: auto;\n  flex: 1;\n}\n.view-content-filter > .content .view-list::before {\n  padding: 5px 10px;\n  display: block;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/dropdown.css */\n.view-dropdown {\n  box-sizing: border-box;\n  position: relative;\n  display: inline-flex;\n  overflow: hidden;\n  flex-shrink: 0;\n  align-items: center;\n  min-width: 10ex;\n  max-width: 100%;\n  padding-right: 1.2em;\n  line-height: 1.2;\n  border-radius: 3px;\n  border: 1px solid rgba(127, 127, 127, 0.4);\n  background-color: rgba(255, 255, 255, .1);\n  color: var(--discovery-color);\n  outline: none;\n}\n.view-dropdown::after {\n  content: "";\n  right: 7px;\n  color: #999999;\n  display: flex;\n  align-items: center;\n  flex-shrink: 0;\n  pointer-events: none;\n  position: absolute;\n  width: 1em;\n  height: 1em;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28">%0A    <path fill="%23888" d="M19,15.9393398 L24.4696699,10.4696699 C24.7625631,10.1767767 25.2374369,10.1767767 25.5303301,10.4696699 C25.8232233,10.7625631 25.8232233,11.2374369 25.5303301,11.5303301 L19.5303301,17.5303301 C19.2374369,17.8232233 18.7625631,17.8232233 18.4696699,17.5303301 L12.4696699,11.5303301 C12.1767767,11.2374369 12.1767767,10.7625631 12.4696699,10.4696699 C12.7625631,10.1767767 13.2374369,10.1767767 13.5303301,10.4696699 L19,15.9393398 Z" />%0A</svg>%0A\');\n  background-size: 1em;\n  background-position: center;\n  cursor: pointer;\n}\n.view-dropdown.discovery-view-popup-active,\n.view-dropdown:focus {\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, .2), inset 0 1px 1px rgba(142, 142, 142, .2);\n  border-color: rgba(128, 128, 128, 0.6);\n  z-index: 1;\n}\n.view-dropdown:hover {\n  background-color: rgba(221, 221, 221, 0.3);\n  border-color: rgba(170, 170, 170, 0.6);\n}\n.view-dropdown:active {\n  background-color: rgba(131, 131, 131, 0.25);\n}\n.view-dropdown__caption {\n  padding: 8px 8px 8px 12px;\n}\n.view-dropdown:not([data-placeholder]):empty .view-dropdown__caption::before {\n  content: "|";\n  visibility: hidden;\n  padding: 8px 0;\n}\n.view-dropdown[data-placeholder]:empty .view-dropdown__caption::before {\n  content: attr(data-placeholder);\n  visibility: visible;\n  padding: 8px 8px 8px 12px;\n  color: #bbb;\n}\n.view-dropdown > * {\n  pointer-events: none;\n}\n.discovery-view-popup.view-dropdown-popup {\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n}\n.discovery-view-popup.view-dropdown-popup > .content {\n  gap: 5px;\n  padding: 8px;\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow: hidden;\n  overflow-y: scroll;\n}\n.discovery-view-popup.view-dropdown-popup > .confirm {\n  padding: 8px;\n  background-color: rgba(0, 0, 0, .2);\n  font-size: 80%;\n  text-align: right;\n}\n.discovery-view-popup.view-dropdown-popup > .confirm .view-button {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/input.css */\n.view-input input {\n  position: relative;\n  width: 100%;\n  box-sizing: border-box;\n  margin: 0;\n  padding: 8px 12px;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: 1.2;\n  border: 1px solid rgba(153, 153, 153, 0.5);\n  border-radius: 3px;\n  background-color: rgba(255, 255, 255, .05);\n  color: var(--discovery-color);\n  outline: 0;\n}\n.view-input input:hover {\n  border-color: rgba(153, 153, 153, 0.75);\n}\n.view-input input:focus {\n  border-color: rgba(0, 170, 255, .65);\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, .2), inset 0 1px 1px rgba(142, 142, 142, .2);\n  z-index: 1;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/menu-item.css */\n.view-menu-item {\n  display: block;\n  padding: 4px 12px;\n  color: inherit;\n  text-decoration: none;\n  cursor: pointer;\n}\n.view-menu-item:empty::before {\n  content: "|";\n  visibility: hidden;\n}\n.view-menu-item:hover,\n.view-menu-item.discovery-view-popup-active {\n  background: rgba(131, 131, 131, 0.25);\n}\n.view-menu-item.selected {\n  background: rgba(178, 221, 248, 0.3);\n  cursor: default;\n}\n.view-menu-item.disabled {\n  opacity: .65;\n  background: none;\n  pointer-events: none;\n}\n.view-menu-item:not(.onclick):not([href]) {\n  pointer-events: none;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/menu.css */\n.view-menu:empty::before {\n  content: attr(emptyText);\n  display: block;\n  padding: 4px 12px;\n  color: #888;\n}\n.view-menu > .more-buttons {\n  margin: 2px 12px 8px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/nav-button.css */\n.view-nav-button {\n  vertical-align: top;\n  display: inline-block;\n  min-height: 1.6em;\n  padding: 5px 15px 6px;\n  color: #444;\n  background-color: rgba(155, 155, 155, 0.15);\n  font-size: 12px;\n  text-decoration: none;\n  outline: none;\n  cursor: pointer;\n}\n.view-nav-button:hover,\n.view-nav-button:focus,\n.view-nav-button.discovery-view-popup-active {\n  color: black;\n  background-color: rgba(151, 151, 151, 0.3);\n}\n.view-nav-button + .view-nav-button {\n  margin-left: 1px;\n}\n.view-nav-button.disabled,\n.view-nav-button:not(.onclick):not([href]) {\n  pointer-events: none;\n}\n.discovery-root-darkmode .view-nav-button {\n  color: inherit;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/progress.css */\n.view-progress {\n  max-width: 300px;\n  width: 100%;\n  z-index: 1;\n  transition: opacity .15s var(--appearance-delay, 0ms);\n  pointer-events: none;\n}\n.view-progress.init {\n  opacity: 0;\n}\n.view-progress > .progress {\n  content: "";\n  display: block;\n  position: relative;\n  overflow: hidden;\n  margin-top: 4px;\n  box-sizing: border-box;\n  height: 3px;\n  background: rgba(198, 198, 198, 0.3);\n  border-radius: 2px;\n}\n.view-progress > .progress::before {\n  content: "";\n  display: block;\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform: scaleX(var(--progress, 0));\n  transform-origin: left;\n  background-color: var(--color, #1f7ec5);\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/select.css */\n.view-select {\n  box-sizing: border-box;\n  position: relative;\n  display: inline-flex;\n  overflow: hidden;\n  flex-shrink: 0;\n  align-items: center;\n  min-width: 10ex;\n  max-width: 100%;\n  padding-right: 1.2em;\n  line-height: 1.2;\n  border-radius: 3px;\n  border: 1px solid rgba(127, 127, 127, 0.4);\n  background-color: rgba(255, 255, 255, .1);\n  color: var(--discovery-color);\n  outline: none;\n}\n.view-select::after {\n  content: "";\n  right: 7px;\n  color: #999999;\n  display: flex;\n  align-items: center;\n  flex-shrink: 0;\n  pointer-events: none;\n  position: absolute;\n  width: 1em;\n  height: 1em;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28">%0A    <path fill="%23888" d="M19,15.9393398 L24.4696699,10.4696699 C24.7625631,10.1767767 25.2374369,10.1767767 25.5303301,10.4696699 C25.8232233,10.7625631 25.8232233,11.2374369 25.5303301,11.5303301 L19.5303301,17.5303301 C19.2374369,17.8232233 18.7625631,17.8232233 18.4696699,17.5303301 L12.4696699,11.5303301 C12.1767767,11.2374369 12.1767767,10.7625631 12.4696699,10.4696699 C12.7625631,10.1767767 13.2374369,10.1767767 13.5303301,10.4696699 L19,15.9393398 Z" />%0A</svg>%0A\');\n  background-size: 1em;\n  background-position: center;\n  cursor: pointer;\n}\n.view-select.discovery-view-popup-active,\n.view-select:focus {\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, .2), inset 0 1px 1px rgba(142, 142, 142, .2);\n  border-color: rgba(128, 128, 128, 0.6);\n  z-index: 1;\n}\n.view-select:hover {\n  background-color: rgba(221, 221, 221, 0.3);\n  border-color: rgba(170, 170, 170, 0.6);\n}\n.view-select:active {\n  background-color: rgba(131, 131, 131, 0.25);\n}\n.view-select .view-menu-item {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-right: 8px;\n}\n.view-select:empty:not([data-placeholder])::before {\n  content: "|";\n  visibility: hidden;\n  padding: 8px 0;\n}\n.view-select:empty[data-placeholder]::before {\n  content: attr(data-placeholder);\n  visibility: visible;\n  padding: 8px 8px 8px 12px;\n  opacity: .3;\n}\n.view-select > * {\n  pointer-events: none;\n}\n.discovery-view-popup.view-select-popup {\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n.discovery-view-popup.view-select-popup > .view-select__variants {\n  flex: 1;\n  overflow: auto;\n  display: flex;\n  flex-direction: column;\n  min-width: 100%;\n}\n.discovery-view-popup.view-select-popup > .view-select__variants:not(:last-child) {\n  border-bottom: 1px solid rgba(202, 202, 202, 0.65);\n}\n.discovery-view-popup.view-select-popup > .view-select__filter {\n  margin: 0;\n  border-bottom: 1px solid rgba(202, 202, 202, 0.65);\n}\n.discovery-view-popup.view-select-popup > :not(.view-tabs) + .view-select__filter {\n  border-top: 1px solid rgba(202, 202, 202, 0.65);\n}\n.discovery-view-popup.view-select-popup > .view-select__filter input,\n.discovery-view-popup.view-select-popup > .view-select__filter input:focus {\n  outline: none;\n  box-shadow: none;\n  border: none;\n}\n.discovery-view-popup.view-select-popup .reset-item {\n  color: #aaa;\n}\n.discovery-view-popup.view-select-popup .reset-item:empty::before {\n  content: "(nothing selected)";\n  visibility: visible;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/tab.css */\n.view-tab {\n  display: inline-block;\n  position: relative;\n  padding: 3px 11px;\n  border-bottom: var(--discovery-view-tabs-border);\n  font-size: 13px;\n  cursor: pointer;\n  white-space: nowrap;\n}\n.view-tab.active {\n  z-index: 10;\n  border-bottom: none;\n  padding-bottom: 4px;\n  cursor: default;\n}\n.view-tab.active::before {\n  content: "";\n  position: absolute;\n  z-index: -1;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  border: var(--discovery-view-tabs-border);\n  border-bottom: none;\n  border-radius: 5px 5px 0 0;\n  pointer-events: none;\n}\n.view-tab.disabled {\n  color: #aaa;\n}\n.view-tab.disabled,\n.view-tab:not(.onclick) {\n  pointer-events: none;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/tabs.css */\n.view-tabs-buttons {\n  --discovery-view-tabs-border: 1px solid rgba(170, 170, 170, 0.4);\n  margin-top: 2px;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: flex-end;\n}\n.view-tabs-buttons::before,\n.view-tabs-buttons::after {\n  content: "";\n  width: 6px;\n  border-bottom: var(--discovery-view-tabs-border);\n}\n.view-tabs-buttons::after {\n  flex: 1;\n}\n.view-tabs-buttons-before,\n.view-tabs-buttons-after {\n  padding: 0 6px 3px;\n  padding-bottom: 3px;\n  border-bottom: var(--discovery-view-tabs-border);\n  color: #888;\n  font-size: 13px;\n}\n.view-tabs-content {\n  overflow: auto;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/toggle-group.css */\n.view-toggle-group {\n  display: inline-flex;\n  align-items: baseline;\n  flex-wrap: wrap;\n}\n.view-toggle-group-before {\n  padding-right: 1ex;\n}\n.view-toggle-group-after {\n  padding-left: 1ex;\n  order: 1000;\n}\n.view-toggle-group .view-toggle + .view-toggle {\n  margin-left: 1px;\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.view-toggle-group .view-toggle:not(:last-child) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/toggle.css */\n.view-toggle {\n  display: inline-block;\n  position: relative;\n  padding: 3px 12px;\n  background: rgba(200, 200, 200, 0.2);\n  border-radius: 4px;\n  font-size: 13px;\n  cursor: pointer;\n  white-space: nowrap;\n}\n.view-toggle:hover {\n  background-color: rgba(78, 187, 255, .2);\n}\n.view-toggle.checked {\n  background-color: rgba(78, 187, 255, .3);\n  cursor: default;\n}\n.view-toggle.disabled {\n  color: #aaa;\n}\n.view-toggle.disabled,\n.view-toggle:not(.onclick) {\n  pointer-events: none;\n}\n\n/* node_modules/codemirror/lib/codemirror.css */\n.CodeMirror {\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n.CodeMirror-lines {\n  padding: 4px 0;\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  padding: 0 4px;\n}\n.CodeMirror-scrollbar-filler,\n.CodeMirror-gutter-filler {\n  background-color: white;\n}\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {\n}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n.CodeMirror-guttermarker {\n  color: black;\n}\n.CodeMirror-guttermarker-subtle {\n  color: #999;\n}\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor .CodeMirror-line::selection,\n.cm-fat-cursor .CodeMirror-line > span::selection,\n.cm-fat-cursor .CodeMirror-line > span > span::selection {\n  background: transparent;\n}\n.cm-fat-cursor .CodeMirror-line::-moz-selection,\n.cm-fat-cursor .CodeMirror-line > span::-moz-selection,\n.cm-fat-cursor .CodeMirror-line > span > span::-moz-selection {\n  background: transparent;\n}\n.cm-fat-cursor {\n  caret-color: transparent;\n}\n@-moz-keyframes blink {\n  0% {\n  }\n  50% {\n    background-color: transparent;\n  }\n  100% {\n  }\n}\n@-webkit-keyframes blink {\n  0% {\n  }\n  50% {\n    background-color: transparent;\n  }\n  100% {\n  }\n}\n@keyframes blink {\n  0% {\n  }\n  50% {\n    background-color: transparent;\n  }\n  100% {\n  }\n}\n.CodeMirror-overwrite .CodeMirror-cursor {\n}\n.cm-tab {\n  display: inline-block;\n  text-decoration: inherit;\n}\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: -50px;\n  bottom: 0;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0;\n  bottom: 0;\n  position: absolute;\n}\n.cm-s-default .cm-header {\n  color: blue;\n}\n.cm-s-default .cm-quote {\n  color: #090;\n}\n.cm-negative {\n  color: #d44;\n}\n.cm-positive {\n  color: #292;\n}\n.cm-header,\n.cm-strong {\n  font-weight: bold;\n}\n.cm-em {\n  font-style: italic;\n}\n.cm-link {\n  text-decoration: underline;\n}\n.cm-strikethrough {\n  text-decoration: line-through;\n}\n.cm-s-default .cm-keyword {\n  color: #708;\n}\n.cm-s-default .cm-atom {\n  color: #219;\n}\n.cm-s-default .cm-number {\n  color: #164;\n}\n.cm-s-default .cm-def {\n  color: #00f;\n}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {\n}\n.cm-s-default .cm-variable-2 {\n  color: #05a;\n}\n.cm-s-default .cm-variable-3,\n.cm-s-default .cm-type {\n  color: #085;\n}\n.cm-s-default .cm-comment {\n  color: #a50;\n}\n.cm-s-default .cm-string {\n  color: #a11;\n}\n.cm-s-default .cm-string-2 {\n  color: #f50;\n}\n.cm-s-default .cm-meta {\n  color: #555;\n}\n.cm-s-default .cm-qualifier {\n  color: #555;\n}\n.cm-s-default .cm-builtin {\n  color: #30a;\n}\n.cm-s-default .cm-bracket {\n  color: #997;\n}\n.cm-s-default .cm-tag {\n  color: #170;\n}\n.cm-s-default .cm-attribute {\n  color: #00c;\n}\n.cm-s-default .cm-hr {\n  color: #999;\n}\n.cm-s-default .cm-link {\n  color: #00c;\n}\n.cm-s-default .cm-error {\n  color: #f00;\n}\n.cm-invalidchar {\n  color: #f00;\n}\n.CodeMirror-composing {\n  border-bottom: 2px solid;\n}\ndiv.CodeMirror span.CodeMirror-matchingbracket {\n  color: #0b0;\n}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {\n  color: #a22;\n}\n.CodeMirror-matchingtag {\n  background: rgba(255, 150, 0, .3);\n}\n.CodeMirror-activeline-background {\n  background: #e8f2ff;\n}\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n.CodeMirror-scroll {\n  overflow: scroll !important;\n  margin-bottom: -50px;\n  margin-right: -50px;\n  padding-bottom: 50px;\n  height: 100%;\n  outline: none;\n  position: relative;\n  z-index: 0;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 50px solid transparent;\n}\n.CodeMirror-vscrollbar,\n.CodeMirror-hscrollbar,\n.CodeMirror-scrollbar-filler,\n.CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n  outline: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0;\n  top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0;\n  left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0;\n  bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0;\n  bottom: 0;\n}\n.CodeMirror-gutters {\n  position: absolute;\n  left: 0;\n  top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -50px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection {\n  background-color: transparent;\n}\n.CodeMirror-gutter-wrapper ::-moz-selection {\n  background-color: transparent;\n}\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px;\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  -moz-border-radius: 0;\n  -webkit-border-radius: 0;\n  border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre.CodeMirror-line,\n.CodeMirror-wrap pre.CodeMirror-line-like {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  z-index: 0;\n}\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px;\n}\n.CodeMirror-widget {\n}\n.CodeMirror-rtl pre {\n  direction: rtl;\n}\n.CodeMirror-code {\n  outline: none;\n}\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre {\n  position: static;\n}\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n.CodeMirror-selected {\n  background: #d9d9d9;\n}\n.CodeMirror-focused .CodeMirror-selected {\n  background: #d7d4f0;\n}\n.CodeMirror-crosshair {\n  cursor: crosshair;\n}\n.CodeMirror-line::selection,\n.CodeMirror-line > span::selection,\n.CodeMirror-line > span > span::selection {\n  background: #d7d4f0;\n}\n.CodeMirror-line::-moz-selection,\n.CodeMirror-line > span::-moz-selection,\n.CodeMirror-line > span > span::-moz-selection {\n  background: #d7d4f0;\n}\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n.cm-force-border {\n  padding-right: .1px;\n}\n@media print {\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n.cm-tab-wrap-hack:after {\n  content: "";\n}\nspan.CodeMirror-selectedtext {\n  background: none;\n}\n\n/* node_modules/codemirror/theme/neo.css */\n.cm-s-neo.CodeMirror {\n  background-color: #ffffff;\n  color: #2e383c;\n  line-height: 1.4375;\n}\n.cm-s-neo .cm-comment {\n  color: #75787b;\n}\n.cm-s-neo .cm-keyword,\n.cm-s-neo .cm-property {\n  color: #1d75b3;\n}\n.cm-s-neo .cm-atom,\n.cm-s-neo .cm-number {\n  color: #75438a;\n}\n.cm-s-neo .cm-node,\n.cm-s-neo .cm-tag {\n  color: #9c3328;\n}\n.cm-s-neo .cm-string {\n  color: #b35e14;\n}\n.cm-s-neo .cm-variable,\n.cm-s-neo .cm-qualifier {\n  color: #047d65;\n}\n.cm-s-neo pre {\n  padding: 0;\n}\n.cm-s-neo .CodeMirror-gutters {\n  border: none;\n  border-right: 10px solid transparent;\n  background-color: transparent;\n}\n.cm-s-neo .CodeMirror-linenumber {\n  padding: 0;\n  color: #e0e2e5;\n}\n.cm-s-neo .CodeMirror-guttermarker {\n  color: #1d75b3;\n}\n.cm-s-neo .CodeMirror-guttermarker-subtle {\n  color: #e0e2e5;\n}\n.cm-s-neo .CodeMirror-cursor {\n  width: auto;\n  border: 0;\n  background: rgba(155, 157, 162, 0.37);\n  z-index: 1;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/editor/editors-hint.css */\n.discovery-view-editor-hints-popup {\n  position: absolute;\n  z-index: 1000;\n  box-sizing: border-box;\n  overflow: hidden;\n  overflow-y: auto;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  min-width: 200px;\n  max-height: 20em;\n  box-shadow: 2px 3px 5px rgba(0, 0, 0, .2);\n  border-radius: 2px;\n  border: 1px solid rgba(176, 176, 176, 0.65);\n  background: white;\n  color: black;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 12px;\n  line-height: 18px;\n}\n.discovery-root-darkmode .discovery-view-editor-hints-popup {\n  background: #323232;\n  color: #ccc;\n}\n.discovery-view-editor-hint {\n  display: flex;\n  align-items: baseline;\n  margin: 0;\n  padding: 2px 6px;\n  white-space: pre;\n  cursor: pointer;\n}\n.discovery-view-editor-hint:hover {\n  background-color: rgba(180, 180, 180, 0.2);\n}\n.discovery-view-editor-hint .name {\n  flex: 1;\n}\n.discovery-view-editor-hint .match {\n  color: #06C;\n}\n.discovery-root-darkmode .discovery-view-editor-hints-popup .discovery-view-editor-hint .match {\n  color: #4d8bca;\n}\n.discovery-view-editor-hint.active {\n  background: rgba(0, 170, 255, .2);\n}\n.discovery-view-editor-hint::before {\n  content: "?";\n  display: inline-block;\n  place-self: center;\n  aspect-ratio: 1 / 1;\n  height: 1em;\n  margin-left: -2px;\n  margin-right: 4px;\n  padding: 2px;\n  border: 1px solid currentColor;\n  border-radius: 3px;\n  color: #888;\n  font-size: 8px;\n  line-height: 1;\n  text-align: center;\n}\n.discovery-view-editor-hint.type-variable::before {\n  content: "$";\n}\n.discovery-view-editor-hint.type-property::before {\n  content: "P";\n}\n.discovery-view-editor-hint.type-value::before {\n  content: "V";\n}\n.discovery-view-editor-hint.type-method::before {\n  content: "M";\n}\n.discovery-view-editor-hint.type-assertion::before {\n  content: "A";\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/editor/editors.css */\n.discovery-view-editor {\n  --editor-border-color: rgba(124, 124, 124, 0.65);\n  display: flex;\n  flex-direction: column;\n  margin-bottom: 5px;\n  border: 1px solid var(--editor-border-color);\n  border-radius: 3px;\n  background-color: var(--discovery-background-color);\n}\n.discovery-view-editor:focus-within {\n  --editor-border-color: rgba(0, 141, 255, 0.75);\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, .2), inset 0 1px 1px rgba(142, 142, 142, .2) !important;\n}\n.discovery-view-editor .discovery-view-editor__input-panel {\n  order: 0;\n}\n.discovery-view-editor .discovery-view-editor__output-panel {\n  order: 2;\n}\n.discovery-view-editor .CodeMirror {\n  order: 1;\n  height: auto;\n  overflow-y: hidden !important;\n  padding: 2px 8px;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 12px;\n  background-color: var(--discovery-input-bg-color);\n  transition: .25s ease-in;\n  transition-property: background-color, color;\n}\n.discovery-root-darkmode .discovery-view-editor .CodeMirror {\n  color: #d1c7c3;\n}\n.discovery-view-editor .CodeMirror-scroll {\n  min-height: 6.5em;\n  height: auto;\n  overflow-y: hidden !important;\n  cursor: text;\n}\n.discovery-view-editor .CodeMirror .CodeMirror-line {\n  padding: 0;\n}\n.discovery-view-editor .CodeMirror-cursor {\n  border-left: 1px solid var(--discovery-color, black);\n  background: none;\n}\n.discovery-view-editor .CodeMirror-focused .CodeMirror-selected {\n  background-color: rgba(0, 170, 255, 0.22);\n}\n.discovery-view-editor .CodeMirror-selected {\n  background-color: rgba(126, 126, 126, 0.3);\n}\n.discovery-view-editor .CodeMirror .cm-comment {\n  color: var(--discovery-fmt-comment-color);\n}\n.discovery-view-editor .CodeMirror .cm-keyword {\n  color: var(--discovery-fmt-keyword-color);\n}\n.discovery-view-editor .CodeMirror .cm-property {\n  color: var(--discovery-fmt-property-color);\n}\n.discovery-view-editor .CodeMirror .cm-atom {\n  color: var(--discovery-fmt-atom-color);\n}\n.discovery-view-editor .CodeMirror .cm-number {\n  color: var(--discovery-fmt-number-color);\n}\n.discovery-view-editor .CodeMirror .cm-type {\n  color: var(--discovery-fmt-type-color);\n}\n.discovery-view-editor .CodeMirror .cm-node,\n.discovery-view-editor .CodeMirror .cm-tag {\n  color: #9c3328;\n}\n.discovery-view-editor .CodeMirror .cm-string,\n.discovery-view-editor .CodeMirror .cm-string-2 {\n  color: var(--discovery-fmt-string-color);\n}\n.discovery-view-editor .CodeMirror .cm-variable,\n.discovery-view-editor .CodeMirror .cm-variable-2,\n.discovery-view-editor .CodeMirror .cm-def,\n.discovery-view-editor .CodeMirror .cm-qualifier {\n  color: var(--discovery-fmt-variable-color);\n}\n.discovery-view-editor .CodeMirror .cm-discovery-view-name {\n  background-color: var(--discovery-fmt-string-highlight-color);\n  border-bottom: 1px dashed;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/_usage.css */\n.discovery-view-usage {\n  margin-top: 20px;\n}\n.discovery-view-usage > .view-header:first-child {\n  margin-top: 0;\n}\n.discovery-view-usage .usage-render {\n  position: relative;\n  z-index: 0;\n  margin: 15px 0 10px;\n  padding: 30px 16px 16px;\n  border: solid rgba(170, 170, 170, 0.2);\n  border-width: 2px;\n  border-radius: 3px;\n}\n.discovery-view-usage .usage-render.demo-fixed {\n  --image-preview-bg-color: rgba(119, 119, 119, 0.125);\n  margin-top: 29px;\n  padding: var(--discovery-page-padding-top) var(--discovery-page-padding-right) var(--discovery-page-padding-bottom) var(--discovery-page-padding-left);\n  border-top-left-radius: 0;\n  background-clip: padding-box;\n  background-image:\n    linear-gradient(\n      45deg,\n      var(--image-preview-bg-color) 25%,\n      transparent 0,\n      transparent 75%,\n      var(--image-preview-bg-color) 75%),\n    linear-gradient(\n      45deg,\n      var(--image-preview-bg-color) 25%,\n      transparent 0,\n      transparent 75%,\n      var(--image-preview-bg-color) 75%);\n  background-position: 0 0, 10px 10px;\n  background-size: 20px 20px;\n}\n.discovery-view-usage .usage-render::before {\n  content: "DEMO";\n  position: absolute;\n  top: 0;\n  left: 0;\n  padding: 2px 24px 3px 24px;\n  font-size: 9px;\n  line-height: 1;\n  background-color: rgba(170, 170, 170, 0.2);\n  border-bottom-right-radius: 4px;\n}\n.discovery-view-usage .usage-render.demo-fixed::before {\n  top: -16px;\n  left: -2px;\n  padding-left: 26px;\n  border-radius: 4px 4px 0 0;\n}\n.discovery-view-usage .usage-section > .view-h2 {\n  margin-top: 1.2em;\n  margin-bottom: .5em;\n}\n.discovery-view-usage .usage-section > .view-h2 .view-header__anchor {\n  scroll-margin: .5em;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-tabs-buttons::before {\n  display: none;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-tabs-content {\n  overflow: visible;\n  border: 1px solid rgba(170, 170, 170, 0.4);\n  border-top: none;\n  border-radius: 0 0 3px 3px;\n  padding: 2px;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-tabs-content .view-expand {\n  margin-bottom: 1px;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-tabs-content .view-expand > .header {\n  --discovery-view-expand-trigger-size: 32px;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-tabs-content .view-expand .view-struct.struct-expand {\n  padding-left: 28px;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-tabs-content .view-expand .view-struct:not(.struct-expand) {\n  border-left: 20px solid rgba(205, 205, 205, .1);\n}\n.discovery-view-usage .view-tabs.usage-sources .view-source {\n  background: rgba(155, 155, 155, 0.1);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-source.first-tab {\n  border-top-left-radius: 0;\n}\n.discovery-view-usage .view-tabs.usage-sources .view-source .spotlight {\n  padding: 3px 2px 2px;\n  margin: 0 -2px;\n}\n.discovery-root-darkmode .discovery-view-usage .view-tabs.usage-sources .view-source .spotlight {\n  background: #92926654;\n  color: #b6aa6a;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/list-item.css */\n.view-inline-list > .view-list-item,\n.view-comma-list > .view-list-item {\n  display: inline-block;\n  list-style: none;\n}\n.view-comma-list > .view-list-item > * {\n  margin-right: 0;\n}\n.view-comma-list > .view-list-item::after {\n  content: ", ";\n  white-space: pre;\n}\n.view-comma-list > .view-list-item:last-child::after {\n  content: "";\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/lists.css */\n.view-list {\n  display: block;\n  list-style: none;\n}\n.view-ul,\n.view-ol {\n  margin: 0;\n  padding-left: 0;\n}\n.view-ul:not(:empty),\n.view-ol:not(:empty) {\n  padding-left: 20px;\n}\n:is(.view-list, .view-ul, .view-ol) + :is(.view-list, .view-ul, .view-ol),\n.view-list-item > :is(.view-list, .view-ul, .view-ol) {\n  margin-top: 0;\n  margin-bottom: 2px;\n}\n.view-inline-list,\n.view-comma-list {\n  display: inline-block;\n}\n.view-list:empty::before,\n.view-inline-list:empty::before,\n.view-ul:empty::before,\n.view-ol:empty::before {\n  content: attr(emptyText);\n  color: #888;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/alerts.css */\n.view-alert {\n  position: relative;\n  padding: .75rem 1.25rem;\n  margin-bottom: 1rem;\n  border: 1px solid transparent;\n  border-radius: .25rem;\n  color: #383d41;\n  background-color: rgba(139, 143, 151, 0.25);\n  border-color: rgba(152, 157, 165, 0.4);\n  background-clip: padding-box;\n}\n.discovery-root-darkmode .view-alert {\n  color: var(--discovery-color);\n}\n.view-alert:last-child {\n  margin-bottom: 0;\n}\n.view-alert > :first-child {\n  margin-top: 0;\n}\n.page > .view-alert:first-child,\n.page > .view-alert-success:first-child,\n.page > .view-alert-danger:first-child,\n.page > .view-alert-warning:first-child {\n  margin-top: 15px;\n}\n.view-alert-primary {\n  color: #004085;\n  background-color: rgba(51, 151, 255, 0.25);\n  border-color: rgba(77, 162, 255, 0.4);\n}\n.discovery-root-darkmode .view-alert-primary {\n  color: #6a96c6;\n}\n.view-alert-success {\n  color: #155724;\n  background-color: rgba(83, 183, 107, 0.25);\n  border-color: rgba(105, 192, 125, 0.4);\n}\n.discovery-root-darkmode .view-alert-success {\n  color: #5fab70;\n}\n.view-alert-danger {\n  color: #721c24;\n  background-color: rgba(227, 95, 107, 0.25);\n  border-color: rgba(230, 112, 125, 0.4);\n}\n.discovery-root-darkmode .view-alert-danger {\n  color: #c7888e;\n}\n.view-alert-warning {\n  color: #856404;\n  background-color: rgba(255, 207, 55, 0.25);\n  border-color: rgba(255, 212, 82, 0.4);\n}\n.discovery-root-darkmode .view-alert-warning {\n  color: #bdab77;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/badges.css */\n.view-badge,\n.view-pill-badge {\n  --discovery-view-badge-color: rgba(135, 135, 135, 0.2);\n  --discovery-view-badge-text-color: var(--discovery-color);\n  padding: 1px 6px 3px;\n  margin-right: 1ex;\n  text-shadow: 1px 1px rgba(255, 255, 255, .35);\n  background: var(--discovery-view-badge-color);\n  color: var(--discovery-view-badge-text-color);\n  border-radius: 3px;\n  font-size: 85%;\n  text-decoration: none;\n  white-space: nowrap;\n}\n.view-pill-badge {\n  border-radius: 9px;\n}\n.discovery-root-darkmode .view-badge,\n.discovery-root-darkmode .view-pill-badge {\n  background: var(--discovery-view-badge-dark-color, var(--discovery-view-badge-color));\n  color: var(--discovery-view-badge-dark-text-color, var(--discovery-view-badge-text-color));\n  text-shadow: 1px 1px rgba(0, 0, 0, .1);\n}\n.view-badge[href]:hover,\n.view-pill-badge[href]:hover {\n  color: var(--discovery-color);\n  background-image:\n    linear-gradient(\n      to top,\n      rgba(0, 0, 0, .1),\n      rgba(0, 0, 0, .1));\n}\n.view-badge > .prefix {\n  padding: 1px 6px 3px;\n  margin: -1px 6px -3px -6px;\n  border-radius: 3px 0 0 3px;\n  background-color: rgba(0, 0, 0, .12);\n}\n.view-badge > .postfix {\n  padding: 1px 6px 3px;\n  margin: -1px -6px -3px 6px;\n  border-radius: 0 3px 3px 0;\n  background-color: rgba(0, 0, 0, .12);\n}\n.view-pill-badge > .prefix {\n  padding: 1px 6px 3px;\n  margin: -1px 6px -3px -6px;\n  border-radius: 8px 0 0 8px;\n  background-color: rgba(0, 0, 0, .12);\n}\n.view-pill-badge > .postfix {\n  padding: 1px 6px 3px;\n  margin: -1px -6px -3px 6px;\n  border-radius: 0 8px 8px 0;\n  background-color: rgba(0, 0, 0, .12);\n}\n.discovery-buildin-view-tooltip .view-badge,\n.discovery-buildin-view-tooltip .view-pill-badge {\n  display: inline-block;\n  margin: 0 0 3px -5px;\n  padding-top: 0;\n  padding-bottom: 1px;\n  line-height: 19px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/headers.css */\n.view-header {\n  font-size: 120%;\n  font-weight: normal;\n  position: relative;\n}\n.view-header > .view-header__anchor {\n  position: absolute;\n  margin-left: -22px;\n  display: inline-block;\n  width: 22px;\n  text-align: center;\n  color: inherit;\n  background: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="%23888" viewBox="0 0 16 16">%0A  <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>%0A  <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>%0A</svg>%0A\') center / 20px no-repeat content-box;\n  padding-top: 2px;\n  font-weight: normal;\n  opacity: 0;\n  transition: opacity .25s;\n}\n.view-header:hover > .view-header__anchor,\n.view-header:hover > .view-header__anchor {\n  opacity: 1;\n}\n.view-header > .view-header__anchor::before {\n  content: "\\a7";\n  display: inline-block;\n  width: 0;\n  visibility: hidden;\n}\n.view-h1 {\n  font-size: 220%;\n  font-weight: normal;\n  margin: .812em 0 .65em;\n}\n.view-h2 {\n  font-size: 150%;\n  font-weight: normal;\n  margin: .78em 0;\n}\n.view-h3 {\n  font-size: 135%;\n  font-weight: normal;\n  margin: .73em 0;\n}\n.view-h4 {\n  font-size: 120%;\n  font-weight: normal;\n  margin: .73em 0;\n}\n.view-h5 {\n  font-size: 110%;\n  font-weight: normal;\n  margin: .68em 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/link.css */\n.view-link {\n  color: var(--discovery-link-color, #0099DD);\n  text-decoration-skip: ink;\n  text-decoration-color: var(--discovery-link-underline-color, rgba(0, 153, 221, 0.4));\n}\n.view-link.onclick {\n  text-decoration-line: underline;\n  cursor: pointer;\n}\n.view-link:hover {\n  color: var(--discovery-link-hover-color, #0077BB);\n  text-decoration-color: currentColor;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/image.css */\n.view-image {\n  background: no-repeat center / 20px;\n}\n.view-image:not(.error):not(.loaded) {\n  background-color: rgba(141, 141, 141, .3);\n}\n.view-image.error,\n.view-image:not([src]) {\n  width: 32px;\n  height: 32px;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="%23888" viewBox="0 0 16 16">%0A  <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>%0A  <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/>%0A</svg>%0A\');\n  background-color: rgba(141, 70, 70, .3);\n}\n.discovery-root-darkmode .view-image {\n  opacity: .85;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/image-preview.css */\n.view-image-preview {\n  --image-preview-bg-color: rgba(119, 119, 119, 0.125);\n  display: flex;\n  justify-content: center;\n  padding: 16px;\n  background-image:\n    linear-gradient(\n      45deg,\n      var(--image-preview-bg-color) 25%,\n      transparent 0,\n      transparent 75%,\n      var(--image-preview-bg-color) 75%),\n    linear-gradient(\n      45deg,\n      var(--image-preview-bg-color) 25%,\n      transparent 0,\n      transparent 75%,\n      var(--image-preview-bg-color) 75%);\n  background-position: 0 0, 10px 10px;\n  background-size: 20px 20px;\n}\n.view-image-preview .view-image {\n  opacity: 1;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/indicator.css */\n.view-indicator {\n  display: inline-flex;\n  margin: 0 1px 1px 0;\n  width: 150px;\n  height: 100px;\n  background: rgba(181, 181, 181, 0.15);\n  flex-direction: column;\n  justify-content: center;\n  text-align: center;\n  text-decoration: none;\n}\n.view-indicator[href]:hover {\n  background: rgba(165, 165, 165, 0.3);\n}\n.view-indicator > .value {\n  color: #666;\n  font-size: 40px;\n  line-height: 1.2;\n}\n.view-indicator[href] > .value {\n  color: #1f7ec5;\n}\n.view-indicator > .label {\n  font-size: 14px;\n  color: #888;\n  box-sizing: border-box;\n  padding: 0 8px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/markdown.css */\n.view-markdown:first-child > :first-child {\n  margin-top: 0;\n}\n.view-markdown:last-child > :last-child {\n  margin-bottom: 0;\n}\n.view-markdown :is(p, blockquote, ul, ol, dl, pre, code) {\n  margin: 0;\n}\n.view-markdown :is(p, blockquote, ul, ol, dl, table, pre):not(:first-child) {\n  margin-top: 15px;\n}\n.view-markdown :is(ul, ol) + :is(ul, ol),\n.view-markdown li > :is(ul, ol) {\n  margin-top: 0 !important;\n}\n.view-markdown blockquote {\n  padding: 0;\n  padding-left: 1em;\n  color: #6a737d;\n  border-left: .25em solid rgba(191, 197, 203, 0.5);\n}\n.discovery-root-darkmode .view-markdown blockquote {\n  color: #808993;\n}\n.view-markdown code {\n  padding: .2em .4em;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 90%;\n  background-color: rgba(210, 220, 230, 0.2);\n  border-radius: 3px;\n}\n.discovery-root-darkmode .view-markdown blockquote code {\n  background-color: rgba(116, 126, 136, 0.2);\n}\n.view-markdown sup {\n  vertical-align: top;\n}\n.view-markdown sub {\n  vertical-align: bottom;\n}\n.view-markdown pre:not(.view-source) {\n  overflow: auto;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 90%;\n  line-height: 1.25;\n  background-color: rgba(155, 155, 155, 0.1);\n  border-radius: 3px;\n  word-break: normal;\n}\n.view-markdown pre:not(.view-source) code {\n  padding: 0;\n  font-family: inherit;\n  font-size: 100%;\n  background: none;\n  border-radius: 0;\n  text-shadow: none;\n  color: inherit;\n}\n.view-markdown .check-list-item {\n  list-style: none;\n  margin-left: -22px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/source.css */\n.view-source {\n  display: grid;\n  grid-template: "prelude" auto "content" 1fr "postlude" auto;\n  margin: 0;\n  border-radius: 3px;\n  background-color: rgba(205, 205, 205, .1);\n  color: var(--discovery-color);\n  font-family: var(--discovery-font-family);\n  font-size: 12px;\n  line-height: 1.6;\n  white-space: normal;\n}\n.view-source__prelude {\n  grid-area: prelude;\n  overflow: hidden;\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n}\n.view-source__postlude {\n  grid-area: postlude;\n  overflow: hidden;\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n}\n.view-source__content {\n  grid-area: content;\n  position: relative;\n  display: flex;\n  align-items: flex-start;\n  padding: 8px;\n  overflow: auto;\n  white-space: pre;\n}\n.view-source__action-buttons {\n  order: 2;\n  position: sticky;\n  top: 0px;\n  right: 0px;\n  translate: 3px -3px;\n  margin-left: 1ex;\n  margin-bottom: -8px;\n  display: flex;\n  gap: 4px;\n  font-family: var(--discovery-font-family);\n  font-size: 12px;\n  line-height: 1.6;\n}\n.view-source__action-buttons .view-button {\n  padding: 4px 6px;\n  margin: 0;\n  opacity: 0.25;\n  transition: .5s opacity;\n  line-height: 14px;\n}\n.view-source__content:hover > .view-source__action-buttons .view-button {\n  opacity: 1;\n  transition-duration: .25s;\n}\n.view-source__action-buttons .view-button.copied {\n  opacity: 1;\n}\n.view-source__action-buttons .view-button.copy::before {\n  content: "";\n  display: inline-block;\n  vertical-align: top;\n  width: 12px;\n  height: 12px;\n  -webkit-mask: center / 12px no-repeat url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%23000" viewBox="0 0 16 16">%0A    <path d="M3.5 2a.5.5 0 0 0-.5.5v12a.5.5 0 0 0 .5.5h9a.5.5 0 0 0 .5-.5v-12a.5.5 0 0 0-.5-.5H12a.5.5 0 0 1 0-1h.5A1.5 1.5 0 0 1 14 2.5v12a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 14.5v-12A1.5 1.5 0 0 1 3.5 1H4a.5.5 0 0 1 0 1h-.5Z"/>%0A    <path d="M10 .5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5.5.5 0 0 1-.5.5.5.5 0 0 0-.5.5V2a.5.5 0 0 0 .5.5h5A.5.5 0 0 0 11 2v-.5a.5.5 0 0 0-.5-.5.5.5 0 0 1-.5-.5Z"/>%0A</svg>%0A\');\n  mask: center / 12px no-repeat url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%23000" viewBox="0 0 16 16">%0A    <path d="M3.5 2a.5.5 0 0 0-.5.5v12a.5.5 0 0 0 .5.5h9a.5.5 0 0 0 .5-.5v-12a.5.5 0 0 0-.5-.5H12a.5.5 0 0 1 0-1h.5A1.5 1.5 0 0 1 14 2.5v12a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 14.5v-12A1.5 1.5 0 0 1 3.5 1H4a.5.5 0 0 1 0 1h-.5Z"/>%0A    <path d="M10 .5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5.5.5 0 0 1-.5.5.5.5 0 0 0-.5.5V2a.5.5 0 0 0 .5.5h5A.5.5 0 0 0 11 2v-.5a.5.5 0 0 0-.5-.5.5.5 0 0 1-.5-.5Z"/>%0A</svg>%0A\');\n  visibility: visible;\n  background-color: currentColor;\n  transition: .1s .25s;\n  transition-property: scale, opacity;\n}\n.view-source__action-buttons .view-button::after {\n  content: "";\n  display: inline-block;\n  vertical-align: top;\n  margin-left: -12px;\n  width: 12px;\n  height: 12px;\n  -webkit-mask: center / 16px no-repeat url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%23000" viewBox="0 0 16 16">%0A  <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022Z"/>%0A</svg>%0A\');\n  mask: center / 16px no-repeat url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%23000" viewBox="0 0 16 16">%0A  <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022Z"/>%0A</svg>%0A\');\n  background-color: #6a9c11;\n  transition: .1s .25s;\n  transition-property: scale, opacity;\n}\n.view-source__action-buttons .view-button.copied::before,\n.view-source__action-buttons .view-button:not(.copied)::after {\n  scale: 0;\n  opacity: 0;\n  transition-delay: 0s;\n  transition-duration: .2s;\n}\n.view-source__lines {\n  float: left;\n  text-align: right;\n  min-width: 3ex;\n  padding-right: 1ex;\n  margin-right: 1.5ex;\n  border-right: 1px solid rgba(170, 170, 170, 0.4);\n  color: rgba(150, 150, 150, 0.65);\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 12px;\n  line-height: 18px;\n}\n.view-source__lines > span {\n  display: block;\n}\n.view-source__source {\n  flex-grow: 1;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 12px;\n  line-height: 18px;\n  color: var(--discovery-fmt-color);\n}\n.view-source__source .spotlight {\n  background: #f5e69a;\n  padding: 1px 2px 2px;\n}\n.discovery-root-darkmode .view-source__source .spotlight {\n  background: #686246;\n}\n.view-source__source .spotlight.error {\n  background: #ffc9c9;\n}\n.view-source__source .spotlight.def {\n  background: #d3e7fb;\n}\n.view-source__source .spotlight.ref {\n  background: #cee99b;\n}\n.view-source__source .spotlight.global-ref {\n  background: #ffd8a3;\n}\n.view-source__source a.spotlight {\n  position: relative;\n  color: inherit;\n  text-decoration: none;\n}\n.view-source__source a.spotlight:hover {\n  background-color: #f3eec4;\n  color: #aa6622 !important;\n  text-decoration: none;\n}\n.view-source__source .spotlight-ignore {\n  background: #ddd;\n  background-image:\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 6px,\n      rgba(225, 125, 0, .1) 6px,\n      rgba(225, 125, 0, .1) 12px,\n      transparent 12px);\n}\n.view-source__source .token {\n  background: none;\n}\n.view-source__source .token.comment,\n.view-source__source .token.prolog,\n.view-source__source .token.doctype,\n.view-source__source .token.cdata,\n.view-source__source .token.quote {\n  color: var(--discovery-fmt-comment-color);\n}\n.view-source__source .token.punctuation {\n  color: var(--discovery-fmt-punctuation);\n}\n.view-source__source .token.namespace {\n  opacity: .7;\n}\n.view-source__source .token.boolean,\n.view-source__source .token.atom {\n  color: var(--discovery-fmt-atom-color);\n}\n.view-source__source .token.number {\n  color: var(--discovery-fmt-number-color);\n}\n.view-source__source .token.selector,\n.view-source__source .token.attr-value,\n.view-source__source .token.string,\n.view-source__source .token.string-2,\n.view-source__source .token.char,\n.view-source__source .token.builtin,\n.view-source__source .token.inserted {\n  color: var(--discovery-fmt-string-color);\n}\n.view-source__source .token.property,\n.view-source__source .token.tag,\n.view-source__source .token.constant,\n.view-source__source .token.symbol,\n.view-source__source .token.deleted,\n.view-source__source .token.header {\n  color: var(--discovery-fmt-property-color);\n}\n.view-source__source .token.regex,\n.view-source__source .token.important,\n.view-source__source .token.def,\n.view-source__source .token.variable,\n.view-source__source .token.variable-2 {\n  color: var(--discovery-fmt-variable-color);\n}\n.view-source__source .token.keyword,\n.view-source__source .token.atrule,\n.view-source__source .token.link,\n.view-source__source .token.url {\n  color: var(--discovery-fmt-keyword-color);\n}\n.view-source__source .token.qualifier,\n.view-source__source .token.function,\n.view-source__source .token.attribute,\n.view-source__source .token.attr-name,\n.view-source__source .token.class-name {\n  color: var(--discovery-fmt-qualifier);\n}\n.view-source__source .token.entity {\n  color: var(--discovery-fmt-entity);\n}\n.view-source__source .token.image,\n.view-source__source .token.type {\n  color: var(--discovery-fmt-type-color);\n}\n.view-source__source .token.discovery-view-name {\n  background-color: var(--discovery-fmt-string-highlight-color);\n  box-shadow: 0 0 0 1px var(--discovery-fmt-string-highlight-color);\n  color: #6a9c11;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/text-match.css */\n.view-text-match {\n  background: rgba(255, 232, 5, 0.22);\n  border-bottom: 2px solid rgba(213, 190, 15, 0.8);\n  line-height: 1.2;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/text/text-numeric.css */\n.view-text-numeric .num-delim {\n  padding-left: 0.14em;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/column.css */\n.view-column {\n  padding-right: 40px;\n  min-width: 150px;\n}\n.view-column:last-child {\n  padding-right: 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/columns.css */\n.view-columns {\n  display: flex;\n  flex-wrap: wrap;\n}\n.view-columns:empty::before {\n  content: attr(emptyText);\n  color: #888;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/expand.css */\n.view-list > .view-list-item > .view-expand {\n  margin-bottom: 1px;\n}\n.view-expand + .view-expand {\n  margin-top: 1px;\n}\n.view-list > .view-list-item:not(:last-child) > .view-expand.expanded {\n  margin-bottom: 4px;\n}\n.view-expand.expanded + .view-expand {\n  margin-top: 4px;\n}\n.view-expand > .header {\n  display: flex;\n  background: rgba(192, 192, 192, 0.175);\n  font-size: 12px;\n  cursor: pointer;\n  margin-left: calc(var(--discovery-view-expand-trigger-size) + 1px);\n  --discovery-view-expand-trigger-size: 22px;\n}\n.view-expand.trigger-outside > .header {\n  margin-left: 0;\n}\n.view-expand > .header:hover {\n  background: rgba(165, 165, 165, 0.3);\n}\n.view-expand > .header > .header-content {\n  flex: 1;\n  padding: 2px 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  pointer-events: none;\n}\n.view-expand > .header > .trigger {\n  order: -1;\n  width: var(--discovery-view-expand-trigger-size, 20px);\n  margin-left: calc(-1 * var(--discovery-view-expand-trigger-size) - 1px);\n  text-align: center;\n  background-color: inherit;\n  background-image:\n    linear-gradient(\n      0deg,\n      rgba(150, 150, 150, .15),\n      rgba(150, 150, 150, .15));\n}\n.view-expand > .header > .trigger::before {\n  background: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">%0A    <path fill="%23888" d="M 3.71875 7.78125 L 2.28125 9.21875 L 11.28125 18.21875 L 12 18.90625 L 12.71875 18.21875 L 21.71875 9.21875 L 20.28125 7.78125 L 12 16.0625 Z "/>%0A</svg>%0A\') no-repeat center;\n  background-size: 12px;\n  transition: transform .15s ease-in;\n  width: 12px;\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n  transform: rotate(-90deg);\n  content: "";\n}\n.view-expand.expanded > .header > .trigger::before {\n  transform: rotate(0deg);\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/hstack.css */\n.view-hstack {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 20px 40px;\n}\n.view-hstack > * {\n  min-width: 240px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/page-header.css */\n.view-page-header {\n  position: sticky;\n  z-index: 100;\n  top: -15px;\n  left: 0px;\n  padding: 23px var(--discovery-page-padding-right) 6px var(--discovery-page-padding-left);\n  margin: calc(-1 * var(--discovery-page-padding-top)) calc(-1 * var(--discovery-page-padding-right)) 20px calc(-1 * var(--discovery-page-padding-left));\n  background-color: rgba(255, 255, 255, .92);\n  transition: background-color .25s ease-in;\n}\n.discovery-root-darkmode .view-page-header {\n  background-color: rgba(36, 36, 36, .92);\n}\n.page_overscrolled > .view-page-header {\n  box-shadow: 0 0 3px rgba(0, 0, 0, .2);\n  transition-property: background-color, box-shadow;\n}\n.discovery-root-darkmode .page_overscrolled > .view-page-header {\n  box-shadow: 0 0 3px rgba(0, 0, 0, .5);\n}\n@supports (backdrop-filter: blur(5px)) or (-webkit-backdrop-filter: blur(5px)) {\n  .view-page-header {\n    background-color: rgba(255, 255, 255, .8);\n    -webkit-backdrop-filter: blur(5px);\n    backdrop-filter: blur(5px);\n  }\n  .discovery-root-darkmode .view-page-header {\n    background-color: rgba(36, 36, 36, .8);\n  }\n}\n.view-page-header::before {\n  content: "x";\n  visibility: hidden;\n  float: right;\n  margin-left: 10px;\n  width: var(--discovery-nav-width, 200px);\n}\n.view-page-header__prelude .view-badge,\n.view-page-header__prelude .view-pill-badge {\n  display: inline-block;\n  padding: 3px 8px 3px;\n}\n.view-page-header__prelude .view-badge .prefix,\n.view-page-header__prelude .view-badge .postfix,\n.view-page-header__prelude .view-pill-badge .prefix,\n.view-page-header__prelude .view-pill-badge .postfix {\n  padding: 5px 8px 6px;\n  margin: -3px 6px -3px -8px;\n}\n.view-page-header__prelude .view-badge .postfix,\n.view-page-header__prelude .view-pill-badge .postfix {\n  padding: 5px 8px 6px;\n  margin: -3px -8px -3px 6px;\n}\n.view-page-header .view-header {\n  margin: 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/toc-section.css */\n.view-toc-section > .header {\n  top: 0px;\n  position: sticky;\n  z-index: 1;\n  padding: 9px 12px;\n  line-height: 1;\n  font-size: 14px;\n  border: 1px solid rgba(85, 85, 85, 0.2);\n  border-width: 1px 0;\n  background-color: rgba(250, 250, 250, .92);\n  text-transform: capitalize;\n  margin: 0;\n  margin-bottom: -1px;\n  transition: background-color .25s ease-in;\n}\n.discovery-root-darkmode .view-toc-section > .header {\n  background-color: rgba(50, 50, 50, .92);\n  border-color: rgba(0, 0, 0, .25);\n}\n@supports (backdrop-filter: blur(5px)) or (-webkit-backdrop-filter: blur(5px)) {\n  .view-toc-section > .header {\n    background-color: rgba(250, 250, 250, .8);\n    -webkit-backdrop-filter: blur(5px);\n    backdrop-filter: blur(5px);\n  }\n  .discovery-root-darkmode .view-toc-section > .header {\n    background-color: rgba(50, 50, 50, .8);\n    border-color: rgba(0, 0, 0, .25);\n  }\n}\n.view-toc-section > .header .view-badge,\n.view-toc-section > .header .view-pill-badge {\n  text-transform: none;\n  font-weight: normal;\n  margin-left: 4px;\n  margin-right: 0;\n}\n.view-toc-section > .content {\n  padding: 8px 0 8px 12px;\n  white-space: nowrap;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/popup.css */\n.discovery-view-popup {\n  position: fixed;\n  min-width: 200px;\n  box-sizing: border-box;\n  z-index: 300;\n  overflow: hidden;\n  overflow-y: auto;\n  min-height: 20px;\n  border: 1px solid rgba(176, 176, 176, 0.65);\n  box-shadow: 3px 3px 18px rgba(0, 0, 0, .2);\n  background-color: var(--discovery-background-color);\n  transition-property: background-color;\n  transition-duration: .25s;\n  transition-timing-function: ease-in;\n}\n.discovery-view-popup.inspect {\n  z-index: 2002;\n}\n.discovery-view-popup.show-on-hover:not([data-pin-mode=popup-hover]):not(.pinned) {\n  pointer-events: none;\n}\n.discovery-view-popup:not(.pinned)[data-pin-mode=trigger-click]::before,\n.discovery-view-popup:not(.pinned)[data-pin-mode=trigger-click]::after {\n  content: "Click to pin this popup";\n  display: block;\n  visibility: hidden;\n  left: 0;\n  right: 0;\n  z-index: 100;\n  padding: 2px 8px;\n  background-color: var(--discovery-background-color);\n  background-image:\n    linear-gradient(\n      to bottom,\n      rgba(0, 0, 0, .05),\n      rgba(0, 0, 0, .05));\n  color: #888;\n  font-size: 10px;\n  text-align: center;\n}\n.discovery-view-popup:not(.pinned)[data-pin-mode=trigger-click][data-v-to=top]::before {\n  position: absolute;\n  visibility: visible;\n  bottom: 0;\n}\n.discovery-view-popup:not(.pinned)[data-pin-mode=trigger-click][data-v-to=bottom]::after {\n  position: absolute;\n  visibility: visible;\n  top: 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/layout/section.css */\n.view-section {\n  margin-bottom: 30px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/signature/style/action-button.css */\n.view-signature [data-action] {\n  vertical-align: top;\n  margin-left: 2px;\n  padding: 2px 5px;\n  font-size: 9px;\n  color: rgba(170, 170, 170, 0.4);\n  background: rgba(195, 195, 195, 0.05);\n  border: 1px solid rgba(141, 141, 141, 0.15);\n  border-radius: 3px;\n  cursor: pointer;\n}\n.discovery-root-darkmode .view-signature [data-action] {\n  --discovery-view-signature-hover-color: #aaa;\n  --discovery-view-signature-toggle-color: #72b372;\n}\n.view-signature [data-action][data-enabled=true],\n.view-signature [data-action][data-enabled=true]:hover {\n  color: var(--discovery-view-signature-toggle-color, #333);\n  background: rgba(151, 223, 151, 0.25);\n  border-color: rgba(137, 177, 137, 0.4);\n}\n.view-signature [data-action=collapse]::before {\n  content: "\\2013";\n}\n.view-signature [data-action=dict-mode]::before {\n  content: "dict";\n}\n.view-signature [data-action=sort-keys]::before {\n  content: "keys \\2193";\n}\n.view-signature [data-action]:hover {\n  color: var(--discovery-view-signature-hover-color, #333);\n  background: rgba(187, 187, 187, 0.25);\n  border-color: rgba(137, 137, 137, 0.4);\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/signature/style/details-popup.css */\n.discovery-view-popup.signature-details {\n  padding: 10px;\n}\n.discovery-view-popup.signature-details > * {\n  max-width: 420px;\n}\n.discovery-view-popup.signature-details .path {\n  position: relative;\n  top: -4px;\n  margin-bottom: -2px;\n  font-size: 12px;\n  color: var(--discovery-fmt-property-color);\n  opacity: .8;\n}\n.discovery-view-popup.signature-details .view-h1 {\n  margin: 20px 0 15px;\n  line-height: 1;\n  font-size: 180%;\n}\n.discovery-view-popup.signature-details .view-h1.property {\n  color: var(--discovery-fmt-property-color);\n}\n.discovery-view-popup.signature-details .view-h1.type {\n  color: var(--discovery-fmt-atom-color);\n  margin-bottom: 8px;\n}\n.discovery-view-popup.signature-details .path + .view-h1,\n.discovery-view-popup.signature-details .view-h1:first-child {\n  margin-top: 0;\n}\n.discovery-view-popup.signature-details .view-h1:last-child {\n  margin-bottom: 0;\n}\n.discovery-view-popup.signature-details .usage-stat {\n  display: inline-block;\n  padding: 0 2ex 0 1ex;\n  font-size: 12px;\n  font-weight: normal;\n  color: #aaa;\n}\n.discovery-view-popup.signature-details .usage-stat.optional::before {\n  content: "optional ";\n  color: var(--discovery-fmt-flag-color);\n}\n.discovery-view-popup.signature-details .num {\n  color: var(--discovery-fmt-atom-color);\n}\n.discovery-view-popup.signature-details .pie-stat {\n  display: flex;\n  align-items: center;\n  margin: 10px 0;\n}\n.discovery-view-popup.signature-details .pie-stat .list-header {\n  font-size: 11px;\n  color: #aaa;\n}\n.discovery-view-popup.signature-details .pie-stat .view-list {\n  max-width: 270px;\n}\n.discovery-view-popup.signature-details .pie-stat .view-list-item {\n  display: flex;\n  align-items: baseline;\n  white-space: nowrap;\n}\n.discovery-view-popup.signature-details .pie-stat .dot {\n  display: inline-block;\n  min-width: var(--size);\n  height: var(--size);\n  border-radius: 50%;\n}\n.discovery-view-popup.signature-details .pie-stat .caption {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  margin: 0 5px;\n}\n.discovery-view-popup.signature-details .pie-stat .caption:empty::before {\n  content: "empty string";\n  padding: 2px 4px 3px;\n  border-radius: 3px;\n  background: rgba(180, 180, 180, 0.2);\n  color: #888;\n  font-size: 11px;\n}\n.discovery-view-popup.signature-details .pie-stat .times {\n  color: #aaa;\n  font-size: 11px;\n}\n.discovery-view-popup.signature-details .pie-stat .pie {\n  transform: rotate(-90deg);\n  height: var(--size, 100px);\n  width: var(--size, 100px);\n  margin: 0 20px 0 10px;\n  border-radius: 50%;\n}\n.discovery-view-popup.signature-details .overview-stat {\n  color: #aaa;\n  font-size: 12px;\n}\n.discovery-view-popup.signature-details .overview-stat + .view-content-filter {\n  margin-top: 8px;\n}\n.discovery-view-popup.signature-details .view-content-filter > .view-input {\n  margin-bottom: 4px;\n}\n.discovery-view-popup.signature-details .view-menu-item {\n  display: flex;\n  align-items: baseline;\n}\n.discovery-view-popup.signature-details .view-menu-item > .caption {\n  flex: 1;\n}\n.discovery-view-popup.signature-details .view-menu-item > .caption:empty::before {\n  content: "[empty string]";\n  color: #888;\n}\n.discovery-view-popup.signature-details .view-menu-item > .count {\n  color: #aaa;\n  font-size: 11px;\n}\n.discovery-view-popup.signature-details .struct-list > .view-list-item {\n  position: relative;\n}\n.discovery-view-popup.signature-details .struct-list > .view-list-item > .view-struct {\n  overflow: hidden;\n}\n.discovery-view-popup.signature-details .struct-list > .view-list-item > .view-struct.struct-expanded-value {\n  overflow-x: auto;\n}\n.discovery-view-popup.signature-details .struct-list > .view-list-item > .count {\n  position: absolute;\n  top: 7px;\n  right: 0;\n  color: #aaa;\n  font-size: 11px;\n  padding: 0 4px 1px;\n  border-radius: 3px 0 0 3px;\n  background: var(--discovery-background-color);\n  opacity: .9;\n}\n.discovery-view-popup.signature-details .array-types,\n.discovery-view-popup.signature-details .set-types {\n  padding: 8px 0 8px 12px;\n  margin-top: 4px;\n  border-left: 2px solid rgba(-45, 112, 178, 0.8);\n}\n.discovery-view-popup.signature-details .array-types::before,\n.discovery-view-popup.signature-details .set-types::before {\n  display: inline-block;\n  vertical-align: top;\n  position: relative;\n  top: -8px;\n  left: -12px;\n  padding: 2px 4px;\n  color: white;\n  font-size: 10px;\n  line-height: 12px;\n  background: rgba(-45, 112, 178, 0.8);\n}\n.discovery-view-popup.signature-details .array-types::before {\n  content: "Array value types";\n}\n.discovery-view-popup.signature-details .set-types::before {\n  content: "Set value types";\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/signature/style/index.css */\n.view-signature {\n  position: relative;\n  margin: 1px 0;\n  padding: 7px 32px 7px 8px;\n  overflow: auto;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 12px;\n  line-height: 18px;\n  background: rgba(205, 205, 205, 0.1);\n  color: var(--discovery-fmt-color);\n  white-space: pre;\n}\n.discovery-view-popup .view-signature {\n  background: none;\n}\n.view-signature .expand {\n  padding: 2px;\n  margin: 0 -2px;\n}\n.view-signature .expand:hover {\n  color: var(--discovery-fmt-hover-color);\n  background-color: rgba(187, 187, 187, 0.25);\n  border-radius: 4px;\n  cursor: pointer;\n}\n.view-signature .count {\n  vertical-align: middle;\n  padding-left: 3px;\n  font-size: 90%;\n  color: rgba(157, 157, 157, 0.35);\n}\n.view-signature .count::before {\n  content: attr(data-value);\n}\n.view-signature .count:hover {\n  color: rgba(148, 148, 148, 0.8);\n}\n.view-signature .property {\n  padding: 2px;\n  margin: 0 -2px;\n  color: var(--discovery-fmt-property-color);\n  cursor: pointer;\n}\n.view-signature .property.discovery-view-popup-active,\n.view-signature .property:hover {\n  background-color: rgba(170, 170, 170, 0.2);\n}\n.view-signature .optional {\n  color: var(--discovery-fmt-flag-color);\n  padding-left: 2px;\n}\n.view-signature .type {\n  padding: 2px;\n  margin: 0 -2px 0 -2px;\n  color: var(--discovery-fmt-atom-color);\n  cursor: pointer;\n}\n.view-signature .type.discovery-view-popup-active,\n.view-signature .type:hover {\n  background-color: rgba(170, 170, 170, 0.2);\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/struct/style/structure.css */\n.view-struct .entry-line {\n  white-space: nowrap;\n  padding-left: 4ch;\n}\n.view-struct .label {\n  float: left;\n  margin-left: -4ch;\n}\n.view-struct .property {\n  color: var(--discovery-fmt-property-color);\n}\n.view-struct .value {\n  white-space: normal;\n  vertical-align: top;\n}\n.view-struct .keyword {\n  color: var(--discovery-fmt-atom-color);\n}\n.view-struct .value > .number {\n  color: var(--discovery-fmt-number-color);\n}\n.view-struct .value > .number .num-delim {\n  padding-left: 2px;\n}\n.view-struct .value > .string,\n.view-struct .value > .string a {\n  color: var(--discovery-fmt-string-color);\n  text-decoration-color: var(--discovery-fmt-string-underline-color);\n  white-space: pre;\n}\n.view-struct .value > .string a:hover {\n  color: var(--discovery-fmt-string-hover-color);\n  text-decoration-color: currentColor;\n}\n.view-struct .value > .regexp {\n  color: var(--discovery-fmt-string-color);\n  white-space: pre;\n}\n.view-struct .value-size,\n.view-struct .string-length {\n  padding-left: 6px;\n  color: rgba(153, 153, 153, 0.5);\n  font-size: 11px;\n  line-height: 14px;\n  vertical-align: text-top;\n}\n.view-struct .value-size:hover,\n.view-struct .string-length:hover {\n  color: inherit;\n}\n.view-struct .value-size > .num-delim,\n.view-struct .string-length > .num-delim {\n  padding-left: 2px;\n}\n.view-struct .string-text-wrapper {\n  display: block;\n  padding: 4px 4px 4px 5.5ex;\n}\n.view-struct .string-text {\n  display: inline;\n  white-space: pre-wrap;\n  box-shadow: 0 0 0 2px var(--discovery-fmt-string-highlight-color);\n  background: var(--discovery-fmt-string-highlight-color);\n  color: var(--discovery-fmt-string-color);\n}\n.view-struct .string-value-as-text .string-text {\n  display: block;\n  white-space: pre-wrap;\n  box-shadow: 0 0 0 2px rgba(145, 145, 145, 0.1);\n  background: rgba(145, 145, 145, 0.1);\n  color: var(--discovery-fmt-color);\n}\n.view-struct .view-as-table > .entry-line,\n.view-struct .view-as-table > .more-buttons {\n  display: none;\n}\n.view-struct .more {\n  color: rgba(127, 127, 127, 0.8);\n  white-space: nowrap;\n}\n.view-struct .more > .num-delim {\n  padding-left: 2px;\n}\n.view-struct .string > .more {\n  margin: 0 3px;\n}\n.view-struct .value > .more-buttons {\n  padding-left: 4ch;\n}\n.view-struct .value > .view-table {\n  margin-top: 2px;\n  margin-left: 4ch;\n  margin-right: 4px;\n  padding: 0 1px 1px;\n  font-family: var(--discovery-font-family);\n  background-color: var(--discovery-background-color);\n  color: var(--discovery-color);\n}\n.view-struct .value > .view-table .more-buttons {\n  margin: 2px 5px 4px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/struct/style/action-button.css */\n.view-struct .struct-action-button {\n  vertical-align: top;\n  margin-left: 2px;\n  padding: 2px 5px;\n  color: rgba(170, 170, 170, 0.4);\n  background-color: rgba(195, 195, 195, 0.05);\n  border: 1px solid rgba(141, 141, 141, 0.15);\n  border-radius: 3px;\n  font-size: 9px;\n  cursor: pointer;\n}\n.discovery-root-darkmode .view-struct .struct-action-button {\n  --discovery-view-struct-hover-color: #aaa;\n  --discovery-view-struct-toggle-color: #72b372;\n}\n.view-struct .struct-action-button:hover,\n.view-struct .discovery-view-popup-active {\n  color: var(--discovery-view-struct-hover-color, #333);\n  background-color: rgba(187, 187, 187, 0.25);\n  border-color: rgba(137, 137, 137, 0.4);\n}\n.view-struct .sort-keys > .struct-action-button[data-action=toggle-sort-keys],\n.view-struct .string-value-as-text > .struct-action-button[data-action=toggle-string-mode],\n.view-struct .view-as-table > .struct-action-button[data-action=toggle-view-as-table] {\n  color: var(--discovery-view-struct-toggle-color, #686);\n  background-color: rgba(151, 223, 151, 0.25);\n  border-color: rgba(137, 177, 137, 0.4);\n}\n.view-struct .struct-action-button[data-action=show-signature] {\n  cursor: default;\n}\n@media (hover:none), (hover:on-demand) {\n  .view-struct .struct-action-button {\n    padding: 3px 20px 3px;\n    color: #333;\n    background-color: white;\n    border-color: rgba(100, 100, 100, 0.2);\n  }\n  .discovery-root-darkmode .view-struct .struct-action-button {\n    color: #aaa;\n    background-color: #50505080;\n  }\n  .view-struct .struct-action-button[data-action=show-signature] {\n    cursor: pointer;\n  }\n}\n.discovery-view-popup .view-struct .struct-action-button[data-action=show-signature] {\n  display: none;\n}\n.view-struct .view-as-table > .struct-action-button[data-action=toggle-sort-keys] {\n  display: none;\n}\n.view-struct .struct-action-button[data-action=collapse]::before {\n  content: "\\2013";\n}\n.view-struct .struct-action-button[data-action=show-signature]::before {\n  content: "\\1d54a";\n}\n.view-struct .struct-action-button[data-action=value-actions]::before {\n  content: "\\192";\n}\n.view-struct .struct-action-button[data-action=toggle-sort-keys]::before {\n  content: "keys \\2193";\n}\n.view-struct .struct-action-button[data-action=toggle-string-mode]::before {\n  content: "as text";\n}\n.view-struct .struct-action-button[data-action=toggle-view-as-table]::before {\n  content: "as table";\n}\n.discovery-view-popup.view-struct-actions-popup .notes {\n  display: inline;\n  color: #666;\n}\n.discovery-view-popup.view-struct-actions-popup .notes::before {\n  content: " ";\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/struct/style/annotation.css */\n.view-struct .value-annotations {\n  margin-left: 6px;\n}\n.view-struct .value + .value-annotations {\n  margin-left: 1.5ex;\n}\n.view-struct .value-annotation {\n  display: inline-block;\n  vertical-align: middle;\n  padding: 1px 4px;\n  margin-top: -2px;\n  font-size: 10px;\n  line-height: 14px;\n  border-radius: 3px;\n  color: #aaa;\n}\n.view-struct .value-annotation + .value-annotation {\n  margin-left: 2px;\n}\n.view-struct .value-annotation[href]:focus-visible {\n  outline: none;\n  background-color: rgba(187, 187, 187, 0.25);\n  box-shadow: 0 0 0 3px rgba(187, 187, 187, 0.25);\n}\n.view-struct .value-annotation.icon::before {\n  content: "";\n  display: inline-block;\n  vertical-align: text-bottom;\n  height: 14px;\n  width: 14px;\n  background: var(--annotation-image, ) var(--annotation-image-position, 50% center) no-repeat;\n  background-size: var(--annotation-image-size, 14px);\n}\n.view-struct .value-annotation.icon.has-text::before {\n  margin-right: var(--annotation-image-margin, 2px);\n}\n.view-struct .value-annotation.before + .value {\n  margin-left: 2px;\n}\n.view-struct .value-annotation.style-none,\n.view-struct .value-annotation.style-default {\n  --annotation-bg-gradient-from: white;\n  --annotation-bg-gradient-to: rgba(255, 255, 255, 0);\n}\n.discovery-root-darkmode .view-struct .value-annotation.style-default {\n  --annotation-bg-gradient-from: rgba(33, 33, 33, .5);\n  --annotation-bg-gradient-to: rgba(33, 33, 33, 0);\n}\n.view-struct .value-annotation.before.style-default {\n  background:\n    linear-gradient(\n      to left,\n      var(--annotation-bg-gradient-from),\n      var(--annotation-bg-gradient-to));\n  border-right: 1px solid;\n}\n.view-struct .value-annotation.after.style-default {\n  background:\n    linear-gradient(\n      to right,\n      var(--annotation-bg-gradient-from),\n      var(--annotation-bg-gradient-to));\n  border-left: 1px solid;\n}\n.view-struct .value-annotation.style-badge {\n  text-decoration: none;\n  background: rgba(155, 155, 155, 0.15);\n  color: #999;\n  border-radius: 3px;\n  user-select: none;\n}\n.view-struct .value-annotation.style-badge[href] {\n  background: rgba(55, 155, 230, 0.16);\n}\n.view-struct .value-annotation.style-badge[href]:hover {\n  color: #89a0bd;\n  text-decoration: underline;\n  text-decoration-color: #89a0bd88;\n}\n.view-struct .value-annotation .num-delim {\n  padding-left: 2px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/struct/style/index.css */\n.view-struct {\n  position: relative;\n  margin: 1px 0;\n  padding: 7px 8px;\n  overflow: auto;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 12px;\n  line-height: 18px;\n  background-color: rgba(205, 205, 205, 0.1);\n  color: var(--discovery-fmt-color);\n  white-space: nowrap;\n}\n.view-struct.struct-expand {\n  cursor: pointer;\n}\n.view-struct .struct-expand-value {\n  display: inline-block;\n  vertical-align: top;\n  white-space: nowrap !important;\n  border-radius: 4px;\n  cursor: pointer;\n}\n.view-struct.struct-expand:hover,\n.view-struct.struct-expanded-value .struct-expand-value:hover {\n  color: var(--discovery-fmt-hover-color);\n  background-color: rgba(187, 187, 187, 0.25);\n}\n.view-struct.struct-expanded-value,\n.view-struct .struct-expanded-value {\n  background-image:\n    linear-gradient(\n      to bottom,\n      rgba(187, 187, 187, 0.15),\n      rgba(187, 187, 187, 0.15));\n  background-size: 1px calc(100% - 36px);\n  background-position: 3px 18px;\n  background-repeat: no-repeat;\n  background-attachment: local;\n  background-origin: content-box;\n}\n.discovery-view-popup.view-struct-actions-popup .error {\n  font-size: 11px;\n  color: rgba(214, 31, 31, 77%);\n  text-shadow: 0.2px 0px 0.3px rgba(255, 255, 255, .8);\n}\n.discovery-root-darkmode .discovery-view-popup.view-struct-actions-popup .error {\n  color: #e66;\n  text-shadow: none;\n}\n.discovery-view-popup.view-struct-actions-popup .num-delim {\n  padding-left: 3px;\n}\n.discovery-view-popup.view-struct-signature-popup.computing {\n  padding: 8px;\n  line-height: 1px;\n  animation: view-struct-signature-computing .5s forwards linear;\n}\n@keyframes view-struct-signature-computing {\n  from {\n    opacity: 0;\n  }\n}\n.discovery-view-popup.view-struct-signature-popup.computing::before {\n  --color: #f6f61cb5;\n  content: "";\n  display: inline-block;\n  vertical-align: top;\n  width: 10px;\n  height: 10px;\n  border: 2px solid var(--color);\n  border-radius: 50%;\n  clip-path: inset(0px 0px 50% 50%);\n  animation: view-struct-signature-computing-spinner .65s forwards infinite linear;\n}\n@keyframes view-struct-signature-computing-spinner {\n  to {\n    rotate: 360deg;\n  }\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/table/table-cell.css */\n.view-table-cell {\n  padding: 2px 8px;\n  height: 19px;\n  vertical-align: top;\n}\n.view-table-cell.number {\n  text-align: right;\n}\n.view-table-cell .num-delim {\n  padding-left: 2px;\n}\n.view-table-cell.complex {\n  color: #888;\n}\n.view-table-cell.details {\n  padding-left: 14px;\n  position: relative;\n  background-clip: padding-box;\n}\n.view-table-cell.details::before {\n  content: ".";\n  color: transparent;\n  display: inline-block;\n  position: absolute;\n  left: 3px;\n  top: 3px;\n  width: 9px;\n  transform: rotate(-90deg);\n  transition: .12s ease-in;\n  transition-property: transform, opacity;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">%0A    <path fill="%23888" d="M 3.71875 7.78125 L 2.28125 9.21875 L 11.28125 18.21875 L 12 18.90625 L 12.71875 18.21875 L 21.71875 9.21875 L 20.28125 7.78125 L 12 16.0625 Z "/>%0A</svg>%0A\');\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 9px;\n  opacity: .5;\n}\n.view-table-cell.details:hover {\n  background-color: rgba(180, 180, 180, 0.2);\n  cursor: pointer;\n}\n.view-table-cell.details-expanded {\n  background-image:\n    linear-gradient(\n      to top,\n      rgba(170, 170, 170, 0.2),\n      transparent),\n    linear-gradient(\n      to top,\n      rgba(170, 170, 170, 0.2),\n      transparent);\n  background-repeat: no-repeat;\n  background-size: 1px 100%;\n  background-position: left top, right top;\n  border-bottom: none !important;\n}\n.view-table-cell.details-expanded:hover {\n  background-color: rgba(180, 180, 180, 0.2);\n}\n.view-table-cell.details.details-expanded::before {\n  transform: rotate(0deg);\n  opacity: 1;\n}\n.view-table-cell-details-row > .view-cell-details-content {\n  padding: 1px;\n  border: 1px solid rgba(170, 170, 170, 0.25);\n  border-top: none;\n}\n.view-table-cell-details-row > .view-cell-details-content > :first-child {\n  margin-top: 0 !important;\n}\n.view-table-cell-details-row > .view-cell-details-content > :last-child {\n  margin-bottom: 0 !important;\n}\n.view-table-cell > .view-struct,\n.view-table-cell > .view-struct:hover {\n  margin: -1px -8px -2px;\n  padding: 2px 8px 1px;\n  background-color: transparent;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/table/table-row.css */\n.view-table-row:not(:last-child) > td {\n  border-bottom: 1px solid rgba(170, 170, 170, 0.2);\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/table/table.css */\n.view-table {\n  font-size: 12px;\n  line-height: 19px;\n  border-spacing: 0;\n}\n.view-table > thead th {\n  padding: 2px 8px;\n  font-weight: normal;\n  text-align: left;\n  background: rgba(141, 141, 141, 0.15) no-repeat right 1px center;\n  background-size: 16px;\n  background-clip: padding-box;\n  border: 1px solid transparent;\n  border-width: 1px 1px 1px 0;\n}\n.view-table > thead th:last-child {\n  border-right: none;\n}\n.view-table > thead th.sortable {\n  padding-right: 18px;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 172 172">%0A    <path fill="rgba(153, 153, 153, 0.4)" d="M86,11.21192l-64.03808,64.03808h128.07617zM86,26.41308l38.08692,38.08692h-76.17383zM21.96192,86l64.03808,64.03808l64.03808,-64.03808zM47.91308,96.75h76.17383l-38.08692,38.08692z"/>%0A</svg>%0A\');\n  cursor: pointer;\n}\n.view-table > thead th.sortable:not(.asc):not(.desc) {\n  background-size: 14px;\n  background-position: right 2px center;\n}\n.view-table > thead th.sortable.asc {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">%0A    <path fill="%23888" d="M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"/>%0A</svg>%0A\');\n}\n.view-table > thead th.sortable.desc {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet">%0A    <path fill="%23888" d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z" />%0A</svg>%0A\');\n}\n.view-table > thead th.sortable:hover {\n  background-color: rgba(141, 141, 141, 0.3);\n}\n.view-table-cell-details-row > .view-cell-details-content > .view-table:first-child {\n  margin-top: -1px !important;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/tree/tree-leaf.css */\n.view-tree-leaf {\n  --view-leaf-lines-offset: 0;\n  position: relative;\n  display: grid;\n  grid-template-columns: 20px auto;\n  grid-template-areas: "toggle content" "toggle children";\n  background-image:\n    linear-gradient(\n      to right,\n      rgba(153, 153, 153, 0.5),\n      rgba(153, 153, 153, 0.5)),\n    linear-gradient(\n      to right,\n      rgba(153, 153, 153, 0.5),\n      rgba(153, 153, 153, 0.5));\n  background-size: 1px calc(1em - 7px * var(--view-leaf-lines-offset, 0)), 1px 100%;\n  background-position: 5px top, 5px calc(1em + 6px * var(--view-leaf-lines-offset, 0));\n  background-repeat: no-repeat;\n}\n.view-tree-leaf.has-children:not(.non-collapsible),\n.view-tree-leaf.has-children.collapsed {\n  --view-leaf-lines-offset: 1;\n}\n.view-tree-leaf.last,\n:not(.incomplete) > .view-tree-leaf:last-child {\n  background-image:\n    linear-gradient(\n      to right,\n      rgba(153, 153, 153, 0.5),\n      rgba(153, 153, 153, 0.5));\n}\n.view-tree-leaf-toggle {\n  grid-area: toggle;\n  visibility: hidden;\n  display: inline-block;\n  position: relative;\n  top: 1em;\n  margin-top: -3px;\n  width: 9px;\n  height: 9px;\n  border-radius: 2px;\n  border: 1px solid currentColor;\n  margin-right: 9px;\n  font-size: 10px;\n  line-height: 8px;\n  text-align: center;\n  color: rgba(127, 127, 127, 0.8);\n  cursor: pointer;\n}\n.view-tree-leaf-toggle:hover {\n  color: #808080;\n}\n.view-tree-leaf.has-children > .view-tree-leaf-toggle {\n  visibility: visible;\n}\n.view-tree-leaf.non-collapsible:not(.collapsed) > .view-tree-leaf-toggle {\n  visibility: hidden;\n}\n.view-tree-leaf-toggle::before {\n  content: "\\2013";\n}\n.view-tree-leaf.collapsed > .view-tree-leaf-toggle::before {\n  content: "+";\n}\n.view-tree-leaf-toggle::after {\n  content: "";\n  visibility: visible;\n  position: absolute;\n  top: 4px;\n  left: 5px;\n  right: -6px;\n  height: 1px;\n  background-color: rgba(153, 153, 153, 0.5);\n  pointer-events: none;\n}\n.view-tree-leaf.has-children:not(.non-collapsible) > .view-tree-leaf-toggle::after,\n.view-tree-leaf.has-children.collapsed > .view-tree-leaf-toggle::after {\n  left: 11px;\n}\n.view-tree-leaf-content {\n  grid-area: content;\n  display: inline-block;\n}\n.view-tree-leaf-children {\n  grid-area: children;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.view-tree-leaf.collapsed > .view-tree-leaf-children {\n  display: none;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/tree/tree.css */\n.view-tree {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  font-size: 13px;\n  line-height: 24px;\n}\n.view-tree:empty::before {\n  content: attr(emptyText);\n  color: #888;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/index.css */\n.more-buttons {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 5px;\n  margin-top: 2px;\n}\n.more-buttons .more-button {\n  vertical-align: top;\n  color: var(--discovery-color, black);\n  min-height: 0;\n  padding: 4px 8px;\n  margin: 0;\n  background-color: rgba(255, 255, 255, .1);\n  border: 1px solid rgba(127, 127, 127, 0.4);\n  border-radius: 3px;\n  font-size: 11px;\n  line-height: 12px;\n  font-family: var(--discovery-ui-font-family);\n  cursor: pointer;\n}\n@supports not (gap: 5px) {\n  .more-buttons {\n    margin-top: 0;\n  }\n  .more-buttons .more-button {\n    margin-top: 4px;\n    margin-right: 5px;\n  }\n}\n.more-buttons .more-button:hover,\n.more-buttons .more-button:active,\n.more-buttons .more-button:focus {\n  background-color: rgba(221, 221, 221, 0.3);\n  border-color: rgba(170, 170, 170, 0.6);\n  outline: none;\n}\n.more-buttons .more-button:active {\n  background-color: rgba(131, 131, 131, 0.25);\n  border-color: rgba(127, 127, 127, 0.4);\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/default.css */\n.page-default h1.no-data-loaded {\n  margin-top: 0;\n}\n.page-default h1.no-data-loaded::before {\n  display: inline-block;\n  vertical-align: middle;\n  position: relative;\n  top: -5px;\n  margin-right: 10px;\n  width: 42px;\n  height: 42px;\n  content: "";\n  background: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">%0A    <rect x="65.6" y="24.6" transform="matrix(0.9397 -0.342 0.342 0.9397 -9.9426 31.828)" fill="%23FFFFFF" width="39.3" height="39"></rect>%0A    <rect x="70.6" y="52.7" transform="matrix(-0.9397 0.342 -0.342 -0.9397 194.7852 81.1204)" fill="%23C7D7E2" width="39.3" height="10"></rect>%0A    <path fill="%2398BED8" d="M111.5,54.6l-1.1,1.1L97.1,19.1l1.5,0.2c8,0.9,14.7,6.2,17.4,13.7l0,0C118.8,40.4,117,48.8,111.5,54.6z"></path>%0A    <path fill="%23454B54" d="M73.5,72.2c-1.2,0-2.4-0.8-2.8-2L57.3,33.5c-0.3-0.7-0.2-1.6,0.1-2.3c0.3-0.7,0.9-1.3,1.7-1.6l36.9-13.4c1.6-0.6,3.3,0.2,3.8,1.8l13.3,36.6c0.3,0.7,0.2,1.6-0.1,2.3c-0.3,0.7-0.9,1.3-1.7,1.6L74.5,72C74.2,72.1,73.8,72.2,73.5,72.2zM64,34.3l11.3,31l31.3-11.4l-11.3-31L64,34.3z"></path>%0A    <rect x="35" y="46.7" transform="matrix(0.9397 -0.342 0.342 0.9397 -16.2011 20.988)" fill="%23FFFFFF" width="32.8" height="19.5"></rect>%0A    <rect x="37.3" y="59.8" transform="matrix(-0.9397 0.342 -0.342 -0.9397 125.6763 103.3946)" fill="%23C7D7E2" width="32.8" height="6"></rect>%0A    <path fill="%23454B54" d="M39.4,74.2c-0.4,0-0.9-0.1-1.3-0.3c-0.7-0.3-1.3-0.9-1.6-1.7l-6.7-18.3c-0.3-0.7-0.2-1.6,0.1-2.3c0.3-0.7,0.9-1.3,1.7-1.6l30.8-11.2c0.7-0.3,1.6-0.2,2.3,0.1c0.7,0.3,1.3,0.9,1.6,1.7L73,59c0.6,1.6-0.2,3.3-1.8,3.8L40.4,74C40,74.1,39.7,74.2,39.4,74.2z M36.5,54.7l4.6,12.7l25.2-9.2l-4.6-12.7L36.5,54.7z"></path>%0A    <path fill="%23454B54" d="M70,118.9c-1.2,0-2.4-0.7-2.8-1.9l-14-37.2l-8.4,3.1l-17.2,34.4c-0.7,1.5-2.5,2.1-4,1.3c-1.5-0.7-2.1-2.5-1.3-4L40,79c0.3-0.7,0.9-1.2,1.7-1.5L54,73.1c1.5-0.6,3.3,0.2,3.8,1.8l15,40c0.6,1.6-0.2,3.3-1.8,3.9C70.7,118.8,70.4,118.9,70,118.9z"></path>%0A    <path fill="%23454B54" d="M13.6,80.1c-1.2,0-2.4-0.8-2.8-2L6.3,65.9c-0.6-1.6,0.2-3.3,1.8-3.8c1.6-0.6,3.3,0.2,3.8,1.8l4.4,12.2c0.6,1.6-0.2,3.3-1.8,3.8C14.3,80.1,14,80.1,13.6,80.1z"></path>%0A    <path fill="%23454B54" d="M13.2,73.3c-1.2,0-2.4-0.8-2.8-2c-0.6-1.6,0.2-3.3,1.8-3.8L35,59.2c1.6-0.6,3.3,0.2,3.8,1.8c0.6,1.6-0.2,3.3-1.8,3.8l-22.8,8.3C13.9,73.3,13.6,73.3,13.2,73.3z"></path>%0A</svg>%0A\') no-repeat center;\n  background-size: 42px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/discover/header.css */\n.page-discovery > .discovery-header {\n  display: flex;\n  flex-direction: row;\n  line-height: 1.2;\n  position: sticky;\n  top: -2px;\n  z-index: 100;\n  padding: 22px calc(210px + var(--discovery-page-padding-right)) 7px var(--discovery-page-padding-left);\n  padding: 22px calc(var(--discovery-page-padding-right) + 6px + max(42px * 3, var(--discovery-nav-width, 0px))) 7px var(--discovery-page-padding-left);\n  margin: 0 calc(-1 * var(--discovery-page-padding-right)) 18px calc(-1 * var(--discovery-page-padding-left));\n  background-color: rgba(255, 255, 255, .92);\n  transition: background-color .25s ease-in;\n}\n.discovery-root-darkmode .page-discovery > .discovery-header {\n  background-color: rgba(36, 36, 36, .92);\n}\n.page-discovery.page_overscrolled > .discovery-header {\n  box-shadow: 0 0 3px rgba(0, 0, 0, .2);\n  transition-property: background-color, box-shadow;\n}\n.discovery-root-darkmode .page-discovery.page_overscrolled > .discovery-header {\n  box-shadow: 0 0 3px rgba(0, 0, 0, .5);\n}\n@supports (backdrop-filter: blur(5px)) or (-webkit-backdrop-filter: blur(5px)) {\n  .page-discovery > .discovery-header {\n    background-color: rgba(255, 255, 255, .8);\n    -webkit-backdrop-filter: blur(5px);\n    backdrop-filter: blur(5px);\n  }\n  .discovery-root-darkmode .page-discovery > .discovery-header {\n    background-color: rgba(36, 36, 36, .8);\n  }\n}\n.page-discovery > .discovery-header .discovery-header-text {\n  flex: 1;\n  position: relative;\n  font-size: 220%;\n}\n.page-discovery > .discovery-header .discovery-header-text::before {\n  content: attr(data-title);\n  white-space: pre;\n}\n.page-discovery > .discovery-header .discovery-header-text:focus-within:before {\n  visibility: hidden;\n}\n.page-discovery > .discovery-header .discovery-header-text input {\n  font: inherit;\n  color: inherit;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  margin: -1px;\n  padding: 0;\n  opacity: .0001;\n  border: 1px solid #aaa;\n  border-color: transparent transparent #aaa transparent;\n  background-color: transparent;\n  transition: box-shadow .15s ease-out;\n}\n.page-discovery > .discovery-header .discovery-header-text input:hover,\n.page-discovery > .discovery-header .discovery-header-text input:focus {\n  opacity: 1;\n}\n.page-discovery > .discovery-header .discovery-header-text input:focus {\n  border-bottom-color: #0af;\n  box-shadow: 0 3px 0 0 rgba(0, 170, 255, .2) !important;\n  outline: 0;\n}\n.page-discovery > .discovery-header .discovery-header-text .timestamp {\n  display: block;\n  font-size: 10px;\n  color: rgba(153, 153, 153, 0.5);\n  margin-top: 4px;\n}\n.page-discovery > .discovery-actions {\n  position: sticky;\n  top: 34px;\n  transition: top .25s;\n  z-index: 101;\n  display: flex;\n  justify-content: flex-end;\n  margin-top: 19px;\n  margin-bottom: -61px;\n  pointer-events: none;\n}\n.page-discovery > .discovery-actions button {\n  width: 42px;\n  height: 42px;\n  background: center no-repeat;\n  border-radius: 5px;\n  border: none;\n  text-indent: -500px;\n  overflow: hidden;\n  cursor: pointer;\n  opacity: .5;\n  outline: none;\n  pointer-events: auto;\n}\n.page-discovery > .discovery-actions button.discovery-view-popup-active,\n.page-discovery > .discovery-actions button:hover,\n.page-discovery > .discovery-actions button:focus {\n  background-color: rgba(0, 0, 0, .03125);\n  opacity: 1;\n}\n.page-discovery > .discovery-actions button.toggle-fullscreen {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50">%0A    <path stroke="%23888" stroke-width=".5" fill="%23888" d="M -3 8 C -2.734375 8 -2.48046875 8.10546875 -2.29296875 8.29296875 C -2.10546875 8.48046875 -2 8.734375 -2 9 L -2 26.265625 C -2.29296875 26.09765625 -2.63671875 26 -3 26 L -4 26 L -4 10 L -46 10 L -46 44 L -29.999998092651367 44 L -29.999998092651367 45 C -29.999998092651367 45.36328125 -29.902341842651367 45.70703125 -29.734373092651367 46 L -47 46 C -47.265625 46 -47.51953125 45.89453125 -47.70703125 45.70703125 C -47.89453125 45.51953125 -48 45.265625 -48 45 L -48 9 C -48 8.734375 -47.89453125 8.48046875 -47.70703125 8.29296875 C -47.51953125 8.10546875 -47.265625 8 -47 8 Z M -36 13 C -35.640625 12.99609375 -35.3046875 13.18359375 -35.12109375 13.49609375 C -34.94140625 13.80859375 -34.94140625 14.19140625 -35.12109375 14.50390625 C -35.3046875 14.81640625 -35.640625 15.00390625 -36 15 L -39.5859375 15 L -29.292966842651367 25.29296875 C -29.031248092651367 25.54296875 -28.925779342651367 25.91796875 -29.019529342651367 26.265625 C -29.109373092651367 26.6171875 -29.382810592651367 26.890625 -29.734373092651367 26.98046875 C -30.082029342651367 27.07421875 -30.457029342651367 26.96875 -30.707029342651367 26.70703125 L -41 16.4140625 L -41 20 C -40.99609375 20.359375 -41.18359375 20.6953125 -41.49609375 20.87890625 C -41.80859375 21.05859375 -42.19140625 21.05859375 -42.50390625 20.87890625 C -42.81640625 20.6953125 -43.00390625 20.359375 -43 20 L -43 13 Z M -3 28 C -2.44921875 28 -2 28.44921875 -2 29 L -2 45 C -2 45.55078125 -2.44921875 46 -3 46 L -26.999998092651367 46 C -27.550779342651367 46 -27.999998092651367 45.55078125 -27.999998092651367 45 L -27.999998092651367 29 C -27.999998092651367 28.44921875 -27.550779342651367 28 -26.999998092651367 28 Z M -4 30 L -25.999998092651367 30 L -25.999998092651367 44 L -4 44 Z" transform="matrix(1 0 0 1 50 0)" />%0A</svg>%0A\');\n  background-size: 25px;\n}\n.page-discovery > .discovery-actions button.edit-mode {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">%0A    <path d="M84.7,39.1l-37.3,64.4c-3.1,5.4-7.4,10-12.6,13.4L24,124l0.8-12.9c0.4-6.2,2.2-12.2,5.3-17.6l37.3-64.4" style="fill:%23FFFFFF;"></path>%0A    <path d="M60.4,44.1c-0.5,0-1-0.1-1.5-0.4c-1.4-0.8-1.9-2.7-1.1-4.1l7-12c0.8-1.4,2.7-1.9,4.1-1.1s1.9,2.7,1.1,4.1l-7,12C62.4,43.5,61.4,44.1,60.4,44.1z" style="fill:%23FFFFFF;"></path>%0A    <path d="M77.7,54.1c-0.5,0-1-0.1-1.5-0.4c-1.4-0.8-1.9-2.7-1.1-4.1l7-12c0.8-1.4,2.7-1.9,4.1-1.1c1.4,0.8,1.9,2.7,1.1,4.1l-7,12C79.7,53.5,78.7,54.1,77.7,54.1z" style="fill:%23FFFFFF;"></path>%0A    <path d="M47.2,94.8c-0.5,0-1-0.1-1.5-0.4c-1.4-0.8-1.9-2.7-1.1-4.1l25-43.4c0.8-1.4,2.6-1.8,4.1-1.1c5.6,2.7,5.6,2.7,5.6,2.7L49.9,93.4C49.3,94.4,48.2,94.8,47.2,94.8z" style="fill:%23FCCA3D;"></path>%0A    <path fill="%23888" stroke="%23888" stroke-width=".5" d="M24,127c-0.5,0-1-0.1-1.5-0.4c-1-0.6-1.6-1.6-1.5-2.8l0.8-12.9c0.4-6.6,2.4-13.2,5.7-18.9l30.3-52.4c0.8-1.4,2.7-1.9,4.1-1.1c1.4,0.8,1.9,2.7,1.1,4.1L32.7,95c-2.9,4.9-4.5,10.6-4.9,16.3l-0.4,6.9l5.8-3.8C38,111.3,42,107,44.9,102l30.3-52.4c0.8-1.4,2.7-1.9,4.1-1.1c1.4,0.8,1.9,2.7,1.1,4.1L50,105c-3.3,5.8-8,10.7-13.5,14.4l-10.8,7.1C25.2,126.8,24.6,127,24,127z"></path>%0A    <path fill="%23888" stroke="%23888" stroke-width=".5" d="M89,127H49c-1.7,0-3-1.3-3-3s1.3-3,3-3h40c1.7,0,3,1.3,3,3S90.7,127,89,127z"></path>%0A    <circle fill="%23888" stroke="%23888" stroke-width=".5" cx="104" cy="124" r="3"></circle>%0A    <path d="M87.7,36.7c-0.5,0-1-0.1-1.5-0.4c-1.4-0.8-1.9-2.7-1.1-4.1c0.9-1.6,1.2-3.5,0.7-5.3s-1.6-3.3-3.3-4.2c-1.6-0.9-3.5-1.2-5.3-0.7s-3.3,1.6-4.3,3.3c-0.8,1.4-2.7,1.9-4.1,1.1s-1.9-2.7-1.1-4.1c3.6-6.2,11.6-8.3,17.8-4.8c3,1.7,5.2,4.5,6.1,7.9s0.4,6.9-1.3,9.9C89.7,36.2,88.7,36.7,87.7,36.7z" style="fill:%23FF5576;"></path>%0A    <path d="M87.7,33.7c2.8-4.8,1.1-10.9-3.7-13.7l0,0c-4.8-2.8-10.9-1.1-13.7,3.7l-3.7,6.5l17.3,10L87.7,33.7z" style="fill:%23FF5576;"></path>%0A    <path d="M83.9,43.2c-0.5,0-1-0.1-1.5-0.4l-17.3-10c-0.7-0.4-1.2-1.1-1.4-1.8c-0.2-0.8-0.1-1.6,0.3-2.3l3.7-6.5c3.6-6.2,11.6-8.3,17.8-4.8c3,1.7,5.2,4.5,6.1,7.9s0.4,6.9-1.3,9.9l-3.7,6.5c-0.4,0.7-1.1,1.2-1.8,1.4C84.4,43.2,84.2,43.2,83.9,43.2z M70.7,29.1l12.1,7l2.2-3.9l0,0c0.9-1.6,1.2-3.5,0.7-5.3s-1.6-3.3-3.3-4.2c-3.3-1.9-7.6-0.8-9.6,2.6L70.7,29.1z" style="fill:%23FF5576;"></path>%0A    <path d="M83.9,43.2c-0.5,0-1-0.1-1.5-0.4c-1.4-0.8-1.9-2.7-1.1-4.1l3.7-6.5c1-1.8,1.2-4,0.5-6c-0.6-1.6,0.2-3.3,1.8-3.9c1.6-0.6,3.3,0.2,3.9,1.8c1.4,3.7,1,7.7-0.9,11.1l-3.7,6.5C86,42.7,85,43.2,83.9,43.2z" style="fill:%23D32F56;"></path>%0A</svg>%0A\');\n  background-size: 20px;\n}\n.page-discovery > .discovery-actions button.edit-mode:not(.disabled) {\n  opacity: 1;\n}\n.page-discovery > .discovery-actions button.edit-mode.disabled {\n  filter: grayscale();\n}\n.page-discovery > .discovery-actions button.share {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50">%0A    <path stroke="%23888" stroke-width=".5" fill="%23888"  d="M 28.875 11 C 28.371094 11.0625 27.996094 11.492188 28 12 L 28 19.0625 C 16.488281 19.414063 10.28125 25.507813 7.21875 31.5625 C 4.113281 37.699219 4.003906 43.683594 4 43.875 C 4 43.875 4 43.9375 4 43.9375 L 4 44 C 3.984375 44.550781 4.417969 45.015625 4.96875 45.03125 C 5.519531 45.046875 5.984375 44.613281 6 44.0625 C 6 44.0625 6 44 6 44 C 6.007813 43.90625 6.230469 40.878906 9.09375 37.65625 C 11.90625 34.496094 17.394531 31.308594 28 31.09375 L 28 38 C 28 38.382813 28.21875 38.734375 28.566406 38.902344 C 28.914063 39.070313 29.324219 39.023438 29.625 38.78125 L 45.625 25.78125 C 45.863281 25.589844 46 25.304688 46 25 C 46 24.695313 45.863281 24.410156 45.625 24.21875 L 29.625 11.21875 C 29.414063 11.046875 29.144531 10.96875 28.875 11 Z M 30 14.09375 L 43.40625 25 L 30 35.90625 L 30 30 C 30 29.449219 29.550781 29 29 29 C 17.246094 29 10.910156 32.613281 7.59375 36.34375 C 7.46875 36.484375 7.398438 36.609375 7.28125 36.75 C 7.703125 35.375 8.257813 33.90625 9 32.4375 C 11.917969 26.671875 17.488281 21 29 21 C 29.550781 21 30 20.550781 30 20 Z " />%0A</svg>%0A\');\n  background-size: 25px;\n}\n.discovery[data-dzen] .page-discovery > .discovery-actions {\n  top: 20px;\n}\n.discovery[data-dzen] .page-discovery > .discovery-actions button.toggle-fullscreen {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50">%0A    <path stroke="%23888" stroke-width=".5" fill="%23888" d="M -3 8 C -2.734375 8 -2.48046875 8.10546875 -2.29296875 8.29296875 C -2.10546875 8.48046875 -2 8.734375 -2 9 L -2 26.265625 C -2.29296875 26.09765625 -2.63671875 26 -3 26 L -4 26 L -4 10 L -46 10 L -46 44 L -29.999998092651367 44 L -29.999998092651367 45 C -29.999998092651367 45.36328125 -29.902341842651367 45.70703125 -29.734373092651367 46 L -47 46 C -47.265625 46 -47.51953125 45.89453125 -47.70703125 45.70703125 C -47.89453125 45.51953125 -48 45.265625 -48 45 L -48 9 C -48 8.734375 -47.89453125 8.48046875 -47.70703125 8.29296875 C -47.51953125 8.10546875 -47.265625 8 -47 8 Z M -35.98592758178711 27.01408576965332 C -36.34530258178711 27.01799201965332 -36.68124008178711 26.83049201965332 -36.86483383178711 26.51799201965332 C -37.04452133178711 26.20549201965332 -37.04452133178711 25.82267951965332 -36.86483383178711 25.51017951965332 C -36.68124008178711 25.19767951965332 -36.34530258178711 25.01017951965332 -35.98592758178711 25.01408576965332 L -32.39999008178711 25.01408576965332 L -42.692962646484375 14.721118927001953 C -42.954681396484375 14.471118927001953 -43.060150146484375 14.096118927001953 -42.966400146484375 13.748462677001953 C -42.876556396484375 13.396900177001953 -42.603118896484375 13.123462677001953 -42.251556396484375 13.033618927001953 C -41.903900146484375 12.939868927001953 -41.528900146484375 13.045337677001953 -41.278900146484375 13.307056427001953 L -30.98592185974121 23.60002326965332 L -30.98592185974121 20.01408576965332 C -30.98982810974121 19.65471076965332 -30.80232810974121 19.31877326965332 -30.48982810974121 19.13517951965332 C -30.17732810974121 18.95549201965332 -29.79451560974121 18.95549201965332 -29.48201560974121 19.13517951965332 C -29.16951560974121 19.31877326965332 -28.98201560974121 19.65471076965332 -28.98592185974121 20.01408576965332 L -28.98592185974121 27.01408576965332 Z M -3 28 C -2.44921875 28 -2 28.44921875 -2 29 L -2 45 C -2 45.55078125 -2.44921875 46 -3 46 L -26.999998092651367 46 C -27.550779342651367 46 -27.999998092651367 45.55078125 -27.999998092651367 45 L -27.999998092651367 29 C -27.999998092651367 28.44921875 -27.550779342651367 28 -26.999998092651367 28 Z M -4 30 L -25.999998092651367 30 L -25.999998092651367 44 L -4 44 Z" transform="matrix(1 0 0 1 50 -7.10543e-15)" />%0A</svg>%0A\');\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/discover/editor-common.css */\n.page-discovery > .discovery-editor .discovery-editor-tabs {\n  overflow: hidden;\n  display: inline-block;\n  vertical-align: top;\n}\n.page-discovery > .discovery-editor .data-query-result::before,\n.page-discovery > .discovery-editor .discovery-editor-tabs::before {\n  padding: 3px 4px;\n  width: 40px;\n  text-align: right;\n  box-sizing: border-box;\n  font-size: 11px;\n  color: rgba(141, 141, 141, 0.75);\n}\n.page-discovery > .discovery-editor .discovery-editor-tab {\n  display: inline-block;\n  margin: 0 1px 1px 0;\n  padding: 2px 12px;\n  background: rgba(200, 200, 200, 0.2);\n  font-size: 12px;\n  cursor: pointer;\n}\n.page-discovery > .discovery-editor .discovery-editor-tab.active {\n  padding-bottom: 3px;\n  margin-bottom: 0;\n  background: rgba(108, 188, 241, 0.15);\n  cursor: default;\n}\n.page-discovery > .discovery-editor .discovery-editor-tab:not(.active):hover {\n  background: rgba(187, 187, 187, 0.4);\n}\n.page-discovery > .discovery-editor .discovery-editor-tab:first-child {\n  border-top-left-radius: 4px;\n}\n.page-discovery > .discovery-editor .discovery-editor-tab.active:first-child {\n  border-bottom-left-radius: 4px;\n  padding-bottom: 2px;\n  margin-bottom: 1px;\n}\n.page-discovery > .discovery-editor .discovery-editor-tab:last-child {\n  border-top-right-radius: 4px;\n}\n.page-discovery > .discovery-editor .discovery-editor-tab:not(.active):last-child {\n  border-bottom-right-radius: 4px;\n}\n.page-discovery > .discovery-editor .editor-toolbar {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: baseline;\n  gap: 10px;\n}\n.page-discovery > .discovery-editor .editor-toolbar label {\n  padding: 4px;\n  margin: 0 1ex;\n  white-space: nowrap;\n}\n.page-discovery > .discovery-editor .editor-toolbar .syntax-hint {\n  padding-left: 10px;\n  flex: 1;\n  color: rgba(141, 141, 141, 0.75);\n  font-size: 12px;\n  align-self: start;\n}\n.page-discovery > .discovery-editor .editor-toolbar .view-checkbox__label {\n  margin-right: 0;\n}\n.page-discovery > .discovery-editor .discovery-editor-error {\n  border-bottom: 1px solid rgba(255, 0, 0, .6);\n  background: rgba(255, 215, 209, 0.3);\n}\n.page-discovery > .discovery-editor textarea {\n  padding: 8px;\n  width: 100%;\n  box-sizing: border-box;\n  min-height: 9em;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 12px;\n  line-height: 18px;\n  border-color: #aaa;\n  border-radius: 3px;\n  box-shadow: inset 0 1px 1px rgba(142, 142, 142, .2);\n  resize: vertical;\n}\n.page-discovery > .discovery-editor textarea:focus {\n  border-color: #0af;\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, .2), inset 0 1px 1px rgba(142, 142, 142, .2) !important;\n  outline: 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/discover/editor-query.css */\n.page-discovery > .discovery-editor .query-graph {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  gap: 50px;\n  margin: 0 0 10px;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-box {\n  display: flex;\n  flex-direction: column;\n  gap: 1px;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node {\n  --color: #8888;\n  display: block;\n  width: 10px;\n  height: 10px;\n  padding: 3px;\n  background-color: var(--color);\n  background-clip: content-box;\n  border-radius: 50%;\n  cursor: pointer;\n  transition: .2s ease-in-out;\n  transition-property: box-shadow, background-color;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node[data-state=computing] {\n  --color: #f6f61cb5;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node[data-state=computing]::before {\n  content: "";\n  position: absolute;\n  display: block;\n  aspect-ratio: 1/1;\n  width: 12px;\n  margin: -3px 0 0 -3px;\n  border: 2px solid var(--color);\n  border-radius: 50%;\n  clip-path: inset(0px 0px 50% 50%);\n  animation: discovery-graph-computing .65s forwards infinite linear;\n}\n@keyframes discovery-graph-computing {\n  to {\n    rotate: 360deg;\n  }\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node[data-state=successful] {\n  --color: #4da32fcf;\n  transition: none;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node[data-state=failed] {\n  --color: #d84343;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node[data-state=canceled] {\n  background-image: radial-gradient(transparent calc(50% - 2px), var(--discovery-color) 50%);\n  background-color: transparent;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node.current {\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node.target {\n  pointer-events: none;\n  box-shadow: 0 0 0 2px var(--color) inset, 0 0 0 3px var(--discovery-background-color) inset;\n  outline: 1px solid var(--discovery-background-color);\n  cursor: default;\n}\n.page-discovery > .discovery-editor .query-graph .query-graph-node:not(.target):hover {\n  opacity: 1;\n  box-shadow: 0 0 0 2px #888 inset, 0 0 0 3px var(--discovery-background-color) inset;\n  outline: 1px solid var(--discovery-background-color);\n  transition: none;\n}\n.page-discovery > .discovery-editor .query-graph > svg {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  z-index: -1;\n  pointer-events: none;\n}\n.query-graph-actions {\n  display: flex;\n  gap: 1px;\n}\n.query-graph-actions .view-button {\n  padding: 3px 10px 5px;\n  font-size: 12px;\n  line-height: 14px;\n  margin: 0 !important;\n  border: none;\n  border-radius: 0px;\n  background-color: #c0c0c02d;\n  background-repeat: no-repeat;\n  background-position: center;\n}\n.query-graph-actions .view-button:hover {\n  background-color: #a5a5a54d;\n}\n.query-graph-actions .view-button.clone {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" fill="%23888">%0A    <path d="M 13.5 5 C 11.458 5 9.737 5.82 8.629 7.066 C 7.521 8.313 7 9.917 7 11.5 C 7 13.083 7.521 14.687 8.629 15.934 C 9.439 16.845 10.65 17.394 12 17.695 L 12 30.305 C 10.65 30.606 9.439 31.155 8.629 32.066 C 7.521 33.313 7 34.917 7 36.5 C 7 38.083 7.521 39.687 8.629 40.934 C 9.737 42.18 11.458 43 13.5 43 C 17.072 43 20 40.072 20 36.5 C 20 33.596 18.03 31.21 15.387 30.385 C 15.439 30.313 15.421 30.166 15.486 30.098 C 15.806 29.763 16.385 29.433 17.23 29.168 C 18.921 28.637 21.526 28.421 24.229 28.006 C 26.931 27.591 29.792 26.971 32.111 25.252 C 34.185 23.716 35.591 21.178 35.881 17.719 C 38.775 17.064 41 14.583 41 11.5 C 41 7.928 38.072 5 34.5 5 C 32.458 5 30.737 5.82 29.629 7.066 C 28.521 8.313 28 9.917 28 11.5 C 28 13.083 28.521 14.687 29.629 15.934 C 30.397 16.798 31.531 17.329 32.791 17.652 C 32.54 20.191 31.712 21.815 30.326 22.842 C 28.708 24.041 26.319 24.648 23.771 25.039 C 21.224 25.431 18.579 25.601 16.332 26.307 C 15.869 26.452 15.43 26.645 15 26.855 L 15 17.695 C 17.835 16.997 20 14.541 20 11.5 C 20 7.928 17.072 5 13.5 5 Z" transform="matrix(0, 1, -1, 0, 48, 0)"/>%0A</svg>%0A\');\n  background-size: 18px 18px;\n}\n.query-graph-actions .view-button.stash {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" fill="%23888">%0A    <path d="M 13.5 5 C 11.458 5 9.737 5.82 8.629 7.066 C 7.521 8.313 7 9.917 7 11.5 C 7 13.083 7.521 14.687 8.629 15.934 C 9.439 16.845 10.65 17.394 12 17.695 L 12 30.305 C 10.65 30.606 9.439 31.155 8.629 32.066 C 7.521 33.313 7 34.917 7 36.5 C 7 38.083 7.521 39.687 8.629 40.934 C 9.737 42.18 11.458 43 13.5 43 C 17.072 43 20 40.072 20 36.5 C 20 33.596 18.03 31.21 15.387 30.385 C 15.439 30.313 15.421 30.166 15.486 30.098 C 15.806 29.763 16.385 29.433 17.23 29.168 C 18.921 28.637 21.526 28.421 24.229 28.006 C 26.931 27.591 29.792 26.971 32.111 25.252 C 34.185 23.716 35.591 21.178 35.881 17.719 C 38.775 17.064 41 14.583 41 11.5 C 41 7.928 38.072 5 34.5 5 C 32.458 5 30.737 5.82 29.629 7.066 C 28.521 8.313 28 9.917 28 11.5 C 28 13.083 28.521 14.687 29.629 15.934 C 30.397 16.798 31.531 17.329 32.791 17.652 C 32.54 20.191 31.712 21.815 30.326 22.842 C 28.708 24.041 26.319 24.648 23.771 25.039 C 21.224 25.431 18.579 25.601 16.332 26.307 C 15.869 26.452 15.43 26.645 15 26.855 L 15 17.695 C 17.835 16.997 20 14.541 20 11.5 C 20 7.928 17.072 5 13.5 5 Z M 34.5 8 C 36.451 8 38 9.549 38 11.5 C 38 13.42 36.493 14.935 34.586 14.982 C 34.527 14.979 34.467 14.979 34.408 14.982 C 33.182 14.958 32.413 14.551 31.871 13.941 C 31.313 13.313 31 12.417 31 11.5 C 31 10.583 31.313 9.687 31.871 9.059 C 32.43 8.43 33.208 8 34.5 8 Z" transform="matrix(0, 1, -1, 0, 48, 0)"/>%0A</svg>%0A\');\n  background-size: 18px 18px;\n}\n.query-graph-actions .view-button.subquery {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" fill="%23888">%0A    <path d="M 24.5 5 C 22.458 5 20.737 5.82 19.629 7.066 C 18.521 8.313 18 9.917 18 11.5 C 18 13.083 18.521 14.687 19.629 15.934 C 20.439 16.845 21.65 17.394 23 17.695 L 23 30.305 C 21.65 30.606 20.439 31.155 19.629 32.066 C 18.521 33.313 18 34.917 18 36.5 C 18 38.083 18.521 39.687 19.629 40.934 C 20.737 42.18 22.458 43 24.5 43 C 28.072 43 31 40.072 31 36.5 C 31 33.596 28.671 31.193 26.028 30.368 C 26.08 30.296 26 17.695 26 17.695 C 28.835 16.997 31 14.541 31 11.5 C 31 7.928 28.072 5 24.5 5 Z M 24.5 8 C 26.451 8 28 9.549 28 11.5 C 28 13.42 26.493 14.935 24.586 14.982 C 24.527 14.979 24.467 14.979 24.408 14.982 C 23.182 14.958 22.413 14.551 21.871 13.941 C 21.313 13.313 21 12.417 21 11.5 C 21 10.583 21.313 9.687 21.871 9.059 C 22.43 8.43 23.208 8 24.5 8 Z" transform="matrix(0, 1, -1, 0, 48.499998, -0.499998)"/>%0A</svg>%0A\');\n  background-size: 20px 20px;\n}\n.query-graph-actions .view-button.delete {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="%23888">%0A  <path d="M6.5 1h3a.5.5 0 0 1 .5.5v1H6v-1a.5.5 0 0 1 .5-.5ZM11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3A1.5 1.5 0 0 0 5 1.5v1H2.506a.58.58 0 0 0-.01 0H1.5a.5.5 0 0 0 0 1h.538l.853 10.66A2 2 0 0 0 4.885 16h6.23a2 2 0 0 0 1.994-1.84l.853-10.66h.538a.5.5 0 0 0 0-1h-.995a.59.59 0 0 0-.01 0H11Zm1.958 1-.846 10.58a1 1 0 0 1-.997.92h-6.23a1 1 0 0 1-.997-.92L3.042 3.5h9.916Zm-7.487 1a.5.5 0 0 1 .528.47l.5 8.5a.5.5 0 0 1-.998.06L5 5.03a.5.5 0 0 1 .47-.53Zm5.058 0a.5.5 0 0 1 .47.53l-.5 8.5a.5.5 0 1 1-.998-.06l.5-8.5a.5.5 0 0 1 .528-.47ZM8 4.5a.5.5 0 0 1 .5.5v8.5a.5.5 0 0 1-1 0V5a.5.5 0 0 1 .5-.5Z"/>%0A</svg>%0A\');\n  background-size: 13px 13px;\n}\n.discovery-buildin-view-tooltip.hint-tooltip {\n  font-size: 12px;\n  padding: 1px 6px;\n}\n.query-graph-tooltip {\n  margin: 4px;\n}\n.query-graph-tooltip .view-source {\n  margin: -5px -10px;\n  background: none;\n}\n.query-graph-tooltip > .view-badge {\n  vertical-align: top;\n  padding: 4px 8px !important;\n  margin: 0 -5px !important;\n  font-size: 12px;\n}\n.page-discovery > .discovery-editor .query-path {\n  opacity: .35;\n}\n.page-discovery > .discovery-editor .query-path .query {\n  background: #eee;\n  border: solid #888;\n  border-width: 1px 1px 0 1px;\n  padding: 2px 8px;\n  padding-bottom: 6px;\n  margin-bottom: -4px;\n  border-radius: 4px 4px 0 0;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 10px;\n  line-height: 16px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  cursor: pointer;\n}\n.discovery-root-darkmode .page-discovery > .discovery-editor .query-path .query {\n  background: #333;\n}\n.page-discovery > .discovery-editor .query-path .query:last-child {\n  padding-bottom: 7px;\n}\n.page-discovery > .discovery-editor .query-path .query:empty::before {\n  content: "<empty query>";\n}\n.page-discovery > .discovery-editor .query-path .query:hover {\n  background: #ccc;\n}\n.discovery-root-darkmode .page-discovery > .discovery-editor .query-path .query:hover {\n  background: #444;\n}\n.page-discovery > .discovery-editor .query-editor {\n  position: relative;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor {\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__input-panel {\n  display: grid;\n  grid-template-areas: "actions input engine" "details details details";\n  grid-template-columns: auto 1fr auto;\n  margin: 1px 0;\n  padding: 0 1px;\n  background-color: var(--discovery-background-color);\n  border-radius: 1px 1px 0 0;\n  gap: 0 1px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__input-panel.details-expanded {\n  gap: 1px;\n  border-bottom: 1px solid var(--editor-border-color, #888);\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-engine {\n  grid-area: engine;\n  background-color: rgba(192, 192, 192, .175);\n  padding: 1px 8px 3px;\n  font-size: 12px;\n  color: var(--discovery-color);\n  text-decoration: none;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-engine:hover {\n  background-color: rgba(165, 165, 165, .3);\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-engine::before {\n  content: "Syntax: ";\n  color: #888;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input {\n  grid-area: input;\n  display: flex;\n  gap: 1px;\n  font-size: 12px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-data,\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-context {\n  flex: 1;\n  padding: 1px 8px 3px;\n  background-color: rgba(192, 192, 192, .175);\n  cursor: pointer;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-data:hover,\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-context:hover {\n  background-color: rgba(165, 165, 165, .3) !important;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input[data-details=data] .query-input-data,\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input[data-details=context] .query-input-context {\n  margin-bottom: -1px;\n  background-color: #cdcdcd1a;\n  background-clip: padding-box;\n  border-bottom: 1px solid #cdcdcd1a;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-variable {\n  position: relative;\n  padding-right: 14px;\n  color: var(--discovery-fmt-variable-color);\n  font-family: var(--discovery-monospace-font-family);\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-variable::before {\n  content: "";\n  background: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">%0A    <path fill="%23888" d="M 3.71875 7.78125 L 2.28125 9.21875 L 11.28125 18.21875 L 12 18.90625 L 12.71875 18.21875 L 21.71875 9.21875 L 20.28125 7.78125 L 12 16.0625 Z "/>%0A</svg>%0A\') no-repeat center;\n  background-size: 12px;\n  transition: transform .15s ease-in;\n  height: 100%;\n  aspect-ratio: 1/1;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transform: rotate(-90deg);\n  margin-right: 2px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input[data-details=data] .query-input-data .query-input-variable::before,\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input[data-details=context] .query-input-context .query-input-variable::before {\n  transform: rotate(0deg);\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-variable::after {\n  content: " (" attr(data-name) ") ";\n  color: #888;\n  font-family: var(--discovery-font-family);\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-details {\n  display: none;\n  grid-area: details;\n  max-height: max(30vh, 150px);\n  overflow: auto;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .discovery-view-editor__input-panel.details-expanded .query-input-details {\n  display: block;\n  margin-bottom: 1px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor .query-input-details > .view-struct {\n  margin: 0;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel {\n  display: grid;\n  grid-template-areas: "result buttons";\n  grid-template-columns: 1fr auto;\n  gap: 1px;\n  margin: 1px;\n  overflow: hidden;\n  border-radius: 0 0 1px 1px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel.details-expanded {\n  grid-template-areas: "result buttons" "details details";\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel > .buttons {\n  grid-area: buttons;\n  display: flex;\n  gap: 1px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel > .buttons .view-button {\n  font-size: 12px;\n  padding: 3px 8px 4px;\n  border-radius: 0px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel > .buttons .view-checkbox {\n  padding: 2px 8px 2px 22px;\n  background-color: rgba(192, 192, 192, .175);\n  font-size: 12px;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel > .buttons .view-checkbox .view-checkbox__label {\n  margin-right: 0;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel > .buttons .view-checkbox:hover {\n  background-color: rgba(165, 165, 165, .3);\n}\n.page-discovery > .discovery-editor .data-query-result .query-result-data {\n  display: flex;\n  flex: 1;\n  padding: 2px 8px;\n  background-color: rgba(192, 192, 192, .175);\n  font-size: 12px;\n  cursor: pointer;\n}\n.page-discovery > .discovery-editor .data-query-result .query-result-data:hover {\n  background-color: rgba(165, 165, 165, .3);\n}\n.page-discovery > .discovery-editor .data-query-result .query-result-data > .query-output-message {\n  flex: 1;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.page-discovery > .discovery-editor .data-query-result .query-result-data > .query-output-prelude {\n  color: #888;\n  position: relative;\n  display: inline-block;\n  padding-right: 20px;\n}\n.page-discovery > .discovery-editor .data-query-result .query-result-data > .query-output-prelude::before {\n  content: "";\n  background: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">%0A    <path fill="%23888" d="M 3.71875 7.78125 L 2.28125 9.21875 L 11.28125 18.21875 L 12 18.90625 L 12.71875 18.21875 L 21.71875 9.21875 L 20.28125 7.78125 L 12 16.0625 Z "/>%0A</svg>%0A\') no-repeat center;\n  background-size: 12px;\n  transition: transform .15s ease-in;\n  height: 100%;\n  aspect-ratio: 1/1;\n  position: absolute;\n  right: 0;\n  top: 0;\n  transform: rotate(-90deg);\n  margin-right: 2px;\n}\n.page-discovery > .discovery-editor .data-query-result .query-result-data.error {\n  background-color: #ff2d2836;\n}\n.page-discovery > .discovery-editor .discovery-view-editor__output-panel.details-expanded .data-query-result .query-result-data > .query-output-prelude::before {\n  transform: rotate(0deg);\n}\n.page-discovery > .discovery-editor .data-query-result {\n  grid-area: result;\n  overflow: hidden;\n}\n.page-discovery > .discovery-editor .data-query-result > * {\n  overflow: hidden;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel .data-query-result-details {\n  grid-area: details;\n  max-height: max(50vh, 200px);\n  overflow: auto;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel:not(.details-expanded) .data-query-result-details {\n  display: none;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel .data-query-result-details > .view-struct {\n  margin: 0;\n}\n.page-discovery > .discovery-editor .query-editor > .discovery-view-editor > .discovery-view-editor__output-panel .data-query-result-details .state-message {\n  padding: 4px 8px;\n  font-size: 12px;\n  background-color: rgba(205, 205, 205, 0.1);\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/discover/editor-view.css */\n.page-discovery > .discovery-editor .view-editor-form {\n  margin: 12px calc(-1 * var(--discovery-page-padding-right)) 12px calc(-1 * var(--discovery-page-padding-left));\n}\n.page-discovery > .discovery-editor .view-editor-form-header {\n  display: flex;\n  flex-wrap: wrap-reverse;\n  margin-right: var(--discovery-page-padding-right);\n}\n.page-discovery > .discovery-editor .view-editor-form-header-links {\n  flex: 1;\n  margin: 2px 0 0 10px;\n  text-align: right;\n  font-size: 12px;\n}\n.page-discovery > .discovery-editor .discovery-editor-tabs.view-mode::before {\n  display: inline-block;\n  content: "View:";\n}\n.page-discovery > .discovery-editor .discovery-editor-tabs.presets {\n  margin-left: 3ex;\n}\n.page-discovery > .discovery-editor .discovery-editor-tabs.presets::before {\n  content: "View presets:";\n}\n.page-discovery > .discovery-editor .discovery-editor-tabs.presets .discovery-editor-tab:first-child {\n  border-bottom-left-radius: 4px;\n}\n.page-discovery > .discovery-editor .view-editor-form-content {\n  padding: 8px var(--discovery-page-padding-right) 8px var(--discovery-page-padding-left);\n  margin-bottom: 1px;\n  background-color: rgba(108, 188, 241, 0.15);\n}\n.page-discovery > .discovery-editor .view-editor-form-content .formatting {\n  position: absolute;\n  left: 5px;\n  width: 30px;\n  height: 30px;\n  font-size: 0;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="%23888">%0A  <path fill-rule="evenodd" d="M6.854 4.646a.5.5 0 0 1 0 .708L4.207 8l2.647 2.646a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 0 1 .708 0zm2.292 0a.5.5 0 0 0 0 .708L11.793 8l-2.647 2.646a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708 0z"/>%0A</svg>%0A\');\n  background-repeat: no-repeat;\n  background-size: 20px;\n  background-position: center;\n  border-color: rgba(21, 98, 148, 0.3);\n}\n.page-discovery > .discovery-editor .view-editor-form-content .view-expand {\n  width: 100%;\n  margin-top: 5px;\n}\n.page-discovery > .discovery-editor .view-editor-form-content .view-expand .header {\n  background: none;\n}\n.page-discovery > .discovery-editor .view-editor-form-content .view-expand .header:hover {\n  background: rgba(0, 0, 0, .05);\n}\n.page-discovery > .discovery-editor .view-editor-form-content .view-editor-view-list {\n  display: none;\n  padding: 15px 8px;\n  font-size: 12px;\n  color: #aaa;\n  column-count: 8;\n  column-width: 150px;\n  column-gap: 20px;\n  margin-right: -190px;\n}\n.page-discovery > .discovery-editor .view-editor-form-content .view-editor-view-list.visible {\n  display: block;\n}\n.page-discovery > .discovery-editor .view-editor-form-content .view-editor-view-list .item:not([href]) {\n  color: #888;\n}\n.discovery-view-popup.view-editor-view-list-hint {\n  padding: 20px;\n  min-width: 640px;\n  min-height: 100px;\n}\n.discovery-view-popup.view-editor-view-list-hint > .discovery-view-usage > .view-header:first-child {\n  font-size: 16px;\n  background: rgba(180, 180, 180, 0.2);\n  margin: -20px -20px 0;\n  padding: 6px 20px;\n  line-height: 24px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/discover.css */\n.page-discovery {\n  padding-top: 20px !important;\n}\n.discovery:not([data-dzen]) .page-discovery > .discovery-content {\n  min-height: calc(100vh - 121px);\n}\n.page-discovery > .discovery-editor .discovery-error,\n.page-discovery > .discovery-content > .discovery-error {\n  display: block;\n  overflow: hidden;\n  border-left: 3px solid rgba(255, 0, 0, 0.8);\n  background: rgba(225, 75, 75, 0.2);\n  background-clip: padding-box;\n  padding: 8px 12px;\n  font-size: 12px;\n  white-space: pre-wrap;\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 11px;\n}\n.page-discovery > .discovery-editor .discovery-error::before,\n.page-discovery > .discovery-content > .discovery-error::before {\n  display: block;\n  margin-bottom: .5em;\n  font-size: 16px;\n}\n.page-discovery > .discovery-editor .query-error::before {\n  content: "Query error";\n}\n.page-discovery > .discovery-content > .render-error::before {\n  content: "Render error";\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/views-showcase.css */\n.page-views-showcase {\n  flex: 1;\n  display: flex;\n  flex-direction: row;\n  border: 1px solid rgba(170, 170, 170, 0.4);\n  margin: 35px 40px 20px;\n  padding: 0 !important;\n  box-sizing: border-box;\n  overflow: hidden;\n  border-radius: 3px;\n  background-color: rgba(255, 255, 255, .8);\n  transition-property: background-color;\n  transition-duration: .25s;\n  transition-timing-function: ease-in;\n}\n.discovery-root-darkmode .page-views-showcase {\n  background-color: rgba(36, 36, 36, .8);\n}\n.page-views-showcase > .sidebar {\n  width: 220px;\n  border-right: 1px solid rgba(170, 170, 170, 0.2);\n}\n.page-views-showcase > .sidebar .view-content-filter {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.page-views-showcase > .sidebar .view-content-filter > .view-input {\n  margin: 0;\n}\n.page-views-showcase > .sidebar .view-content-filter > .view-input input {\n  border: none;\n  border-bottom: 1px solid rgba(170, 170, 170, 0.2);\n  border-radius: 0;\n  box-shadow: none;\n}\n.page-views-showcase > .sidebar .view-content-filter .view-block {\n  flex: 1;\n  overflow: hidden;\n  overflow-y: scroll;\n  padding: 1px;\n}\n.page-views-showcase > .sidebar .view-menu-item:not(.disabled) {\n  color: var(--discovery-link-color, #0099DD);\n}\n.page-views-showcase > .sidebar .view-menu-item:hover {\n  color: var(--discovery-link-hover-color, #0077BB);\n}\n.page-views-showcase > .content {\n  flex: 1;\n  padding: 0 24px 20px;\n  overflow: hidden;\n  overflow-y: scroll;\n}\n.page-views-showcase > .content > .view-h1 {\n  margin-top: 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/pages/index.css */\n\n/* node_modules/@discoveryjs/discovery/src/main/style/base.css */\n:host {\n  transition: opacity .2s;\n}\n:host(.init) {\n  opacity: 0;\n}\n.discovery-root {\n  all: initial;\n  position: relative;\n  font-family: var(--discovery-font-family);\n  font-size: 14px;\n  line-height: 1.6;\n  -webkit-text-size-adjust: none;\n  text-size-adjust: none;\n  background-color: var(--discovery-background-color, white);\n  color: var(--discovery-color, black);\n  transition-property: background-color, color;\n  transition-duration: .25s;\n  transition-timing-function: ease-in;\n  --discovery-font-family:\n    Tahoma,\n    Verdana,\n    Arial,\n    sans-serif;\n  --discovery-monospace-font-family:\n    SFMono-Regular,\n    Consolas,\n    Liberation Mono,\n    Menlo,\n    monospace;\n  --discovery-ui-font-family:\n    system-ui,\n    Arial,\n    sans-serif;\n  --discovery-background-color: white;\n  --discovery-color: black;\n  --discovery-input-bg-color: white;\n  --discovery-input-color: black;\n  --discovery-button-color: black;\n  --discovery-button-bg-color: white;\n  --discovery-button-border-color: #cccccc;\n  --discovery-button-hover-color: black;\n  --discovery-button-hover-bg-color: #f5f5f5;\n  --discovery-button-hover-border-color: #cccccc;\n  --discovery-fmt-color: #666;\n  --discovery-fmt-hover-color: #333;\n  --discovery-fmt-flag-color: #ff6e13;\n  --discovery-fmt-variable-color: #047d65;\n  --discovery-fmt-property-color: #bd6476;\n  --discovery-fmt-keyword-color: #9150c5;\n  --discovery-fmt-number-color: #07a;\n  --discovery-fmt-atom-color: #07a;\n  --discovery-fmt-type-color: #a7994b;\n  --discovery-fmt-string-color: #690;\n  --discovery-fmt-string-highlight-color: rgba(35, 165, 25, 0.1);\n  --discovery-fmt-comment-color: #75787b;\n  --discovery-fmt-qualifier: #dd4a68;\n  --discovery-fmt-entity: #9a6e3a;\n  --discovery-fmt-punctuation: #999;\n  --discovery-page-padding-top: 35px;\n  --discovery-page-padding-right: 40px;\n  --discovery-page-padding-bottom: 30px;\n  --discovery-page-padding-left: 40px;\n}\n.discovery-root-darkmode {\n  --discovery-background-color: #242424;\n  --discovery-color: #cccccc;\n  --discovery-link-color: #1c87d4;\n  --discovery-link-underline-color: rgb(37, 146, 226, 50%);\n  --discovery-link-hover-color: #4aa6e8;\n  --discovery-input-bg-color: #343434;\n  --discovery-input-color: #e8e8e8;\n  --discovery-button-color: #cccccc;\n  --discovery-button-bg-color: #3a3a3a;\n  --discovery-button-border-color: #cccccc;\n  --discovery-button-hover-color: black;\n  --discovery-button-hover-bg-color: #f5f5f5;\n  --discovery-button-hover-border-color: #cccccc;\n  --discovery-fmt-color: #999;\n  --discovery-fmt-hover-color: #aaa;\n  --discovery-fmt-flag-color: #ff8030;\n  --discovery-fmt-variable-color: #16a78a;\n  --discovery-fmt-property-color: #d17a8c;\n  --discovery-fmt-keyword-color: #a783c4;\n  --discovery-fmt-number-color: #0f8dc2;\n  --discovery-fmt-atom-color: #0f8dc2;\n  --discovery-fmt-string-color: #7faf20;\n  --discovery-fmt-string-underline-color: #85ab51;\n  --discovery-fmt-string-hover-color: #97cf26;\n}\n.discovery[data-dzen] .discovery-hidden-in-dzen {\n  display: none;\n}\n.discovery {\n  display: flex;\n  overflow: hidden;\n  height: 100%;\n}\n.discovery-content {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  overflow: auto;\n  z-index: 10;\n}\n.discovery-content > .page {\n  padding: var(--discovery-page-padding-top) var(--discovery-page-padding-right) var(--discovery-page-padding-bottom) var(--discovery-page-padding-left);\n}\n.discovery[data-compact] .page {\n  --discovery-page-padding-top: 0;\n  --discovery-page-padding-left: 0;\n  --discovery-page-padding-right: 0;\n  --discovery-page-padding-bottom: 0;\n}\n\n/* node_modules/@discoveryjs/discovery/src/main/style/sidebar.css */\n.discovery-sidebar {\n  position: relative;\n  z-index: 200;\n  overflow: auto;\n  width: 350px;\n  background: rgba(105, 105, 105, 0.1);\n  border-right: 1px solid rgba(85, 85, 85, 0.2);\n  box-shadow: 2px 0 5px -3px rgba(0, 0, 0, .26);\n  transform: translate3d(0, 0, 0);\n}\n.discovery-sidebar:empty {\n  display: none;\n}\n.discovery-sidebar .view-tabs,\n.discovery-sidebar .view-tabs-content,\n.discovery-sidebar .view-content-filter {\n  display: flex;\n  flex-direction: column;\n  max-height: 100%;\n}\n.discovery-sidebar .view-tabs {\n  height: 100%;\n}\n.discovery-sidebar .view-tab.active::before {\n  background-color: white;\n  transition-property: background-color;\n  transition-duration: .25s;\n  transition-timing-function: ease-in;\n}\n.discovery-root-darkmode .discovery-sidebar .view-tab.active::before {\n  background-color: #363637;\n}\n.discovery-sidebar .view-content-filter > .view-input {\n  border-bottom: 1px solid rgba(170, 170, 170, 0.4);\n  margin-bottom: -1px;\n  background-color: white;\n  transition-property: background-color;\n  transition-duration: .25s;\n  transition-timing-function: ease-in;\n}\n.discovery-root-darkmode .discovery-sidebar .view-content-filter > .view-input {\n  background-color: #363637;\n}\n.discovery-sidebar .view-content-filter > .view-input input,\n.discovery-sidebar .view-content-filter > .view-input input:focus {\n  background-color: transparent;\n  outline: none;\n  box-shadow: none;\n  border: none;\n  border-radius: 0;\n}\n.discovery-sidebar .view-content-filter > .content > .view-list {\n  padding: 8px 0 8px 12px;\n}\n.discovery-sidebar .view-content-filter > .content > .view-tree {\n  padding: 4px 0 8px 8px;\n}\n.discovery-sidebar .view-list-item:first-child .view-toc-section {\n  margin-top: -8px;\n}\n.discovery-sidebar .view-list-item:last-child .view-toc-section {\n  margin-bottom: -8px;\n}\n.discovery-sidebar .view-toc-section {\n  margin-left: -12px;\n}\n.discovery-sidebar .view-text-match {\n  color: rgba(40, 40, 40, 0.85);\n  background: rgba(255, 255, 255, 0.45);\n  border-bottom: 2px solid orange;\n  line-height: 1.2;\n  display: inline-block;\n  border-radius: 3px;\n  padding: 0 1px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/nav/index.css */\n.discovery-nav {\n  position: absolute;\n  z-index: 102;\n  top: 0;\n  right: var(--discovery-page-padding-right, 40px);\n  padding: 0 1px 1px;\n  border-radius: 0 0 6px 6px;\n  background-color: rgba(255, 255, 255, .92);\n  transition: background-color .25s ease-in;\n  user-select: none;\n}\n.discovery-root-darkmode .discovery-nav {\n  background-color: rgba(36, 36, 36, .92);\n}\n@supports (backdrop-filter: blur(5px)) or (-webkit-backdrop-filter: blur(5px)) {\n  .discovery-nav {\n    background-color: rgba(255, 255, 255, .8);\n    -webkit-backdrop-filter: blur(5px);\n    backdrop-filter: blur(5px);\n  }\n  .discovery-root-darkmode .discovery-nav {\n    background-color: rgba(36, 36, 36, .8);\n  }\n}\n.discovery-nav > :first-child {\n  border-bottom-left-radius: 5px;\n  transition: border-radius .25s ease-in-out;\n}\n.discovery-nav > :last-child {\n  border-bottom-right-radius: 5px;\n  transition: border-radius .25s ease-in-out;\n}\n.discovery-nav .view-nav-button.discovery-view-popup-active {\n  border-radius: 0;\n}\n.discovery-nav .view-nav-button[data-name=burger] {\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 172 172">%0A    <path fill="%23888" d="M21.5,35.83333c-2.58456,-0.03655 -4.98858,1.32136 -6.29153,3.55376c-1.30295,2.2324 -1.30295,4.99342 0,7.22582c1.30295,2.2324 3.70697,3.59031 6.29153,3.55376h129c2.58456,0.03655 4.98858,-1.32136 6.29153,-3.55376c1.30295,-2.2324 1.30295,-4.99342 0,-7.22582c-1.30295,-2.2324 -3.70697,-3.59031 -6.29153,-3.55376zM21.5,78.83333c-2.58456,-0.03655 -4.98858,1.32136 -6.29153,3.55376c-1.30295,2.2324 -1.30295,4.99342 0,7.22582c1.30295,2.2324 3.70697,3.59031 6.29153,3.55376h129c2.58456,0.03655 4.98858,-1.32136 6.29153,-3.55376c1.30295,-2.2324 1.30295,-4.99342 0,-7.22582c-1.30295,-2.2324 -3.70697,-3.59031 -6.29153,-3.55376zM21.5,121.83333c-2.58456,-0.03655 -4.98858,1.32136 -6.29153,3.55376c-1.30295,2.2324 -1.30295,4.99342 0,7.22582c1.30295,2.2324 3.70697,3.59031 6.29153,3.55376h129c2.58456,0.03655 4.98858,-1.32136 6.29153,-3.55376c1.30295,-2.2324 1.30295,-4.99342 0,-7.22582c-1.30295,-2.2324 -3.70697,-3.59031 -6.29153,-3.55376z" />%0A</svg>%0A\');\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 18px;\n}\n.discovery-nav .view-nav-button[data-name=inspect]::before {\n  content: "";\n  display: inline-block;\n  -webkit-mask: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="1 -1 30 30">%0A<path fill="currentColor" d="M 15 2 C 8.3844239 2 3 7.3844287 3 14 C 3 20.615571 8.3844239 26 15 26 L 25 26 C 26.105 26 27 25.105 27 24 L 27 14 C 27 7.3844287 21.615576 2 15 2 z M 15 4 C 20.534697 4 25 8.465307 25 14 C 25 19.534693 20.534697 24 15 24 C 9.4653034 24 5 19.534693 5 14 C 5 8.465307 9.4653034 4 15 4 z M 15.953125 6.9863281 A 1.0001 1.0001 0 0 0 15.013672 7.8359375 L 13.013672 19.835938 A 1.0001 1.0001 0 1 0 14.986328 20.164062 L 16.986328 8.1640625 A 1.0001 1.0001 0 0 0 15.953125 6.9863281 z M 10.980469 9.9882812 A 1.0001 1.0001 0 0 0 10.167969 10.445312 L 8.1679688 13.445312 A 1.0001 1.0001 0 0 0 8.1679688 14.554688 L 10.167969 17.554688 A 1.0001 1.0001 0 1 0 11.832031 16.445312 L 10.201172 14 L 11.832031 11.554688 A 1.0001 1.0001 0 0 0 10.980469 9.9882812 z M 18.988281 9.9882812 A 1.0001 1.0001 0 0 0 18.167969 11.554688 L 19.798828 14 L 18.167969 16.445312 A 1.0001 1.0001 0 1 0 19.832031 17.554688 L 21.832031 14.554688 A 1.0001 1.0001 0 0 0 21.832031 13.445312 L 19.832031 10.445312 A 1.0001 1.0001 0 0 0 18.988281 9.9882812 z"/>%0A</svg>%0A\') no-repeat center / 16px 16px;\n  mask: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="1 -1 30 30">%0A<path fill="currentColor" d="M 15 2 C 8.3844239 2 3 7.3844287 3 14 C 3 20.615571 8.3844239 26 15 26 L 25 26 C 26.105 26 27 25.105 27 24 L 27 14 C 27 7.3844287 21.615576 2 15 2 z M 15 4 C 20.534697 4 25 8.465307 25 14 C 25 19.534693 20.534697 24 15 24 C 9.4653034 24 5 19.534693 5 14 C 5 8.465307 9.4653034 4 15 4 z M 15.953125 6.9863281 A 1.0001 1.0001 0 0 0 15.013672 7.8359375 L 13.013672 19.835938 A 1.0001 1.0001 0 1 0 14.986328 20.164062 L 16.986328 8.1640625 A 1.0001 1.0001 0 0 0 15.953125 6.9863281 z M 10.980469 9.9882812 A 1.0001 1.0001 0 0 0 10.167969 10.445312 L 8.1679688 13.445312 A 1.0001 1.0001 0 0 0 8.1679688 14.554688 L 10.167969 17.554688 A 1.0001 1.0001 0 1 0 11.832031 16.445312 L 10.201172 14 L 11.832031 11.554688 A 1.0001 1.0001 0 0 0 10.980469 9.9882812 z M 18.988281 9.9882812 A 1.0001 1.0001 0 0 0 18.167969 11.554688 L 19.798828 14 L 18.167969 16.445312 A 1.0001 1.0001 0 1 0 19.832031 17.554688 L 21.832031 14.554688 A 1.0001 1.0001 0 0 0 21.832031 13.445312 L 19.832031 10.445312 A 1.0001 1.0001 0 0 0 18.988281 9.9882812 z"/>%0A</svg>%0A\') no-repeat center / 16px 16px;\n  background-color: currentColor;\n  width: 16px;\n  height: 16px;\n  vertical-align: top;\n  margin: 1px -7px 0;\n  opacity: .85;\n}\n.discovery-nav .view-nav-button[data-name=inspect][data-suspend-seconds]::before {\n  visibility: hidden;\n}\n.discovery-nav .view-nav-button[data-name=inspect][data-suspend-seconds]::after {\n  content: attr(data-suspend-seconds);\n  display: inline-block;\n  position: absolute;\n  margin-left: -14px;\n  width: 24px;\n  text-align: center;\n}\n.discovery-nav-popup > .toggle-menu-item {\n  padding: 4px 4px 4px 12px;\n}\n.discovery-nav-popup > .toggle-menu-item .view-toggle-group {\n  display: flex;\n  align-items: center;\n}\n.discovery-nav-popup > .toggle-menu-item .view-toggle-group-before {\n  flex: 1;\n}\n.discovery-nav-popup > .toggle-menu-item .view-toggle {\n  font-size: 11px;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n.discovery-nav-popup .powered-by-discoveryjs {\n  padding: 2px 6px 4px;\n  font-size: 11px;\n  opacity: .75;\n  background-color: #8882;\n  text-align: right;\n}\n\n/* node_modules/@discoveryjs/discovery/src/main/widget.css */\n\n/* node_modules/@discoveryjs/discovery/src/extensions/inspector/overlay.css */\n.discovery-view-inspector-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 255, .1);\n  z-index: 2000;\n}\n.discovery-view-inspector-overlay .cancel-hint {\n  content: "Inspection mode is enabled. Press Esc to cancel";\n  position: absolute;\n  z-index: 10;\n  top: 4px;\n  left: 50%;\n  transform: translateX(-50%);\n  padding: 2px 10px;\n  font-size: 12px;\n  border-radius: 25px;\n  background-color: var(--discovery-background-color);\n  opacity: .8;\n}\n.discovery-view-inspector-overlay .cancel-hint::before {\n  content: "Inspection mode is enabled. Press Esc to cancel";\n}\n.discovery-view-inspector-overlay .cancel-hint[data-alt]::before {\n  content: "Inspection mode is enabled. Unhold Alt to cancel";\n}\n.discovery-view-inspector-overlay .overlay {\n  position: absolute;\n  transition: background-color 15ms 25ms;\n  box-sizing: border-box;\n}\n.discovery-view-inspector-overlay .overlay.view-root:not([data-inspectable]) {\n  pointer-events: none;\n}\n.discovery-view-inspector-overlay .overlay:not(.view-root) {\n  pointer-events: auto;\n}\n.discovery-view-inspector-overlay .overlay.hovered {\n  background-color: rgba(0, 255, 0, var(--discovery-background-alpha));\n  outline: 1px dashed rgba(0, 128, 0, .4);\n  outline-offset: -1px;\n  --discovery-background-alpha: .3;\n}\n.discovery-view-inspector-overlay .overlay.view-root.hovered {\n  background-color: rgba(106, 0, 204, var(--discovery-background-alpha));\n  outline: 1px dashed rgba(54, 0, 102, .4);\n}\n.discovery-root-darkmode .discovery-view-inspector-overlay .overlay.hovered {\n  outline-color: rgba(128, 200, 128, .65);\n  --discovery-background-alpha: .2;\n}\n.discovery-root-darkmode .discovery-view-inspector-overlay .overlay.view-root.hovered {\n  outline-color: rgba(111, 74, 152, .65);\n}\n@supports (backdrop-filter: grayscale(1)) or (-webkit-backdrop-filter: grayscale(1)) {\n  .discovery-view-inspector-overlay .overlay.hovered {\n    --discovery-background-alpha: .25;\n    -webkit-backdrop-filter: grayscale(1);\n    backdrop-filter: grayscale(1);\n  }\n}\n\n/* node_modules/@discoveryjs/discovery/src/extensions/inspector/popup.css */\n.discovery-inspect-details-popup {\n  pointer-events: none;\n  z-index: 2001;\n  max-width: 650px !important;\n  display: grid;\n  grid-template-areas: "sidebar toolbar toolbar" "sidebar props-config data-context";\n  grid-template-rows: auto 1fr;\n  grid-template-columns: 0px 4fr 6fr;\n  gap: 1px;\n  padding: 1px;\n  border-radius: 2px;\n  background: rgba(255, 255, 255, var(--discovery-background-alpha));\n  --discovery-background-alpha: .95;\n  --discovery-mate-background: rgba(240, 240, 240, .5);\n  --discovery-link-color: #333;\n  --discovery-link-underline-color: #0002;\n  --discovery-view-root-highlight-color: rgba(106, 0, 204, 25%);\n}\n.discovery-root-darkmode .discovery-inspect-details-popup {\n  background: rgba(36, 36, 36, var(--discovery-background-alpha));\n  --discovery-background-alpha: .92;\n  --discovery-mate-background: rgba(52, 52, 52, .5);\n  --discovery-link-color: #aaa;\n  --discovery-link-underline-color: #aaa2;\n  --discovery-view-root-highlight-color: rgba(189, 120, 255, 25%);\n}\n.discovery-inspect-details-popup.frozen {\n  pointer-events: all;\n  top: 32px !important;\n  left: 20px !important;\n  right: 20px !important;\n  bottom: 20px !important;\n  max-height: none !important;\n  max-width: none !important;\n  transition: .125s ease;\n  transition-property:\n    top,\n    left,\n    right,\n    bottom,\n    grid-template-rows,\n    grid-template-columns;\n  grid-template-rows: auto minmax(20%, 1fr);\n  grid-template-columns: minmax(290px, 25%) 4fr 6fr;\n}\n@supports (backdrop-filter: blur(5px)) or (-webkit-backdrop-filter: blur(5px)) {\n  .discovery-inspect-details-popup {\n    --discovery-background-alpha: .65;\n    -webkit-backdrop-filter: blur(5px);\n    backdrop-filter: blur(5px);\n  }\n  .discovery-root-darkmode .discovery-inspect-details-popup {\n    --discovery-background-alpha: .4;\n  }\n}\n\n/* node_modules/@discoveryjs/discovery/src/extensions/inspector/sidebar.css */\n.discovery-inspect-details-popup .sidebar {\n  grid-area: sidebar;\n  overflow: auto;\n  overscroll-behavior: contain;\n  padding: 4px;\n  background-color: var(--discovery-mate-background);\n}\n.discovery-inspect-details-popup .sidebar .view-tree-leaf-content {\n  white-space: nowrap;\n  padding-right: 12px;\n}\n.discovery-inspect-details-popup .sidebar .view-root {\n  display: inline-block;\n  margin-bottom: 1px;\n  margin-left: -6px;\n  border: 4px solid transparent;\n  border-width: 1px 8px;\n  background-color: var(--discovery-view-root-highlight-color);\n}\n.discovery-inspect-details-popup .sidebar .selected {\n  background-color: rgba(78, 187, 255, .3);\n  box-shadow: 0 0 0 3px rgba(78, 187, 255, .3);\n  display: inline;\n}\n.discovery-inspect-details-popup .sidebar .skipped {\n  text-decoration: line-through;\n  font-style: italic;\n  opacity: .65;\n}\n.discovery-inspect-details-popup .sidebar > .view-tree-leaf:only-child {\n  margin: -4px 0 0 -4px;\n  grid-template-columns: 6px auto;\n  background: none;\n}\n.discovery-inspect-details-popup .sidebar > .view-tree-leaf:only-child > .view-tree-leaf-toggle {\n  display: none;\n}\n.discovery-inspect-details-popup .sidebar .view-badge {\n  vertical-align: top;\n  margin-left: 1ex;\n  margin-right: 0;\n  border-radius: 0;\n  font-size: 9px;\n}\n.discovery-inspect-details-popup .sidebar .view-badge + .view-badge {\n  margin-left: 1px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/extensions/inspector/toolbar.css */\n.discovery-inspect-details-popup .toolbar {\n  grid-area: toolbar;\n  display: flex;\n  gap: 1px;\n}\n.discovery-inspect-details-popup .stack-view-chain {\n  flex: 1;\n  gap: 1px;\n  background-color: var(--discovery-mate-background);\n}\n.discovery-inspect-details-popup .stack-view-chain .view-toggle {\n  border-radius: 0;\n  margin: 0;\n  padding: 5px 8px;\n  line-height: 16px;\n}\n.discovery-inspect-details-popup .stack-view-chain .skipped {\n  text-decoration: line-through;\n  font-style: italic;\n  opacity: .65;\n}\n.discovery-inspect-details-popup .stack-view-chain .view-root:not(.checked):not(:hover) {\n  background-color: var(--discovery-view-root-highlight-color);\n}\n.discovery-inspect-details-popup .stack-view-chain .data-flow-changes {\n  position: relative;\n  vertical-align: middle;\n  display: inline-flex;\n  gap: 2px;\n  margin: -5px -2px -2px 4px;\n  font-size: 7px;\n  line-height: 12px;\n  text-align: center;\n  text-transform: uppercase;\n}\n.discovery-inspect-details-popup .stack-view-chain .data-flow-changes > * {\n  width: 12px;\n  height: 12px;\n  border-radius: 8px;\n  overflow: hidden;\n  box-shadow: 1px 1px 1px rgba(0, 0, 0, .2);\n}\n.discovery-inspect-details-popup .stack-view-chain .data-flow-changes .data {\n  background: #1f841f80;\n}\n.discovery-inspect-details-popup .stack-view-chain .data-flow-changes .context {\n  background: #b1366f80;\n  bottom: 0;\n}\n.discovery-inspect-details-popup .toolbar .view-button {\n  padding: 5px 8px 7px;\n  font-size: 12px;\n  line-height: 12px;\n  border-radius: 2px 1px 2px 2px;\n  box-shadow: none;\n}\n\n/* node_modules/@discoveryjs/discovery/src/extensions/inspector/content.css */\n.discovery-inspect-details-popup .content {\n  overflow: hidden;\n  background-color: var(--discovery-mate-background);\n  font-size: 12px;\n  line-height: 14px;\n}\n.discovery-inspect-details-popup.frozen .content {\n  overflow: auto;\n}\n.discovery-inspect-details-popup .content .view-struct {\n  overflow: visible;\n  background-color: transparent;\n}\n.discovery-inspect-details-popup .content .view-source {\n  font-size: 11px;\n  line-height: 15px;\n  background-color: transparent;\n}\n.discovery-inspect-details-popup .content.props-config {\n  grid-area: props-config;\n}\n.discovery-inspect-details-popup .content.data-context {\n  grid-area: data-context;\n}\n.discovery-inspect-details-popup .content-section::before {\n  content: var(--header);\n  display: inline-block;\n  padding: 8px 10px 2px 1px;\n  margin-left: 7px;\n  text-transform: uppercase;\n  font-size: 10px;\n  color: #444;\n  border-bottom: 2px solid #ddd;\n}\n.discovery-root-darkmode .discovery-inspect-details-popup .content-section::before {\n  color: inherit;\n  text-shadow: 1px 1px 0 rgba(0, 0, 0, .25);\n  border-bottom: 2px solid #666;\n}\n.discovery-inspect-details-popup .content-section.skip {\n  --header: "Not rendered reason";\n}\n.discovery-inspect-details-popup .content-section.skip .view-block {\n  padding: 6px 0 8px 6px;\n  font-size: 14px;\n}\n.discovery-inspect-details-popup .content-section.render {\n  --header: "Render function";\n}\n.discovery-inspect-details-popup .content-section.props {\n  --header: "Render props";\n}\n.discovery-inspect-details-popup .content-section.config {\n  --header: "Config";\n}\n.discovery-inspect-details-popup .content-section.config > .view-tree {\n  margin-left: 6px;\n}\n.discovery-inspect-details-popup .content-section.config .view-tree-leaf-content > .view-struct {\n  margin: -4px 0 -4px -4px;\n}\n.discovery-inspect-details-popup .content-section.data {\n  --header: "Data";\n}\n.discovery-inspect-details-popup .content-section.data .data-flow-transitions {\n  display: flex;\n  flex-direction: column-reverse;\n}\n.discovery-inspect-details-popup .content-section.data .data-flow-transitions > .more-buttons {\n  margin-top: 0;\n  padding: 6px 0 0 8px;\n  margin-bottom: -4px;\n}\n.discovery-inspect-details-popup .content-section.data .data-flow-transitions > .more-buttons .more-button {\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n.discovery-inspect-details-popup .content-section.data .root-data {\n  padding: 6px 0 0 8px;\n  pointer-events: none;\n  margin-bottom: -6px;\n}\n.discovery-inspect-details-popup .content-section.data .root-data .view-badge {\n  padding: 2px 8px;\n  font-size: 9px;\n  text-transform: uppercase;\n}\n.discovery-inspect-details-popup .content-section.data .data-flow-transition {\n  position: relative;\n  padding: 12px 0 0 4px;\n  margin: -4px 0 -2px 11px;\n  border-left: 1px solid #888;\n}\n.discovery-inspect-details-popup .content-section.data .data-flow-transition > .view-name {\n  position: absolute;\n  top: 0;\n  left: 0;\n  padding: 0px 4px;\n  background: #8885;\n  font-size: 10px;\n  opacity: .75;\n}\n.discovery-inspect-details-popup .content-section.data .data-flow-transition::before {\n  content: "";\n  position: absolute;\n  left: -4px;\n  bottom: -2px;\n  width: 7px;\n  height: 7px;\n  border: 3.5px solid transparent;\n  border-bottom: none;\n  border-top: 7px solid #888;\n  box-sizing: border-box;\n}\n.discovery-inspect-details-popup .content-section.context {\n  --header: "Context";\n}\n\n/* node_modules/@discoveryjs/discovery/src/extensions/inspector.css */\n\n/* node_modules/@discoveryjs/discovery/src/main/app.css */\n.discovery > .loading-overlay {\n  position: absolute;\n  z-index: 10000;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  padding: 35px 40px;\n  background: var(--discovery-background-color);\n  will-change: opacity;\n}\n.discovery > .loading-overlay > * {\n  transition: opacity .15s .4s;\n}\n.discovery > .loading-overlay.init > *,\n.discovery > .loading-overlay.done:not(.error) > * {\n  opacity: 0;\n}\n.discovery > .loading-overlay.error {\n  overflow: auto;\n}\n.discovery > .loading-overlay.error .action-buttons {\n  margin-bottom: 1em;\n}\n.discovery > .loading-overlay.error .action-buttons .view-button + .view-button {\n  margin-left: 2ex;\n}\n.discovery > .loading-overlay.error .view-alert .view-header {\n  margin-top: 0;\n}\n.discovery > .loading-overlay.error .view-alert .view-badge {\n  color: inherit;\n}\n.discovery > .loading-overlay.error .view-alert pre {\n  font-family: var(--discovery-monospace-font-family);\n  font-size: 13px;\n  margin: 0;\n}\n.discovery > .loading-overlay.done:not(.error) {\n  opacity: 0;\n  visibility: hidden;\n  transition: all .2s;\n}\n.discovery > .loading-overlay .progressbar {\n  margin: 15px 20px;\n}\n\n/* node_modules/@discoveryjs/discovery/src/main/index.css */\n\n/* node_modules/@discoveryjs/discovery/src/lib.css */\n.discovery-buildin-view-render-error {\n  display: inline-block;\n  vertical-align: top;\n  margin: 1px;\n  border: 1px solid rgba(212, 0, 0, 0.4);\n  background-image:\n    linear-gradient(\n      to bottom,\n      rgba(255, 25, 25, 0.1) 19px,\n      transparent 0);\n  background-clip: padding-box;\n  color: #c66;\n  border-radius: 4px;\n  padding: 4px;\n  font-size: 10px;\n  line-height: 1;\n}\n.discovery-buildin-view-render-error::before {\n  content: "ERROR";\n  display: inline-block;\n  margin: -4px 1ex -4px -4px;\n  border-radius: 3px 0 0 3px;\n  background: rgb(226, 36, 36, .4);\n  color: rgba(255, 255, 255, .85);\n  text-shadow: 1px 1px rgb(0, 0, 0, .2);\n  padding: 4px;\n}\n.discovery-buildin-view-render-error[data-type=config]::before {\n  content: "CONFIG ERROR";\n}\n.discovery-buildin-view-render-error[data-type=render]::before {\n  content: "RENDER ERROR";\n}\n.discovery-buildin-view-render-error.expanded::before {\n  border-bottom-left-radius: 0;\n}\n.discovery-buildin-view-render-error .toggle-config {\n  margin-left: 1ex;\n  cursor: pointer;\n  opacity: .65;\n  color: #888;\n  user-select: none;\n}\n.discovery-buildin-view-render-error .toggle-config:hover {\n  opacity: 1;\n}\n.discovery-buildin-view-render-error .view-struct {\n  margin: 5px -4px -4px;\n  border-radius: 0 0 3px 3px;\n}\n.discovery-buildin-view-tooltip {\n  padding: 5px 10px;\n  min-width: 120px;\n  border: 0.5px solid #fff5;\n  border-radius: 3px;\n  font-size: 12px;\n  background: rgba(255, 255, 255, 0.75);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n}\n.discovery-root-darkmode .discovery-buildin-view-tooltip {\n  background: rgba(36, 36, 36, 0.8);\n}\n\n/* app/pages/common.css */\n.discovery-root {\n  --runtime-nodejs: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAMAAAAKE/YAAAAC91BMVEVHcExWnUlanU1anE5anE1WmExBiD9Ulkxbp0loplZEi0FpqFZDikBnqlNCij9ppVlEi0FqrVRnoFpCiT9rrVZtuE9BiT5knVhsplw/iD1rtk9Vl0xnoFtsu0xCiT9qolw/hz1uuk9knVhAiD4/hz1tpV5al1JsvEo/hz11sF9mnlpvuk8/hz1QkUpoo1pqvkc/hz1qvkdhmld2sl9vulBooFtarUU+hz1qvkdVlU5WmkxYpEhXn0pZqUZNj0harEVarUV1tVs+hj1ro15EiUFSkUxJjEVsvUparUVjm1g+hz1zq2JpoVxzt1dXllBsvUo+hj1tpF93smFzq2Njm1hMkEhon1tsvkhCiUBro14+hj1Ymk09hT0+hj0/hz5Ahz5BiD9CiEBDiUFEiUFEikJFikJDjD9Gi0NHjERIjEVJjEVJjEZJjUZHkEBLjkdMj0hNj0hNj0lPkElPkEpLlUJQkUpRkUxRkktTkk1Sk0xUk01Ql0ZVk09VlE5Pm0JWlU9Wl01XllBalVJZllFWmU1Wmkxal1JdllRTnkZXm0xbmFNXnExXnUtfl1VdmVRXnktXn0phmFdemlVXoEpUo0RfmlZimVhYoUpgm1dYokljmlhYo0lkmllYpEhinFhkm1lYpUhfoFJco0tjnVhlnFpknVlZpkhmnVplnlpnnVpZqEdZqUZnnltmn1tZqkZnn1tcqUZon1thpU9noFtnoFxarEVpoFxfqUpooVxqoFxpol1qol1rol1qo11ro11ro15frkZso15spF5spF9irkpnqlNtpV9upmBrqVpvpmBvp2Bwp2FksklwqGFxqGFurFpxqWJyqWJyqmJzqmN0q2Nnt0lstFJ1rGRwsVhzr151rWR2rWR2rmN2r2NpvEd3sGJ3sWJ4sWJ4smJtvUtsvklrv0dyuVR5s2FxulJwu1BvvE54tGB2tltwu1FuvUx3tV51t1l2tlx0uFdsv0h1t1pzuVV0uFhyulR5tGFxu1J4tV93tl12t1vVT6hLAAAAXHRSTlMAAgUJDxccHBwkKS40OD5CSEtVV1xpamp2en6ChYeKlZWboKCprq6utLq8vsHDx8fOztPU1NfY2dnf39/f39/f39/g4OHh4ePk5+np6+vt7/Ly8vP09PX3+Pn6/hJL/5gAAAvvSURBVHja1d15VFNXHgdwZBMX3LVuBetW9zq1juMszlTbOiqdamt1FG4SIkuCEIxgjGyiFYFBxLQaNK1GLYpWKqUqqOA4FJCOonZUXNpKO9aodabVmU4Xlz/mZSEvyXv3vveS937Q398ezufc8333e+Uc7vWTZAL7jJhz4cKMkb0C/X4u4999xGtXrly6dLFy/sju/n4/i+kUPuezT23oMyWmWeGdOvi1+wnqP+nzzx3oizVGk+nZJ4L82vcE9Bp9/TqNPldKqd8Z0yvAr/2Of+iIV7/4wgV9oc5knflDQ9tttDsNnPPPL93R5yqMFPod86zBnfza4wT2nXTjhif6H41mu9r87BPtb/sL6Dn69m0W9CfHjVa12WyeP6Zn+4p2hy5PvfrTT6zo0yVGk1VtZQ/t0o62v5CBzz/8Fwb9SY3RHhBqSmYN7ujXPiawz6R7D/HoM2Uu6pL2EW3/7qPvPSKhz9WZbAGxo0vmj2nzZqfC/PK//0NGn60wuqpLZoW3bbSD+j//v8ec6EazS0CoKZ3cv+2aPaDP2B/u80CfOWr0UO+f0EaHVv/Qp+//wA/dWOIekNLS0gUj2iDaHTo9+fL3/+WJPl1jYqj3R4RDN3tQ3+dufc8f3VjmDAitLpsMemgN6Dn21o9C0H+vNTnVNLqsDO7Q2iH0qVfu3BGGbjxkdATEXb1gaCjI9tfpyZnfPBCMrjOzBYSaCIBDa2Df577+2gt041EjRl0xWeJm9+85duHdu16hT5U6AsJAVyyQ8tBKdfYr3971Fl1twqorIiQ7tIYMnPnVt96jT5VhA1JRWTljcIif+BPY55mvbvqEPmnyVLeirerKCX3EjrZ/96cX3rzpG7qu3OgZEDe1yM1uDbPlO5/RJ81k9bGI8C5+Yk3QwF9ZLCKgP6o0EmJtVR8T69Aa0OeZmxZx0B+VGNzVNNqhrl40QYRmpw6gCy0WsdDHjRwBOVZdvWBEqL+vB9CZFot46JP7DISAONQ1vjV7YF8qzKKiq0181DXeN3sA1dkWkdEnyw02NTYglTZ0zSKq2b08gFosYqP/Wm02cMe6hpp5XjR7iDXMEqBPHDbyCQg1tUKbPbDvLywWadDVJQYudbVNXVtbK6TZ/XtS25xk6KOOb5Eca7t6EdXs/DvbIh36eKmBZ6xrqYng9euoEGtnS4qmlppvrK0zo38Qn86WGl1mMBDrnI61bbiaPSgsssUiOfqo2cA31rapmxceQjCP1OmqANDlRrzagXZX143ERsR/kF6ny26WHn3YbBAU67qjiWG4z7HrizpqqgDQ5SZKLSAga9Dsrhj0IL1eZ11q6dGH9xiE7Hvl8QiFYWpwvF5vZe8GQB8yCQlIJkJoXCD7ZzhVb1NnNgGgSw2s6v0eaht6TwyFnsL+KXacqrdPcYv0aCrVfGNdsxJRMz0Yg85Is6HTmgDQ+wx8Y70lmozOsLOLWqRHv7+jkF+sK5cjDrSdnVYPgN5nKOSMtRW9UU5GZ2Y42Pkt0qPf30EMSKu6XIM40Jmt7Crp0fv2bS00cNf5ehknupUd2QyANhu4Y12qRpxoJ7sKAL2HWmquU2om4kY72dnNAOgdhkKOWO+I5YGm2bsB0O9uLeRQ6xEnOttFvboJAL1jSyEx1luUPNDZ2S5L3QKNZix1WQrihabZq+sB0FuJ6o0KnmiaXdQCg8YGpFSD+KJpdj0cmk1dtl7OG02zC5oB0G8W4gJiTkQ80L+2e2l2FQR6I069WiYATbMjmyHQueyx3hGPhKBpdRUE+i+5rLFOQ/zQ6zzVkc0QaErNDMiWWL7odZ7s3S0A6PW5LGod4o1msJsg0GuZsS5U8kXnrLON+1IDoN+wqt3/d66Vyfiic5jsegj0G54BWauUUcMTzWQXtQCg13gExLhMLpfb2Nzo/BwWdj0E2kO9VimXO9jc6HwWdlEzAHr1GteAGDQKalrZnGgr29NdBYHOXOuizlBGK1zZRHRBPhu7oBkCvTrXGZDCpdHUuLFJ6AJWdhUEOm2NU61XKpUMNgHNys5vhkCntQYkN0Gp9GTj0b/dUMDO3t0CgF6VkWtX65YsWcJk49Eb2Nn5TRDoVfalXquOiWGwiWgMe3cLAHql3qZOiaWGycaii4o2YNxNEOgV1oCsVcfHsrFfwKNx7OIWCLSOWmptPDVMNg4dQqGx7HoI9HJ9boZaFc/KxqI3FWHZm5oh0MsztCpqWNgE9CYsO6fqJgB6mXapWs3OxqNtw8rOSW36DgCdnKhWs7EJ6Lda1Ux2ujwLYqWTNQlqdjYeTQ37auerohR/A0EnLk1IYGGT0Dh2ugxFpbbAoJe6sFVONhZdXIxh58QhhGQfgKATWdhkNIadSpmppW6GQKtZ2Vj0b4qL2dnp9l9uy/aCoK1qJhuL3raNlb0hCdkmKqkZAq1K0LCwX8Kj2dib0p3/Jd4MglYlaphsIprJ3hCHWieuCQIdr9ZoPNgE9Ntvs7FTET15IOjYRA2DTUCzsPNcfxWoqIdAx8QnJ7uzyWgm23WhUVQWCHpJQrInG4vevp3JTpcj11FUQaCVsZpkDzYBzWC/lUSD7Q0Dgo5WaZe5sUloT/Y2x3ZHj+wDEHS0RuvOxqJ37vRkb4qjuc6GgUArYrVaVzYJ7clORczZDoKWJ2rd2AS0BztPwYJOugyBlim1WppNQO/d687eloTYJg8ELVNrXdnTOmLR7uws96+QLnMINFIsS3Gy8ejf7d3rxsYsNIrK+wYCjeJTUmg2Fv3ee67snYyvkC7zBxBouSaFZhPQruy8OBw6Kv3OjwBotCTFNlxomk1YaITkVQ8g0LKlKfbhQNNs9+3Os8wvQ6BRtDbFMSQ0zd6ehAgj2w2CRmpdq5qApsd9u2OW+WUQtFyr03GgDxxwmjfHIfIUg6BRrE5nZ7+IRzvZqYhj4i6DoGXJOusQ0a3szQrENXm3INBIqbMPFn3w4AGHOwlxTlwDCBolcqId7DzCV0g3zC0QtCJFT0L//uBBO3sncaGdP60BBI1Uer2egD5yxM7OImLphrkFgpZr9dQQ0DY2x3ZH/7QPQdDUtkdG29ic2x3dMCBoWTI3mnu7o8v8PgQaKXVc6ANJiPckXQVBo8SMNBz6DzZ0lgzxnyIYtEKXMZWEPuD2FXI3zGMINFKlEdFZSNDk3AdBy7RYNP+vkP5GGkDQKAaT6aBfUmjP7Y67zO+DoNG0IPY/DJ5ALbTbv+VX5o9B0Jg/DPYbeOQgc7vjLvOrjyDQYX7sE/rHLCR8ZB9CoGd3w93sMSjOC3SU5ioAOswfe4HDcOTN7JIePZxwx0fwkLleoFVXH0mLnjskmHgpSe9xi4WrCyRd6cXjegdwXdnWb4pgdNx5CdFTBgTxuGin85DZQtU596RCzx7SuQO/K426DRcY7egGadCLR3Xz5395VO+Ji4WV+b2H4qMXT+wt7F604AHThajlDeKjpw9g7hnc0Z4rYKmTr4mMnjusawdvrp7rMYp/RmS7REX/eVSPAG8v+es3kbc68Zp46NiJ/Xy54zQ4jHe0d4mGfiEs2McrTbsO4xnt+PPioF8f1tX3e3t5N3ukGOjk8b19vyJUQLMrP77tM3paP3EuY7Vtf2F8mn3Vlz6iXwrr7HsyBDa7osEn9Osju4l5wbB1ArmjHbXimg/o8b3FvsrZ3uxc0ZbvuuEteuogiV564Ty0RmmueYf+01BRw+wRbY5ml+3y6u/GR/YQZ5vzstlV54WjIR7TIR9aI4WiZ0kVZgHNHvuxIPR8oGckbIdW/PaXfZ0/eg/cgx3kZlee4I2GfRqF2OwrP+WHhnipg3ezKw5d54H2+eZ0cQ+tUcsucKPFuKPe62gPmMLWMFxosV4DELPZE88S0WK+u+B1tJnNvpGAXiTuCxce48Ovo1SnPsOhxX9LRLRmX4NZaWlebRGp2WNOsKHnSfY+jnV8/3XUqksM9CIpXyIS5dAafcgTLfWbT15H26XZV1xwQ89pi87mG21ns8vfvUKj57VVZwttds3ZVvS5tuxsYYdW2ZsO9Iy27Wxhh1b16UsUek7bd7agQ2vkxYuvtY/O5tvso2YjVcRoiTr7/yQNxSNiKj13AAAAAElFTkSuQmCC);\n  --runtime-deno: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 30 30">%0A    <g clip-path="url(%23a)">%0A        <path fill="%23000" d="M15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0Z" />%0A        <path fill="%23fff" d="M14.664 22.34a.733.733 0 0 0-.893.498l-.006.018-.996 3.691-.004.018a.732.732 0 0 0 1.414.381l.005-.017.996-3.691.004-.018a.735.735 0 0 0 .016-.084l.003-.028-.024-.12-.034-.171-.022-.108a.732.732 0 0 0-.46-.37Zm-6.942-3.802a.738.738 0 0 0-.045.114l-.007.024-.996 3.692-.005.018a.732.732 0 0 0 1.414.381l.005-.018.903-3.347a6.622 6.622 0 0 1-1.269-.864Zm-2.375-4.245a.732.732 0 0 0-.893.498l-.005.018-.996 3.692-.005.017a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.52-.88Zm22.335-.838a.732.732 0 0 0-.893.498l-.005.018-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.692.005-.017a.732.732 0 0 0-.521-.88ZM3.178 8.525a13.383 13.383 0 0 0-1.564 4.908.732.732 0 0 0 1.252-.275l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.694-.906Zm21.981.026a.732.732 0 0 0-.893.498l-.005.018-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.521-.88ZM7.513 5.04a.732.732 0 0 0-.893.5l-.005.017-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.521-.88Zm12.799.698a.732.732 0 0 0-.893.5l-.005.017-.67 2.48c.434.214.848.466 1.237.753l.064.048.783-2.9.004-.017a.732.732 0 0 0-.52-.88Zm-6.515-4.162a13.47 13.47 0 0 0-1.393.197l-.097.02-.929 3.441-.004.018a.732.732 0 0 0 1.413.381l.005-.017.997-3.692.004-.017a.728.728 0 0 0 .004-.33Zm9.166 2.55-.196.726-.005.017a.732.732 0 0 0 1.414.382l.005-.018.021-.078a13.548 13.548 0 0 0-1.153-.965l-.086-.064Zm-5.796-2.43-.353 1.31-.005.018a.732.732 0 0 0 1.414.381l.005-.017.372-1.378c-.438-.121-.881-.22-1.329-.296l-.104-.017ZM9.69 24.625a.733.733 0 0 1 1.415.382l-.005.018-.713 2.641-.1-.036c-.429-.16-.85-.343-1.26-.546l.659-2.441.005-.018Z" />%0A        <path fill="%23fff" d="M14.414 8.49c-4.362 0-7.755 2.747-7.755 6.162 0 3.225 3.122 5.284 7.962 5.181.412-.009.53.268.665.64.134.373.494 2.337.78 3.839.257 1.344.518 2.693.717 4.048 3.16-.418 6.083-1.98 8.225-4.334l-2.284-8.517c-.57-2.057-1.235-3.953-2.996-5.33-1.416-1.107-3.216-1.688-5.314-1.688Z" />%0A        <path fill="%23000" d="M15.352 10.957a.937.937 0 1 1 0 1.875.937.937 0 0 1 0-1.875Z" />%0A    </g>%0A    <defs>%0A        <clipPath id="a">%0A            <path fill="%23fff" d="M0 0h30v30H0z" />%0A        </clipPath>%0A    </defs>%0A</svg>%0A\');\n  --runtime-chromium: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="511.985" height="511.985"><defs><linearGradient xlink:href="%23a" id="f" x1=".465" x2=".557" y1="-.674" y2=".811" gradientTransform="matrix(231.62575 0 0 231.62472 111.11 159.994)" gradientUnits="userSpaceOnUse"/><linearGradient id="a"><stop offset="0" style="stop-color:%231972e7"/><stop offset="1" style="stop-color:%231969d5"/></linearGradient><linearGradient xlink:href="%23b" id="e" x1="101.744" x2="101.599" y1="33.726" y2="135.466" gradientTransform="matrix(3.77942 0 0 3.7794 .002 .004)" gradientUnits="userSpaceOnUse"/><linearGradient id="b" x2="1" gradientTransform="translate(29.399 42.333) scale(61.286)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:%23afccfb"/><stop offset="1" style="stop-color:%238bb5f8"/></linearGradient><linearGradient xlink:href="%23c" id="g" x1=".018" x2="1.77" y1="-.512" y2=".499" gradientTransform="matrix(94.93156 164.42687 -164.4276 94.93114 97.556 173.61)" gradientUnits="userSpaceOnUse"/><linearGradient id="c" x2="1" gradientTransform="scale(50.236) rotate(60 -.535 .902)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:%23659cf6"/><stop offset="1" style="stop-color:%234285f4"/></linearGradient><linearGradient xlink:href="%23d" id="h" x1="67.452" x2="67.733" y1="40.321" y2="95.25" gradientTransform="matrix(3.77942 0 0 3.7794 .002 .004)" gradientUnits="userSpaceOnUse"/><linearGradient id="d"><stop offset="0" style="stop-color:%233680f0"/><stop offset="1" style="stop-color:%232678ec"/></linearGradient></defs><path d="m255.993 255.994 110.85 63.997-110.85 191.994c141.38 0 255.992-114.61 255.992-255.99 0-46.642-12.536-90.332-34.331-127.998H255.99z" style="fill:url(%23e)"/><path d="M255.99 0C161.24 0 78.578 51.513 34.313 128.027L145.14 319.991l110.85-63.997V127.997h221.664C433.382 51.502 350.729 0 255.99 0Z" style="fill:url(%23f)"/><path d="M.002 255.994c0 141.38 114.607 255.99 255.991 255.99l110.85-191.993-110.85-63.997-110.85 63.997L34.315 128.027C12.53 165.682 0 209.357 0 255.991" style="fill:url(%23g)"/><path fill="%23fff" d="M383.99 255.994c0 70.69-57.306 127.997-127.997 127.997-70.69 0-127.998-57.307-127.998-127.997s57.308-127.997 127.998-127.997 127.998 57.307 127.998 127.997"/><path d="M359.992 255.994c0 57.436-46.563 103.998-103.999 103.998-57.436 0-103.998-46.562-103.998-103.998 0-57.435 46.562-103.998 103.998-103.998 57.436 0 103.999 46.563 103.999 103.998" style="fill:url(%23h)"/></svg>%0A\');\n  --runtime-edge: url(\'data:image/svg+xml,<svg viewBox="0 0 27600 27600" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="%23000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><linearGradient id="A" gradientUnits="userSpaceOnUse"></linearGradient><linearGradient id="B" x1="6870" x2="24704" y1="18705" y2="18705" xlink:href="%23A"><stop offset="0" stop-color="%230c59a4"></stop><stop offset="1" stop-color="%23114a8b"></stop></linearGradient><linearGradient id="C" x1="16272" x2="5133" y1="10968" y2="23102" xlink:href="%23A"><stop offset="0" stop-color="%231b9de2"></stop><stop offset=".16" stop-color="%231595df"></stop><stop offset=".67" stop-color="%230680d7"></stop><stop offset="1" stop-color="%230078d4"></stop></linearGradient><radialGradient id="D" cx="16720" cy="18747" r="9538" xlink:href="%23A"><stop offset=".72" stop-opacity="0"></stop><stop offset=".95" stop-opacity=".53"></stop><stop offset="1"></stop></radialGradient><radialGradient id="E" cx="7130" cy="19866" r="14324" gradientTransform="matrix(.14843 -.98892 .79688 .1196 -8759 25542)" xlink:href="%23A"><stop offset=".76" stop-opacity="0"></stop><stop offset=".95" stop-opacity=".5"></stop><stop offset="1"></stop></radialGradient><radialGradient id="F" cx="2523" cy="4680" r="20243" gradientTransform="matrix(-.03715 .99931 -2.12836 -.07913 13579 3530)" xlink:href="%23A"><stop offset="0" stop-color="%2335c1f1"></stop><stop offset=".11" stop-color="%2334c1ed"></stop><stop offset=".23" stop-color="%232fc2df"></stop><stop offset=".31" stop-color="%232bc3d2"></stop><stop offset=".67" stop-color="%2336c752"></stop></radialGradient><radialGradient id="G" cx="24247" cy="7758" r="9734" gradientTransform="matrix(.28109 .95968 -.78353 .22949 24510 -16292)" xlink:href="%23A"><stop offset="0" stop-color="%2366eb6e"></stop><stop offset="1" stop-color="%2366eb6e" stop-opacity="0"></stop></radialGradient><path id="H" d="M24105 20053a9345 9345 0 01-1053 472 10202 10202 0 01-3590 646c-4732 0-8855-3255-8855-7432 0-1175 680-2193 1643-2729-4280 180-5380 4640-5380 7253 0 7387 6810 8137 8276 8137 791 0 1984-230 2704-456l130-44a12834 12834 0 006660-5282c220-350-168-757-535-565z"></path><path id="I" d="M11571 25141a7913 7913 0 01-2273-2137 8145 8145 0 01-1514-4740 8093 8093 0 013093-6395 8082 8082 0 011373-859c312-148 846-414 1554-404a3236 3236 0 012569 1297 3184 3184 0 01636 1866c0-21 2446-7960-8005-7960-4390 0-8004 4166-8004 7820 0 2319 538 4170 1212 5604a12833 12833 0 007684 6757 12795 12795 0 003908 610c1414 0 2774-233 4045-656a7575 7575 0 01-6278-803z"></path><path id="J" d="M16231 15886c-80 105-330 250-330 566 0 260 170 512 472 723 1438 1003 4149 868 4156 868a5954 5954 0 003027-839 6147 6147 0 001133-850 6180 6180 0 001910-4437c26-2242-796-3732-1133-4392-2120-4141-6694-6525-11668-6525-7011 0-12703 5635-12798 12620 47-3654 3679-6605 7996-6605 350 0 2346 34 4200 1007 1634 858 2490 1894 3086 2921 618 1067 728 2415 728 2952s-271 1333-780 1990z"></path><use fill="url(%23B)" xlink:href="%23H"></use><use fill="url(%23D)" opacity=".35" xlink:href="%23H"></use><use fill="url(%23C)" xlink:href="%23I"></use><use fill="url(%23E)" opacity=".4" xlink:href="%23I"></use><use fill="url(%23F)" xlink:href="%23J"></use><use fill="url(%23G)" xlink:href="%23J"></use></g></svg>%0A<!-- <svg viewBox="0 0 27600 27600" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="%23000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round" stroke="%23000000" stroke-width="386.40000000000003"><linearGradient id="A" gradientUnits="userSpaceOnUse"></linearGradient><linearGradient id="B" x1="6870" x2="24704" y1="18705" y2="18705" xlink:href="%23A"><stop offset="0" stop-color="%230c59a4"></stop><stop offset="1" stop-color="%23114a8b"></stop></linearGradient><linearGradient id="C" x1="16272" x2="5133" y1="10968" y2="23102" xlink:href="%23A"><stop offset="0" stop-color="%231b9de2"></stop><stop offset=".16" stop-color="%231595df"></stop><stop offset=".67" stop-color="%230680d7"></stop><stop offset="1" stop-color="%230078d4"></stop></linearGradient><radialGradient id="D" cx="16720" cy="18747" r="9538" xlink:href="%23A"><stop offset=".72" stop-opacity="0"></stop><stop offset=".95" stop-opacity=".53"></stop><stop offset="1"></stop></radialGradient><radialGradient id="E" cx="7130" cy="19866" r="14324" gradientTransform="matrix(.14843 -.98892 .79688 .1196 -8759 25542)" xlink:href="%23A"><stop offset=".76" stop-opacity="0"></stop><stop offset=".95" stop-opacity=".5"></stop><stop offset="1"></stop></radialGradient><radialGradient id="F" cx="2523" cy="4680" r="20243" gradientTransform="matrix(-.03715 .99931 -2.12836 -.07913 13579 3530)" xlink:href="%23A"><stop offset="0" stop-color="%2335c1f1"></stop><stop offset=".11" stop-color="%2334c1ed"></stop><stop offset=".23" stop-color="%232fc2df"></stop><stop offset=".31" stop-color="%232bc3d2"></stop><stop offset=".67" stop-color="%2336c752"></stop></radialGradient><radialGradient id="G" cx="24247" cy="7758" r="9734" gradientTransform="matrix(.28109 .95968 -.78353 .22949 24510 -16292)" xlink:href="%23A"><stop offset="0" stop-color="%2366eb6e"></stop><stop offset="1" stop-color="%2366eb6e" stop-opacity="0"></stop></radialGradient><path id="H" d="M24105 20053a9345 9345 0 01-1053 472 10202 10202 0 01-3590 646c-4732 0-8855-3255-8855-7432 0-1175 680-2193 1643-2729-4280 180-5380 4640-5380 7253 0 7387 6810 8137 8276 8137 791 0 1984-230 2704-456l130-44a12834 12834 0 006660-5282c220-350-168-757-535-565z"></path><path id="I" d="M11571 25141a7913 7913 0 01-2273-2137 8145 8145 0 01-1514-4740 8093 8093 0 013093-6395 8082 8082 0 011373-859c312-148 846-414 1554-404a3236 3236 0 012569 1297 3184 3184 0 01636 1866c0-21 2446-7960-8005-7960-4390 0-8004 4166-8004 7820 0 2319 538 4170 1212 5604a12833 12833 0 007684 6757 12795 12795 0 003908 610c1414 0 2774-233 4045-656a7575 7575 0 01-6278-803z"></path><path id="J" d="M16231 15886c-80 105-330 250-330 566 0 260 170 512 472 723 1438 1003 4149 868 4156 868a5954 5954 0 003027-839 6147 6147 0 001133-850 6180 6180 0 001910-4437c26-2242-796-3732-1133-4392-2120-4141-6694-6525-11668-6525-7011 0-12703 5635-12798 12620 47-3654 3679-6605 7996-6605 350 0 2346 34 4200 1007 1634 858 2490 1894 3086 2921 618 1067 728 2415 728 2952s-271 1333-780 1990z"></path><use fill="url(%23B)" xlink:href="%23H"></use><use fill="url(%23D)" opacity=".35" xlink:href="%23H"></use><use fill="url(%23C)" xlink:href="%23I"></use><use fill="url(%23E)" opacity=".4" xlink:href="%23I"></use><use fill="url(%23F)" xlink:href="%23J"></use><use fill="url(%23G)" xlink:href="%23J"></use></g><g id="SVGRepo_iconCarrier"><linearGradient id="A" gradientUnits="userSpaceOnUse"></linearGradient><linearGradient id="B" x1="6870" x2="24704" y1="18705" y2="18705" xlink:href="%23A"><stop offset="0" stop-color="%230c59a4"></stop><stop offset="1" stop-color="%23114a8b"></stop></linearGradient><linearGradient id="C" x1="16272" x2="5133" y1="10968" y2="23102" xlink:href="%23A"><stop offset="0" stop-color="%231b9de2"></stop><stop offset=".16" stop-color="%231595df"></stop><stop offset=".67" stop-color="%230680d7"></stop><stop offset="1" stop-color="%230078d4"></stop></linearGradient><radialGradient id="D" cx="16720" cy="18747" r="9538" xlink:href="%23A"><stop offset=".72" stop-opacity="0"></stop><stop offset=".95" stop-opacity=".53"></stop><stop offset="1"></stop></radialGradient><radialGradient id="E" cx="7130" cy="19866" r="14324" gradientTransform="matrix(.14843 -.98892 .79688 .1196 -8759 25542)" xlink:href="%23A"><stop offset=".76" stop-opacity="0"></stop><stop offset=".95" stop-opacity=".5"></stop><stop offset="1"></stop></radialGradient><radialGradient id="F" cx="2523" cy="4680" r="20243" gradientTransform="matrix(-.03715 .99931 -2.12836 -.07913 13579 3530)" xlink:href="%23A"><stop offset="0" stop-color="%2335c1f1"></stop><stop offset=".11" stop-color="%2334c1ed"></stop><stop offset=".23" stop-color="%232fc2df"></stop><stop offset=".31" stop-color="%232bc3d2"></stop><stop offset=".67" stop-color="%2336c752"></stop></radialGradient><radialGradient id="G" cx="24247" cy="7758" r="9734" gradientTransform="matrix(.28109 .95968 -.78353 .22949 24510 -16292)" xlink:href="%23A"><stop offset="0" stop-color="%2366eb6e"></stop><stop offset="1" stop-color="%2366eb6e" stop-opacity="0"></stop></radialGradient><path id="H" d="M24105 20053a9345 9345 0 01-1053 472 10202 10202 0 01-3590 646c-4732 0-8855-3255-8855-7432 0-1175 680-2193 1643-2729-4280 180-5380 4640-5380 7253 0 7387 6810 8137 8276 8137 791 0 1984-230 2704-456l130-44a12834 12834 0 006660-5282c220-350-168-757-535-565z"></path><path id="I" d="M11571 25141a7913 7913 0 01-2273-2137 8145 8145 0 01-1514-4740 8093 8093 0 013093-6395 8082 8082 0 011373-859c312-148 846-414 1554-404a3236 3236 0 012569 1297 3184 3184 0 01636 1866c0-21 2446-7960-8005-7960-4390 0-8004 4166-8004 7820 0 2319 538 4170 1212 5604a12833 12833 0 007684 6757 12795 12795 0 003908 610c1414 0 2774-233 4045-656a7575 7575 0 01-6278-803z"></path><path id="J" d="M16231 15886c-80 105-330 250-330 566 0 260 170 512 472 723 1438 1003 4149 868 4156 868a5954 5954 0 003027-839 6147 6147 0 001133-850 6180 6180 0 001910-4437c26-2242-796-3732-1133-4392-2120-4141-6694-6525-11668-6525-7011 0-12703 5635-12798 12620 47-3654 3679-6605 7996-6605 350 0 2346 34 4200 1007 1634 858 2490 1894 3086 2921 618 1067 728 2415 728 2952s-271 1333-780 1990z"></path><use fill="url(%23B)" xlink:href="%23H"></use><use fill="url(%23D)" opacity=".35" xlink:href="%23H"></use><use fill="url(%23C)" xlink:href="%23I"></use><use fill="url(%23E)" opacity=".4" xlink:href="%23I"></use><use fill="url(%23F)" xlink:href="%23J"></use><use fill="url(%23G)" xlink:href="%23J"></use></g></svg> -->%0A\');\n  --runtime-electron: url(\'data:image/svg+xml,<svg width="256" height="256" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle fill="%232B2E3A" cx="128" cy="128" r="128"/><g fill="%239FEAF9" fill-rule="nonzero"><path d="M100.502 71.69c-26.005-4.736-46.567.221-54.762 14.415-6.115 10.592-4.367 24.635 4.24 39.646a2.667 2.667 0 1 0 4.626-2.653c-7.752-13.522-9.261-25.641-4.247-34.326 6.808-11.791 25.148-16.213 49.187-11.835a2.667 2.667 0 0 0 .956-5.247zm-36.999 72.307c10.515 11.555 24.176 22.394 39.756 31.388 37.723 21.78 77.883 27.601 97.675 14.106a2.667 2.667 0 1 0-3.005-4.406c-17.714 12.078-55.862 6.548-92.003-14.318-15.114-8.726-28.343-19.222-38.478-30.36a2.667 2.667 0 1 0-3.945 3.59z"/><path d="M194.62 140.753c17.028-20.116 22.973-40.348 14.795-54.512-6.017-10.423-18.738-15.926-35.645-16.146a2.667 2.667 0 0 0-.069 5.333c15.205.198 26.165 4.939 31.096 13.48 6.792 11.765 1.49 29.807-14.248 48.399a2.667 2.667 0 1 0 4.071 3.446zm-43.761-68.175c-15.396 3.299-31.784 9.749-47.522 18.835-38.942 22.483-64.345 55.636-60.817 79.675a2.667 2.667 0 1 0 5.277-.775c-3.133-21.344 20.947-52.769 58.207-74.281 15.267-8.815 31.135-15.06 45.972-18.239a2.667 2.667 0 1 0-1.117-5.215z"/><path d="M87.77 187.753c8.904 24.86 23.469 40.167 39.847 40.167 11.945 0 22.996-8.143 31.614-22.478a2.667 2.667 0 1 0-4.571-2.748c-7.745 12.883-17.258 19.892-27.043 19.892-13.605 0-26.596-13.652-34.825-36.63a2.667 2.667 0 1 0-5.021 1.797zm81.322-4.863c4.61-14.728 7.085-31.718 7.085-49.423 0-44.179-15.463-82.263-37.487-92.042a2.667 2.667 0 0 0-2.164 4.874c19.643 8.723 34.317 44.866 34.317 87.168 0 17.177-2.397 33.63-6.84 47.83a2.667 2.667 0 1 0 5.09 1.593zm50.224-2.612c0-7.049-5.714-12.763-12.763-12.763-7.049 0-12.763 5.714-12.763 12.763 0 7.049 5.714 12.763 12.763 12.763 7.049 0 12.763-5.714 12.763-12.763zm-5.333 0a7.43 7.43 0 1 1-14.86 0 7.43 7.43 0 0 1 14.86 0zM48.497 193.041c7.05 0 12.764-5.714 12.764-12.763 0-7.049-5.715-12.763-12.764-12.763-7.048 0-12.763 5.714-12.763 12.763 0 7.049 5.715 12.763 12.763 12.763zm0-5.333a7.43 7.43 0 1 1 0-14.86 7.43 7.43 0 0 1 0 14.86z"/><path d="M127.617 54.444c7.049 0 12.763-5.714 12.763-12.763 0-7.049-5.714-12.763-12.763-12.763-7.049 0-12.763 5.714-12.763 12.763 0 7.049 5.714 12.763 12.763 12.763zm0-5.333a7.43 7.43 0 1 1 0-14.86 7.43 7.43 0 0 1 0 14.86zm1.949 93.382c-4.985 1.077-9.896-2.091-10.975-7.076a9.236 9.236 0 0 1 7.076-10.976c4.985-1.077 9.896 2.091 10.976 7.076 1.077 4.985-2.091 9.897-7.077 10.976z"/></g></g></svg>\');\n  --runtime-unknown: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="2.5 0.1 187 187"><path fill="none" d="M0 0h192v192H0z"/><defs><path id="a" d="m184 32-16 28-4.5 8h-10.9L139 94a44.1 44.1 0 0 1-28.4 51.5L96 172l-14.6-26.5-1.4-.5A44.2 44.2 0 0 1 53 94L39.4 68H28.6L24 60 8 32h46l7.5 14.9.4.2.1-.2a34 34 0 0 1 67.8 0l-.2.2V47L138 32h46z"/></defs><clipPath id="b"><use xlink:href="%23a" overflow="visible"/></clipPath><g clip-path="url(%23b)"><path fill="%239e9e9e" d="m155.5 59-4.3 9h12.2l.6-1 4.5-8h-13.1zM36.3 59H23.5l5.1 9h12l-4.3-9z"/><path fill="%23424242" d="m184 32-16 28h-11.2l-18 34L96 172 53.1 94 35.2 60H24L8 32h46l7.5 14.9 24.4 44.5 10 18.3 9.6-18.3 24-44.5L138 32"/><g fill-opacity=".2"><path fill="%23fff" d="M54.6 33h-46L8 32h46l.6 1zm83.4-1-.6 1h46l.6-1h-46z"/><path fill="%23263238" d="m164 67-.5 1h-10.9l-13.7 26L96 172 53.1 94 39.4 68H28.6l-.6-1h11.4l.6 1L53 93 96 171l42.9-78L152 68l.5-1"/></g></g><g clip-path="url(%23b)"><path fill="%23fff" d="M113 104a17 17 0 1 1-34 0 17 17 0 0 1 34 0zm-2-52a15 15 0 1 1-30 0 15 15 0 0 1 30 0z"/><path fill="%234285f4" d="M138.9 94a44 44 0 0 0-15.2-24.2 34 34 0 1 0-55.4 0A44 44 0 1 0 139 94zM96 38a14 14 0 1 1 0 28 14 14 0 0 1 0-28zm0 82a16 16 0 1 1 0-32 16 16 0 0 1 0 32z"/><g fill-opacity=".2"><path fill="%23fff" d="M130 50v.5a34 34 0 0 0-68 0V50a34 34 0 1 1 68 0zM67.9 70.2A43.9 43.9 0 0 0 52 104v.5a44 44 0 0 1 16.3-33.7l.5-.4-.5-.6-.4.4zm56.2 0-.4-.4-.5.6.5.4a44 44 0 0 1 16.3 33.7v-.5c0-13.6-6.2-25.8-15.9-33.8z"/><path fill="%23263238" d="M140 103.5v.5a44 44 0 0 1-88 0v-.5a44 44 0 0 0 88 0zm-78-54v.5c0 7.7 2.5 14.7 6.8 20.4l.5-.4A33.9 33.9 0 0 1 62 49.5zm68 0a33.9 33.9 0 0 1-7.3 20.5l.5.4A33.6 33.6 0 0 0 130 50v-.5z"/></g></g><radialGradient id="c" cx="10.3" cy="33.8" r="185.4" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="%23FFF" stop-opacity=".1"/><stop offset="1" stop-color="%23FFF" stop-opacity="0"/></radialGradient><path fill="url(%23c)" d="m184 32-16 28-4.5 8h-10.9l-13.7 26a44.1 44.1 0 0 1-28.4 51.5L96 172l-14.6-26.5-1.4-.5A44.2 44.2 0 0 1 53 94L39.4 68H28.6L24 60 8 32h46l7.5 14.9.4.2.1-.2a34 34 0 0 1 67.8 0l-.2.2V47L138 32h46z"/></svg>%0A\');\n}\n.discovery-root-darkmode {\n  --runtime-unknown: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="%23fff" viewBox="0 0 2020 2020"><clipPath id="a"><path d="M1890 370l-160 280-46 80h-108l-138 261a441.1 441.1 0 01-268 509l-15 6-145 264-146-265c-5-2-10-4-15-5a441.6 441.6 0 01-269-510L444 730H336l-46-80-160-280h460l75 149 4 2c0-1 1-2 1-2 16-173 162-309 339-309s323 136 339 309c0 1-2 2-2 2l-1-2 85-149z"/></clipPath><radialGradient id="b" cx="152.5" cy="387.5" r="1854.4" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="%23fff" stop-opacity=".1"/><stop offset="1" stop-color="%23fff" stop-opacity="0"/></radialGradient><path fill="%234285f4" stroke="%23fff" stroke-miterlimit="10" stroke-width="150" d="M1890 370h-460l-82 144a339.6 339.6 0 00-338-304c-178 0-324 136-340 309 0 1-2 2-2 2l-4-2-70-139h1l-5-10H130l6 10 154 270 41 70h-1l6 10h109l137 260c-2 8-3 16-5 24-4 25-6 50-6 75 0 186 116 346 280 410 5 2 10 4 15 5l144 266 146-265c5-2 10-3 15-5 164-64 280-223 280-410 0-34-4-68-11-100l138-260h108l6-10 194-340z"/><g clip-path="url(%23a)"><path fill="%239e9e9e" d="M1605 640l-43 90h122l6-10 45-80zm-1192 0H285l52 90h120z"/><path fill="%23424242" d="M1890 370l-160 280h-112l-179 341-429 779-429-780-179-340H290L130 370h460l75 149 244 445 100 183 96-183 240-445 85-149"/><path d="M1180 1090a169.9 169.9 0 11-340 0 169.9 169.9 0 11340 0zm-20-520a149.8 149.8 0 11-300 0 149.8 149.8 0 11300 0z"/><g fill="%23263238" fill-opacity=".2"><path d="M1690 720l-6 10h-109l-137 261-428 779-429-780-137-260H336l-6-10h114l5 10 132 250 429 780 429-779 137-261"/><path fill="%234285f4" fill-opacity="1" d="M1439 991c-22-97-77-182-152-243 40-56 63-124 63-198 0-10-1-21-1-31-16-173-162-309-339-309S687 346 672 519c-1 10-2 21-2 31 0 74 23 142 63 198-75 61-130 145-152 242-8 32-11 65-11 100 0 186 116 346 280 410 50 19 104 30 160 30s111-11 160-30c164-64 280-223 280-410 0-34-4-68-11-99zm-429-561c77 0 140 63 140 140s-63 140-140 140-140-63-140-140 63-140 140-140zm0 820c-88 0-160-72-160-160 0-51 24-97 62-126 27-21 61-34 98-34s71 13 98 34c38 29 62 75 62 126 0 88-72 160-160 160z"/><path fill="%23fff" d="M1350 550v5c-3-185-154-335-340-335S673 370 670 555v-5c0-188 152-340 340-340s340 152 340 340zM729 752c-97 80-159 202-159 338v5c2-136 65-258 163-337l5-4-5-6zm562 0l-4-4-5 6 5 4c99 80 162 201 163 337v-5c0-136-62-258-159-338zM596 380H136l-6-10h460zm834-10l-6 10h460l6-10z"/><path d="M1450 1085v5a440 440 0 01-880 0v-5c3 241 199 435 440 435s437-194 440-435zM670 545v5c0 77 25 147 68 204 2-1 3-2 5-4-45-56-72-128-73-205zm680 0c-1 78-28 149-73 205 2 1 3 2 5 4 43-56 68-127 68-204z"/></g></g><path fill="url(%23b)" d="M1890 370l-160 280-46 80h-108l-137 261a441.1 441.1 0 01-268 509l-15 6-146 264-146-265c-5-2-10-4-15-5a441.6 441.6 0 01-269-510L444 730H336l-46-80-160-280h460l75 149 4 2c0-1 1-2 1-2 16-173 162-309 339-309s323 136 339 309c0 1-2 2-2 2l-1-2 85-149z"/></svg>%0A\');\n}\n.view-alert-warning .view-link {\n  color: inherit;\n  text-decoration-color: inherit;\n}\n.view-page-indicators,\n:not(.view-page-indicators) > .view-page-indicator-group {\n  margin-bottom: 1px;\n}\n.page .view-page-header :is(.view-h1, .view-h2) {\n  font-family:\n    Helvetica Neue,\n    Helvetica,\n    Tahoma,\n    Arial,\n    sans-serif;\n  font-weight: 200;\n}\n.page .view-page-header__prelude .view-badge + .view-badge:not(:last-child) {\n  margin-right: 1px;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.page .view-page-header__prelude .view-badge:not(:first-child) + .view-badge {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.page .view-page-header__prelude .type-badge {\n  min-width: 8ex;\n  text-align: center;\n}\n.page .view-page-header__prelude .category-badge {\n  background-clip: padding-box;\n  background-color: color-mix(in srgb, var(--discovery-view-badge-color, rgba(128, 128, 128, .25)) 35%, transparent);\n  border: solid color-mix(in srgb, var(--discovery-view-badge-color, rgba(128, 128, 128, .25)) 60%, transparent);\n  border-width: 1px;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n.hint-tooltip {\n  max-width: 400px !important;\n}\n.hint-tooltip .view-markdown {\n  padding: 10px 8px;\n}\n.hint-tooltip .view-markdown .view-header:first-child {\n  margin: 0;\n  margin-top: -.2em;\n}\n.hint-tooltip .view-markdown :is(p, blockquote, ul) {\n  margin-top: .5em;\n}\n.view-badge {\n  --discovery-view-badge-color: #bababa33;\n  --discovery-view-badge-dark-color: #383838;\n}\n.discovery-root-darkmode .view-badge {\n  box-shadow: 0 0 0 .5px rgba(0, 0, 0, .12);\n}\n.view-table-cell > .view-badge,\n.view-table-cell > .view-badge .prefix,\n.view-table-cell > .view-badge .postfix {\n  padding-top: 2px;\n}\n.view-badge > .prefix {\n  color: #777;\n}\n.discovery-root-darkmode .view-badge > .prefix {\n  color: #a4a4a4;\n}\n.discovery-nav {\n  position: fixed;\n}\n.discovery-nav > .github::before {\n  --size: 15px;\n  content: "";\n  display: inline-block;\n  vertical-align: text-top;\n  height: var(--size);\n  aspect-ratio: 1/1;\n  margin-right: 5px;\n  margin-left: -3px;\n  background: url(\'data:image/svg+xml,<svg width="98" height="96" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="%2324292f"/></svg>\') no-repeat center;\n  background-size: calc(var(--size) - 0px);\n  opacity: .85;\n}\n.discovery-root-darkmode .discovery-nav > .github::before {\n  background-image: url(\'data:image/svg+xml,<svg width="98" height="96" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="%23fff"/></svg>\');\n}\n.discovery-nav > .full-page-mode {\n  background-color: rgba(78, 187, 255, .3);\n  border-radius: 0;\n  clip-path: rect(1px calc(100% - 1px) auto auto);\n  margin-right: calc(-1 * var(--discovery-page-padding-right));\n}\n.discovery-nav > .full-page-mode:hover {\n  background-color: rgba(78, 187, 255, .2);\n}\n.logo {\n  --color1: #242424;\n  --color2: white;\n  display: inline-flex;\n  border: 1px solid var(--color1, black);\n  line-height: 1;\n  border-radius: 3px;\n  box-shadow: 0 0 0 .5px rgba(255, 255, 255, .5);\n  flex-direction: column;\n  aspect-ratio: 1/1;\n  vertical-align: middle;\n}\n.discovery-root-darkmode .logo {\n  filter: brightness(0.9);\n}\nh2 .logo {\n  font-size: 47%;\n  margin-right: 8px;\n  position: relative;\n  vertical-align: bottom;\n}\n.logo::before {\n  content: "CPU";\n  background-color: var(--color1, black);\n  color: var(--color2, white);\n  padding: .3em .5em;\n}\n.logo::after {\n  content: "PRO";\n  background-color: var(--color2, white);\n  color: var(--color1, black);\n  padding: .3em .5em;\n  border-radius: 0 0 2px 2px;\n}\n.page > .view-expand.trigger-outside > .header {\n  --discovery-view-expand-trigger-size: calc(var(--discovery-page-padding-left) - 2px);\n  margin-right: calc(-1 * var(--discovery-page-padding-right) + 1px);\n}\n.table-content-filter > .view-input {\n  margin: 1px 0;\n}\n.view-table-cell > .view-timeline-segments-bin {\n  margin: -1px -6px -2px;\n  width: 250px;\n}\n.view-time-ruler-tooltip .timeline-segment-info {\n  padding-bottom: 4px;\n  border-bottom: 1px solid #0004;\n  margin-bottom: 4px;\n  opacity: .8;\n}\n.view-time-ruler-tooltip .timeline-segment-info .view-duration {\n  display: inline-flex;\n}\n.view-time-ruler-tooltip .category-timings-list {\n  display: grid;\n  grid-template-columns: 80px 100px;\n  gap: 2px 1ex;\n}\n.view-time-ruler-tooltip .category-timings-list .view-list-item {\n  display: contents;\n}\n.view-time-ruler-tooltip .category-timings-list .category-name::before {\n  content: "";\n  display: inline-block;\n  vertical-align: middle;\n  width: .75em;\n  aspect-ratio: 1/1;\n  margin-right: 1ex;\n  margin-top: -1px;\n  border-radius: 50%;\n  background-color: var(--color, #888);\n}\n.view-time-ruler-tooltip .category-timings-list .no-time {\n  color: #666;\n  --color: #8884 !important;\n}\n.view-time-ruler-tooltip .category-timings-list .no-time .view-duration {\n  opacity: 0;\n}\n.page .call-tree .view-tree-leaf-content {\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  gap: 1px;\n  padding-bottom: 1px;\n}\n.page .call-tree .view-tree-leaf-content > * {\n  line-height: 20px;\n  height: 22px;\n}\n.page .call-tree .view-tree-leaf-content .view-badge,\n.page .call-tree .view-tree-leaf-content .view-pill-badge {\n  --badge-padding-left: 25px;\n  --badge-icon-top-bottom: 4px;\n  --badge-icon-left: 5px;\n  height: 18px;\n  margin-right: 0px;\n  margin-left: 3px;\n}\n.page .call-tree .view-tree-leaf-content .view-badge.module {\n  margin-right: 0 !important;\n}\n.page .call-tree .view-tree-leaf-content .function-loc {\n  padding: 1px 5px 3px 2px;\n  color: #aaa;\n}\n.page .call-tree .view-tree-leaf-content .view-link {\n  margin-right: 4px;\n}\n.page .call-tree .self {\n  display: inline;\n  background-color: #f5e69a;\n  padding: 0 6px;\n  margin-left: -3px;\n  margin-right: 4px;\n  border-radius: 3px;\n}\n.discovery-root-darkmode .page .call-tree .self {\n  background-color: #68624685;\n  color: #b6aa6a;\n}\n.page .call-tree .grouped {\n  display: inline-block;\n  font-size: 10px;\n  padding-right: 4px;\n  color: #888;\n}\n.script-source > .content > .view-source {\n  margin-top: 1px;\n  margin-right: calc(1px - var(--discovery-page-padding-right));\n  max-height: calc(100vh - 118px);\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.script-source .view-source__prelude:empty {\n  display: none;\n}\n.script-source .view-source__prelude {\n  padding: 2px 7px 4px;\n  border-bottom: 1px solid var(--discovery-background-color);\n  color: #aaa;\n}\n.script-source .view-source__prelude .function-path::before {\n  content: "Top level";\n}\n.script-source .view-source__prelude .function-path .view-list-item::before {\n  content: "\\203a";\n  color: #888;\n  padding: 0 .6ex;\n}\n.script-source .view-source__prelude .function-path .view-list-item .target {\n  display: inline;\n  padding: 1px 5px 3px;\n  border-radius: 3px;\n  background-color: #68624685;\n  color: #b6aa6a;\n}\n.script-source .view-source .spotlight {\n  background-color: #46453c;\n}\n.script-source .view-source .spotlight .spotlight {\n  background-color: #3d473b;\n}\n.script-source .view-source .spotlight .spotlight .spotlight {\n  background-color: #414455;\n}\n.script-source .view-source .spotlight .spotlight .spotlight .spotlight {\n  background-color: #463c4b;\n}\n.script-source .view-source .spotlight.function:not(:has(.spotlight.function:hover)):hover {\n  background-color: #686246aa;\n}\n.script-source .view-source .spotlight.function {\n  padding-left: 0;\n  padding-right: 4px;\n  margin-left: 2px;\n  border-radius: 9px;\n}\n.script-source .view-source .spotlight.function::before {\n  content: attr(data-marker);\n  display: inline;\n  border: 1px solid currentColor;\n  padding: 2px 2.5px 3px 2.5px;\n  margin-right: 1px;\n  font-size: 9px;\n  border-radius: 9px;\n  vertical-align: top;\n  background: var(--discovery-background-color);\n  color: #f0f173;\n  opacity: .8;\n}\n.script-source .view-source .spotlight.function:not(:has(.spotlight.function:hover)):hover::before {\n  opacity: 1;\n}\n\n/* app/pages/default.css */\n.page-default .flamecharts > .content {\n  margin-bottom: calc(-1 * var(--discovery-page-padding-bottom));\n  margin-right: calc(1px - var(--discovery-page-padding-right));\n  margin-left: calc(1px - var(--discovery-page-padding-left));\n}\n.page-default .flamecharts .view-flamechart {\n  padding: 0;\n  margin: 0;\n}\n.page-default .flamecharts .view-flamechart {\n  --height: calc(100vh - 64px - 9px );\n  min-height: var(--height);\n  max-height: var(--height);\n  height: var(--height);\n}\n.flamecharts {\n  margin-top: 8px;\n}\n.flamecharts-fullpage {\n  visibility: hidden;\n}\n.flamecharts-fullpage .flamecharts {\n  height: 100vh;\n}\n.flamecharts-fullpage .flamecharts > .content {\n  visibility: visible;\n  position: fixed;\n  margin: 0;\n  top: 0px;\n  left: 2px;\n  right: 2px;\n  bottom: 2px;\n  display: flex;\n  flex-direction: column;\n}\n.flamecharts-fullpage .flamecharts .view-flamechart {\n  flex: 1;\n  height: auto;\n  max-height: none;\n}\n.flamecharts .toolbar {\n  display: flex;\n  gap: 0px 8px;\n  margin: 1px 0;\n}\n.flamecharts-fullpage .flamecharts .toolbar {\n  gap: 0px 4px;\n  flex-wrap: wrap;\n  padding-right: calc(var(--discovery-nav-width) + var(--discovery-page-padding-right) + 16px);\n}\n.flamecharts-fullpage .flamechart-fullpage-toggle {\n  display: none;\n  align-self: start;\n  cursor: pointer;\n}\n.page-default .flamechart-fullpage-toggle:hover {\n  background-color: rgba(78, 187, 255, .2);\n}\n.flamecharts-fullpage .flamecharts .toolbar .view-toggle-group {\n  min-height: calc(var(--discovery-nav-height) - 1px);\n}\n.flamecharts .toolbar .filters {\n  flex: 1;\n}\n.flamecharts-fullpage .flamecharts .toolbar .filters {\n  white-space: nowrap;\n  padding: 2px 6px;\n}\n.flamecharts .toolbar .filters .discovery-view-has-tooltip > .view-checkbox__label {\n  padding-right: 18px;\n  margin-right: 12px;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="%23888">%0A  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>%0A  <path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/>%0A</svg>%0A\');\n  background-position: right center;\n  background-size: 14px;\n  background-repeat: no-repeat;\n}\n.flamecharts .view-toggle {\n  font-size: 11px;\n  border-radius: 0;\n}\n.flamecharts-fullpage .flamecharts .view-toggle {\n  align-self: stretch;\n  padding-top: 5px;\n}\n.flamecharts .view-checkbox {\n  --discovery-checkbox-size: 13px;\n  white-space: nowrap;\n}\n.flamecharts .view-checkbox__label {\n  font-size: 12px;\n}\n.page-default .view-page-indicators {\n  margin-bottom: 3px;\n  margin-left: calc(-1 * var(--discovery-page-padding-left));\n  margin-right: calc(-1 * var(--discovery-page-padding-right));\n  padding-left: var(--discovery-page-padding-left);\n  overflow: hidden;\n  overflow-x: auto;\n}\n.page-default .view-page-indicators .view-page-indicator-group.filters .view-page-indicator {\n  background-color: #2c3a4a;\n}\n.page-default .view-page-indicators .view-page-indicator-group.filters .page-indicator-group-tag {\n  width: 18px;\n  position: relative;\n  background-color: #374c64;\n}\n.page-default .view-page-indicators .view-page-indicator-group.filters .page-indicator-group-tag::before {\n  content: "Filtered";\n  position: absolute;\n  width: 66px;\n  right: 0;\n  bottom: 100%;\n  transform: rotate(-90deg);\n  transform-origin: right bottom;\n  text-align: center;\n  font-size: 9px;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  padding-bottom: 2px;\n}\n.page-default .view-page-indicators .runtime .value {\n  text-align: left;\n}\n.page-default .view-page-indicators .runtime:is(.nodejs, .deno, .chromium, .edge, .electron, .unknown) .value::before {\n  content: "";\n  display: inline-block;\n  vertical-align: baseline;\n  height: 1em;\n  aspect-ratio: 1/1;\n  background: center no-repeat;\n  background-size: 100%;\n  margin-right: .5ex;\n  margin-bottom: -.125em;\n}\n.discovery-root-darkmode .page-default .view-page-indicators .runtime .value::before {\n  filter: brightness(.85);\n}\n.page-default .view-page-indicators .runtime:is(.nodejs) .value::before {\n  background-image: var(--runtime-nodejs);\n}\n.page-default .view-page-indicators .runtime:is(.deno) .value::before {\n  background-image: var(--runtime-deno);\n}\n.page-default .view-page-indicators .runtime:is(.edge) .value::before {\n  background-image: var(--runtime-edge);\n  filter: none;\n}\n.page-default .view-page-indicators .runtime:is(.chromium) .value::before {\n  background-image: var(--runtime-chromium);\n}\n.page-default .view-page-indicators .runtime:is(.electron) .value::before {\n  background-image: var(--runtime-electron);\n}\n.page-default .view-page-indicators .runtime:is(.unknown) .value::before {\n  background-image: var(--runtime-unknown);\n}\n.page-default .view-expand.timelines > .header > .header-content {\n  background: var(--discovery-background-color);\n  padding: 0;\n  margin-left: 1px;\n}\n.page-default .view-expand.timelines > .header:hover > .header-content {\n  filter: brightness(1.1);\n}\n.page-default .view-expand.timelines > .header .view-timing-bar-segment {\n  border-left-width: 0;\n  padding-top: 3px;\n  padding-bottom: 5px;\n}\n.page-default .view-expand.timelines > .content {\n  padding: 2px 0 0;\n  margin-left: calc(-1 * var(--discovery-page-padding-left));\n  margin-right: calc(-1 * var(--discovery-page-padding-right));\n}\n.page-default .category-timelines {\n  position: relative;\n  display: grid;\n  grid-template-columns: auto auto 1fr;\n  padding: 15px 0 0;\n  user-select: none;\n}\n.page-default .category-timelines .view-time-ruler {\n  grid-column: 3 / 4;\n  box-sizing: border-box;\n  margin: 0 1px;\n  --overlay-offset-top: -1px;\n  --overlay-offset-bottom: -3px;\n}\n.page-default .category-timelines .view-time-ruler .interval-marker:first-child {\n  margin-left: -1px;\n}\n.page-default .category-timelines-list,\n.page-default .category-timelines-list > .view-list-item {\n  display: contents;\n}\n.page-default .category-timelines-item {\n  color: inherit;\n  display: contents;\n}\n.page-default .category-timelines-item .view-timeline-segments {\n  margin: 0 1px;\n}\n.page-default .category-timelines-item:hover > * {\n  background: rgba(165, 165, 165, .3);\n}\n.page-default .category-timelines-item > .label {\n  font-size: 12px;\n  text-align: right;\n  padding: 0px 4px 0 12px;\n  border-bottom: 1px solid #0004;\n}\n.page-default .category-timelines-item > .label::after {\n  content: "";\n  display: inline-block;\n  vertical-align: middle;\n  width: .75em;\n  aspect-ratio: 1/1;\n  margin-left: 8px;\n  margin-right: -6px;\n  margin-top: -1px;\n  background: var(--color, #888);\n  border-radius: 50%;\n}\n.page-default .category-timelines-item > .total-percent {\n  text-align: right;\n  font-size: 11px;\n  padding: 1px 8px 0 8px;\n  border-bottom: 1px solid #0004;\n  color: #888;\n}\n.page-default .category-timelines-item > .total-percent::after {\n  content: "%";\n  font-size: 8px;\n  opacity: .5;\n  padding-left: 1px;\n}\n.page-default .view-list-item:first-child .category-timelines-item > * {\n  border-top: 1px solid #0004;\n}\n.page-default .hierarchical-components > .header > .header-content {\n  display: flex;\n  flex-direction: row;\n  padding: 0 2px 0 0;\n}\n.page-default .hierarchical-components > .header > .header-content > .view-block:first-child {\n  max-width: calc((100% + var(--discovery-page-padding-left)) / 3 - var(--discovery-page-padding-left) + 2px);\n  box-sizing: border-box;\n  border: none;\n}\n.page-default .hierarchical-components > .header > .header-content > .view-block {\n  flex: 1;\n  padding: 2px 8px;\n  border-left: 1px solid var(--discovery-background-color);\n}\n.page-default .hierarchical-components > .header > .header-content .view-text-numeric {\n  display: inline-block;\n  padding-left: .65ex;\n  color: #9ea867;\n}\n.page-default .hierarchical-components > .content {\n  display: flex;\n  flex-direction: row;\n  gap: 6px;\n  margin-bottom: 5px;\n  margin-left: calc(4px - var(--discovery-page-padding-left));\n  margin-right: calc(4px - var(--discovery-page-padding-right));\n}\n.page-default .hierarchical-components > .content .view-section {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  margin-bottom: 0;\n}\n.page-default .hierarchical-components > .content .view-section > .view-header {\n  display: none;\n}\n.page-default .hierarchical-components > .content .view-section > .view-content-filter {\n  display: contents;\n}\n.page-default .hierarchical-components > .content .view-section > .view-content-filter > .view-input {\n  margin: 3px 0 2px;\n}\n.page-default .hierarchical-components > .content .view-section > .view-content-filter > .view-input input {\n  padding: 4px 6px;\n  border-radius: 0;\n  box-shadow: none !important;\n}\n.page-default .hierarchical-components > .content .view-section > .view-content-filter > .content {\n  overflow: auto;\n  max-height: 418px;\n}\n.page-default .hierarchical-components > .content .view-section .view-table {\n  min-width: 100%;\n}\n.page-default .hierarchical-components > .content .view-section .view-table th {\n  white-space: nowrap;\n}\n.page-default .hierarchical-components > .content .view-section .view-table th:last-child,\n.page-default .hierarchical-components > .content .view-section .view-table .view-table-cell.main {\n  width: 100%;\n}\n.page-default .hierarchical-components > .content .view-section .view-table .view-duration .time {\n  min-width: calc(var(--total-time-digits) * 1ex + 3.5ex);\n}\n.page-default .welcome-page .logo {\n  float: left;\n  margin-right: 1.8ex;\n  margin-top: 5px;\n  font-family:\n    Helvetica Neue,\n    Helvetica,\n    Tahoma,\n    Arial,\n    sans-serif;\n  font-weight: 200;\n  font-size: 13px;\n}\n.page-default .welcome-page .view-page-header__content h1 {\n  position: relative;\n  top: -11px;\n}\n.page-default .welcome-page .view-page-header__content .description {\n  padding-left: 55px;\n  margin-top: -17px;\n  font-size: 12px;\n  color: #aaa;\n}\n.page-default .welcome-page .view-markdown .view-ul {\n  margin-top: 2px;\n}\n.page-default .welcome-page .upload-data {\n  margin: -8px -15px 15px;\n  background-color: #00000014;\n  border: 1px dashed #555;\n  padding: 12px;\n  border-radius: 7px;\n  max-width: 620px;\n}\n.page-default .welcome-page .upload-notes {\n  font-size: 82%;\n  color: #aaa;\n  padding: 10px 0 0 3px;\n}\n.page-default .welcome-page .examples {\n  margin-top: 15px;\n}\n.page-default .welcome-page .examples .view-button {\n  margin-top: .35em;\n  margin-left: 0;\n  margin-right: .8ex;\n}\n.page-default .welcome-page .examples .view-button::before {\n  content: "";\n  display: inline-block;\n  vertical-align: middle;\n  height: 1.3em;\n  aspect-ratio: 1/1;\n  background: center no-repeat;\n  background-size: 100%;\n  margin-right: 7px;\n  margin-left: -.5ex;\n  margin-top: -4px;\n}\n.page-default .welcome-page .examples .view-button.nodejs::before {\n  background-image: var(--runtime-nodejs);\n}\n.page-default .welcome-page .examples .view-button.deno::before {\n  background-image: var(--runtime-deno);\n  filter: brightness(.8);\n  height: 1.4em;\n  margin-top: -5px;\n  margin-bottom: -2px;\n}\n.page-default .welcome-page .examples .view-button.chromium::before {\n  background-image: var(--runtime-chromium);\n  filter: brightness(.85);\n}\n.page-default .welcome-page .examples .view-button.edge::before {\n  background-image: var(--runtime-edge);\n  filter: brightness(.95);\n}\n\n/* app/pages/function.css */\n.page-function .view-page-header__prelude .function-loc {\n  padding: 3px 6px;\n  color: #aaa;\n}\n.page-function .view-page-header__content .view-source {\n  margin: 8px 0 1px;\n}\n.page-function .view-page-header__content .view-source__content {\n  padding-top: 11px;\n  padding-bottom: 12px;\n}\n.page-function .view-page-header__content .view-source__source {\n  font-size: 16px;\n}\n\n/* app/views/misc/mode-regexp.css */\n.view-source__source .token.quantifier {\n  color: var(--discovery-fmt-flag-color);\n}\n.view-source__source .token.anchor {\n  color: var(--discovery-fmt-variable-color);\n}\n.view-source__source .token.generic-character-type {\n  color: var(--discovery-fmt-property-color);\n}\n.view-source__source .token.character-class {\n  color: var(--discovery-fmt-keyword-color);\n}\n.view-source__source .token.generic-character-type {\n  color: var(--discovery-fmt-atom-color);\n}\n.view-source__source .token.alternation,\n.view-source__source .token.start-group,\n.view-source__source .token.end-group {\n  color: var(--discovery-fmt-string-color);\n}\n\n/* app/views/duration.css */\n.view-duration {\n  max-width: 18ex;\n  height: 19.5px;\n  display: flex;\n  text-align: right;\n  align-items: baseline;\n  gap: .65ex;\n}\n.view-tree-leaf .view-duration {\n  display: inline-flex;\n}\n.view-duration .num-delim {\n  padding-left: .12em;\n}\n.view-duration > .time {\n  flex: 1;\n}\n.view-duration > .time::after {\n  content: "ms";\n  color: #787878;\n  font-size: 90%;\n  padding-left: 1px;\n}\n.view-duration > .fraction {\n  width: 3em;\n  opacity: .65;\n  font-size: 83%;\n}\n\n/* app/views/flamechart/index.css */\n.flamechart {\n  --transition-duration: 250ms;\n  --transition-delay: 250ms;\n  --transition: var(--transition-duration) ease-in-out;\n  --frame-height: 17px;\n  position: relative;\n  height: calc(max(var(--max-depth) + 1, 10) * var(--frame-height) + 2px);\n  contain: strict;\n}\n.flamechart .frames-group {\n  opacity: 1;\n  transition: var(--transition);\n  transition-delay: var(--transition-delay);\n  transition-property: opacity;\n  contain: layout size style;\n}\n.flamechart.first-enter .frames-group {\n  --transition-duration: 125ms;\n  --transition-delay: 0ms;\n}\n.flamechart .frames-group_init-enter-state {\n  opacity: 0;\n  visibility: hidden;\n  pointer-events: none;\n}\n.flamechart .frame {\n  --fill-opacity: .4;\n  position: absolute;\n  overflow: hidden;\n  cursor: pointer;\n  left: calc(100% * var(--x0));\n  right: calc(100% - 100% * var(--x1));\n  top: calc(var(--depth) * var(--frame-height));\n  height: calc(var(--frame-height) - 1px);\n  border: solid transparent;\n  border-width: 0 1px 1px 0;\n  background-clip: content-box;\n  background-color: rgba(var(--color, 128, 128, 128), var(--fill-opacity));\n  background-color: color-mix(in srgb, rgb(var(--color, 128, 128, 128)) calc(var(--fill-opacity)*100%), var(--discovery-background-color));\n  transition: var(--transition);\n  transition-property:\n    left,\n    right,\n    opacity;\n}\n.flamechart .frame:hover {\n  --fill-opacity: .5;\n}\n.flamechart .frame.fade {\n  opacity: .65;\n}\n.flamechart .frame.similar {\n  transition-property:\n    left,\n    right,\n    opacity,\n    color;\n  transition-duration:\n    var(--transition-duration),\n    var(--transition-duration),\n    var(--transition-duration),\n    .15s;\n  color: black;\n}\n.flamechart .frame::before {\n  content: "";\n  position: absolute;\n  inset: 0;\n  z-index: 0;\n  opacity: 0;\n  background-color: #d6bb2d;\n  pointer-events: none;\n}\n.flamechart .frame.similar::before {\n  opacity: 1;\n  transition: .15s ease-in-out;\n  transition-property: opacity;\n}\n.flamechart .frame.zoomed {\n  box-shadow: 0 0 0 1.5px #d6bb2d inset;\n}\n.flamechart .frame.zoomed::before {\n  inset: 2px;\n}\n.flamechart .frame-label {\n  position: relative;\n  pointer-events: none;\n  font-size: 10px;\n  line-height: 14px;\n  padding: 0 3px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  opacity: calc(max(var(--x1) - var(--x0) - 20 * var(--width-scale), 0) * 100000);\n  transition: var(--transition);\n  transition-property: opacity;\n}\n\n/* app/views/flamechart.css */\n.view-flamechart {\n  position: relative;\n  margin: 4px 0;\n  padding: 4px 0;\n  background-color: rgba(136, 136, 136, .05);\n  min-height: 150px;\n  max-height: 50vh;\n  max-height: min(40vh, 300px);\n  overflow: clip;\n  contain: strict;\n}\n.view-flamechart__content {\n  box-sizing: border-box;\n  height: 100%;\n  padding-bottom: var(--details-height);\n  overflow: hidden;\n  overflow-y: auto;\n  contain: strict;\n  will-change: padding;\n}\n.view-flamechart.lock-scrolling.disable-scrolling .view-flamechart__content {\n  overflow: hidden;\n}\n.view-flamechart .flamechart .root-content {\n  display: flex;\n  gap: 8px;\n}\n.view-flamechart .flamechart .root-content > .view-duration::before {\n  content: "\\203a";\n  padding-right: 2px;\n  color: #888;\n}\n.view-flamechart .flamechart .root-content .fraction {\n  font-size: inherit;\n  width: auto;\n}\n.view-flamechart .flamechart .root-content .zoom-timings {\n  display: inline-flex;\n}\n.view-flamechart .flamechart .root-content .zoom-timings::before {\n  content: "\\203a";\n  color: #888;\n}\n.view-flamechart .flamechart .root-content .zoom-timings .view-duration {\n  margin-left: 1ex;\n}\n.view-flamechart .flamechart .root-content .zoom-timings .view-duration::before {\n  content: "zoom:";\n  color: #888;\n}\n.view-flamechart__details {\n  position: sticky;\n  bottom: 0;\n  box-sizing: border-box;\n  max-height: 0;\n  width: 100%;\n  overflow: hidden;\n  overflow-y: auto;\n  padding: 0 12px;\n  margin-top: 51px;\n  display: flex;\n  flex-direction: row;\n  gap: 0 20px;\n  background: rgba(255, 255, 255, .75);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n  opacity: 0;\n  transition: .2s ease-in-out;\n  transition-property:\n    padding,\n    max-height,\n    opacity;\n  font-size: 11px;\n}\n.view-flamechart__details.has-details {\n  max-height: 80px;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  opacity: 1;\n}\n.discovery-root-darkmode .view-flamechart__details {\n  background: rgba(36, 36, 36, .8);\n}\n.view-flamechart__details .view-badge {\n  display: inline-block;\n  margin: 0 0 3px -5px;\n  padding-top: 0;\n  padding-bottom: 1px;\n  line-height: 19px;\n}\n.view-flamechart__details .view-duration {\n  align-items: baseline;\n}\n.view-flamechart__details .view-duration.total::before {\n  content: "Total time: ";\n  white-space: pre;\n  font-size: 80%;\n  color: #888;\n}\n.view-flamechart__details .view-duration.self::before {\n  content: "Self time: ";\n  white-space: pre;\n  font-size: 80%;\n  color: #888;\n}\n.view-flamechart__details .view-duration > .time {\n  flex: 0;\n}\n.view-flamechart__details .view-duration > .fraction {\n  width: auto;\n}\n.view-flamechart:not(.fully-visible.lock-scrolling.disable-scrolling) .view-flamechart__enable-scrolling-button {\n  opacity: 0;\n  pointer-events: none;\n}\n.view-flamechart.fully-visible .view-flamechart__enable-scrolling-button {\n  position: absolute;\n  bottom: calc(var(--details-height, 0px) + 4px);\n  z-index: 10;\n  background: var(--discovery-background-color);\n  left: 50%;\n  transform: translate(-50%);\n  padding: 4px 10px;\n  border-radius: 10px;\n  font-size: 11px;\n  opacity: .75;\n  cursor: pointer;\n  transition: opacity .2s ease-in-out;\n  contain: style layout paint;\n}\n.view-flamechart.fully-visible .view-flamechart__enable-scrolling-button:hover {\n  opacity: .95;\n}\n.discovery-root-darkmode .flamechart .frame:hover {\n  --fill-opacity: .3;\n}\n.flamechart-tooltip {\n  padding: 5px 10px;\n  min-width: 250px;\n  border: none;\n  border-radius: 3px;\n  font-size: 12px;\n  background: rgba(255, 255, 255, .75);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n}\n.discovery-root-darkmode .flamechart-tooltip {\n  background: rgba(36, 36, 36, .8);\n}\n.flamechart-tooltip .view-badge {\n  display: inline-block;\n  margin: 0 0 3px -5px;\n  padding-top: 0;\n  padding-bottom: 1px;\n  line-height: 19px;\n}\n.flamechart-tooltip .view-duration {\n  align-items: baseline;\n}\n.flamechart-tooltip .view-duration.total::before {\n  content: "Total time: ";\n  white-space: pre;\n  font-size: 80%;\n  color: #888;\n}\n.flamechart-tooltip .view-duration.self::before {\n  content: "Self time: ";\n  white-space: pre;\n  font-size: 80%;\n  color: #888;\n}\n.flamechart-tooltip .view-duration > .time {\n  flex: 0;\n}\n.flamechart-tooltip .view-duration > .fraction {\n  width: auto;\n}\n\n/* app/views/flamechart-expand.css */\n.flamechart-expand > .content {\n  margin-left: calc(1px - var(--discovery-page-padding-left));\n  margin-right: calc(1px - var(--discovery-page-padding-right));\n  margin-bottom: calc(1px - var(--discovery-page-padding-bottom));\n}\n.flamechart-expand > .content > .toolbar {\n  display: flex;\n  gap: 0px 8px;\n  margin: 1px 0 1px -1px;\n}\n.flamechart-expand > .content > .toolbar .view-toggle {\n  font-size: 11px;\n  border-radius: 0;\n}\n.flamechart-expand > .content > .toolbar .view-toggle:not(.checked) {\n  display: none;\n}\n.flamechart-expand > .content > .view-flamechart {\n  margin: 1px 0 0;\n  padding: 0;\n  --height: calc(100vh - 114px - 26px);\n  min-height: var(--height);\n  max-height: var(--height);\n  height: var(--height);\n}\n\n/* app/views/loc-badge.css */\n.view-badge.function-loc {\n  padding-left: 2px;\n  padding-right: 4px;\n  padding-top: 4px;\n  padding-bottom: 3.5px;\n}\n.view-badge.function-loc .delim {\n  color: #888;\n  padding: 0 1px;\n}\n.view-badge.module + .view-badge.function-loc {\n  margin-left: 0;\n  border-radius: 0 3px 3px 0;\n}\n.view-badge.module:has(+ .view-badge.function-loc) {\n  border-radius: 3px 0 0 3px;\n  margin-right: 1px;\n}\n\n/* app/views/page-indicator.css */\n.view-page-indicators {\n  display: flex;\n  gap: 1px 3px;\n}\n.view-page-indicator-group {\n  display: flex;\n  gap: 1px;\n  flex-shrink: 0;\n}\n.view-page-indicator {\n  flex-shrink: 0;\n  display: grid;\n  grid-template: "title annotation hint" "value value value";\n  grid-template-columns: auto 1fr auto;\n  gap: 0 5px;\n  padding: 4px 12px;\n  min-width: 100px;\n  background: #9b9b9b26;\n}\n.view-page-indicator > .title {\n  grid-area: title;\n  display: block;\n  margin-top: 2px;\n  margin-bottom: -2px;\n  color: #888;\n  font-size: 11px;\n}\n.view-page-indicator > .value {\n  grid-area: value;\n  display: block;\n  font-family:\n    Helvetica Neue,\n    Helvetica,\n    Tahoma,\n    Arial,\n    sans-serif;\n  font-size: 180%;\n  font-weight: 200;\n  text-align: right;\n  white-space: nowrap;\n}\n.view-page-indicator > .value .unit {\n  font-size: 65%;\n  color: #888;\n  padding-left: .25ex;\n}\n.view-page-indicator > .hint {\n  grid-area: hint;\n  display: inline-block;\n  width: 24px;\n  height: 29px;\n  mask: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">%0A    <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>%0A    <path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286m1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94"/>%0A</svg>%0A\');\n  mask-repeat: no-repeat;\n  mask-position: center;\n  mask-size: 14px;\n  background-color: #666;\n  margin-left: -6px;\n  margin-right: -12px;\n  margin-top: -4px;\n  margin-bottom: -16px;\n}\n.view-page-indicator > .hint:hover {\n  background-color: #aaa;\n}\n.view-page-indicator > .annotation {\n  grid-area: annotation;\n  display: block;\n  height: 22px;\n  margin-top: -2px;\n  margin-bottom: -5px;\n}\n\n/* app/views/page-indicator-timings.css */\n.view-page-indicator-timings .annotation {\n  min-width: 48px;\n}\n.view-page-indicator-timings .annotation .view-badge {\n  background: #6d5135;\n  font-size: 11px;\n  text-transform: capitalize;\n  margin: 0;\n  padding-top: 2px;\n}\n.view-page-indicator-timings .view-text-with-unit {\n  display: block;\n}\n.view-page-indicator-timings .view-text-with-unit + .view-text-with-unit {\n  visibility: hidden;\n  overflow: hidden;\n  overflow: clip;\n  height: 0;\n}\n\n/* app/views/subject-badges.css */\n.subject-badge {\n  --badge-font-size: inherit;\n  --badge-padding-left: 22px;\n  --badge-icon-top-bottom: 3px;\n  --badge-icon-left: 4px;\n  font-size: var(--badge-font-size);\n}\n.subject-badge[data-cdn] {\n  --badge-padding-left: 38px;\n}\n.view-page-header__prelude .subject-badge {\n  --badge-font-size: 85%;\n  --badge-padding-left: 27px;\n  --badge-icon-top-bottom: 4px;\n  --badge-icon-left: 5px;\n}\n.view-page-header__prelude .subject-badge[data-cdn] {\n  --badge-padding-left: 47px;\n}\n.subject-badge:is(.subject-badge_type__script, .subject-badge_type__node, .subject-badge_type__deno, .subject-badge_type__electron, .subject-badge_type__npm, .subject-badge_type__github, .subject-badge_type__jsr, .subject-badge_type__denoland, .subject-badge_type__chrome-extension, .subject-badge_type__wasm) .prefix {\n  padding-left: var(--badge-padding-left);\n  margin-left: calc(-1 * var(--badge-padding-left));\n}\n.subject-badge .prefix {\n  background-color: #8080801f;\n}\n.subject-badge_type__script,\n.subject-badge_type__node,\n.subject-badge_type__deno,\n.subject-badge_type__electron,\n.subject-badge_type__npm,\n.subject-badge_type__github,\n.subject-badge_type__jsr,\n.subject-badge_type__denoland,\n.subject-badge_type__chrome-extension,\n.subject-badge_type__wasm {\n  padding-left: var(--badge-padding-left) !important;\n  position: relative;\n}\n.subject-badge_type__script::before,\n.subject-badge_type__node::before,\n.subject-badge_type__deno::before,\n.subject-badge_type__electron::before,\n.subject-badge_type__npm::before,\n.subject-badge_type__github::before,\n.subject-badge_type__jsr::before,\n.subject-badge_type__denoland::before,\n.subject-badge_type__chrome-extension::before,\n.subject-badge_type__wasm::before {\n  content: "";\n  position: absolute;\n  top: var(--badge-icon-top-bottom);\n  bottom: var(--badge-icon-top-bottom);\n  left: var(--badge-icon-left);\n  aspect-ratio: 1 / 1;\n  background-repeat: no-repeat;\n  background-position: left center, right center;\n  background-size: contain;\n  background-image: var(--icon), var(--cdn, none);\n}\n.subject-badge[data-cdn]::before {\n  padding-right: 4px;\n  aspect-ratio: 2 / 1;\n}\n.subject-badge[data-cdn=esmsh]::before {\n  --cdn: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="%23ccc" stroke-width="1.8" stroke-linecap="round">%0A  <path d="M11.4286 2.3158H5.74576C3.41404 2.3158 1.52381 4.0124 1.52381 6.10527C1.52381 8.19814 3.41404 9.89474 5.74576 9.89474H10.6667" />%0A  <path d="M5.33334 6.10526H10.2542C12.586 6.10526 14.4762 7.80187 14.4762 9.89474C14.4762 11.9876 12.586 13.6842 10.2542 13.6842H4.84034" />%0A</svg>%0A\');\n}\n.subject-badge[data-cdn=jsdelivr]::before {\n  --cdn: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 34 34">%0A  <path fill="%23bd483b" d="m16.8.3-3 11v11.2l3 11.2L20 22.5V11.4z" />%0A  <path fill="%23e64e3d" stroke="%23000" stroke-width="1.1" d="M16.8.3 1.4 6l2.2 20.5 13.2 7.3" />%0A  <path fill="%23bd483b" stroke="%23000" stroke-width="1.1" d="m16.8 33.7 13.3-7.4 2.5-20.5L16.8.3" />%0A  <path fill="%23fec82f" d="M14 25a9.4 9.4 0 0 1-4-2.3 9.3 9.3 0 0 1-2.2-3.9l.8.7a8.6 8.6 0 0 0 1.7 1l.6.1h.1a1.7 1.7 0 0 0 1.4 1.6c.3 1.1.8 2.1 1.6 2.9zm.6-13.2c0 .3 0 .6.2.9a14.5 14.5 0 0 0-2.5 6.1c-.5.1-.8.4-1 .8h-.1a7.2 7.2 0 0 1-2.8-1.7 6.8 6.8 0 0 1-.4-.4l-.1-.2h-.1V17h-.1a4 4 0 0 1-.2-.3A9.3 9.3 0 0 1 9.7 10 9.4 9.4 0 0 1 14 7.2a11.4 11.4 0 0 0 1 3.5c-.2.3-.4.7-.4 1zm-1 8.7a.9.9 0 0 1-.3.7.9.9 0 0 1-1 0 1 1 0 0 1-.4-.3.9.9 0 0 1-.1-.4.9.9 0 0 1 .4-.8.9.9 0 0 1 1.3.3.9.9 0 0 1 .1.5zm3.6-8.7a.9.9 0 0 1-.9.9h-.1a.9.9 0 0 1 .1-1.8 1 1 0 0 1 1 .9z" />%0A  <path fill="%23df9c26" d="M26.2 16.1c0 1-.1 1.8-.4 2.7a12.8 12.8 0 0 1-2.4-1 1.7 1.7 0 0 0 0-1 15 15 0 0 0 2.4-3.2 9.4 9.4 0 0 1 .4 2.5zm-.9-3.9a11.3 11.3 0 0 1-.2.4 13.8 13.8 0 0 1-2.5 3.4 1.7 1.7 0 0 0-1.9.1 16.8 16.8 0 0 1-1.4-1.3 16.7 16.7 0 0 1-1.7-2 1.7 1.7 0 0 0 .2-1.9 16 16 0 0 1 3.9-2.8 9.4 9.4 0 0 1 3.6 4.1zm-2.7 5.3a.9.9 0 0 1-1.8 0 1 1 0 0 1 1.2-.9 1 1 0 0 1 .6.9zm.3 1.3a1.7 1.7 0 0 1-2.1.1h-.1a13.7 13.7 0 0 1-3.9 1.8v4.8a9.4 9.4 0 0 0 8.7-5.7 14 14 0 0 1-2.6-1z" />%0A  <path fill="%23fec82f" d="M16.8 20.7a11.7 11.7 0 0 1-2.4.4h-.1c-.1.4-.5.7-.8.9.2 1 .7 1.7 1.3 2.3a5 5 0 0 0 1.9 1.2h.1v-4.8z" />%0A  <path fill="%23df9c26" d="m20 17.5.1-.5a18 18 0 0 1-3.3-3.4v6a12.9 12.9 0 0 0 3.3-1.5 1.7 1.7 0 0 1 0-.6z" />%0A  <path fill="%23fec82f" d="m16.8 13.6-.1-.1a1.7 1.7 0 0 1-1-.1 13.4 13.4 0 0 0-2.4 5.5c.5.2.9.6 1 1 .9 0 1.7 0 2.5-.3v-6z" />%0A  <path fill="%23df9c26" d="M16.8 6.8v3.4h.2a17.2 17.2 0 0 1 3.5-2.7 9.3 9.3 0 0 0-3.7-.7z" />%0A  <path fill="%23fec82f" d="m16.8 6.8-1.8.1.1.7c.2.8.5 1.7.9 2.5a1.7 1.7 0 0 1 .8 0V6.9z" />%0A</svg>%0A\');\n}\n.subject-badge[data-cdn=jspm]::before {\n  --cdn: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid" viewBox="-21 0 298 298">%0A  <path fill="%23FEEA5F" stroke="%23222" stroke-width="15" d="m210.741 74.865-82.858 47.877L44.959 74.88l82.915-47.886z" />%0A  <path fill="%23E0CC41" stroke="%23222" stroke-width="15" d="m104.25 258.24-82.239-47.465v-95.653l82.239 47.447z" />%0A  <path fill="%23EFDB50" stroke="%23222" stroke-width="15" d="m150.051 161.649 84.853-48.988v99.186l-84.853 48.971z" />%0A  <path fill="%23C3C2C2" d="m50.435 74.879 77.446 44.7 77.384-44.714-77.393-44.708-77.437 44.722ZM127.658 0l128.33 74.699-61.239 48.043-67.764 25.904-63.565-20.762L0 74.69 127.658 0Z" />%0A  <path fill="%23B3B3B3" d="m154.24 253.505 76.476-44.137v-89.394l-76.477 44.152v89.379Zm-27.311-104.859 129.059-73.778v149.337l-129.06 73.707-6.546-73.707 6.547-75.559Z" />%0A  <path fill="%23A5A5A4" d="m101.559 164.147-76.857-44.342v89.393l76.857 44.358v-89.41ZM0 74.867l126.985 73.78-.056 149.264L0 224.77V74.868Z" />%0A</svg>%0A\');\n}\n.subject-badge[data-cdn=unpkg]::before {\n  --cdn: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">%0A    <polygon fill="white" stroke="black" stroke-width="20" points="0 256 0 0 256 0 256 256" />%0A    <path fill="black" d="M 53.829 101.046 C 53.829 160.6 54.205 167.27 58.432 179.575 C 67.262 205.219 86.518 218.37 118.174 220.531 C 130.48 221.282 146.355 220.343 155.091 218.182 C 158.566 217.431 165.236 214.894 169.838 212.64 C 186.841 204.468 196.516 190.378 201.025 167.27 C 202.152 161.446 202.528 148.671 202.903 102.455 L 203.373 44.967 L 158.19 44.967 L 157.909 102.455 C 157.627 159.943 157.627 160.037 155.466 165.297 C 152.93 171.591 146.261 178.354 140.625 180.327 C 135.834 182.017 120.241 182.017 115.45 180.327 C 110.284 178.542 104.178 172.624 101.83 167.176 C 98.448 159.191 97.978 151.395 97.978 97.288 L 97.978 44.967 L 53.829 44.967 L 53.829 101.046 Z" style=""/>%0A</svg>%0A\');\n}\n.subject-badge[data-cdn=skypack]::before {\n  --cdn: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 26">%0A    <path fill="%23fff" d="M17.387 12.213L10.95 9l6.438-3.212c.3-.15.487-.45.487-.788a.875.875 0 00-.488-.788l-8-4a.874.874 0 00-.787 0l-8 4c-.3.15-.487.45-.487.788v8c0 .3.162.588.412.75l.075.037L7.038 17 .6 20.212c-.3.15-.487.45-.487.788 0 .337.187.637.487.788l8 4a.874.874 0 00.388.087.874.874 0 00.387-.087l8-4c.3-.15.488-.45.488-.788v-8a.842.842 0 00-.476-.787zM9 1.975L15.037 5 9 8.025 2.963 5 9 1.975zM1.875 6.413L7.038 9l-5.163 2.588V6.413zM2.963 13L9 9.975 15.037 13 9 16.025 2.963 13zm5.162 5.413v5.162l-5.162-2.587 5.162-2.575zm8 2.05l-6.25 3.124V17.55l6.25-3.125v6.037z"/>%0A</svg>%0A\');\n}\n.subject-badge_type__script::before {\n  filter: brightness(.85);\n  --icon: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 630 630">%0A  <rect stroke="black" stroke-width="40" width="630" height="630" fill="%23f7df1e" />%0A  <path d="m423.2 492.19c12.69 20.72 29.2 35.95 58.4 35.95 24.53 0 40.2-12.26 40.2-29.2 0-20.3-16.1-27.49-43.1-39.3l-14.8-6.35c-42.72-18.2-71.1-41-71.1-89.2 0-44.4 33.83-78.2 86.7-78.2 37.64 0 64.7 13.1 84.2 47.4l-46.1 29.6c-10.15-18.2-21.1-25.37-38.1-25.37-17.34 0-28.33 11-28.33 25.37 0 17.76 11 24.95 36.4 35.95l14.8 6.34c50.3 21.57 78.7 43.56 78.7 93 0 53.3-41.87 82.5-98.1 82.5-54.98 0-90.5-26.2-107.88-60.54zm-209.13 5.13c9.3 16.5 17.76 30.45 38.1 30.45 19.45 0 31.72-7.61 31.72-37.2v-201.3h59.2v202.1c0 61.3-35.94 89.2-88.4 89.2-47.4 0-74.85-24.53-88.81-54.075z" />%0A</svg>%0A\');\n}\n.subject-badge_type__node::before {\n  --icon: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAMAAAAKE/YAAAAC91BMVEVHcExWnUlanU1anE5anE1WmExBiD9Ulkxbp0loplZEi0FpqFZDikBnqlNCij9ppVlEi0FqrVRnoFpCiT9rrVZtuE9BiT5knVhsplw/iD1rtk9Vl0xnoFtsu0xCiT9qolw/hz1uuk9knVhAiD4/hz1tpV5al1JsvEo/hz11sF9mnlpvuk8/hz1QkUpoo1pqvkc/hz1qvkdhmld2sl9vulBooFtarUU+hz1qvkdVlU5WmkxYpEhXn0pZqUZNj0harEVarUV1tVs+hj1ro15EiUFSkUxJjEVsvUparUVjm1g+hz1zq2JpoVxzt1dXllBsvUo+hj1tpF93smFzq2Njm1hMkEhon1tsvkhCiUBro14+hj1Ymk09hT0+hj0/hz5Ahz5BiD9CiEBDiUFEiUFEikJFikJDjD9Gi0NHjERIjEVJjEVJjEZJjUZHkEBLjkdMj0hNj0hNj0lPkElPkEpLlUJQkUpRkUxRkktTkk1Sk0xUk01Ql0ZVk09VlE5Pm0JWlU9Wl01XllBalVJZllFWmU1Wmkxal1JdllRTnkZXm0xbmFNXnExXnUtfl1VdmVRXnktXn0phmFdemlVXoEpUo0RfmlZimVhYoUpgm1dYokljmlhYo0lkmllYpEhinFhkm1lYpUhfoFJco0tjnVhlnFpknVlZpkhmnVplnlpnnVpZqEdZqUZnnltmn1tZqkZnn1tcqUZon1thpU9noFtnoFxarEVpoFxfqUpooVxqoFxpol1qol1rol1qo11ro11ro15frkZso15spF5spF9irkpnqlNtpV9upmBrqVpvpmBvp2Bwp2FksklwqGFxqGFurFpxqWJyqWJyqmJzqmN0q2Nnt0lstFJ1rGRwsVhzr151rWR2rWR2rmN2r2NpvEd3sGJ3sWJ4sWJ4smJtvUtsvklrv0dyuVR5s2FxulJwu1BvvE54tGB2tltwu1FuvUx3tV51t1l2tlx0uFdsv0h1t1pzuVV0uFhyulR5tGFxu1J4tV93tl12t1vVT6hLAAAAXHRSTlMAAgUJDxccHBwkKS40OD5CSEtVV1xpamp2en6ChYeKlZWboKCprq6utLq8vsHDx8fOztPU1NfY2dnf39/f39/f39/g4OHh4ePk5+np6+vt7/Ly8vP09PX3+Pn6/hJL/5gAAAvvSURBVHja1d15VFNXHgdwZBMX3LVuBetW9zq1juMszlTbOiqdamt1FG4SIkuCEIxgjGyiFYFBxLQaNK1GLYpWKqUqqOA4FJCOonZUXNpKO9aodabVmU4Xlz/mZSEvyXv3vveS937Q398ezufc8333e+Uc7vWTZAL7jJhz4cKMkb0C/X4u4999xGtXrly6dLFy/sju/n4/i+kUPuezT23oMyWmWeGdOvi1+wnqP+nzzx3oizVGk+nZJ4L82vcE9Bp9/TqNPldKqd8Z0yvAr/2Of+iIV7/4wgV9oc5knflDQ9tttDsNnPPPL93R5yqMFPod86zBnfza4wT2nXTjhif6H41mu9r87BPtb/sL6Dn69m0W9CfHjVa12WyeP6Zn+4p2hy5PvfrTT6zo0yVGk1VtZQ/t0o62v5CBzz/8Fwb9SY3RHhBqSmYN7ujXPiawz6R7D/HoM2Uu6pL2EW3/7qPvPSKhz9WZbAGxo0vmj2nzZqfC/PK//0NGn60wuqpLZoW3bbSD+j//v8ec6EazS0CoKZ3cv+2aPaDP2B/u80CfOWr0UO+f0EaHVv/Qp+//wA/dWOIekNLS0gUj2iDaHTo9+fL3/+WJPl1jYqj3R4RDN3tQ3+dufc8f3VjmDAitLpsMemgN6Dn21o9C0H+vNTnVNLqsDO7Q2iH0qVfu3BGGbjxkdATEXb1gaCjI9tfpyZnfPBCMrjOzBYSaCIBDa2Df577+2gt041EjRl0xWeJm9+85duHdu16hT5U6AsJAVyyQ8tBKdfYr3971Fl1twqorIiQ7tIYMnPnVt96jT5VhA1JRWTljcIif+BPY55mvbvqEPmnyVLeirerKCX3EjrZ/96cX3rzpG7qu3OgZEDe1yM1uDbPlO5/RJ81k9bGI8C5+Yk3QwF9ZLCKgP6o0EmJtVR8T69Aa0OeZmxZx0B+VGNzVNNqhrl40QYRmpw6gCy0WsdDHjRwBOVZdvWBEqL+vB9CZFot46JP7DISAONQ1vjV7YF8qzKKiq0181DXeN3sA1dkWkdEnyw02NTYglTZ0zSKq2b08gFosYqP/Wm02cMe6hpp5XjR7iDXMEqBPHDbyCQg1tUKbPbDvLywWadDVJQYudbVNXVtbK6TZ/XtS25xk6KOOb5Eca7t6EdXs/DvbIh36eKmBZ6xrqYng9euoEGtnS4qmlppvrK0zo38Qn86WGl1mMBDrnI61bbiaPSgsssUiOfqo2cA31rapmxceQjCP1OmqANDlRrzagXZX143ERsR/kF6ny26WHn3YbBAU67qjiWG4z7HrizpqqgDQ5SZKLSAga9Dsrhj0IL1eZ11q6dGH9xiE7Hvl8QiFYWpwvF5vZe8GQB8yCQlIJkJoXCD7ZzhVb1NnNgGgSw2s6v0eaht6TwyFnsL+KXacqrdPcYv0aCrVfGNdsxJRMz0Yg85Is6HTmgDQ+wx8Y70lmozOsLOLWqRHv7+jkF+sK5cjDrSdnVYPgN5nKOSMtRW9UU5GZ2Y42Pkt0qPf30EMSKu6XIM40Jmt7Crp0fv2bS00cNf5ehknupUd2QyANhu4Y12qRpxoJ7sKAL2HWmquU2om4kY72dnNAOgdhkKOWO+I5YGm2bsB0O9uLeRQ6xEnOttFvboJAL1jSyEx1luUPNDZ2S5L3QKNZix1WQrihabZq+sB0FuJ6o0KnmiaXdQCg8YGpFSD+KJpdj0cmk1dtl7OG02zC5oB0G8W4gJiTkQ80L+2e2l2FQR6I069WiYATbMjmyHQueyx3hGPhKBpdRUE+i+5rLFOQ/zQ6zzVkc0QaErNDMiWWL7odZ7s3S0A6PW5LGod4o1msJsg0GuZsS5U8kXnrLON+1IDoN+wqt3/d66Vyfiic5jsegj0G54BWauUUcMTzWQXtQCg13gExLhMLpfb2Nzo/BwWdj0E2kO9VimXO9jc6HwWdlEzAHr1GteAGDQKalrZnGgr29NdBYHOXOuizlBGK1zZRHRBPhu7oBkCvTrXGZDCpdHUuLFJ6AJWdhUEOm2NU61XKpUMNgHNys5vhkCntQYkN0Gp9GTj0b/dUMDO3t0CgF6VkWtX65YsWcJk49Eb2Nn5TRDoVfalXquOiWGwiWgMe3cLAHql3qZOiaWGycaii4o2YNxNEOgV1oCsVcfHsrFfwKNx7OIWCLSOWmptPDVMNg4dQqGx7HoI9HJ9boZaFc/KxqI3FWHZm5oh0MsztCpqWNgE9CYsO6fqJgB6mXapWs3OxqNtw8rOSW36DgCdnKhWs7EJ6Lda1Ux2ujwLYqWTNQlqdjYeTQ37auerohR/A0EnLk1IYGGT0Dh2ugxFpbbAoJe6sFVONhZdXIxh58QhhGQfgKATWdhkNIadSpmppW6GQKtZ2Vj0b4qL2dnp9l9uy/aCoK1qJhuL3raNlb0hCdkmKqkZAq1K0LCwX8Kj2dib0p3/Jd4MglYlaphsIprJ3hCHWieuCQIdr9ZoPNgE9Ntvs7FTET15IOjYRA2DTUCzsPNcfxWoqIdAx8QnJ7uzyWgm23WhUVQWCHpJQrInG4vevp3JTpcj11FUQaCVsZpkDzYBzWC/lUSD7Q0Dgo5WaZe5sUloT/Y2x3ZHj+wDEHS0RuvOxqJ37vRkb4qjuc6GgUArYrVaVzYJ7clORczZDoKWJ2rd2AS0BztPwYJOugyBlim1WppNQO/d687eloTYJg8ELVNrXdnTOmLR7uws96+QLnMINFIsS3Gy8ejf7d3rxsYsNIrK+wYCjeJTUmg2Fv3ee67snYyvkC7zBxBouSaFZhPQruy8OBw6Kv3OjwBotCTFNlxomk1YaITkVQ8g0LKlKfbhQNNs9+3Os8wvQ6BRtDbFMSQ0zd6ehAgj2w2CRmpdq5qApsd9u2OW+WUQtFyr03GgDxxwmjfHIfIUg6BRrE5nZ7+IRzvZqYhj4i6DoGXJOusQ0a3szQrENXm3INBIqbMPFn3w4AGHOwlxTlwDCBolcqId7DzCV0g3zC0QtCJFT0L//uBBO3sncaGdP60BBI1Uer2egD5yxM7OImLphrkFgpZr9dQQ0DY2x3ZH/7QPQdDUtkdG29ic2x3dMCBoWTI3mnu7o8v8PgQaKXVc6ANJiPckXQVBo8SMNBz6DzZ0lgzxnyIYtEKXMZWEPuD2FXI3zGMINFKlEdFZSNDk3AdBy7RYNP+vkP5GGkDQKAaT6aBfUmjP7Y67zO+DoNG0IPY/DJ5ALbTbv+VX5o9B0Jg/DPYbeOQgc7vjLvOrjyDQYX7sE/rHLCR8ZB9CoGd3w93sMSjOC3SU5ioAOswfe4HDcOTN7JIePZxwx0fwkLleoFVXH0mLnjskmHgpSe9xi4WrCyRd6cXjegdwXdnWb4pgdNx5CdFTBgTxuGin85DZQtU596RCzx7SuQO/K426DRcY7egGadCLR3Xz5395VO+Ji4WV+b2H4qMXT+wt7F604AHThajlDeKjpw9g7hnc0Z4rYKmTr4mMnjusawdvrp7rMYp/RmS7REX/eVSPAG8v+es3kbc68Zp46NiJ/Xy54zQ4jHe0d4mGfiEs2McrTbsO4xnt+PPioF8f1tX3e3t5N3ukGOjk8b19vyJUQLMrP77tM3paP3EuY7Vtf2F8mn3Vlz6iXwrr7HsyBDa7osEn9Osju4l5wbB1ArmjHbXimg/o8b3FvsrZ3uxc0ZbvuuEteuogiV564Ty0RmmueYf+01BRw+wRbY5ml+3y6u/GR/YQZ5vzstlV54WjIR7TIR9aI4WiZ0kVZgHNHvuxIPR8oGckbIdW/PaXfZ0/eg/cgx3kZlee4I2GfRqF2OwrP+WHhnipg3ezKw5d54H2+eZ0cQ+tUcsucKPFuKPe62gPmMLWMFxosV4DELPZE88S0WK+u+B1tJnNvpGAXiTuCxce48Ovo1SnPsOhxX9LRLRmX4NZaWlebRGp2WNOsKHnSfY+jnV8/3XUqksM9CIpXyIS5dAafcgTLfWbT15H26XZV1xwQ89pi87mG21ns8vfvUKj57VVZwttds3ZVvS5tuxsYYdW2ZsO9Iy27Wxhh1b16UsUek7bd7agQ2vkxYuvtY/O5tvso2YjVcRoiTr7/yQNxSNiKj13AAAAAElFTkSuQmCC);\n}\n.subject-badge_type__deno::before {\n  filter: brightness(.85);\n  --icon: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 30 30">%0A    <g clip-path="url(%23a)">%0A        <path fill="currentColor" d="M15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0Z" />%0A        <path fill="%23fff" d="M14.664 22.34a.733.733 0 0 0-.893.498l-.006.018-.996 3.691-.004.018a.732.732 0 0 0 1.414.381l.005-.017.996-3.691.004-.018a.735.735 0 0 0 .016-.084l.003-.028-.024-.12-.034-.171-.022-.108a.732.732 0 0 0-.46-.37Zm-6.942-3.802a.738.738 0 0 0-.045.114l-.007.024-.996 3.692-.005.018a.732.732 0 0 0 1.414.381l.005-.018.903-3.347a6.622 6.622 0 0 1-1.269-.864Zm-2.375-4.245a.732.732 0 0 0-.893.498l-.005.018-.996 3.692-.005.017a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.52-.88Zm22.335-.838a.732.732 0 0 0-.893.498l-.005.018-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.692.005-.017a.732.732 0 0 0-.521-.88ZM3.178 8.525a13.383 13.383 0 0 0-1.564 4.908.732.732 0 0 0 1.252-.275l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.694-.906Zm21.981.026a.732.732 0 0 0-.893.498l-.005.018-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.521-.88ZM7.513 5.04a.732.732 0 0 0-.893.5l-.005.017-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.521-.88Zm12.799.698a.732.732 0 0 0-.893.5l-.005.017-.67 2.48c.434.214.848.466 1.237.753l.064.048.783-2.9.004-.017a.732.732 0 0 0-.52-.88Zm-6.515-4.162a13.47 13.47 0 0 0-1.393.197l-.097.02-.929 3.441-.004.018a.732.732 0 0 0 1.413.381l.005-.017.997-3.692.004-.017a.728.728 0 0 0 .004-.33Zm9.166 2.55-.196.726-.005.017a.732.732 0 0 0 1.414.382l.005-.018.021-.078a13.548 13.548 0 0 0-1.153-.965l-.086-.064Zm-5.796-2.43-.353 1.31-.005.018a.732.732 0 0 0 1.414.381l.005-.017.372-1.378c-.438-.121-.881-.22-1.329-.296l-.104-.017ZM9.69 24.625a.733.733 0 0 1 1.415.382l-.005.018-.713 2.641-.1-.036c-.429-.16-.85-.343-1.26-.546l.659-2.441.005-.018Z" />%0A        <path fill="%23fff" d="M14.414 8.49c-4.362 0-7.755 2.747-7.755 6.162 0 3.225 3.122 5.284 7.962 5.181.412-.009.53.268.665.64.134.373.494 2.337.78 3.839.257 1.344.518 2.693.717 4.048 3.16-.418 6.083-1.98 8.225-4.334l-2.284-8.517c-.57-2.057-1.235-3.953-2.996-5.33-1.416-1.107-3.216-1.688-5.314-1.688Z" />%0A        <path fill="currentColor" d="M15.352 10.957a.937.937 0 1 1 0 1.875.937.937 0 0 1 0-1.875Z" />%0A    </g>%0A    <defs>%0A        <clipPath id="a">%0A            <path fill="%23fff" d="M0 0h30v30H0z" />%0A        </clipPath>%0A    </defs>%0A</svg>%0A\');\n}\n.subject-badge_type__electron::before {\n  --icon: url(data:image/x-icon;base64,AAABAAQAQEAAAAEAIAAoQAAARgAAACAgAAABACAAKBAAAG5AAAAYGAAAAQAgACgJAACWUAAAEBAAAAEAIAAoBAAAvlkAACgAAABAAAAAgAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhXpDF42CRm6Og0WtjYNFyo6DR86MgkayjoNHc4Z5QxMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgDcOj4JGj46DRvuPhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+Mg0TxjoRHfol2Ow0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLf0MujoBD4o+ER/+PhEf/j4RH/4yEQ9+Ogka2joJGvYyBRuyPhEf/j4RH/4+ER/+MhEPfioNFJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOgkU/jINE8Y+ER/+PhEf/joREvo2ERjoAAAAAAAAAAAAAAAAAAAAAjIRGPo6BRcmPhEf/j4RH/46DRumNgkQxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJg0QpjING74+ER/+MgUb+joNGcQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj4RFdo+ER/+PhEf/jINE8YmDRCkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJdjsNioRG3Y+ER/+MgUb+j4RGWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOgkVojIFG/o+ER/+Mg0bPgIArBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4FGmI+ER/+PhEf/joRGfAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6ER36PhEf/j4RH/46DRo4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoJFP4yBRv6PhEf/jYRHuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVVQADjoFFxY+ER/+MgUb+joJELQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6BRcmPhEf/joFG9IeAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIuDRiGOg0bpjIFE/IqARTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6BRk2PhEf/j4RH/46ER34AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhnk9FY+ARCIAAAAAAAAAAAAAAACLdEYLVVUAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOg0bIj4RH/4+BRO6AgDcOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKgEAYjYNGTI+DRn+MgkayjoNHzo6DReOMgUT4j4RH/4+ER/+Mg0bzjoNF44yDRsaNgkeJjYNFSol2Ow0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgAACjYJGbo6CRr2PgEbcjYNEr4yBRkkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNgkcvj4RH/4+ER/+OgkWBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmZjMFj4NERI+BR5SOgEXgj4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+OgUTyj4NGhI6CR1qMgkayioRG3Y+ERbqPgkZmAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgEAEjoREvo+ER/+PhEf/j4RH/4+ER/+PhEf/joJFgQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjIRFl4+ER/+MgUT8iYBAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY+DRESOg0aljING74+ER/+PhEf/j4RH/4+ER/+PhEf/joNE/Y6CRdWOg0a1joNGnI+DRoSOg0dzj4NFfY+DRYiMhEWXjYNFyoyBRvqPhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4yCRrIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoRFeo+ER/+PhEf/i4NG1o6DRqOOg0frj4RH/46DRP2NhEY6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyDRsaPhEf/j4NHsQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACId0QPjYJGboyDRNiPhEf/j4RH/4+ER/+PhEf/joNE+Y6CRrePhEV2i4NEQICAQAwAAAAAAAAAAI57QhuMgEYoAAAAAAAAAAAAAAAAAAAAAAAAAACOcTkJj4FES46DRtKPhEf/j4RH/4uBROaOg0WijoRE24+ER/+PhEf/j4NFawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6DRtKPhEf/j4NGzGZmMwUAAAAAiIBEHo6BRvSPhEf/joNHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMhEQ8joRGlY96PRkAAAAAAAAAAAAAAAAAAAAAAAAAAIqAQBiNgUaSjoFG9I+ER/+PhEf/j4RH/42DRPWPhEeqjIRFWYCANw4AAAAAAAAAAAAAAAAAAAAAAAAAAFVVAAOMgUbsjIFE/I1/RDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPhEefj4RH/46DQ+2Lf0YWAAAAAICAQAiOgkLXj4RH/4+BR8MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMgUT4j4RH/46CRocAAAAAAAAAAAAAAACOgUXJj4RH/46CRrYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAh3g8EY6CRoeNg0T1j4RH/4+ER/+PhEf/joNG2o6DRW+Id0QPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtbSQHjIFG+o+ER/+PgkaPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoFFxY+ER/+PhEW6AAAAAAAAAAAAAAAAj4FGlo+ER/+Og0bpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoNG0o+ER/+Pg0bMZmYzBQAAAACMhEIfjoFG9I+ER/+Og0eQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtbSQHjoRFeoyDRu+PhEf/j4RH/4+ER/+NhEe4jIFERwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2DRMKPhEf/jYNG0wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+ER5+PhEf/joND7YV6QxcAAAAAjnE5CY6CQtePhEf/j4FHwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6ERXqPhEf/j4RH/4uDRtaOg0ajjoNH64+ER/+Og0T9jYRGOgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLg0RAjoJH2Y+ER/+PhEf/j4RH/4+BR8OOgkM9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOhEd+j4RH/4+ER/+KgEAYAAAAAAAAAAAAAAAAAAAAAAAAAACMgURHj4RH/4+ER/+Og0bnjoNGo46ERNuPhEf/j4RH/4+DRWsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgEAEjoJGvY+ER/+PhEf/j4RH/4+ER/+PhEf/jYNGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6ARxKOg0Wej4RH/4+ER/+PhEf/joND0I2DRUoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4JFO4+ER/+PhEf/jYFHUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+CRo+PhEf/j4RH/4+ER/+PhEf/j4RH/4+DR7EAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAAAKOg0frj4RH/46DQ+2Ng0SvjoNHSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6CRT+OgUbkj4RH/4+ER/+OgUb0joNGcVVVAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAMwqOg0T9j4RH/42DR4IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoFFUYyCRrKPgEbcjYJGuY+CRmYAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjIFG6I+ER/+PgUaWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVVUAA4+DRn+MgUT8j4RH/4+ER/+Og0SziIBEHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoJH2Y+ER/+NgkawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6ERNuPhEf/joJGrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoBHEo6CRr2PhEf/j4RH/46BRvaPgkVkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+ER6qPhEf/jIRD3wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPhEefj4RH/46DQ+2AgAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAioNCI4yDRNiPhEf/j4RH/4yDRdSOgkErAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNg0aAj4RH/4yBRv5mZjMFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYJFYI+ER/+PhEf/jn9FNAAAAAAAAAAAAAAAAAAAAAAAAAAAjYRGOo6DR+uPhEf/j4RH/46DRqeOcTkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoNGY4+ER/+PhEf/jIRCHwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2ERh2Og0T9j4RH/46ERZMAAAAAAAAAAAAAAAAAAAAAjIRGPo2DRPWPhEf/j4RH/4+DRoQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6DR0iPhEf/j4RH/42ERjoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoNFrY+ER/+Og0b3ioBAGAAAAAAAAAAAjIREPI6BRvSPhEf/jIFE/I6DR2EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOgkQtj4RH/4+ER/+NhEVVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIuCRjePhEf/j4RH/46DRYwAAAAAi4BGLI6BRPKPhEf/jIFE/I6CRlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAioBAGI+ER/+PhEf/joJFaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoNGwI+ER/+Og0b3jIBDKo+DRX2PhEf/joNE/Y+ERlsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMhEY+jINGoI+ER5+OgkM9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICANw6PhEf/j4RH/46DRnEAAAAAAAAAAAAAAACNgkZujoJGrouDRiEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIqARTCMgUb6j4RH/4+DRsyNe0YdjYFGkoyBREcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMgUZJjIFE/I+ER/+PhEf/jIFE/IyBRkkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmZjMFj4RH/4+ER/+OhEV6AAAAAAAAAAAAAAAAjoNH64+ER/+Og0bRjnE5CQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYNHgo+ER/+PhEf/j4NGfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoREvo+ER/+PhEf/j4RH/4+ER/+OhES+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyBRPyPhEf/joJGgwAAAAAAAAAAAAAAAI6CRoOPhEf/j4RH/4yDRqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAKwaNg0bTj4RH/46DRvuOg0dIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6DR86PhEf/j4RH/4+ER/+PhEf/jYNEzQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMgUb6j4RH/46CR4UAAAAAAAAAAAAAAABVVQADjoJGvY+ER/+PhEf/jYRFVQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKg0IjioBCMoyDRvOPhEf/joFE8oqARTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOhEd+j4RH/4+ER/+PhEf/j4RH/4+DRX0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmZjMFj4RH/4+ER/+OhEV6AAAAAAAAAAAAAAAAAAAAAIt/RhaLgUTqj4RH/46DRueAgEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOgkeFj4RH/42BRpKNg0ZMjoNE/Y+ER/+Pg0bliYBAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVVUAA42BRpKOg0b3joFG9o6ERZOAgEAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgIBAEI+ER/+PhEf/joNFbwAAAAAAAAAAAAAAAAAAAAAAAAAAjIRFWY+ER/+PhEf/j4FHlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACGeT0VjoFG9o+ER/+Pg0ahAAAAAI6DRW+PhEf/j4RH/4yDRNiNhEYdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYCAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI57QhuPhEf/j4RH/4+CRWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNgka5j4RH/46DRPmJgEAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYNHgo+ER/+PhEf/jYRGOgAAAAAAAAAAjoJGkY+ER/+PhEf/jYNG4YqDRSUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNf0Mmj4RH/4+ER/+MhEVZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjn9FNI+ER/+PhEf/j4FHlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAi3RGC46DQ+2PhEf/jYNEwgAAAAAAAAAAAAAAAAAAAACNgkaLj4RH/4+ER/+Og0bpjYJHLwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjIREPI+ER/+PhEf/joNHSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOg0a1j4RH/46BRvBtbSQHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2DRU6PhEf/j4RH/42DRU4AAAAAAAAAAAAAAAAAAAAAAAAAAI+DRX2PhEf/j4RH/4yDRPGOgUVRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+ERV2PhEf/j4RH/4mDQScAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjINEUo+ER/+PhEf/jINEUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOg0aKj4RH/46DRPmOcTkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYJHcIyBRv6PhEf/j4RH/42CR4lVVQADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOhEd+j4RH/4yBRv5tbSQHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAKwaMg0bzj4RH/46DRpoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjINGxo+ER/+PgUfDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPgURLjING74+ER/+PhEf/joJFv4V6QxcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjINGoI+ER/+Og0XjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoJFv4+ER/+LgUbLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6BRPKPhEf/joNHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+ARCKMg0bPj4RH/4+ER/+MgUbsj4RFXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+BR8OPhEf/jYNEwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6ERZOPhEf/jINE8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPgUTuj4RH/46DRo4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjnE5CYyDRqCPhEf/j4RH/4+ER/+NhEe4h4BAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAQASNg0T1j4RH/4+BRpgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPg0aGj4RH/46DRvcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAi4FE5o+ER/+OgkaRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoFFUY+DRuWPhEf/j4RH/46BRvSOg0dzbW0kBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPgEIyj4RH/4+ER/+PhEVdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjIRFl4+ER/+Mg0TxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6DQ9CPhEf/i4FGywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACId0QPjoNGmoyBRv6PhEf/j4RH/46AReCOhEZfgIAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4NFa4+ER/+PhEf/ioNCIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6BRsePhEf/joFFxQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNg0Z7j4RH/4+ER/+Nf0MmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLg0RAjoJC14+ER/+PhEf/j4RH/42DRtONhEZXgIBABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6DRqWPhEf/jIFG6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAImDRCmPhEf/j4RH/42CR4kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjIRCH4yBRv6PhEf/joJFtAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFVVAAOPgkVkjoFG5I+ER/+PhEf/j4RH/46AQ+KOg0Z1iHdEDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAQASOg0Ptj4RH/46CRqwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAQAiOg0bIj4RH/46DRP2Lg0YhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNg0Skj4RH/4+ER/+PgUaYgIBABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI5xOQmPhEV2i4FE6o+ER/+PhEf/j4RH/42DRPWOg0alj4FES4CAQAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOg0VGj4RH/4+ER/+PhEVdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIt0RguOg0arj4RH/4+ER/+PgkaPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiXY7DY6DRtqPhEf/j4RH/42DRcqPg0ZCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAQAiOg0ZjjINF1I+ER/+PhEf/j4RH/4+ER/+Og0frjYREnYyERVmFekMXAAAAAAAAAAAAAAAAjoNGmo+ER/+Og0b3iXY7DQAAAAAAAAAAAAAAAAAAAAAAAAAAgIAAAo2BR1OOgEPij4RH/4+ER/+PhEW6VVUAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKgEAYi4FGy4+ER/+PhEf/j4RH/4yDRNiPg0WIjINEUoyARiiOgEcSgIArBoCAKwaMgEAUjn9HJIyBRkWOgkZqjYJHcI6ARxIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMgUZFjYNHpo2DRPWPhEf/j4RH/4+ER/+PhEf/j4RH/4+DRsyNgkcvgIArBo6DR+uPhEf/joJGrgAAAACJdjsNiYNBJ46CRT+NgkVcj4NGoYuBROqPhEf/j4RH/4+ER/+Mgka7h3g8EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI5xOQmPg0Z/joFG9I+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+Pg0WIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLdEYLj4RGW4yCRrKMg0bzj4RH/4+ER/+PhEf/joNGjo6DRmOPhEf/j4RH/46CRFaOgkaDjoNE/Y+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4yBRuyNgkdeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIV6QxeOg0ZxjoFFyYyBRPyPhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+Og0PtjIFGRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZmYzBY+CRTuOhEd+j4FGmIeAQCCOgkLXj4RH/46AQ+JmZjMFjYFGwY+ER/+PhEf/j4RH/4+ER/+OgUTyjINFqYyERVmAgDcOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOcTkJjn9HNo+ERluPg0VrjoRFeo2DR3ePg0VrjYJHXoyERj6Oe0IbAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMg0ZQj4RH/4+ER/+Pg0ZtAAAAAI57QhuOgkVojYRGV4yERj6Kg0UlgIArBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgEAIjoNG2o+ER/+Og0bpjnE5CQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4NFiI+ER/+PhEf/jYJHcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAi4JGN46DRvuPhEf/jINGxoCAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKg0Ulj4RFXY+ERV2Kg0UlAAAAAAAAAAAAAAAAiYNEKY6DR+uPhEf/joFG9o1/QyYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAQAiOhEaVjIFG/o+ER/+PhEf/jIFG/o6ERpWAgEAIjX9DJo6BRuSPhEf/j4RH/42DR2UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPgkaPj4RH/4+ER/+PhEf/j4RH/4+ER/+PhEf/jYFGwY6BRvaPhEf/j4RH/46DR3MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPej0ZjoNE/Y+ER/+Ng0bEjX9DJo1/QyaNg0bEj4RH/4+ER/+PhEf/jIFG/o+ERXYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoFGTY+ER/+PhEf/jn9FNAAAAAAAAAAAjIJDNY+ER/+PhEf/i4NG1o+CRTsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6DR0iPhEf/j4RH/46CQz0AAAAAAAAAAI6CQz2PhEf/j4RH/46DR0gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMgEAUjIFG+o+ER/+Mg0XUjYFHQY2BR0GMg0XUj4RH/4yBRvqGeUMTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6ERnyPhEf/j4RH/4+ER/+PhEf/j4RH/4+ER/+OhEZ8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVVQADjoRFeo6DRPmPhEf/j4RH/46DRPmOhEV6VVUAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACId0QPj4NGQo+DRkKId0QPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACAAAABAAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHgEAgjYJHiY+BR8ONg0XKj4FHlIuDRiEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjIRFWYyDRPGPhEf/jIFE+I2DRPWPhEf/joNE+Y2CRVwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6BRk2MgUb+jINE8Y6CR1qAgEAIgIAAAo2ERVWOg0frjIFG/o6CRlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHgEAgj4FE7oyDRvOOgkErAAAAAAAAAAAAAAAAAAAAAIyAQyqOgUbwjoFE8oeAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2DR6aPhEf/joRGXwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+DRlSMgUT8j4FES4CAQAhmZjMFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyARiiNgkdwjoFGTQAAAAAAAAAAAAAAAAAAAACHgEAgjIFE/IuBRssAAAAAAAAAAAAAAAAAAAAAAAAAAI2ERh2OgkZqjoNGo4yDRNiNg0T1j4RH/4+ER/+Mg0bzjoJFv46DRnGMg0RSjYJHcI1/QyYAAAAAAAAAAAAAAACMhEY+joNE+Y+ER/+PhEf/jIRFlwAAAAAAAAAAAAAAAI6DRoqPhEf/joJEVgAAAAAAAAAAi3RGC42DR2WLgUbLj4RH/4+ER/+PhEf/jINE8YyDRNiOg0bRjoFFxY6DRtGMgUT8j4RH/4+ER/+PhEf/jIFE+I1/RDgAAAAAAAAAAI6CRqyPhEf/jYNFZ46CRdWOg0T9iXY7DQAAAAAAAAAAjoJEVo2ERJ1VVQADgIA3Do+DRn+OgUbwj4RH/46DRvuOhES+jYNGe41/RDhVVQADjoJFtI5/Rt4AAAAAAAAAAIqDQiOPhEf/joND0I6CR2yPhEf/jYNEpAAAAAAAAAAAjYNEpI+ER/+NgkeJjoBD4oyBRvqAgEAIAAAAAAAAAAAAAAAAAAAAAI+CRWSOg0Ptj4RH/42DRPWOgkaRjIRCHwAAAAAAAAAAAAAAAAAAAACNg0Skj4RH/45/RyQAAAAAiXY7DY6DRP2Of0bejoNFjI+ER/+NhESdAAAAAAAAAACLgEYsjING74+ER/+PhEf/jYNGeQAAAAAAAAAAAAAAAImAQByNhEe4j4RH/4yDRu+Ng0aAhnlDEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+DRWuPhEf/jYJHXgAAAAAAAAAAjYNGgI+ER/+PhEf/i4FE6omDQScAAAAAAAAAAAAAAACOg0Szj4RH/4uCRjcAAAAAAAAAAAAAAACMhEVZjoFG8I+ER/+Og0a1iX9FGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYJEMY+ER/+PgUaYAAAAAAAAAAAAAAAAi39DLo2DRU6HeDwRAAAAAAAAAAAAAAAAAAAAAI2CR4mPhEf/j4NGQgAAAAAAAAAAj4RGdIyBRv6OgUbwjYJFYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVVQADjIFE/I2BRsEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYFHQY+ER/+Og0WiAAAAAI2CR4mPhEf/joBD4oyARigAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOg0frjINF1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjINGz4yBRPyPg0Z/j4RH/4uDRtaJgEAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYRGOoqARTAAAAAAAAAAAAAAAAAAAAAAAAAAAI6CR9mLgUTmAAAAAI6CQz2Og0dhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMgUZFj4RH/46CQteOgkWRhnlDEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyERj6MgUb+jIFE/I2DRUoAAAAAAAAAAAAAAAAAAAAAjoFGx4yBRPgAAAAAjoNGpY+ER/+Pg0ZUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIt0RguOgkauj4RH/46DRaIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4JGZo+ER/+PhEf/jYJFXAAAAAAAAAAAAAAAAAAAAACPgUfDjoNG+wAAAACOf0ckjING84+BRO6JgEAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjINFqY6DRP2Og0bIj4RH/46DRo4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgAACjoNFb42DRnsAAAABAAAAAAAAAAAAAAAAAAAAAI6CR9mPg0blAAAAAAAAAACNgkdej4RH/42DR6YAAAAAAAAAAAAAAAAAAAAAAAAAAI5/RySOg0T9joFFyYyAQBSOgkXVj4RH/46DRZ6AgEAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjING74yDRs8AAAAAAAAAAAAAAACMg0bPjIFG+ol/RRoAAAAAAAAAAAAAAAAAAAAAjYNHd4+ER/+MhEVZAAAAAIZ5QxONg0XKj4RH/42DRcqJg0EnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGZmMwWPhEf/jYRHuAAAAAAAAAAAAAAAAI+ERV2PhEf/joRGeAAAAAAAAAAAAAAAAAAAAACNg0Svj4RH/4Z5PRUAAAAAAAAAAICAQAyOg0anj4RH/46BRvaOgkdsAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjYRGHY+ER/+Pg0ahAAAAAAAAAAAAAAAAj4BEIo+ER/+NhESdAAAAAAAAAAAAAAAAAAAAAI6CRbSPhEf/gIBACAAAAAAAAAAAAAAAAAAAAACPg0VrjYNE9Y+ER/+PhEW6joJELQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOgkZYj4RH/4+DRX0AAAAAAAAAAAAAAACId0QPj4RH/4yCRrIAAAAAAAAAAAAAAAAAAAAAjYFGko+ER/+Og0VGAAAAAAAAAAAAAAAAAAAAAAAAAACLg0YhjYJGuY+ER/+MgUb+j4NHsY5/RzYAAAAAAAAAAAAAAAAAAAAAAAAAAI+ER5+PhEf/j4NGQgAAAAAAAAAAAAAAAI6BRVGPhEf/joRHfgAAAAAAAAAAAAAAAAAAAACNgkQxjIFE/I6DRueLf0MuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjIFER4+BR8OPhEf/j4RH/4+BR8ONhEVyjn9HJAAAAAAAAAAAj4NG5Y6BRvaAgDMKAAAAAAAAAACKgEUwjoFG5IyBRPyMgEMqAAAAAAAAAAAAAAAAAAAAAAAAAACNgkZijIFG/oyBRv6Mgka7joRHfo2DR2WOg0ZjjoRGfI+CR42Jg0QpAAAAAI6CQz2Ogka3joNE/Y+ER/+PhEf/joJF1YyBQ1+PhEf/j4NHsY+CRWSOhEd+jIJGu46DRP2PhEf/j4NGbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOg0VGjoRHvI+ER/+PhEf/j4RH/4+ER/+PhEf/j4RH/46DRnEAAAAAAAAAAAAAAACGeT0VjYJFYI6CRq6PgUTuj4RHw4+ER/+Ogka2j4RH/4+ER/+Og0T9jYNGxI6CRT8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiX9FGo6CQz2NgkVcjIRFWY2BR0GMgEYoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6CRC2Og0b7joNG0Y96PRmOgkZYjYFHQYt/RhYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgDMKgIAzCgAAAACAgDMKjYNEzY+ER/+MgURHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoNGioyBRPyMgUT8joJGkY6CRr2PhEf/j4FGlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2BR0GPhEf/joNG2o6ERNuPhEf/j4RH/4yDRamAgEAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjoNGY4+ER/+Ng0Z5jYNGeY+ER/+NgkaLAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIgEQejING84+ER/+PhEf/jING842ERh0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNgkQxjoNFoo+DRqGNgkQxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAGAAAADAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhnk9FY+ER5+OgUbkjIFG7I6DRqOIgEQeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKg0UljIFG6I6CRdWPg0Vrj4JFZI6DRtGOg0bnjoJBKwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAMwqNg0bTjoREvoCAMwoAAAAAAAAAAICAQAiMgka7jINE2ICAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVVQADAAAAAAAAAAAAAAAAAAAAAI+ERnSOg0PtioBAGAAAAAAAAAAAAAAAAAAAAACEezkbjoNGwI+ERV2NgUdTjYFHU496PRkAAAAAAAAAAAAAAAAAAAAAi3RGC46ERcWOg0T9j4NGoQAAAAAAAAAAbW0kB4uBROaOhEd+AAAAAAAAAACPej0ZjoRGfI6CRb+Og0b3j4RH/4+ER/+PhEf/j4RH/46DRP2Mg0TYjoJH2Y6DRooAAAABj4RGW46ERvePhEf/j4RH/4yAQyoAAAAAgIBAEI6CRbSOgEcSjoJBK46DRZ6Og0T5joNE/YuBRsuNgkeJjoNHSI6BRPKOhEd+i39DLo2CR42MgUb+j4RH/46ERPmNg0ZMj4BCMoyBRPyMgUT4j4FE8oCAQBAAAAAAAAAAAIZ5QxOOg0ajjIFG/o6BRvSOg0eQjIRCHwAAAAAAAAAAAAAAAIqERt2Og0arAAAAAI2ERh2MgUT8j4RE/YyBRvqNgUdBAAAAAI6DR86PgEbciYNEKQAAAAAAAAAAjYFHU4yBRuiOg0T5jYNHgod4PBEAAAAAAAAAAAAAAAAAAAAAAAAAAI6DRaKLgUTmAAAAAAAAAACNgUdTj4NHsY6CR2wAAAAAAAAAAIyDRamMhEPfAAAAAAAAAACOgkaDj4RH/42DRcqLgEYsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI+DRWuPhEf/ioBAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2CRWCPhEf/j4NERI6DRpyPhEf/joREmVVVAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyDRFKPhEf/joJELQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAKwaOgEPijoND7Y+ER/+Pg0Z/AAAAAAAAAAAAAAAAAAAAAAAAAACPg0aGjYJHiVVVAAMAAAAAAAAAAIuDRECPhEf/joJFP4+DRoSNg0ZpAAAAAAAAAAAAAAAAAAAAAAAAAACNg0VOj4RH/4+DR7GAgAACAAAAAAAAAAAAAAAAAAAAAI1/QyaPhEf/j4RH/41/QyYAAAAAAAAAAIyCRjOPhEf/jYNGTI2DR2WMgUb6jn9HNgAAAAAAAAAAAAAAAICAAAKOg0bSj4JFtI+ER/+PhEefgIAAAgAAAAAAAAAAAAAAAFVVAAOPg0aEjoJFgQAAAAAAAAAAAAAAAIyBRkWPhEf/i4JDOQAAAACOgkasjINF1AAAAAAAAAAAAAAAAI6BRk2MgUb6jIRCH42BRpKPhEf/j4NEqIl2Ow0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2CRVyPhEf/j4BEIgAAAACKg0IjjoNE/Y6DRUYAAAAAAAAAAI+BR5SOhES+AAAAAAAAAACOhEZ4joNG+46AReCNgUdBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2ERXKPhEf/i3RGCwAAAAAAAAAAj4FHw4+CR40AAAAAAAAAAI6DRqeNg0SkAAAAAAAAAAAAAAAAjn9FNIuDRtaMgUb+jIRFl457QhsAAAAAAAAAAAAAAAAAAAAAAAAAAI2DR6aOg0bnAAAAAAAAAAAAAAAAjoNGq46DRqMAAAAAAAAAAI2DRnuOg0XjgIBAEAAAAAAAAAAAAAAAAICAQAiOg0WMjIFG+o6DRPmNhESdi39DLgAAAAAAAAAAgIAAAoyBRuyNhESdAAAAAAAAAACId0QPjIFG6I6CR2wAAAAAAAAAAIZ5QxOMg0TYjINF1I+ERluLg0YhiXY7DY2ERh2OgkQtiIBEHo6CRpGNg0T1j4RH/4yEQ9+OhEWTjoJHWo+ER/+OgkZYjn9FNI6DRmOOgkXVioRG3Yd4PBEAAAAAAAAAAAAAAACOe0IbjoNFnoyBRPiPhEf/j4RH/4+ER/+MgUb+jYJHLwAAAACGeUMTjoNGY42DRK+OgUb0j4RH/42DRPWOg0frj4RH/42DRPWOg0ajj3o9GQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI5xOQmJg0QpjoJFP46CRC2MgEAUAAAAAAAAAAAAAAAAAAAAAAAAAACLg0RAj4RH/46DRYyOgkErjoJBK4CAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAKwaNg0VnjYNFZ4d/QCSKhEbdjoBD4oCAQBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyERZeOg0b3jIFE+I6DRPmPgUTujIJGMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI6BRcmMgUb+jIFG/ouBROqPgEQiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyBREeOgUTyjoFE8oyBREcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAABAAAAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2ERXKMgUbsj4RH/46DR2EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI2CRmKPgUTujIRCH4uCQzmOg0bnj4RGWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIZ5QxOPhEf/i4NGIQAAAACJf0Uaj4RFXY+ER5uPgUaYjYJFkY6EReCOhETbioNCI46CR4WMg0bzjoJHhQAAAACPgEIyjIFGSY2ERjqMgkayjIFG+o2DRsSNg0TNjoRHvI2DRM2PhEf/j4RH/46DR3OMg0bzj4RH/4+BR/QAAAAAhnlDE4yDRamPgUTujYNHgoyAQBQAAAAAjYRFco6DRa2Kg0IjjoRE246ERNuKg0IjjoJHhYyBRPyOg0Wti39DLouBROaPhEeqhnlDEwAAAAAAAAAAAAAAAI+CRTuNg0bhAAAAAAAAAAAAAAAAAAAAAAAAAACPg0aEjoNGyI+BRO6Og0dzAAAAAAAAAACNf0MmjX9DJgAAAACHgEAgjIFE+AAAAAAAAAAAAAAAAAAAAAAAAAAAgIA3DouBROqPgUaWAAAAAAAAAAAAAAAAjoBD4o+DRuUAAAAAjoBHEo+ER/+MhEZbjIJGsmZmMwUAAAAAAAAAAI+BREuOg0WcjINE8Y2ERVUAAAAAAAAAAI2CRmKNgkdeAAAAAIuDRiGOgUb2AAAAAI2CRrCPg0VrAAAAAAAAAACOgUbHjYFFQ46DRUaOgUbwjoNGjm1tJAcAAAAAAAAAAAAAAACNf0Q4joBF4AAAAACMgUZFjoFFyQAAAAAAAAAAjYRHuI+BREsAAAAAh4BAII2DRsSOgkfZj4RFXVVVAAMAAAAAjYJGbo6DRrUAAAAAjoRGX4+ER/8AAAAAAAAAAI2CRm6PhEf/jYRFcouDRECNg0VOjYJHXoyDRNiLgUTqjYREnYyDRsaOhEV+j4RGdIyDRu+Pg0ZCAAAAAAAAAAAAAAAAjYFHQYqERt2PgUfDjoRFkwAAAAAAAAABi4JDOY6DRqeNg0T1j4NEbY6DR5CNgUVDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4NGho+BR/SLgULqjoRHfgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyDRvOPhEf/joRE+VVVAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOgkeFjING846CR4UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA);\n  filter: brightness(1.1);\n}\n.discovery-root-darkmode .subject-badge_type__electron::before {\n  filter: brightness(1.7);\n}\n.subject-badge_type__npm::before {\n  --icon: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">%0A    <polygon fill="%23b11117" stroke="black" stroke-width="15" points="0 256 0 0 256 0 256 256" />%0A    <polygon fill="%23e0e0e0" points="48 48 208 48 208 208 176 208 176 80 128 80 128 208 48 208" />%0A</svg>%0A\');\n}\n.discovery-root-darkmode .subject-badge_type__npm::before {\n  filter: brightness(.9);\n}\n.subject-badge_type__github::before {\n  --icon: url(\'data:image/svg+xml,<svg width="98" height="96" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="%23fff"/></svg>\');\n}\n.subject-badge_type__jsr::before {\n  --icon: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3 13 13">%0A  <path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="%23083344" />%0A  <g fill="%23f7df1e" >%0A    <path d="M1,3h1v1h1v-3h1v4h-3" />%0A    <path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2" />%0A    <path d="M9,2h3v2h-1v-1h-1v3h-1" />%0A  </g>%0A</svg>%0A\');\n  filter: brightness(.9);\n}\n.subject-badge_type__denoland::before {\n  --icon: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 30 30">%0A    <g clip-path="url(%23a)">%0A        <path fill="currentColor" d="M15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0Z" />%0A        <path fill="%23fff" d="M14.664 22.34a.733.733 0 0 0-.893.498l-.006.018-.996 3.691-.004.018a.732.732 0 0 0 1.414.381l.005-.017.996-3.691.004-.018a.735.735 0 0 0 .016-.084l.003-.028-.024-.12-.034-.171-.022-.108a.732.732 0 0 0-.46-.37Zm-6.942-3.802a.738.738 0 0 0-.045.114l-.007.024-.996 3.692-.005.018a.732.732 0 0 0 1.414.381l.005-.018.903-3.347a6.622 6.622 0 0 1-1.269-.864Zm-2.375-4.245a.732.732 0 0 0-.893.498l-.005.018-.996 3.692-.005.017a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.52-.88Zm22.335-.838a.732.732 0 0 0-.893.498l-.005.018-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.692.005-.017a.732.732 0 0 0-.521-.88ZM3.178 8.525a13.383 13.383 0 0 0-1.564 4.908.732.732 0 0 0 1.252-.275l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.694-.906Zm21.981.026a.732.732 0 0 0-.893.498l-.005.018-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.521-.88ZM7.513 5.04a.732.732 0 0 0-.893.5l-.005.017-.996 3.691-.005.018a.732.732 0 0 0 1.414.382l.005-.018.996-3.691.005-.018a.732.732 0 0 0-.521-.88Zm12.799.698a.732.732 0 0 0-.893.5l-.005.017-.67 2.48c.434.214.848.466 1.237.753l.064.048.783-2.9.004-.017a.732.732 0 0 0-.52-.88Zm-6.515-4.162a13.47 13.47 0 0 0-1.393.197l-.097.02-.929 3.441-.004.018a.732.732 0 0 0 1.413.381l.005-.017.997-3.692.004-.017a.728.728 0 0 0 .004-.33Zm9.166 2.55-.196.726-.005.017a.732.732 0 0 0 1.414.382l.005-.018.021-.078a13.548 13.548 0 0 0-1.153-.965l-.086-.064Zm-5.796-2.43-.353 1.31-.005.018a.732.732 0 0 0 1.414.381l.005-.017.372-1.378c-.438-.121-.881-.22-1.329-.296l-.104-.017ZM9.69 24.625a.733.733 0 0 1 1.415.382l-.005.018-.713 2.641-.1-.036c-.429-.16-.85-.343-1.26-.546l.659-2.441.005-.018Z" />%0A        <path fill="%23fff" d="M14.414 8.49c-4.362 0-7.755 2.747-7.755 6.162 0 3.225 3.122 5.284 7.962 5.181.412-.009.53.268.665.64.134.373.494 2.337.78 3.839.257 1.344.518 2.693.717 4.048 3.16-.418 6.083-1.98 8.225-4.334l-2.284-8.517c-.57-2.057-1.235-3.953-2.996-5.33-1.416-1.107-3.216-1.688-5.314-1.688Z" />%0A        <path fill="currentColor" d="M15.352 10.957a.937.937 0 1 1 0 1.875.937.937 0 0 1 0-1.875Z" />%0A    </g>%0A    <defs>%0A        <clipPath id="a">%0A            <path fill="%23fff" d="M0 0h30v30H0z" />%0A        </clipPath>%0A    </defs>%0A</svg>%0A\');\n}\n.subject-badge_type__chrome-extension::before {\n  --icon: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEMUlEQVRYw+2XXYhVVRTHf2ufc+6MNyWr0SxTyTcHe9CUakQwCSSwiD4MKgiSQF+syKdKiOgleogRIjSJFK1eBD8iTYjyY3xJ6sWMelDnzp2Zazo1fszMvfecvVYP9844d+7H3EzThzacw9777L32f/3/a+29T2hm3MwScpPLrQVARBoOzvb1beg61tWJARgIVAho0NGx7LW5c2ZvrjW/ltxNM5Dt7d+g3neOgwtY+X21S9V3ZnqyzJ1z3+brKoGqdgI8v+a5hjSd7c6YqnUC1xeACNyIhKkA0NvXZxO1KtWvOp3pyRpjYGxM+9H66NSz3ZlxZgwDznRnAOP+efOkLgP/9b4QNlp8fPNG4ZokBirpbx6M/TsAFfrWNWpV3dfCUlh/YalpWFWbMjw+ACuyaXIGpAk2GiZs1Xi7lhio5UHSdQSOfU9w5U9cKBVwfdHjb29DOlYgHcvrxsZEmcL6wXW1oadO4nd8hlweQFoiSEWYBRAEYGA+gTjGZbvRndtIvt5D8OJapL39nwZhNVnx3r34r7bjUhFEAZihXpHAIQ5UBTOF2KPFBEsSyPYQv/cOwUsv41Y/2UCcCQBSqajiY37LVtizmzAKERJEDfEGiUecAFKSQBXzhksUTRKIPRYrtvVT5MIg4atrS0vbJAxEUWqsfv7wQVp3fUkYBYiCqCLekMRD7EpHtyvtyaajIJQg8egogNhjO3YStLcTrFheM01rSjCcDPHh0BdsHCkyxUdYqEjikMAjgSstLKX7g1nZMzVMFUtKD4lHYwUzCu++T+u+3ci0qc1lwcH+A+RmFDi4eiar9uZojUIkECQIQAR3z0ymPP0UqaWLYeplbOgExdwB4nwWcR6c4IISTucEcSNY90ckCzc1sxHBt/3fIE7oWjWdxYfPMWMwoVUDLFZa1jzL4IaN7D+d58JATPqK0DZ1EcsffoM7+99Ez3+OCyAIjVSLEoaGCw0JtvMHm6rCsIqBXwdPMazDOCfk055Dz8xjzbbTOIX0ykf58YXX2fXdJaa1COkIUkXIXCxy9MwAryz9gCXpHKmR/YibILhdIiocp5h6pHEMnBr8paLn58XCA7NDFvQmtLz1Nlt+GMaVjcdeCJzhFQqJsbnrIh8/8Qltvftq5nxU6GoMwKz6QHG3hRx6fBbz9+U5OtDC+aE86ZQQe2OkrLMapXZi/JRr5bFwLi7JVMV3E1kwiqKy69xDU/g9N4uei57LRSNWyIcQOsOJoGYkCsUETuaKrJxTDcCa3QlNwTxYWLoHAkjKcWRBkSWtCYU4IfYhwzGEDqR83fIKicL8OxwuztTwSyZnwIzj5q3DvIFS4rdc+hYWWDTtL1LeGIkjfBASixu7rZop6VB58G7BDdQAoGAqmNnxugBmtN21bH3bOtazru7h8duSJk7ke6tdDYDp5ef/f8NbCsDfEMkfc1zCHD4AAAAASUVORK5CYII=);\n}\n.subject-badge_type__wasm::before {\n  --icon: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="612" height="612">%0A    <path d="m376 0c0 1.08 0 2.16 0 3.3 0 38.76-31.42 70.17-70.17 70.17-38.76 0-70.17-31.42-70.17-70.17l0 0c0-1.14 0-2.22 0-3.3L0 0l0 612 612 0 0-612z" fill="%23654ff0"/>%0A    <path d="m142.16 329.81 40.56 0 27.69 147.47 0.5 0 33.28-147.47 37.94 0 30.06 149.28 0.59 0 31.56-149.28 39.78 0-51.69 216.69-40.25 0-29.81-147.47-0.78 0-31.91 147.47-41 0zm287.69 0 63.94 0 63.5 216.69-41.84 0-13.81-48.22-72.84 0-10.66 48.22-40.75 0zm24.34 53.41-17.69 79.5 55.06 0-20.31-79.5z" fill="%23fff"/>%0A</svg>%0A\');\n}\n.subject-badge.package[data-version]::after,\n.subject-badge .prefix[data-version]::after {\n  content: attr(data-version);\n  display: inline-block;\n  padding-left: 1ex;\n  padding-bottom: calc(var(--badge-icon-top-bottom) - 2px);\n  max-width: 10ex;\n  vertical-align: middle;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  line-height: 12px;\n  font-size: 10px;\n  color: #999;\n}\n\n/* app/views/subject-with-nested-timeline.css */\n.view-subject-with-nested-timeline {\n  --main-histogram-height: 30px;\n  position: relative;\n  padding-top: 15px;\n  margin-bottom: 2px;\n}\n.view-subject-with-nested-timeline::before {\n  content: "TOTAL TIME";\n  display: block;\n  position: absolute;\n  width: calc(2 * var(--main-histogram-height) + 1px);\n  top: 16.5px;\n  left: -5px;\n  transform: translate(-100%, -100%) translateX(-15.5px) rotate(-90deg);\n  transform-origin: bottom right;\n  padding: 3px 0;\n  font-size: 8px;\n  text-align: center;\n  letter-spacing: .75px;\n  color: #888;\n  background-color: color-mix(in srgb, var(--discovery-color) 10%, var(--discovery-background-color));\n}\n.view-subject-with-nested-timeline .view-time-ruler {\n  margin-left: 1px;\n  --overlay-offset-top: -1px;\n  --overlay-offset-bottom: -1px;\n}\n.view-subject-with-nested-timeline .view-time-ruler .interval-marker:first-child {\n  margin-left: -1px;\n}\n.view-subject-with-nested-timeline .view-timeline-segments {\n  border-top: 1px solid #0004;\n  margin-left: 1px;\n}\n.view-subject-with-nested-timeline .nested-work::before {\n  content: "Nested time distributed by category";\n  display: block;\n  margin-left: 1px;\n  font-size: 10px;\n  text-align: center;\n  background-color: #0004;\n  color: color-mix(in srgb, var(--discovery-color) 60%, var(--discovery-background-color));\n  opacity: .5;\n  pointer-events: none;\n}\n.view-subject-with-nested-timeline .nested-work .view-timeline-segments {\n  border-top: none;\n  margin-block: 0;\n}\n.view-subject-with-nested-timeline .view-timeline-segments-bin.nested-time {\n  transform: scaleY(-1);\n  margin-top: -1px;\n  border-bottom: none;\n  border-top: none;\n}\n.view-subject-with-nested-timeline > .view-timeline-segments-bin::before {\n  content: "SELF";\n  display: block;\n  position: absolute;\n  width: 30px;\n  bottom: 0;\n  left: -2px;\n  transform: rotate(-90deg);\n  transform-origin: bottom left;\n  padding: 2px 0;\n  font-size: 9px;\n  text-align: center;\n  letter-spacing: .5px;\n  color: #888;\n  background-color: color-mix(in srgb, var(--discovery-color) 10%, var(--discovery-background-color));\n}\n.view-subject-with-nested-timeline > .view-timeline-segments-bin.self-time::before {\n  bottom: -.5px;\n  padding-left: .5px;\n}\n.view-subject-with-nested-timeline > .view-timeline-segments-bin.nested-time::before {\n  content: "NEST";\n  transform: rotate(-90deg) scaleX(-1) translate(-100%);\n}\n\n/* app/views/time.css */\n.view-time {\n  display: inline-block;\n  padding: 0 6px;\n  border: 1px solid rgba(135, 135, 135, 0.25);\n  box-sizing: border-box;\n  border-radius: 3px;\n  font-size: 12px;\n  line-height: 20px;\n  height: 20px;\n}\n.view-self-time {\n  color: #3b7b3b;\n  border-color: rgba(84, 121, 84, .45);\n}\n.discovery-root-darkmode .view-self-time {\n  color: #83cd83;\n}\n.view-nested-time {\n  color: #8e8e31;\n  border-color: rgba(120, 121, 84, .45);\n}\n.discovery-root-darkmode .view-nested-time {\n  color: #cbcd83;\n}\n.view-total-time {\n  color: #875699;\n  border-color: rgba(149, 111, 166, .45);\n}\n.discovery-root-darkmode .view-total-time {\n  color: #dda3f3;\n}\n.view-time::before {\n  opacity: .5;\n  margin-right: 6px;\n  font-size: 9px;\n  display: inline-block;\n  vertical-align: top;\n}\n.view-self-time::before {\n  content: "S";\n}\n.view-nested-time::before {\n  content: "N";\n}\n.view-total-time::before {\n  content: "T";\n}\n.view-self-time > .value {\n  color: #6eae6e;\n}\n.view-nested-time > .value {\n  color: #aead6e;\n}\n.view-total-time > .value {\n  color: #aa92da;\n}\n.view-time > .value > .num-delim {\n  padding-right: 2px;\n}\n.view-time > .value::after {\n  content: attr(data-unit);\n  opacity: .4;\n  margin-left: 0;\n  font-size: 11px;\n}\n.view-time > .fraction {\n  margin-left: 6px;\n  opacity: .7;\n  font-size: 10px;\n}\n\n/* app/views/time-ruler.css */\n.view-time-ruler {\n  --left: calc(var(--selection-start) * 100%);\n  --width: calc((var(--selection-end) - var(--selection-start)) * 100% - 0.2px);\n  position: absolute;\n  inset: 0;\n}\n.view-time-ruler,\n.view-time-ruler * {\n  -webkit-user-drag: none;\n  user-select: none;\n}\n.view-time-ruler[data-active-trigger=start],\n.view-time-ruler[data-active-trigger=finish] {\n  cursor: col-resize;\n}\n.view-time-ruler[data-active-trigger=both] {\n  cursor: move;\n}\n.view-time-ruler__selection-overlay {\n  display: none;\n  position: absolute;\n  inset: 0;\n  top: var(--overlay-offset-top, 0);\n  bottom: var(--overlay-offset-bottom, 0);\n  z-index: 99;\n}\n.view-time-ruler[data-state=hovered] .view-time-ruler__selection-overlay {\n  pointer-events: none;\n}\n.view-time-ruler:not([data-state=none]) .view-time-ruler__selection-overlay {\n  display: block;\n}\n.view-time-ruler__selection-overlay-mover {\n  position: absolute;\n  inset: 0;\n  left: var(--left);\n  width: var(--width);\n  z-index: 1;\n  cursor: move;\n}\n.view-time-ruler__selection-overlay-mover-trigger {\n  --extra-pointer-size: 2.5px;\n  --extra-pointer-inner-size: clamp(0px, (100% - 2 * var(--extra-pointer-size)) / 2, var(--extra-pointer-size));\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 1px;\n  background-color: #268fea66;\n  background-clip: content-box;\n  padding: 0 var(--extra-pointer-size);\n  transition: .25s ease;\n  transition-property: background-color;\n  cursor: col-resize;\n}\n.view-time-ruler[data-state=selecting] .view-time-ruler__selection-overlay-mover-trigger {\n  transition: none;\n}\n.view-time-ruler__selection-overlay-mover-trigger[data-trigger=start] {\n  left: calc(-1 * var(--extra-pointer-size));\n  padding-right: var(--extra-pointer-inner-size);\n}\n.view-time-ruler__selection-overlay-mover-trigger[data-trigger=finish] {\n  right: calc(-1 * var(--extra-pointer-size));\n  padding-left: var(--extra-pointer-inner-size);\n}\n.view-time-ruler__selection-overlay-mover-trigger:hover,\n.view-time-ruler[data-active-trigger=start] .view-time-ruler__selection-overlay-mover-trigger[data-trigger=start],\n.view-time-ruler[data-active-trigger=finish] .view-time-ruler__selection-overlay-mover-trigger[data-trigger=finish] {\n  background-color: #268fea;\n}\n.view-time-ruler[data-state=hovered] .view-time-ruler__selection-overlay-mover-trigger {\n  display: none;\n}\n.view-time-ruler__selection-overlay::before,\n.view-time-ruler__selection-overlay::after {\n  content: "";\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  width: var(--left);\n  opacity: 0;\n  transition: .25s ease-in;\n  transition-property: opacity, backdrop-filter;\n  pointer-events: none;\n}\n.view-time-ruler__selection-overlay::after {\n  left: calc(var(--left) + var(--width));\n  right: 0;\n  width: auto;\n}\n.view-time-ruler[data-state=selected] .view-time-ruler__selection-overlay::before,\n.view-time-ruler[data-state=selected] .view-time-ruler__selection-overlay::after {\n  opacity: 1;\n  backdrop-filter: saturate(0);\n}\n.view-time-ruler .interval-marker {\n  position: absolute;\n  z-index: -1;\n  left: calc(100% * var(--offset));\n  top: 0;\n  bottom: 0;\n  border-left: 1px solid #6666;\n  color: #888b;\n}\n.view-time-ruler:is([data-labels=both], [data-labels=top]) .interval-marker::before,\n.view-time-ruler:is([data-labels=both], [data-labels=bottom]) .interval-marker::after {\n  content: attr(data-title);\n  position: absolute;\n  left: 3px;\n  font-size: 10px;\n  line-height: 10px;\n}\n.view-time-ruler .interval-marker::before {\n  top: 2px;\n}\n.view-time-ruler .interval-marker::after {\n  bottom: 2px;\n}\n.view-time-ruler::before {\n  content: "";\n  position: absolute;\n  z-index: -1;\n  width: var(--width);\n  left: var(--left);\n  top: var(--overlay-offset-top, 0);\n  bottom: var(--overlay-offset-bottom, 0);\n  pointer-events: none;\n  transition: .2s ease;\n  transition-property: background-color;\n}\n.view-time-ruler[data-state=hovered]::before,\n.view-time-ruler[data-state=selecting]::before {\n  background-color: rgba(0, 152, 251, .2);\n}\n.view-time-ruler[data-state=selected]::before {\n  background-color: rgba(0, 152, 251, .1);\n}\n.view-time-ruler-tooltip {\n  padding: 5px 10px;\n  min-width: 200px;\n  border: none;\n  border-radius: 3px;\n  font-size: 12px;\n  background: rgba(255, 255, 255, .75);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n  pointer-events: none;\n}\n.discovery-root-darkmode .view-time-ruler-tooltip {\n  background: rgba(36, 36, 36, .8);\n}\n\n/* app/views/timeline-profiles.css */\n.view-timeline-profiles {\n  position: relative;\n  border-bottom: 1px solid #0004;\n  margin: 1px 0;\n}\n.view-timeline-profiles > .profile {\n  margin-left: calc(100% * var(--x1));\n  width: calc(100% * (var(--x2) - var(--x1)));\n  height: 5px;\n  background-color: #54a6eea6;\n  border: .5px solid black;\n}\n.view-timeline-profiles > .selected {\n  background-color: orange;\n}\n\n/* app/views/timeline-segments.css */\n.view-timeline-segments {\n  position: relative;\n  border-bottom: 1px solid #0004;\n  margin: 1px 0;\n}\n.view-timeline-segments svg {\n  display: block;\n  margin-bottom: -.5px;\n}\n.view-timeline-segments path {\n  fill: var(--color, #888);\n}\n.view-timeline-segments path.rel-path {\n  opacity: .4;\n}\n\n/* app/views/timing-bar.css */\n.view-timing-bar {\n  display: flex;\n  gap: 1px;\n}\n.view-timing-bar-segment {\n  display: block;\n  box-sizing: border-box;\n  flex: 1;\n  flex-basis: calc(var(--fraction) * 100%);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  background-clip: padding-box;\n  background-color: color-mix(in srgb, var(--color, rgba(128, 128, 128, .25)) 35%, transparent);\n  border: solid var(--color, rgba(128, 128, 128, .25));\n  border-width: 2px 0 0 1px;\n  font-size: 11px;\n  line-height: 13px;\n  padding: 1px 4px 3px;\n  color: var(--discovery-color);\n  text-decoration: none;\n}\n.view-timing-bar-segment[href] {\n  cursor: pointer;\n}\n.view-timing-bar-segment[href]:hover {\n  opacity: .75;\n}\n\n/* app/views/update-on-timings-change.css */\n.view-update-on-timings-change {\n  display: contents;\n}\n\n/* discovery-cli:default/extensions.css */\n\n/* discovery-cli:default/model.css */\n</style>\n    <style type="discovery/style" src="model-loader.css">/* node_modules/@discoveryjs/discovery/src/views/controls/progress.css */\n.view-progress {\n  max-width: 300px;\n  width: 100%;\n  z-index: 1;\n  transition: opacity .15s var(--appearance-delay, 0ms);\n  pointer-events: none;\n}\n.view-progress.init {\n  opacity: 0;\n}\n.view-progress > .progress {\n  content: "";\n  display: block;\n  position: relative;\n  overflow: hidden;\n  margin-top: 4px;\n  box-sizing: border-box;\n  height: 3px;\n  background: rgba(198, 198, 198, 0.3);\n  border-radius: 2px;\n}\n.view-progress > .progress::before {\n  content: "";\n  display: block;\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform: scaleX(var(--progress, 0));\n  transform-origin: left;\n  background-color: var(--color, #1f7ec5);\n}\n\n/* node_modules/@discoveryjs/discovery/src/preloader.css */\n:host {\n  position: absolute;\n  z-index: 1;\n  padding: 35px 40px;\n  width: 100%;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/controls/button.css */\n.view-button {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n  padding: 8px 12px;\n  outline: none;\n  margin: 0;\n  color: var(--discovery-view-button-color);\n  background-color: var(--discovery-view-button-background-color);\n  border: 1px solid var(--discovery-view-button-border-color);\n  border-radius: 3px;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: 1.2;\n  text-align: center;\n  cursor: pointer;\n  --discovery-view-button-color: var(--discovery-color);\n  --discovery-view-button-background-color: rgba(255, 255, 255, .1);\n  --discovery-view-button-border-color: rgba(127, 127, 127, 0.4);\n  --discovery-view-button-hover-background-color: rgba(221, 221, 221, 0.3);\n  --discovery-view-button-hover-border-color: rgba(170, 170, 170, 0.6);\n  --discovery-view-button-active-background-color: rgba(131, 131, 131, 0.25);\n  --discovery-view-button-active-border-color: var(--discovery-view-button-border-color);\n  --discovery-view-button-focus-background-color: var(--discovery-view-button-background-color);\n  --discovery-view-button-focus-border-color: rgba(128, 128, 128, 0.6);\n}\n.view-button:empty::before {\n  content: "|";\n  width: 0;\n  visibility: hidden;\n}\n.view-button:focus-visible {\n  box-shadow: 0 0 1px 3px rgba(0, 170, 255, 0.2);\n  background-color: var(--discovery-view-button-focus-background-color);\n  border-color: var(--discovery-view-button-focus-border-color);\n  z-index: 1;\n}\n.view-button:hover,\n.view-button.discovery-view-popup-active {\n  background-color: var(--discovery-view-button-hover-background-color);\n  border-color: var(--discovery-view-button-hover-border-color);\n}\n.view-button:active {\n  background-color: var(--discovery-view-button-active-background-color);\n  border-color: var(--discovery-view-button-active-border-color);\n}\n.view-button[disabled] {\n  opacity: .5;\n  pointer-events: none;\n  cursor: default;\n}\n.view-button + .view-button {\n  margin-left: 1ex;\n}\n.view-button-primary {\n  --discovery-view-button-color: white;\n  --discovery-view-button-background-color: #00aaff;\n  --discovery-view-button-border-color: transparent;\n  --discovery-view-button-hover-background-color: #009cf0;\n  --discovery-view-button-hover-border-color: transparent;\n  --discovery-view-button-active-background-color: #008ee0;\n  --discovery-view-button-focus-border-color: transparent;\n}\n.discovery-root-darkmode .view-button-primary {\n  --discovery-view-button-color: #fffd;\n  --discovery-view-button-background-color: #006aa3e6;\n  --discovery-view-button-hover-background-color: #0074b3e6;\n  --discovery-view-button-active-background-color: #006aa3d0;\n}\n.view-button-danger {\n  --discovery-view-button-color: white;\n  --discovery-view-button-background-color: #ff6163;\n  --discovery-view-button-border-color: transparent;\n  --discovery-view-button-hover-background-color: #f05456;\n  --discovery-view-button-hover-border-color: transparent;\n  --discovery-view-button-active-background-color: #e34449;\n  --discovery-view-button-focus-border-color: transparent;\n}\n.discovery-root-darkmode .view-button-danger {\n  --discovery-view-button-color: #fffd;\n  --discovery-view-button-background-color: #c32224bf;\n  --discovery-view-button-hover-background-color: #d02528bf;\n  --discovery-view-button-active-background-color: #c32224a6;\n}\n.view-button-warning {\n  --discovery-view-button-color: rgba(0, 0, 0, .84);\n  --discovery-view-button-background-color: #ffcf21;\n  --discovery-view-button-border-color: transparent;\n  --discovery-view-button-hover-background-color: #fcbd00;\n  --discovery-view-button-hover-border-color: transparent;\n  --discovery-view-button-active-background-color: #f7ad00;\n  --discovery-view-button-focus-border-color: transparent;\n}\n.discovery-root-darkmode .view-button-warning {\n  --discovery-view-button-color: #eeee;\n  --discovery-view-button-background-color: #ffd40199;\n  --discovery-view-button-hover-background-color: #ffd91aa6;\n  --discovery-view-button-active-background-color: #ffd4018e;\n}\n\n/* node_modules/@discoveryjs/discovery/src/views/button.css */\n\n/* node_modules/@discoveryjs/cli/lib/static/common-loader.css */\n:host {\n  box-sizing: border-box;\n  max-width: 100vw;\n  height: 100%;\n  z-index: 1;\n}\n:host(.generate-data-crash) {\n  display: flex;\n  flex-direction: column;\n}\n:host > .view-progress {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  max-width: none;\n}\n:host > .view-progress > .progress {\n  max-width: 300px;\n}\n:host > .error {\n  margin: 20px 0;\n  padding: 20px;\n  box-sizing: border-box;\n  width: 100%;\n  font-size: 14px;\n  color: #d85a5a;\n  background: #ff00002e;\n  text-shadow: 1px 1px var(--discovery-background-color);\n  white-space: pre-wrap;\n  overflow: auto;\n  max-height: calc(100vh - 170px);\n}\n:host > .action-buttons {\n  font-size: 14px;\n}\n:host > .action-buttons .view-button {\n  padding-left: 20px;\n  padding-right: 20px;\n}\n:host(.generate-data-crash) > .action-buttons {\n  margin: -3px 0 0 -20px;\n}\n.data-status {\n  flex: 1;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  margin: 15px -20px -15px;\n  font-family:\n    Menlo,\n    Monaco,\n    Consolas,\n    monospace;\n  font-size: 12px;\n  line-height: 16px;\n  transition: opacity .15s, margin .5s;\n  pointer-events: all;\n}\n.data-status.init {\n  opacity: 0;\n}\n.data-status.finished:not(.crashed) {\n  opacity: 0;\n  transition-duration: .5s;\n}\n.data-status.compliment-error {\n  margin: 10px 0 20px;\n}\n.data-status > .header {\n  padding: 10px 20px 10px;\n  background-color: rgba(192, 192, 192, .12);\n  background-image:\n    linear-gradient(\n      to top,\n      rgba(150, 150, 150, .15),\n      rgba(150, 150, 150, .15));\n  margin-bottom: 1px;\n  opacity: .8;\n}\n.data-status.crashed > .header {\n  background-color: #ff898940;\n  color: #d00;\n  opacity: 1;\n}\n:host([darkmode]) .data-status.crashed > .header {\n  background-color: #91000040;\n  color: #e67d7d;\n}\n.data-status.compliment-error.collapsed > .header,\n.data-status.compliment-error:not(.collapsed) > .output {\n  margin-bottom: 20px;\n}\n.data-status > .output {\n  flex: 1;\n  padding: 10px 20px;\n  overflow: scroll;\n  white-space: pre-wrap;\n  background-color: rgba(192, 192, 192, .12);\n}\n.data-status.crashed > .output {\n  background-color: #ff98981f;\n}\n.data-status.collapsed > .output {\n  display: none;\n}\n.data-status > .output .stderr {\n  color: #d00;\n}\n:host([darkmode]) .data-status > .output .stderr {\n  color: #e67d7d;\n}\n.data-status .plan-step-list {\n  --nested-padding: 20px;\n  padding: 0;\n  margin: 0;\n  margin-left: var(--nested-padding);\n}\n.data-status > .output > .plan-step-list {\n  margin-left: -20px;\n}\n.data-status .plan-step {\n  list-style: none;\n}\n.data-status .num-delim {\n  padding-left: 0.14em;\n}\n.data-status .plan-step > .plan-step__header {\n  display: flex;\n  align-items: center;\n  height: 2em;\n  margin: 0 -20px 0 calc(-20px - var(--nested-padding) * var(--level, 0));\n  padding: 0 20px 0 calc(20px + var(--nested-padding) * var(--level, 0));\n}\n.data-status .plan-step:is(.started, .finished, .crashed) > .plan-step__header:hover {\n  background-color: #0001;\n  cursor: pointer;\n}\n:host([darkmode]) .data-status .plan-step:is(.started, .finished, .crashed) > .plan-step__header:hover {\n  background-color: #0002;\n}\n.data-status .plan-step:not(.started, .finished, .crashed) > .plan-step__header .plan-step__header-content,\n.data-status .plan-step:not(.started, .finished, .crashed) > .plan-step__header .plan-step__header-status {\n  filter: brightness(.65) contrast(.1);\n}\n.data-status .plan-step > .plan-step__header .plan-step__header-status {\n  display: inline-block;\n  box-sizing: border-box;\n  height: 10px;\n  margin-top: -1px;\n  margin-right: 1ex;\n  aspect-ratio: 1/1;\n  border: 1px solid currentColor;\n  border-radius: 50%;\n  background-clip: content-box;\n  background-color: transparent;\n}\n.data-status .plan-step.started > .plan-step__header .plan-step__header-status {\n  --spinner-color: #a88d16;\n  border-width: 0px;\n  background:\n    radial-gradient(\n      farthest-side,\n      var(--spinner-color) 94%,\n      #0000) top / 1px 1px no-repeat,\n    conic-gradient(#0000 30%, var(--spinner-color));\n  -webkit-mask:\n    radial-gradient(\n      farthest-side,\n      #0000 calc(100% - 1px),\n      #000 0);\n  mask:\n    radial-gradient(\n      farthest-side,\n      #0000 calc(100% - 1px),\n      #000 0);\n  animation: 1.25s infinite linear discovery-loader-processing;\n}\n:host([darkmode]) .data-status .plan-step.started > .plan-step__header .plan-step__header-status {\n  --spinner-color: #d8d431;\n}\n.data-status .plan-step.finished > .plan-step__header .plan-step__header-status {\n  background: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 8">%0A    <path fill="%23fff6" d="M6.564.75l-3.59 3.612-1.538-1.55L0 4.26l2.974 2.99L8 2.193z"/>%0A</svg>%0A\') no-repeat center #1e7d1e;\n  background-size: 6px;\n  transform: scale(1.2);\n  border-color: #28701a;\n  filter: brightness(1.4);\n}\n:host([darkmode]) .data-status .plan-step.finished > .plan-step__header .plan-step__header-status {\n  background-color: #146614;\n  border-color: #1f880b;\n  filter: none;\n}\n.data-status .plan-step.crashed > .plan-step__header .plan-step__header-status {\n  background: #e05f5fab;\n  border-color: #b97d7d;\n  transition: .5s ease-in-out;\n  transition-property: border, background-color;\n}\n.data-status .plan-step > .plan-step__header .plan-step__header-toggle {\n  order: -1;\n  height: 100%;\n  width: 20px;\n  text-align: center;\n  filter: brightness(.75);\n}\n.data-status .plan-step > .plan-step__header:hover .plan-step__header-toggle,\n.data-status .plan-step:not(.collapsed) > .plan-step__header .plan-step__header-toggle {\n  filter: brightness(1);\n}\n.data-status .plan-step:not(.has-output, :not(.collapsed)) > .plan-step__header:not(:hover) .plan-step__header-toggle {\n  visibility: hidden;\n}\n.data-status .plan-step > .plan-step__header .plan-step__header-toggle::before {\n  content: "";\n  background: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">%0A    <path fill="%23888" d="M 3.71875 7.78125 L 2.28125 9.21875 L 11.28125 18.21875 L 12 18.90625 L 12.71875 18.21875 L 21.71875 9.21875 L 20.28125 7.78125 L 12 16.0625 Z "/>%0A</svg>%0A\') no-repeat center;\n  background-size: 11px;\n  transition: transform .15s ease-out;\n  width: 12px;\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n  transform: rotate(-90deg);\n}\n.data-status .plan-step:not(.collapsed) > .plan-step__header .plan-step__header-toggle::before {\n  transform: rotate(0deg);\n}\n.data-status .plan-step > .plan-step__header .plan-step__header-summary {\n  order: 3;\n  padding: 2px 6px;\n  margin-left: 12px;\n  background-color: #8882;\n  color: #888;\n  border-radius: 3px;\n  opacity: 1;\n  transition: opacity .5s ease-in;\n}\n:host([darkmode]) .data-status .plan-step > .plan-step__header .plan-step__header-summary {\n  background-color: #0003;\n}\n.data-status .plan-step > .plan-step__header .plan-step__header-summary:empty {\n  opacity: 0;\n  visibility: hidden;\n}\n.data-status .plan-step > .plan-step__header .plan-step__elapsed-time {\n  opacity: .5;\n  margin-left: 12px;\n  padding-top: 1px;\n  font-size: 11px;\n}\n.data-status .plan-step > .plan-step__content {\n  min-height: 1em;\n  margin: 2px 0 2px 24px;\n  padding: .25em 0 .25em 12px;\n  border-left: 1px solid #888;\n  line-height: 1.4;\n}\n.data-status .plan-step > .plan-step__content > .stdout {\n  filter: brightness(.8) contrast(.1);\n}\n.data-status .plan-step > .plan-step__content:empty::before {\n  content: "No output";\n  filter: brightness(.65) contrast(.1);\n  font-style: italic;\n}\n.data-status .plan-step.collapsed > .plan-step__content {\n  display: none;\n}\n@keyframes discovery-loader-processing {\n  to {\n    transform: rotate(1turn);\n  }\n}\n\n/* discovery-cli:default/model-loader.css */\n</style>\n    \n    \n    \n    <style>\n        html,\n        body {\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            border: none;\n            -webkit-text-size-adjust: 100%;\n        }\n        .discovery {\n            height: 100vh;\n        }\n    </style>\n</head>\n<body>\n    <noscript type="discovery-noscript">\n        <style>body { margin: 16px }</style>\n        <p>Sorry, but this page requires JavaScript to display properly.</p>\n        <p>Please enable JavaScript in your browser settings or upgrade to a browser that supports JavaScript.</p>\n    </noscript>\n    <script>(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod2) => function __require() {\n    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === "object" || typeof from === "function") {\n      for (let key2 of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key2) && key2 !== except)\n          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. "__esModule" has not been set), then set\n    // "default" to the CommonJS "module.exports" for node compatibility.\n    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,\n    mod2\n  ));\n  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);\n\n  // discovery-cli:default/encodings.js\n  var encodings_default;\n  var init_encodings = __esm({\n    "discovery-cli:default/encodings.js"() {\n      encodings_default = [];\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/publisher.js\n  var Publisher;\n  var init_publisher = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/publisher.js"() {\n      Publisher = class {\n        static setValue(publisher, value) {\n          if (!publisher.shouldPublish(value, publisher.value)) {\n            return false;\n          }\n          const callbacks = [];\n          let cursor = publisher.subscriber;\n          publisher.value = value;\n          while (cursor !== null) {\n            const { callback, thisArg } = cursor;\n            if (callback !== null) {\n              callbacks.push(callback.call(thisArg, value, () => publisher.unsubscribe(callback, thisArg)));\n            }\n            cursor = cursor.subscriber;\n          }\n          return callbacks;\n        }\n        constructor(initValue, shouldPublish) {\n          this.value = initValue;\n          this.shouldPublish = typeof shouldPublish === "function" ? shouldPublish : this.shouldPublish;\n          this.subscriber = null;\n        }\n        get readonly() {\n          const host = this;\n          return {\n            subscribe: this.subscribe.bind(this),\n            subscribeSync: this.subscribeSync.bind(this),\n            unsubscribe: this.unsubscribe.bind(this),\n            get value() {\n              return host.value;\n            }\n          };\n        }\n        subscribe(callback, thisArg) {\n          this.subscriber = {\n            callback,\n            thisArg,\n            subscriber: this.subscriber\n          };\n          return () => this.unsubscribe(callback, thisArg);\n        }\n        subscribeSync(callback, thisArg) {\n          const unsubscribe = this.subscribe(callback, thisArg);\n          callback.call(thisArg, this.value, unsubscribe);\n          return unsubscribe;\n        }\n        unsubscribe(callback, thisArg) {\n          let prev = this;\n          let cursor = this.subscriber;\n          while (cursor !== null) {\n            if (cursor.callback === callback && cursor.thisArg === thisArg) {\n              cursor.callback = null;\n              cursor.thisArg = null;\n              prev.subscriber = cursor.subscriber;\n              break;\n            }\n            prev = cursor;\n            cursor = cursor.subscriber;\n          }\n        }\n        shouldPublish(newValue, oldValue) {\n          return newValue !== oldValue;\n        }\n        set(value) {\n          return this.constructor.setValue(this, value) !== false;\n        }\n        asyncSet(value) {\n          const callbacks = this.constructor.setValue(this, value);\n          return callbacks === false ? Promise.resolve(false) : Promise.all(callbacks).then((res) => res !== false);\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/dom.js\n  var dom_exports = {};\n  __export(dom_exports, {\n    createElement: () => createElement,\n    createFragment: () => createFragment,\n    createText: () => createText,\n    passiveCaptureOptions: () => passiveCaptureOptions,\n    passiveSupported: () => passiveSupported\n  });\n  function createElement(tag, attrs, children) {\n    const el = document.createElement(tag);\n    if (typeof attrs === "string") {\n      attrs = {\n        class: attrs\n      };\n    }\n    for (let attrName in attrs) {\n      if (hasOwnProperty.call(attrs, attrName)) {\n        if (attrs[attrName] === void 0) {\n          continue;\n        }\n        if (attrName.startsWith("on")) {\n          el.addEventListener(attrName.substr(2), attrs[attrName]);\n        } else {\n          el.setAttribute(attrName, attrs[attrName]);\n        }\n      }\n    }\n    if (Array.isArray(children)) {\n      children.forEach(\n        (child) => el.appendChild(child instanceof Node ? child : createText(child))\n      );\n    } else if (typeof children === "string") {\n      el.innerHTML = children;\n    }\n    return el;\n  }\n  function createText(text) {\n    return document.createTextNode(String(text));\n  }\n  function createFragment(...children) {\n    const fragment = document.createDocumentFragment();\n    children.forEach(\n      (child) => fragment.appendChild(child instanceof Node ? child : createText(child))\n    );\n    return fragment;\n  }\n  var passiveSupported, passiveCaptureOptions;\n  var init_dom = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/dom.js"() {\n      passiveSupported = (() => {\n        let passiveSupported2 = false;\n        try {\n          const options2 = {\n            // This function will be called when the browser\n            // attempts to access the passive property.\n            get passive() {\n              passiveSupported2 = true;\n              return false;\n            }\n          };\n          window.addEventListener("test", null, options2);\n          window.removeEventListener("test", null, options2);\n        } catch (err) {\n        }\n        return passiveSupported2;\n      })();\n      passiveCaptureOptions = !passiveSupported ? true : Object.freeze({\n        passive: true,\n        capture: true\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/progressbar.js\n  function decodeStageProgress(stage, progress) {\n    const { value, title: stageTitle, duration: duration2 } = loadStages[stage];\n    let progressValue = 0;\n    let progressText = null;\n    if (progress) {\n      const {\n        done,\n        elapsed,\n        units,\n        completed,\n        total\n      } = progress;\n      if (total) {\n        progressValue = done ? 1 : completed / total;\n        progressText = units === "bytes" ? Math.round(progressValue * 100) + "%" : `${completed}/${total}`;\n      } else {\n        progressValue = done ? 1 : 0.1 + Math.min(0.9, elapsed / 2e4);\n        progressText = units === "bytes" ? (completed / (1024 * 1024)).toFixed(1) + "MB" : completed;\n      }\n    }\n    return {\n      stageTitle,\n      progressValue: value + progressValue * duration2,\n      progressText,\n      title: progressText ? `${stageTitle} (${progressText})...` : stage !== "done" ? `${stageTitle}...` : stageTitle\n    };\n  }\n  var loadStages, int, ensureFunction, letRepaintIfNeeded, Progressbar;\n  var init_progressbar = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/progressbar.js"() {\n      init_publisher();\n      init_dom();\n      loadStages = {\n        request: {\n          value: 0,\n          title: "Awaiting data"\n        },\n        receive: {\n          value: 0.1,\n          title: "Receiving data"\n        },\n        received: {\n          value: 0.9,\n          title: "Await app ready"\n        },\n        prepare: {\n          value: 0.925,\n          title: "Processing data (prepare)"\n        },\n        initui: {\n          value: 0.975,\n          title: "Rendering UI"\n        },\n        done: {\n          value: 1,\n          title: "Done!"\n        },\n        error: {\n          value: 1,\n          title: "Error!"\n        }\n      };\n      Object.values(loadStages).forEach((item, idx, array) => {\n        item.duration = (idx !== array.length - 1 ? array[idx + 1].value : 0) - item.value;\n      });\n      int = (value) => value | 0;\n      ensureFunction = (value) => typeof value === "function" ? value : () => {\n      };\n      letRepaintIfNeeded = async () => {\n        await new Promise((resolve) => setTimeout(resolve, 1));\n        if (!document.hidden) {\n          return Promise.race([\n            new Promise(requestAnimationFrame),\n            new Promise((resolve) => setTimeout(resolve, 8))\n          ]);\n        }\n      };\n      Progressbar = class extends Publisher {\n        constructor({ onTiming, onFinish, delay, domReady }) {\n          super({ stage: null, progress: null, error: null });\n          this.finished = false;\n          this.awaitRepaint = null;\n          this.lastStage = "created";\n          this.lastStageStart = null;\n          this.timings = [];\n          this.onTiming = ensureFunction(onTiming);\n          this.onFinish = ensureFunction(onFinish);\n          this.appearanceDelay = delay === true ? 200 : Number(delay) || 0;\n          this.domReady = domReady || Promise.resolve();\n          this.el = createElement("div", "view-progress init", [\n            createElement("div", "title"),\n            createElement("div", "progress")\n          ]);\n        }\n        recordTiming(stage, start, end = performance.now()) {\n          const entry = {\n            stage,\n            title: loadStages[stage].title,\n            duration: int(end - start)\n          };\n          this.timings.push(entry);\n          this.onTiming(entry);\n        }\n        async setState(state) {\n          const { stage, progress, error } = state;\n          if (this.finished) {\n            return;\n          }\n          if (error) {\n            this.set(\n              "stage" in state ? { stage, progress, error } : { ...this.value, error }\n            );\n            this.finish(error);\n            return;\n          }\n          this.set(state);\n          const stageChanged = stage !== this.lastStage;\n          const now = performance.now();\n          if (this.lastStage === "created") {\n            this.startTime = now;\n            this.domReady.then(() => {\n              const appearanceDelay = Math.max(0, this.appearanceDelay - int(performance.now() - now));\n              if (appearanceDelay) {\n                this.el.style.setProperty("--appearance-delay", `${appearanceDelay}ms`);\n              }\n              getComputedStyle(this.el).opacity;\n              this.el.classList.remove("init");\n            });\n          }\n          if (stageChanged) {\n            if (this.lastStageStart !== null) {\n              this.recordTiming(this.lastStage, this.lastStageStart, now);\n            }\n            this.lastStage = stage;\n            this.lastStageStart = now;\n            this.awaitRepaint = now;\n          }\n          const { title, progressValue } = decodeStageProgress(stage, progress);\n          this.el.querySelector(".title").textContent = title;\n          this.el.style.setProperty("--progress", progressValue);\n          if (stageChanged || now - this.awaitRepaint > 65 && now - this.lastStageStart > 200) {\n            await letRepaintIfNeeded();\n            this.awaitRepaint = performance.now();\n          }\n        }\n        finish(error) {\n          if (!this.finished) {\n            this.finished = true;\n            if (this.lastStageStart !== null) {\n              this.recordTiming(\n                this.lastStage,\n                this.lastStageStart\n              );\n            }\n            this.recordTiming(error ? "error" : "done", this.startTime);\n            this.onFinish(this.timings);\n            this.set({ stage: "done" });\n          }\n        }\n        dispose() {\n          this.finish();\n          this.el.remove();\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/stream-from-blob.js\n  function findFallback() {\n    try {\n      new ReadableStream({ type: "bytes" });\n      return fullStreamSupportFallback;\n    } catch (e) {\n      try {\n        new ReadableStream({});\n        return basicStreamSupportFallback;\n      } catch (e2) {\n        try {\n          new Response(new Blob()).body.getReader();\n          return fetchTransformFallback;\n        } catch (e3) {\n        }\n      }\n    }\n    return noFallback;\n  }\n  function arrayBufferFromBlob(blob) {\n    if (typeof blob.arrayBuffer === "function") {\n      return blob.arrayBuffer();\n    }\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onload = reader.onerror = ({ type }) => {\n        reader.onload = reader.onerror = null;\n        if (type === "load") {\n          resolve(reader.result || reader);\n        } else {\n          reject(new Error("Failed to read the blob/file"));\n        }\n      };\n    });\n  }\n  function fullStreamSupportFallback(blob) {\n    let position = 0;\n    return new ReadableStream({\n      type: "bytes",\n      autoAllocateChunkSize: 512 * 1024,\n      pull(controller) {\n        const view = controller.byobRequest.view;\n        const chunk = blob.slice(position, position + view.byteLength);\n        return arrayBufferFromBlob(chunk).then((buffer) => {\n          const uint8array = new Uint8Array(buffer);\n          const bytesRead = uint8array.byteLength;\n          position += bytesRead;\n          view.set(uint8array);\n          controller.byobRequest.respond(bytesRead);\n          if (position >= blob.size) {\n            controller.close();\n          }\n        });\n      }\n    });\n  }\n  function basicStreamSupportFallback(blob) {\n    let position = 0;\n    return new ReadableStream({\n      pull(controller) {\n        const chunk = blob.slice(position, position + 512 * 1024);\n        return arrayBufferFromBlob(chunk).then((buffer) => {\n          position += buffer.byteLength;\n          controller.enqueue(new Uint8Array(buffer));\n          if (position == blob.size) {\n            controller.close();\n          }\n        });\n      }\n    });\n  }\n  function fetchTransformFallback(blob) {\n    return new Response(blob).body;\n  }\n  function noFallback() {\n    throw new Error("Blob#stream() is not supported and no fallback can be applied, include https://github.com/MattiasBuelens/web-streams-polyfill");\n  }\n  var streamFromBlob;\n  var init_stream_from_blob = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/stream-from-blob.js"() {\n      streamFromBlob = typeof new Blob().stream === "function" ? (blob) => blob.stream() : findFallback();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/encodings/utils.js\n  function validateEncodingConfig(config) {\n    if (!config || typeof config !== "object") {\n      return "value is not an object";\n    }\n    const { name, test: test2, decode: decode2 } = config;\n    if (typeof name !== "string") {\n      return "missed name";\n    }\n    if (typeof test2 !== "function") {\n      return "missed test function";\n    }\n    if (typeof decode2 !== "function") {\n      return "missed decode function";\n    }\n    return false;\n  }\n  function normalizeEncodingConfig(config) {\n    const error = validateEncodingConfig(config);\n    if (error) {\n      throw new Error(`Bad encoding config${config?.name ? ` "${config.name}"` : ""}: ${error}`);\n    }\n    const { name, test: test2, streaming, decode: decode2 } = config;\n    return Object.freeze({\n      name: name || "unknown",\n      test: test2,\n      streaming: Boolean(streaming),\n      decode: decode2\n    });\n  }\n  function normalizeEncodings(encodings) {\n    if (!encodings) {\n      return [];\n    }\n    if (!Array.isArray(encodings)) {\n      throw new Error("Encodings must be an array");\n    }\n    return encodings.map(normalizeEncodingConfig);\n  }\n  var init_utils = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/encodings/utils.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/json-ext/src/utils.js\n  var require_utils = __commonJS({\n    "node_modules/@discoveryjs/json-ext/src/utils.js"(exports, module) {\n      var PrimitiveType = 1;\n      var ObjectType = 2;\n      var ArrayType = 3;\n      var PromiseType = 4;\n      var ReadableStringType = 5;\n      var ReadableObjectType = 6;\n      var escapableCharCodeSubstitution = {\n        // JSON Single Character Escape Sequences\n        8: "\\\\b",\n        9: "\\\\t",\n        10: "\\\\n",\n        12: "\\\\f",\n        13: "\\\\r",\n        34: \'\\\\"\',\n        92: "\\\\\\\\"\n      };\n      function isLeadingSurrogate(code) {\n        return code >= 55296 && code <= 56319;\n      }\n      function isTrailingSurrogate(code) {\n        return code >= 56320 && code <= 57343;\n      }\n      function isReadableStream(value) {\n        return typeof value.pipe === "function" && typeof value._read === "function" && typeof value._readableState === "object" && value._readableState !== null;\n      }\n      function replaceValue(holder, key2, value, replacer) {\n        if (value && typeof value.toJSON === "function") {\n          value = value.toJSON();\n        }\n        if (replacer !== null) {\n          value = replacer.call(holder, String(key2), value);\n        }\n        switch (typeof value) {\n          case "function":\n          case "symbol":\n            value = void 0;\n            break;\n          case "object":\n            if (value !== null) {\n              const cls = value.constructor;\n              if (cls === String || cls === Number || cls === Boolean) {\n                value = value.valueOf();\n              }\n            }\n            break;\n        }\n        return value;\n      }\n      function getTypeNative(value) {\n        if (value === null || typeof value !== "object") {\n          return PrimitiveType;\n        }\n        if (Array.isArray(value)) {\n          return ArrayType;\n        }\n        return ObjectType;\n      }\n      function getTypeAsync(value) {\n        if (value === null || typeof value !== "object") {\n          return PrimitiveType;\n        }\n        if (typeof value.then === "function") {\n          return PromiseType;\n        }\n        if (isReadableStream(value)) {\n          return value._readableState.objectMode ? ReadableObjectType : ReadableStringType;\n        }\n        if (Array.isArray(value)) {\n          return ArrayType;\n        }\n        return ObjectType;\n      }\n      function normalizeReplacer(replacer) {\n        if (typeof replacer === "function") {\n          return replacer;\n        }\n        if (Array.isArray(replacer)) {\n          const allowlist = new Set(\n            replacer.map((item) => {\n              const cls = item && item.constructor;\n              return cls === String || cls === Number ? String(item) : null;\n            }).filter((item) => typeof item === "string")\n          );\n          return [...allowlist];\n        }\n        return null;\n      }\n      function normalizeSpace(space) {\n        if (typeof space === "number") {\n          if (!Number.isFinite(space) || space < 1) {\n            return false;\n          }\n          return " ".repeat(Math.min(space, 10));\n        }\n        if (typeof space === "string") {\n          return space.slice(0, 10) || false;\n        }\n        return false;\n      }\n      module.exports = {\n        escapableCharCodeSubstitution,\n        isLeadingSurrogate,\n        isTrailingSurrogate,\n        type: {\n          PRIMITIVE: PrimitiveType,\n          PROMISE: PromiseType,\n          ARRAY: ArrayType,\n          OBJECT: ObjectType,\n          STRING_STREAM: ReadableStringType,\n          OBJECT_STREAM: ReadableObjectType\n        },\n        isReadableStream,\n        replaceValue,\n        getTypeNative,\n        getTypeAsync,\n        normalizeReplacer,\n        normalizeSpace\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/json-ext/src/text-decoder-browser.js\n  var require_text_decoder_browser = __commonJS({\n    "node_modules/@discoveryjs/json-ext/src/text-decoder-browser.js"(exports, module) {\n      module.exports = TextDecoder;\n    }\n  });\n\n  // node_modules/@discoveryjs/json-ext/src/parse-chunked.js\n  var require_parse_chunked = __commonJS({\n    "node_modules/@discoveryjs/json-ext/src/parse-chunked.js"(exports, module) {\n      var { isReadableStream } = require_utils();\n      var TextDecoder2 = require_text_decoder_browser();\n      var STACK_OBJECT = 1;\n      var STACK_ARRAY = 2;\n      var decoder = new TextDecoder2();\n      function isObject4(value) {\n        return value !== null && typeof value === "object";\n      }\n      function adjustPosition(error, parser3) {\n        if (error.name === "SyntaxError" && parser3.jsonParseOffset) {\n          error.message = error.message.replace(\n            /at position (\\d+)/,\n            (_, pos) => "at position " + (Number(pos) + parser3.jsonParseOffset)\n          );\n        }\n        return error;\n      }\n      function append(array, elements) {\n        const initialLength = array.length;\n        array.length += elements.length;\n        for (let i = 0; i < elements.length; i++) {\n          array[initialLength + i] = elements[i];\n        }\n      }\n      module.exports = function(chunkEmitter) {\n        let parser3 = new ChunkParser();\n        if (isObject4(chunkEmitter) && isReadableStream(chunkEmitter)) {\n          return new Promise((resolve, reject) => {\n            chunkEmitter.on("data", (chunk) => {\n              try {\n                parser3.push(chunk);\n              } catch (e) {\n                reject(adjustPosition(e, parser3));\n                parser3 = null;\n              }\n            }).on("error", (e) => {\n              parser3 = null;\n              reject(e);\n            }).on("end", () => {\n              try {\n                resolve(parser3.finish());\n              } catch (e) {\n                reject(adjustPosition(e, parser3));\n              } finally {\n                parser3 = null;\n              }\n            });\n          });\n        }\n        if (typeof chunkEmitter === "function") {\n          const iterator = chunkEmitter();\n          if (isObject4(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n            return new Promise(async (resolve, reject) => {\n              try {\n                for await (const chunk of iterator) {\n                  parser3.push(chunk);\n                }\n                resolve(parser3.finish());\n              } catch (e) {\n                reject(adjustPosition(e, parser3));\n              } finally {\n                parser3 = null;\n              }\n            });\n          }\n        }\n        throw new Error(\n          "Chunk emitter should be readable stream, generator, async generator or function returning an iterable object"\n        );\n      };\n      var ChunkParser = class {\n        constructor() {\n          this.value = void 0;\n          this.valueStack = null;\n          this.stack = new Array(100);\n          this.lastFlushDepth = 0;\n          this.flushDepth = 0;\n          this.stateString = false;\n          this.stateStringEscape = false;\n          this.pendingByteSeq = null;\n          this.pendingChunk = null;\n          this.chunkOffset = 0;\n          this.jsonParseOffset = 0;\n        }\n        parseAndAppend(fragment, wrap) {\n          if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n            if (wrap) {\n              this.jsonParseOffset--;\n              fragment = "{" + fragment + "}";\n            }\n            Object.assign(this.valueStack.value, JSON.parse(fragment));\n          } else {\n            if (wrap) {\n              this.jsonParseOffset--;\n              fragment = "[" + fragment + "]";\n            }\n            append(this.valueStack.value, JSON.parse(fragment));\n          }\n        }\n        prepareAddition(fragment) {\n          const { value } = this.valueStack;\n          const expectComma = Array.isArray(value) ? value.length !== 0 : Object.keys(value).length !== 0;\n          if (expectComma) {\n            if (fragment[0] === ",") {\n              this.jsonParseOffset++;\n              return fragment.slice(1);\n            }\n            if (fragment[0] !== "}" && fragment[0] !== "]") {\n              this.jsonParseOffset -= 3;\n              return "[[]" + fragment;\n            }\n          }\n          return fragment;\n        }\n        flush(chunk, start, end) {\n          let fragment = chunk.slice(start, end);\n          this.jsonParseOffset = this.chunkOffset + start;\n          if (this.pendingChunk !== null) {\n            fragment = this.pendingChunk + fragment;\n            this.jsonParseOffset -= this.pendingChunk.length;\n            this.pendingChunk = null;\n          }\n          if (this.flushDepth === this.lastFlushDepth) {\n            if (this.flushDepth > 0) {\n              this.parseAndAppend(this.prepareAddition(fragment), true);\n            } else {\n              this.value = JSON.parse(fragment);\n              this.valueStack = {\n                value: this.value,\n                prev: null\n              };\n            }\n          } else if (this.flushDepth > this.lastFlushDepth) {\n            for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n              fragment += this.stack[i] === STACK_OBJECT ? "}" : "]";\n            }\n            if (this.lastFlushDepth === 0) {\n              this.value = JSON.parse(fragment);\n              this.valueStack = {\n                value: this.value,\n                prev: null\n              };\n            } else {\n              this.parseAndAppend(this.prepareAddition(fragment), true);\n            }\n            for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n              let value = this.valueStack.value;\n              if (this.stack[i - 1] === STACK_OBJECT) {\n                let key2;\n                for (key2 in value)\n                  ;\n                value = value[key2];\n              } else {\n                value = value[value.length - 1];\n              }\n              this.valueStack = {\n                value,\n                prev: this.valueStack\n              };\n            }\n          } else {\n            fragment = this.prepareAddition(fragment);\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n              this.jsonParseOffset--;\n              fragment = (this.stack[i] === STACK_OBJECT ? "{" : "[") + fragment;\n            }\n            this.parseAndAppend(fragment, false);\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n              this.valueStack = this.valueStack.prev;\n            }\n          }\n          this.lastFlushDepth = this.flushDepth;\n        }\n        push(chunk) {\n          if (typeof chunk !== "string") {\n            if (this.pendingByteSeq !== null) {\n              const origRawChunk = chunk;\n              chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n              chunk.set(this.pendingByteSeq);\n              chunk.set(origRawChunk, this.pendingByteSeq.length);\n              this.pendingByteSeq = null;\n            }\n            if (chunk[chunk.length - 1] > 127) {\n              for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n                const byte = chunk[chunk.length - 1 - seqLength];\n                if (byte >> 6 === 3) {\n                  seqLength++;\n                  if (seqLength !== 4 && byte >> 3 === 30 || seqLength !== 3 && byte >> 4 === 14 || seqLength !== 2 && byte >> 5 === 6) {\n                    this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n                    chunk = chunk.slice(0, -seqLength);\n                  }\n                  break;\n                }\n              }\n            }\n            chunk = decoder.decode(chunk);\n          }\n          const chunkLength = chunk.length;\n          let lastFlushPoint = 0;\n          let flushPoint = 0;\n          scan:\n            for (let i = 0; i < chunkLength; i++) {\n              if (this.stateString) {\n                for (; i < chunkLength; i++) {\n                  if (this.stateStringEscape) {\n                    this.stateStringEscape = false;\n                  } else {\n                    switch (chunk.charCodeAt(i)) {\n                      case 34:\n                        this.stateString = false;\n                        continue scan;\n                      case 92:\n                        this.stateStringEscape = true;\n                    }\n                  }\n                }\n                break;\n              }\n              switch (chunk.charCodeAt(i)) {\n                case 34:\n                  this.stateString = true;\n                  this.stateStringEscape = false;\n                  break;\n                case 44:\n                  flushPoint = i;\n                  break;\n                case 123:\n                  flushPoint = i + 1;\n                  this.stack[this.flushDepth++] = STACK_OBJECT;\n                  break;\n                case 91:\n                  flushPoint = i + 1;\n                  this.stack[this.flushDepth++] = STACK_ARRAY;\n                  break;\n                case 93:\n                case 125:\n                  flushPoint = i + 1;\n                  this.flushDepth--;\n                  if (this.flushDepth < this.lastFlushDepth) {\n                    this.flush(chunk, lastFlushPoint, flushPoint);\n                    lastFlushPoint = flushPoint;\n                  }\n                  break;\n                case 9:\n                case 10:\n                case 13:\n                case 32:\n                  if (lastFlushPoint === i) {\n                    lastFlushPoint++;\n                  }\n                  if (flushPoint === i) {\n                    flushPoint++;\n                  }\n                  break;\n              }\n            }\n          if (flushPoint > lastFlushPoint) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n          }\n          if (flushPoint < chunkLength) {\n            if (this.pendingChunk !== null) {\n              this.pendingChunk += chunk;\n            } else {\n              this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n            }\n          }\n          this.chunkOffset += chunkLength;\n        }\n        finish() {\n          if (this.pendingChunk !== null) {\n            this.flush("", 0, 0);\n            this.pendingChunk = null;\n          }\n          return this.value;\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/encodings/json.js\n  var import_parse_chunked, json_default;\n  var init_json = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/encodings/json.js"() {\n      import_parse_chunked = __toESM(require_parse_chunked(), 1);\n      json_default = Object.freeze({\n        name: "json",\n        test: () => true,\n        streaming: true,\n        decode: (iterator) => (0, import_parse_chunked.default)(() => iterator)\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/encodings/jsonxl-snapshot9.js\n  function G(e, t) {\n    switch (t) {\n      case X:\n        return e.readUint8();\n      case F:\n        return e.readUint16();\n      case K:\n        return e.readUint24();\n      case j:\n        return e.readUint32();\n      case Q:\n        return e.readUintVar();\n      case W:\n        return e.readInt8();\n      case J:\n        return e.readInt16();\n      case $:\n        return e.readInt24();\n      case z:\n        return e.readInt32();\n      case Z:\n        return e.readIntVar();\n      case q:\n        return e.readFloat32();\n      case H:\n        return e.readFloat64();\n    }\n  }\n  function yt(e) {\n    let t = e.readUint8();\n    switch (t & 15) {\n      case nt:\n      case V:\n      case st:\n      case rt:\n        t |= e.readUint8() << 8;\n        break;\n    }\n    return t;\n  }\n  function h(e, t = e.readVlq()) {\n    let n = yt(e);\n    return L(e, n, t);\n  }\n  function L(e, t, n, r = new Array(n)) {\n    let u = t & 15, a = t & 48, _ = n, x = 0, l = 0;\n    switch (a) {\n      case ot: {\n        x = r[0] = e.readIntVar(), _--, l = 1;\n        break;\n      }\n      case it: {\n        x = e.readIntVar();\n        break;\n      }\n    }\n    switch (u) {\n      case Nt: {\n        for (let s = 0; s < _; s++)\n          r[l + s] = e.readVlq();\n        break;\n      }\n      case lt: {\n        for (let s = 0; s < _; s++)\n          r[l + s] = e.readIntVar();\n        break;\n      }\n      case xt: {\n        let s = e.readBytes(Math.ceil(_ / 2));\n        for (let i = 0, f = 0; i < _; i++)\n          f = i & 1 ? f >> 4 : s[i >> 1], r[l + i] = f & 8 ? e.readVlq() * 8 + (f & 7) : f & 7;\n        break;\n      }\n      case ut: {\n        let s = e.readBytes(Math.ceil(_ / 2));\n        for (let i = 0, f = 0; i < _; i++) {\n          f = i & 1 ? f >> 4 : s[i >> 1];\n          let o = f & 4 ? -1 : 1;\n          r[l + i] = f & 8 ? o * (e.readVlq() * 4 + (f & 3)) : o * (f & 3);\n        }\n        break;\n      }\n      case st: {\n        let s = t >> 8, i = (1 << s) - 1, f = e.readBytes(Math.ceil(_ * s / 8)), o = 0, I = 0, c = 0;\n        for (let U = 0; U < _; U++) {\n          for (; I < s; )\n            c |= f[o] << I, I += 8, o++;\n          r[l + U] = c & i, c >>= s, I -= s;\n        }\n        break;\n      }\n      case rt: {\n        let s = t >> 8, i = (1 << s) - 1, f = e.readBytes(Math.ceil(_ * s / 8)), o = 0, I = 0, c = 0;\n        for (let U = 0; U < _; U++) {\n          for (; I < s; )\n            c |= f[o] << I, I += 8, o++;\n          r[l + U] = c & 1 ? -((c & i) >> 1) : (c & i) >> 1, c >>= s, I -= s;\n        }\n        break;\n      }\n      case pt: {\n        let s = r[0] = e.readIntVar(), i = e.readIntVar();\n        for (let f = 1; f < n; f++)\n          s = r[f] = s + i;\n        break;\n      }\n      case nt:\n      case V: {\n        let s = u === V, i = t >> 8, f = s ? t & et | i & tt : i;\n        if (D[i] > 1) {\n          let I = e.readTypeIndex(_, f);\n          for (let c = 0; c < _; c++)\n            r[l + c] = G(e, I[c]);\n        } else {\n          let I = 31 - Math.clz32(f);\n          for (let c = 0; c < _; c++)\n            r[l + c] = G(e, I);\n        }\n        break;\n      }\n      default:\n        throw new Error(`Unknown numeric array encoding method: ${u}`);\n    }\n    switch (a) {\n      case ot: {\n        r[0] = x;\n        for (let s = 1; s < n; s++)\n          r[s] += r[s - 1];\n        break;\n      }\n      case it: {\n        for (let s = 0; s < n; s++)\n          r[s] += x;\n        break;\n      }\n    }\n    return r;\n  }\n  function bt(e) {\n    if (e.readBytes(8).some((u, a) => u !== _t[a]))\n      throw new Error("Bad magic number");\n    let n = e.readUint16();\n    if (n !== k)\n      throw new Error(`Unsupported jsonxl version "${n}", expected "${k}"`);\n    let r = e.readUint16();\n    return { version: n, flags: r };\n  }\n  function Ot(e) {\n    let t = mt.decode(e.readBytes(e.readVlq())), n = h(e), r = h(e), u = h(e), a = h(e), _ = new Array(n), x = 0;\n    for (let l = 0, s = 0, i = 0, f = 0, o = ""; l < n.length; l++) {\n      let I = n[l], c = t.slice(s, s += I >> 2);\n      I & 2 && (c = o.slice(0, r[i++]) + c), I & 1 && (c = c + o.slice(-u[f++])), _[l] = c, o = c;\n    }\n    return { readStrings(l, s) {\n      return a.slice(l, s).map((i) => _[i]);\n    }, readString() {\n      return _[a[x++]];\n    } };\n  }\n  function wt(e) {\n    let t = h(e), n = 0;\n    return function() {\n      return t[n++];\n    };\n  }\n  function Yt(e) {\n    let t = h(e), n = h(e), r = 0;\n    return function() {\n      return t[n[r++]];\n    };\n  }\n  function Ct(e, t) {\n    let n = e.readVlq(), r = e.readVlq();\n    if (n === 0)\n      return () => null;\n    let u = r ? t(-r) : [], a = new Array(n);\n    for (let _ = 0; _ < n; _++)\n      a[_] = { dict: h(e), refs: h(e), index: 0 };\n    return function(x) {\n      let l = a[x], s = l.refs[l.index++], i = l.dict[s];\n      return i === 0 ? null : { key: u[i >> 8], type: i & 255 };\n    };\n  }\n  function Tt(e, t) {\n    let n = 0;\n    for (let r = 0; r < e.length; r++)\n      e[r] === t && n++;\n    return n;\n  }\n  function jt(e) {\n    function t(o = {}) {\n      let I = 0, c;\n      for (; c = i(I++); )\n        o[c.key] = u(c.type);\n      return o;\n    }\n    function n(o = l()) {\n      if (o === 0)\n        return [];\n      let I = s(), c = I >> 16, U = I & 65535, At = c & 1, dt = c >> 5 & 1, Et = c >> 9 & 1, d = c >> 1 & 255 | (c & 1) << 4, R = new Array(o), T = D[d] > 1 ? a.readTypeIndex(o, d, true) : null;\n      if (d & ct)\n        if (T === null)\n          R.fill(r(d));\n        else\n          for (let N = 0; N < o; N++)\n            T[N] & ct && (R[N] = r(T[N]));\n      if (d & O)\n        for (let N = 0; N < o; N++)\n          (T === null || T[N] === O) && (R[N] = x());\n      if (d & m)\n        if (d === m)\n          L(a, U, o, R);\n        else {\n          let N = Tt(T, m), p = L(a, U, N);\n          for (let E = 0, A = 0; E < o; E++)\n            T[E] === m && (R[E] = p[A++]);\n        }\n      if (d & y)\n        if (Et) {\n          let N = d === y ? o : Tt(T, y), p = h(a, N), E = n();\n          for (let A = 0, S = 0, w = 0; A < o; A++)\n            (T === null || T[A] === y) && (R[A] = E.slice(w, w += p[S++]));\n        } else\n          for (let N = 0; N < o; N++)\n            (T === null || T[N] === y) && (R[N] = n());\n      if (d & b) {\n        let N = d === b ? R : [];\n        for (let p = 0, E = 0; p < o; p++)\n          (T === null || T[p] === b) && (R[p] = N[E++] = {});\n        if (dt) {\n          let p = a.readVlq(), E = new Array(p);\n          for (let A = 0; A < p; A++)\n            E[A] = x();\n          for (let A = 0; A < p; A++) {\n            let S = E[A], w = n(N.length);\n            for (let Y = 0; Y < N.length; Y++)\n              w[Y] !== void 0 && (N[Y][S] = w[Y]);\n          }\n        }\n        if (At)\n          for (let p = 0; p < N.length; p++)\n            t(N[p]);\n      }\n      return R;\n    }\n    function r(o) {\n      switch (o) {\n        default:\n          return;\n        case C:\n          return null;\n        case O:\n          return x();\n        case P:\n          return true;\n        case M:\n          return false;\n      }\n    }\n    function u(o) {\n      switch (B[o & 7]) {\n        case v:\n          return;\n        case C:\n          return null;\n        case O:\n          return x();\n        case m:\n          return G(a, o >> 3);\n        case b:\n          return t();\n        case P:\n          return true;\n        case M:\n          return false;\n        case y:\n          return n();\n      }\n    }\n    let a = new g(e);\n    bt(a);\n    let { readStrings: _, readString: x } = Ot(a), l = wt(a), s = Yt(a), i = Ct(a, _), f = u(a.readUint8());\n    if (a.pos !== e.byteLength)\n      throw new Error("End of input not reached");\n    return f;\n  }\n  var _t, k, at, It, v, C, m, O, b, P, M, y, X, F, K, j, Q, q, H, ht, W, J, $, z, Z, Ut, Pt, tt, Mt, et, Vt, nt, V, Nt, lt, xt, ut, st, rt, pt, ot, it, Bt, ct, Rt, B, D, Dt, gt, ft, g, mt;\n  var init_jsonxl_snapshot9 = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/encodings/jsonxl-snapshot9.js"() {\n      _t = new Uint8Array([0, 0, 74, 83, 79, 78, 88, 76]);\n      k = 9;\n      at = 268435455;\n      It = 4294967295;\n      v = 1 << 0;\n      C = 1 << 1;\n      m = 1 << 2;\n      O = 1 << 3;\n      b = 1 << 4;\n      P = 1 << 5;\n      M = 1 << 6;\n      y = 1 << 7;\n      X = 0;\n      F = 1;\n      K = 2;\n      j = 3;\n      Q = 4;\n      q = 5;\n      H = 6;\n      ht = 7;\n      W = 8;\n      J = 9;\n      $ = 10;\n      z = 11;\n      Z = 12;\n      Ut = 31;\n      Pt = ~Ut;\n      tt = 224;\n      Mt = ~tt;\n      et = 7936;\n      Vt = ~et;\n      nt = 0;\n      V = 1;\n      Nt = 2;\n      lt = 3;\n      xt = 4;\n      ut = 5;\n      st = 6;\n      rt = 7;\n      pt = 8;\n      ot = 16;\n      it = 32;\n      Bt = ~b;\n      ct = C | P | M;\n      Rt = new Uint8Array(256);\n      B = new Uint8Array(8).map((e, t) => (Rt[1 << t] = t, 1 << t));\n      D = new Uint8Array(256).map((e, t) => {\n        for (let n = 0; n < 8; n++)\n          e += t >> n & 1;\n        return e;\n      });\n      Dt = Object.fromEntries(Object.entries({ TYPE_UNDEF: v, TYPE_TRUE: P, TYPE_FALSE: M, TYPE_NULL: C, TYPE_NUMBER: m, TYPE_STRING: O, TYPE_OBJECT: b, TYPE_ARRAY: y }).map(([e, t]) => [t, e]));\n      gt = Object.fromEntries(Object.entries({ UINT_8: X, UINT_16: F, UINT_24: K, UINT_32: j, UINT_32_VAR: Q, INT_8: W, INT_16: J, INT_24: $, INT_32: z, INT_32_VAR: Z, FLOAT_32: q, FLOAT_64: H, DECIMAL: ht }).map(([e, t]) => [t, e]));\n      ft = new Uint8Array(32);\n      g = class {\n        constructor(t) {\n          this.view = new DataView(t.buffer, t.byteOffset, t.byteLength), this.bytes = t, this.pos = 0;\n        }\n        readBytes(t) {\n          return this.bytes.subarray(this.pos, this.pos += t);\n        }\n        readTypeIndex(t, n, r) {\n          let u = 0, a = 0;\n          for (; n > 0; )\n            n & 1 && (ft[u++] = a), a++, n >>= 1;\n          let _ = new Uint8Array(t), x = 32 - Math.clz32(u - 1), l = (1 << x) - 1, s = this.readBytes(Math.ceil(x * t / 8)), i = 0, f = 0, o = 0;\n          for (let I = 0; I < t; I++)\n            f < x && (o |= s[i] << f, f += 8, i++), _[I] = r ? B[ft[o & l]] : ft[o & l], o >>= x, f -= x;\n          return _;\n        }\n        readVlq() {\n          let t = this.view.getUint8(this.pos);\n          if ((t & 1) === 0)\n            t = t >> 1, this.pos += 1;\n          else if ((t & 2) === 0)\n            t = this.view.getUint8(this.pos + 1) << 6 | t >> 2, this.pos += 2;\n          else if ((t & 4) === 0)\n            t = this.view.getUint16(this.pos + 1, true) << 5 | t >> 3, this.pos += 3;\n          else {\n            let n = this.view.getUint32(this.pos, true);\n            t = n >>> 3 & at, this.pos += 4, n >>> 31 && (t += this.readUintVar() * (1 << 28));\n          }\n          return t;\n        }\n        readUintVar() {\n          let t = this.view.getUint8(this.pos++), n = t & 127, r = 128;\n          for (; t & 128; )\n            t = this.view.getUint8(this.pos++), n += (t & 127) * r, r *= 128;\n          return n;\n        }\n        readIntVar() {\n          let t = this.readUintVar();\n          return t & 1 ? -(t - 1) / 2 : t <= It ? t >>> 1 : t / 2;\n        }\n        readUint8() {\n          let t = this.view.getUint8(this.pos);\n          return this.pos++, t;\n        }\n        readInt8() {\n          let t = this.view.getInt8(this.pos);\n          return this.pos++, t;\n        }\n        readUint16() {\n          let t = this.view.getUint16(this.pos, true);\n          return this.pos += 2, t;\n        }\n        readInt16() {\n          let t = this.view.getInt16(this.pos, true);\n          return this.pos += 2, t;\n        }\n        readUint24() {\n          let t = this.view.getUint16(this.pos, true) | this.view.getUint8(this.pos + 2) << 16;\n          return this.pos += 3, t;\n        }\n        readInt24() {\n          let t = this.view.getUint16(this.pos, true), n = this.view.getUint8(this.pos + 2), r = n & 128 ? -(16777215 - (t | n << 16) + 1) : t | n << 16;\n          return this.pos += 3, r;\n        }\n        readUint32() {\n          let t = this.view.getUint32(this.pos, true);\n          return this.pos += 4, t;\n        }\n        readInt32() {\n          let t = this.view.getInt32(this.pos, true);\n          return this.pos += 4, t;\n        }\n        readFloat32() {\n          let t = this.view.getFloat32(this.pos);\n          return this.pos += 4, t;\n        }\n        readFloat64() {\n          let t = this.view.getFloat64(this.pos);\n          return this.pos += 8, t;\n        }\n      };\n      mt = new TextDecoder("utf8", { ignoreBOM: true });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/encodings/jsonxl.js\n  function test(chunk) {\n    return JSONXL_MAGIC_NUMBER.every((code, idx) => code === chunk[idx]);\n  }\n  var JSONXL_MAGIC_NUMBER, jsonxl_default;\n  var init_jsonxl = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/encodings/jsonxl.js"() {\n      init_jsonxl_snapshot9();\n      JSONXL_MAGIC_NUMBER = [0, 0, 74, 83, 79, 78, 88, 76];\n      jsonxl_default = Object.freeze({\n        name: "jsonxl/snapshot9",\n        test,\n        streaming: false,\n        decode: jt\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/encodings/index.js\n  var init_encodings2 = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/encodings/index.js"() {\n      init_json();\n      init_jsonxl();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/load-data.js\n  var load_data_exports = {};\n  __export(load_data_exports, {\n    createLoadDataState: () => createLoadDataState,\n    dataFromStream: () => dataFromStream,\n    dataSource: () => dataSource,\n    extractResourceMetadata: () => extractResourceMetadata,\n    getReadableStreamFromSource: () => getReadableStreamFromSource,\n    loadDataFromEvent: () => loadDataFromEvent,\n    loadDataFromFile: () => loadDataFromFile,\n    loadDataFromPush: () => loadDataFromPush,\n    loadDataFromStream: () => loadDataFromStream,\n    loadDataFromUrl: () => loadDataFromUrl,\n    syncLoaderWithProgressbar: () => syncLoaderWithProgressbar\n  });\n  function isObject(value) {\n    return value !== null && typeof value === "object";\n  }\n  function isSameOrigin(url) {\n    try {\n      return new URL(url, location.origin).origin === location.origin;\n    } catch (e) {\n      return false;\n    }\n  }\n  function defaultFetchOk(response) {\n    return response.ok;\n  }\n  function defaultFetchContentEncodedSize(response) {\n    return response.headers.get("x-file-encoded-size") || response.headers.get("content-length");\n  }\n  function defaultFetchContentSize(response) {\n    return response.headers.get("x-file-size") || (isSameOrigin(response.url) && !response.headers.get("content-encoding") ? response.headers.get("content-length") : void 0);\n  }\n  function defaultFetchContentCreatedAt(response) {\n    return response.headers.get("x-file-created-at") || response.headers.get("last-modified");\n  }\n  function isDiscoveryCliLegacyDataWrapper(input) {\n    const keys = input ? Object.keys(input) : [];\n    const expectedKeys = ["name", "createdAt", "elapsedTime", "data"];\n    if (keys.length !== 4 || keys.some((key2) => !expectedKeys.includes(key2))) {\n      return false;\n    }\n    return true;\n  }\n  function buildDataset(rawData, rawResource, rawMeta, { encoding, size }) {\n    if (isDiscoveryCliLegacyDataWrapper(rawData)) {\n      const { data: data2, ...rawDataMeta } = rawData;\n      rawData = data2;\n      rawResource = { ...rawResource, createdAt: data2.createdAt };\n      rawMeta = rawDataMeta;\n    }\n    const data = rawData;\n    const meta = rawMeta || {};\n    const { type, name, encoding: ignore1, size: ignore2, encodedSize, createdAt, ...restResource } = rawResource;\n    const resource = {\n      type: type || "unknown",\n      name: name || "unknown",\n      encoding,\n      size,\n      ...encodedSize ? { encodedSize } : null,\n      createdAt: new Date(Date.parse(createdAt) || Date.now()),\n      ...restResource\n    };\n    return {\n      resource,\n      meta,\n      data\n    };\n  }\n  async function consumeChunksAsSingleTypedArray(iterator) {\n    const chunks = [];\n    let totalLength = 0;\n    for await (const chunk of iterator) {\n      chunks.push(chunk);\n      totalLength += chunk.byteLength;\n    }\n    const combinedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of chunks) {\n      combinedChunks.set(array, offset);\n      offset += array.length;\n    }\n    return combinedChunks;\n  }\n  function dataFromStream(stream, extraEncodings, totalSize, setProgress) {\n    const CHUNK_SIZE = 1024 * 1024;\n    const reader = stream.getReader();\n    const streamStartTime = Date.now();\n    const encodings = [\n      ...normalizeEncodings(extraEncodings),\n      jsonxl_default,\n      json_default\n    ];\n    let encoding = "unknown";\n    let size = 0;\n    const streamConsumer = async function* (firstChunk) {\n      while (true) {\n        const { value, done } = firstChunk || await reader.read();\n        firstChunk = void 0;\n        if (done) {\n          await setProgress({\n            done: true,\n            elapsed: Date.now() - streamStartTime,\n            units: "bytes",\n            completed: size,\n            total: totalSize\n          });\n          break;\n        }\n        for (let offset = 0; offset < value.length; offset += CHUNK_SIZE) {\n          const chunk = offset === 0 && value.length - offset < CHUNK_SIZE ? value : value.slice(offset, offset + CHUNK_SIZE);\n          size += chunk.length;\n          yield chunk;\n          await setProgress({\n            done: false,\n            elapsed: Date.now() - streamStartTime,\n            units: "bytes",\n            completed: size,\n            total: totalSize\n          });\n        }\n      }\n    };\n    return reader.read().then((firstChunk) => {\n      for (const { name, test: test2, streaming, decode: decode2 } of encodings) {\n        if (test2(firstChunk.value, firstChunk.done)) {\n          encoding = name;\n          return streaming ? decode2(streamConsumer(firstChunk)) : consumeChunksAsSingleTypedArray(streamConsumer(firstChunk)).then(decode2);\n        }\n      }\n      throw new Error("No matched encoding found for the payload");\n    }).finally(() => reader.releaseLock()).then((data) => ({ data, encoding, size }));\n  }\n  async function loadDataFromStreamInternal(request, progress) {\n    const stage = async (stage2, fn) => {\n      await progress.asyncSet({ stage: stage2 });\n      return await fn();\n    };\n    try {\n      const requestStart = /* @__PURE__ */ new Date();\n      const {\n        method,\n        stream,\n        resource: rawResource,\n        options: options2,\n        data: explicitData\n      } = await stage("request", request);\n      const responseStart = /* @__PURE__ */ new Date();\n      const payloadSize = rawResource?.size;\n      const { validateData, encodings } = options2 || {};\n      const { data: rawData, encoding, size } = explicitData ? { data: explicitData } : await stage(\n        "receive",\n        () => dataFromStream(stream, encodings, Number(payloadSize) || 0, (state) => progress.asyncSet({\n          stage: "receive",\n          progress: state\n        }))\n      );\n      const validationStart = /* @__PURE__ */ new Date();\n      if (typeof validateData === "function") {\n        validateData(data);\n      }\n      const finishingStart = /* @__PURE__ */ new Date();\n      await progress.asyncSet({ stage: "received" });\n      const finishedTime = /* @__PURE__ */ new Date();\n      const { data, resource, meta } = buildDataset(rawData, rawResource, null, { size, encoding });\n      return {\n        loadMethod: method,\n        resource,\n        meta,\n        data,\n        timing: {\n          time: finishedTime - requestStart,\n          start: requestStart,\n          end: finishedTime,\n          requestTime: responseStart - requestStart,\n          requestStart,\n          requestEnd: responseStart,\n          responseTime: validationStart - responseStart,\n          responseStart,\n          responseEnd: validationStart,\n          validateTime: finishingStart - validationStart,\n          validationStart,\n          validationEnd: finishingStart\n        }\n      };\n    } catch (error) {\n      console.error("[Discovery] Error loading data:", error);\n      await progress.asyncSet({ stage: "error", error });\n      throw error;\n    }\n  }\n  function createLoadDataState(request, extra) {\n    const state = new Publisher();\n    return {\n      state,\n      // encapsulate logic into separate function since it\'s async,\n      // but we need to return publisher for progress tracking purposes\n      result: loadDataFromStreamInternal(request, state),\n      ...extra\n    };\n  }\n  function loadDataFromStream(stream, options2) {\n    return createLoadDataState(\n      () => ({\n        method: "stream",\n        stream,\n        resource: options2?.resource,\n        options: options2\n      })\n    );\n  }\n  function loadDataFromFile(file, options2) {\n    const resource = extractResourceMetadata(file);\n    return createLoadDataState(\n      () => {\n        return {\n          method: "file",\n          stream: streamFromBlob(file),\n          resource: options2?.resource || resource,\n          // options.resource takes precedence over an extracted resource\n          options: options2\n        };\n      },\n      { title: "Load data from file: " + (resource.name || "unknown") }\n    );\n  }\n  function loadDataFromEvent(event, options2) {\n    const source = event.dataTransfer || event.target;\n    const file = source && source.files && source.files[0];\n    event.stopPropagation();\n    event.preventDefault();\n    if (!file) {\n      throw new Error("Can\'t extract a file from an event object");\n    }\n    return loadDataFromFile(file, options2);\n  }\n  function loadDataFromUrl(url, options2) {\n    options2 = options2 || {};\n    return createLoadDataState(\n      async () => {\n        const response = await fetch(url, options2.fetch);\n        const resource = extractResourceMetadata(response, options2);\n        if (resource) {\n          return {\n            method: "fetch",\n            stream: response.body,\n            resource: options2.resource || resource,\n            // options.resource takes precedence over an extracted resource\n            options: options2\n          };\n        }\n        const contentType = response.headers.get("content-type") || "";\n        let error = await response.text();\n        if (contentType.toLowerCase().startsWith("application/json")) {\n          try {\n            const json = JSON.parse(error);\n            error = json.error || json;\n          } catch {\n          }\n        }\n        error = new Error(error);\n        error.stack = null;\n        throw error;\n      },\n      { title: `Load data from url: ${url}` }\n    );\n  }\n  function loadDataFromPush(options2) {\n    let controller;\n    const stream = new ReadableStream({\n      start(controller_) {\n        controller = controller_;\n      },\n      cancel() {\n        controller = null;\n      }\n    });\n    let resolveRequest;\n    let pushResource;\n    const request = new Promise((resolve) => {\n      resolveRequest = (resource) => resolve({\n        method: "push",\n        stream,\n        resource: (pushResource = resource) || options2.resource,\n        // resource takes precedence over options.resource\n        options: options2\n      }) || (resolveRequest = () => {\n      });\n    });\n    options2 = options2 || {};\n    return createLoadDataState(\n      () => request,\n      {\n        start(resource) {\n          resolveRequest(resource);\n        },\n        push(chunk) {\n          resolveRequest();\n          controller.enqueue(chunk);\n        },\n        // error(error) {\n        //     rejectRequest(error);\n        // },\n        finish(encodedSize) {\n          controller.close();\n          controller = null;\n          if (isFinite(encodedSize) && pushResource) {\n            pushResource.encodedSize = Number(encodedSize);\n          }\n        }\n      }\n    );\n  }\n  function syncLoaderWithProgressbar({ result, state }, progressbar) {\n    return new Promise(\n      (resolve, reject) => state.subscribeSync(({ stage, progress, error }, unsubscribe) => {\n        if (error) {\n          unsubscribe();\n          reject(error);\n          return;\n        }\n        if (stage === "received") {\n          unsubscribe();\n          resolve(result);\n        }\n        return progressbar.setState({ stage, progress });\n      })\n    );\n  }\n  function extractResourceMetadata(source, options2) {\n    if (source instanceof Response) {\n      const isResponseOk = options2?.isResponseOk || defaultFetchOk;\n      const getContentSize = options2?.getContentSize || defaultFetchContentSize;\n      const getContentEncodedSize = options2?.getContentEncodedSize || defaultFetchContentEncodedSize;\n      const getContentCreatedAt = options2?.getContentSize || defaultFetchContentCreatedAt;\n      if (isResponseOk(source)) {\n        return {\n          type: "url",\n          name: source.url,\n          size: Number(getContentSize(source)) || null,\n          encodedSize: Number(getContentEncodedSize(source)),\n          createdAt: getContentCreatedAt(source)\n        };\n      }\n    }\n    if (source instanceof File) {\n      return {\n        type: "file",\n        name: source.name,\n        size: source.size,\n        createdAt: source.lastModified\n      };\n    }\n    if (source instanceof Blob) {\n      return {\n        size: source.size\n      };\n    }\n    if (ArrayBuffer.isView(source)) {\n      return {\n        size: source.byteLength\n      };\n    }\n    if (typeof source === "string") {\n      return {\n        size: source.length\n      };\n    }\n  }\n  function getGeneratorFromSource(source) {\n    if (typeof source === "string" || DataView.isView(source)) {\n      return function* () {\n        yield new TextEncoder().encode(source);\n      };\n    }\n    if (Array.isArray(source)) {\n      if (source.some((elem) => typeof elem !== "string")) {\n        return;\n      }\n    }\n    if (isObject(source)) {\n      if (Symbol.asyncIterator in source) {\n        return source[Symbol.asyncIterator];\n      }\n      if (Symbol.iterator in source) {\n        return source[Symbol.iterator];\n      }\n    }\n  }\n  function getReadableStreamFromSource(source) {\n    if (source instanceof ReadableStream) {\n      return source;\n    }\n    if (source instanceof Response) {\n      return source.body;\n    }\n    if (source instanceof Blob) {\n      return streamFromBlob(source);\n    }\n    return new ReadableStream({\n      start() {\n        const generator = getGeneratorFromSource(source);\n        if (!generator) {\n          throw new Error("Bad value type (can\'t convert to a generator)");\n        }\n        this.iterator = generator();\n      },\n      async pull(controller) {\n        const { value, done } = await this.iterator.next();\n        if (done) {\n          this.iterator = null;\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      },\n      cancel() {\n        this.iterator = null;\n      }\n    });\n  }\n  var dataSource;\n  var init_load_data = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/load-data.js"() {\n      init_publisher();\n      init_stream_from_blob();\n      init_utils();\n      init_encodings2();\n      dataSource = {\n        stream: loadDataFromStream,\n        event: loadDataFromEvent,\n        file: loadDataFromFile,\n        url: loadDataFromUrl,\n        push: loadDataFromPush\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/emitter.js\n  var Emitter;\n  var init_emitter = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/emitter.js"() {\n      Emitter = class {\n        constructor() {\n          this.listeners = /* @__PURE__ */ Object.create(null);\n        }\n        on(event, callback) {\n          this.listeners[event] = {\n            callback,\n            next: this.listeners[event] || null\n          };\n          return this;\n        }\n        once(event, callback) {\n          return this.on(event, function wrapper(...args) {\n            callback.apply(this, args);\n            this.off(event, wrapper);\n          });\n        }\n        off(event, callback) {\n          let cursor = this.listeners[event] || null;\n          let prev = null;\n          while (cursor !== null) {\n            if (cursor.callback === callback) {\n              cursor.callback = null;\n              if (prev) {\n                prev.next = cursor.next;\n              } else {\n                this.listeners[event] = cursor.next;\n              }\n              break;\n            }\n            prev = cursor;\n            cursor = cursor.next;\n          }\n          return this;\n        }\n        emit(event, ...args) {\n          let cursor = this.listeners[event] || null;\n          let hadListeners = false;\n          while (cursor !== null) {\n            if (typeof cursor.callback === "function") {\n              cursor.callback.apply(this, args);\n            }\n            hadListeners = true;\n            cursor = cursor.next;\n          }\n          return hadListeners;\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/persistent.js\n  var persistent_exports = {};\n  __export(persistent_exports, {\n    localStorageEntry: () => localStorageEntry,\n    sessionStorageEntry: () => sessionStorageEntry\n  });\n  function getStorage(type) {\n    const key2 = "__storage_test__" + Math.random();\n    let storage;\n    try {\n      storage = window[type];\n    } catch (e) {\n      return null;\n    }\n    try {\n      storage.setItem(key2, key2);\n      storage.removeItem(key2);\n    } catch (e) {\n      const ok = e instanceof DOMException && // everything except Firefox\n      (e.code === 22 || // Firefox\n      e.code === 1014 || // test name field too, because code might not be present\n      // everything except Firefox\n      e.name === "QuotaExceededError" || // Firefox\n      e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there\'s something already stored\n      storage.length !== 0;\n      if (!ok) {\n        return null;\n      }\n    }\n    return storage;\n  }\n  function getStorageMap(type) {\n    const map2 = /* @__PURE__ */ new Map();\n    map2.storage = getStorage(type);\n    map2.getOrCreate = (key2) => map2.get(key2) || createPersistentKey(key2, map2);\n    map2.getOrCreate.available = map2.storage !== null;\n    return map2;\n  }\n  function createPersistentKey(key2, map2) {\n    let currentValue = null;\n    const emitter = new Emitter();\n    const updateCurrentValue = (newValue = map2.storage.getItem(key2)) => {\n      if (currentValue !== newValue) {\n        emitter.emit("change", currentValue = newValue);\n      }\n    };\n    const api2 = {\n      get value() {\n        return this.get();\n      },\n      get() {\n        return currentValue;\n      },\n      set(value) {\n        if (map2.storage) {\n          map2.storage.setItem(key2, value);\n          updateCurrentValue();\n        }\n      },\n      delete() {\n        if (map2.storage) {\n          map2.storage.removeItem(key2);\n          updateCurrentValue();\n        }\n      },\n      forceSync() {\n        if (map2.storage) {\n          updateCurrentValue();\n        }\n        return this.get();\n      },\n      on(fn, fire) {\n        emitter.on("change", fn);\n        if (fire) {\n          fn(currentValue);\n        }\n        return () => emitter.off("change", fn);\n      },\n      off(fn) {\n        emitter.off("change", fn);\n      }\n    };\n    map2.set(key2, api2);\n    api2.forceSync();\n    return api2;\n  }\n  var storages, sessionStorageEntry, localStorageEntry;\n  var init_persistent = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/persistent.js"() {\n      init_emitter();\n      storages = /* @__PURE__ */ new Map([\n        ["session", getStorageMap("sessionStorage")],\n        ["local", getStorageMap("localStorage")]\n      ]);\n      sessionStorageEntry = storages.get("session").getOrCreate;\n      localStorageEntry = storages.get("local").getOrCreate;\n      addEventListener("storage", (e) => {\n        for (const [, map2] of storages) {\n          if (map2.storage === e.storageArea && map2.has(e.key)) {\n            map2.get(e.key).forceSync();\n          }\n        }\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/darkmode.js\n  function applyPrefersColorScheme() {\n    for (const instance of instances) {\n      if (instance.mode === "auto") {\n        instance.set("auto");\n      }\n    }\n  }\n  function applyLocalStorageValue(value) {\n    const newValue = persistentStorageValueMapping.has(value) ? persistentStorageValueMapping.get(value) : null;\n    if (persistentStorageValue !== newValue) {\n      persistentStorageValue = newValue;\n      for (const instance of instances) {\n        if (instance.persistent && instance.mode !== "disabled" && instance.mode !== "only") {\n          instance.set(newValue !== null ? newValue : "auto");\n        }\n      }\n    }\n  }\n  function resolveInitValue(value, persistent) {\n    if (value === "off" || value === "disable" || !validValues.has(value)) {\n      value = "disabled";\n    }\n    if (value !== "disabled" && value !== "only" && persistent && persistentStorageValue !== null) {\n      value = persistentStorageValue;\n    }\n    return value;\n  }\n  function resolveSetValue(value) {\n    if (!validValues.has(value)) {\n      value = "disabled";\n    }\n    switch (value) {\n      case "only":\n        return true;\n      case "auto":\n        return prefersDarkModeMedia.matches;\n      default:\n        return value === true;\n    }\n  }\n  function resolveDarkmodeValue(value, persistent) {\n    return resolveSetValue(resolveInitValue(value, persistent));\n  }\n  var validValues, instances, prefersDarkModeMedia, persistentStorage, persistentStorageValueMapping, persistentStorageValue, DarkModeController;\n  var init_darkmode = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/darkmode.js"() {\n      init_persistent();\n      validValues = /* @__PURE__ */ new Set([true, false, "auto", "disabled", "only"]);\n      instances = /* @__PURE__ */ new Set();\n      prefersDarkModeMedia = matchMedia("(prefers-color-scheme:dark)");\n      persistentStorage = localStorageEntry("discoveryjs:darkmode");\n      persistentStorageValueMapping = /* @__PURE__ */ new Map([\n        ["true", true],\n        ["false", false],\n        ["auto", "auto"]\n      ]);\n      persistentStorageValue = null;\n      applyLocalStorageValue(persistentStorage.value);\n      persistentStorage.on(applyLocalStorageValue);\n      prefersDarkModeMedia.addListener(applyPrefersColorScheme);\n      DarkModeController = class {\n        constructor(value, persistent) {\n          this.persistent = persistent ? persistentStorage : null;\n          this.handlers = [];\n          this.set(resolveInitValue(value, persistent), true);\n          instances.add(this);\n        }\n        subscribe(fn, fire) {\n          let entry = { fn };\n          this.handlers.push(entry);\n          if (fire) {\n            entry.fn(this.value, this.mode);\n          }\n          return () => {\n            const index = this.handlers.indexOf(entry);\n            entry = null;\n            if (index !== -1) {\n              this.handlers.splice(index, 1);\n            }\n          };\n        }\n        destroy() {\n          instances.delete(this);\n        }\n        set(value, init) {\n          const prevValue = this.value;\n          const prevMode = this.mode;\n          if (!validValues.has(value)) {\n            console.warn(`Bad value "${value}" for darkmode, ${init ? \'fallback to "disabled"\' : "ignored"}`);\n            value = "disabled";\n          }\n          if (!init && (prevMode === "disabled" || value === "disabled" || prevMode === "only" || value === "only")) {\n            return;\n          }\n          this.mode = typeof value === "boolean" ? "manual" : value;\n          this.value = resolveSetValue(value);\n          if (this.mode !== "disabled") {\n            if (this.persistent && !init) {\n              this.persistent.set(this.mode === "auto" ? "auto" : this.value);\n            }\n            if (this.value !== prevValue || this.mode !== prevMode) {\n              this.handlers.forEach(({ fn }) => fn(this.value, this.mode));\n            }\n          }\n        }\n        toggle(useAutoForManual) {\n          switch (this.mode) {\n            case "auto":\n              this.set(!prefersDarkModeMedia.matches);\n              break;\n            case "manual":\n              this.set(useAutoForManual && this.value !== prefersDarkModeMedia.matches ? "auto" : !this.value);\n              break;\n          }\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/container-styles.js\n  var container_styles_exports = {};\n  __export(container_styles_exports, {\n    applyContainerStyles: () => applyContainerStyles,\n    rollbackContainerStyles: () => rollbackContainerStyles\n  });\n  function saveContainerStyleProp(container, prop, styles3) {\n    if (prop in styles3 === false) {\n      styles3[prop] = [\n        container.style.getPropertyValue(prop),\n        container.style.getPropertyPriority(prop)\n      ];\n    }\n  }\n  function applyContainerStyles(container, config) {\n    config = config || {};\n    if (!containerBeforeSetStyle.has(container)) {\n      containerBeforeSetStyle.set(container, /* @__PURE__ */ Object.create(null));\n    }\n    const darkmode = resolveDarkmodeValue(config.darkmode, config.darkmodePersistent);\n    const containerStyles = containerBeforeSetStyle.get(container);\n    for (const [prop, value] of Object.entries(styles)) {\n      if (knowContainer.has(container) || !/^transition/.test(prop)) {\n        saveContainerStyleProp(container, prop, containerStyles);\n        container.style.setProperty(prop, value);\n      }\n    }\n    for (const [prop, value] of Object.entries(darkmodeStyles)) {\n      saveContainerStyleProp(container, prop, containerStyles);\n      if (darkmode) {\n        container.style.setProperty(prop, value);\n      } else {\n        container.style.removeProperty(prop);\n      }\n    }\n    knowContainer.add(container);\n    return darkmode;\n  }\n  function rollbackContainerStyles(container) {\n    if (containerBeforeSetStyle.has(container)) {\n      const containerStyles = containerBeforeSetStyle.get(container);\n      for (const [prop, value] of Object.entries(containerStyles)) {\n        container.style.setProperty(prop, ...value);\n      }\n      containerBeforeSetStyle.delete(containerBeforeSetStyle);\n      knowContainer.delete(container);\n    }\n  }\n  var styles, darkmodeStyles, knowContainer, containerBeforeSetStyle;\n  var init_container_styles = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/container-styles.js"() {\n      init_darkmode();\n      styles = {\n        "font-family": "Tahoma, Verdana, Arial, sans-serif",\n        "font-size": "16px",\n        "line-height": "1.6",\n        "-webkit-text-size-adjust": "none",\n        "text-size-adjust": "none",\n        "background-color": "var(--discovery-background-color, white)",\n        "color": "var(--discovery-color, black)",\n        "transition-property": "background-color, color",\n        "transition-duration": ".25s",\n        "transition-timing-function": "ease-in"\n      };\n      darkmodeStyles = {\n        "--discovery-background-color": "#242424",\n        "--discovery-color": "#cccccc"\n      };\n      knowContainer = /* @__PURE__ */ new WeakSet();\n      containerBeforeSetStyle = /* @__PURE__ */ new WeakMap();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/inject-styles.js\n  function injectStyles(el, styles3) {\n    const foucFix = createElement("style", null, ":host{display:none}");\n    const awaitingStyles = /* @__PURE__ */ new Set();\n    let readyStyles = Promise.resolve();\n    if (Array.isArray(styles3)) {\n      el.append(...styles3.map((style) => {\n        if (typeof style === "string") {\n          style = {\n            type: "style",\n            content: style\n          };\n        }\n        switch (style.type) {\n          case "style":\n          case "inline":\n            return createElement("style", {\n              media: style.media\n            }, style.content);\n          case "link":\n          case "external": {\n            let resolveStyle;\n            let rejectStyle;\n            let state = new Promise((resolve, reject) => {\n              resolveStyle = resolve;\n              rejectStyle = reject;\n            });\n            awaitingStyles.add(state);\n            const linkEl = createElement("link", {\n              rel: "stylesheet",\n              href: style.href,\n              media: style.media,\n              onerror(err) {\n                awaitingStyles.delete(state);\n                rejectStyle(err);\n                if (!awaitingStyles.size) {\n                  foucFix.remove();\n                }\n              },\n              onload() {\n                awaitingStyles.delete(state);\n                resolveStyle();\n                if (!awaitingStyles.size) {\n                  foucFix.remove();\n                }\n              }\n            });\n            return linkEl;\n          }\n          default:\n            throw new Error(`Unknown type "${style.type}" for a style descriptor`);\n        }\n      }));\n      if (awaitingStyles.size) {\n        readyStyles = Promise.all(awaitingStyles);\n        el.append(foucFix);\n      }\n    }\n    return readyStyles;\n  }\n  var init_inject_styles = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/inject-styles.js"() {\n      init_dom();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/id.js\n  function randomId() {\n    return [\n      parseInt(performance.timeOrigin, 10).toString(16),\n      parseInt(1e4 * performance.now(), 10).toString(16),\n      String(Math.random().toString(16).slice(2))\n    ].join("-");\n  }\n  var init_id = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/id.js"() {\n    }\n  });\n\n  // app/prepare/utils.ts\n  function convertToUint32Array(source) {\n    const result = new Uint32Array(source.length);\n    for (let i = 0; i < result.length; i++) {\n      result[i] = source[i];\n    }\n    return result;\n  }\n  function bytesToWasmMemoryPages(bytes) {\n    return Math.ceil(bytes / WASM_PAGE_SIZE);\n  }\n  function decodeBase642(input) {\n    let inputSize = input.length;\n    while (inputSize > 0 && input[inputSize - 1] === "=") {\n      inputSize--;\n    }\n    const output = new Uint8Array(3 * Math.ceil(inputSize / 4));\n    let enc1 = 0;\n    let enc2 = 0;\n    let enc3 = 0;\n    let enc4 = 0;\n    for (let i = 0, j2 = 0; i < inputSize; ) {\n      enc1 = base64map2[input.charCodeAt(i++) & 255];\n      enc2 = base64map2[input.charCodeAt(i++) & 255];\n      enc3 = base64map2[input.charCodeAt(i++) & 255];\n      enc4 = base64map2[input.charCodeAt(i++) & 255];\n      output[j2++] = enc1 << 2 | enc2 >> 4;\n      output[j2++] = enc2 << 4 | enc3 >> 2;\n      output[j2++] = enc3 << 6 | enc4;\n    }\n    return output.subarray(\n      0,\n      // output size:\n      // (length / 4) * 3 +\n      (inputSize >> 2) * 3 + // (length % 4) * 6 / 8\n      (inputSize % 4 * 6 >> 3)\n    );\n  }\n  function findMaxId(nodes2) {\n    let maxId = nodes2[nodes2.length - 1].id;\n    for (let i = 0; i < nodes2.length; i++) {\n      if (nodes2[i].id > maxId) {\n        maxId = nodes2[i].id;\n      }\n    }\n    return maxId;\n  }\n  function remapId(node, index) {\n    node.id = index + 1;\n  }\n  function createMarkTime() {\n    let markTimeTimestamp = Date.now();\n    let markTimeStep = null;\n    return (name) => {\n      const newTimestamp = Date.now();\n      if (markTimeStep !== null) {\n        console.info(">", markTimeStep, newTimestamp - markTimeTimestamp);\n      }\n      markTimeStep = name;\n      markTimeTimestamp = newTimestamp;\n    };\n  }\n  function packageRegistryEndpoints(...endpoints) {\n    return endpoints.map(\n      (enpoint) => typeof enpoint === "string" ? {\n        registry: enpoint,\n        pattern: createRegistryRx("[specifier]")\n      } : {\n        registry: enpoint.registry,\n        pattern: createRegistryRx(enpoint.pattern || "[specifier]")\n      }\n    );\n  }\n  var WASM_PAGE_SIZE, base64alphabet2, base64map2, createRegistryRx;\n  var init_utils2 = __esm({\n    "app/prepare/utils.ts"() {\n      WASM_PAGE_SIZE = 64 * 1024;\n      base64alphabet2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\n      base64map2 = new Uint8Array(256);\n      for (let i = 0; i < base64alphabet2.length; i++) {\n        base64map2[base64alphabet2.charCodeAt(i)] = i;\n      }\n      createRegistryRx = function() {\n        const pkg = "(?<pkg>(?:[^/]+/)?[^/]+?)";\n        const atpkg = "(?<pkg>(?:@[^/]+/)?[^/]+?)";\n        const version3 = "(?:@(?<version>[^/]+))?";\n        const path = "(?:/(?<path>.+))?";\n        const replacements = {\n          specifier: atpkg + version3 + path,\n          pkg,\n          atpkg,\n          version: version3,\n          "/version": "(?:/(?<version>[^/]+))?",\n          path\n        };\n        const replacementsRx = new RegExp(`\\\\[(${Object.keys(replacements).join("|")})\\\\]`, "g");\n        return function createRegistryRx2(pattern) {\n          return new RegExp(`^/${pattern.replace(\n            replacementsRx,\n            (_, name) => replacements[name]\n          )}$`, "d");\n        };\n      }();\n    }\n  });\n\n  // app/prepare/const.ts\n  var TIMINGS, USE_WASM, EMPTY_ARRAY, maxRegExpLength, wellKnownNodeName, knownChromeExtensions, knownRegistry, typeColor, typeColorComponents, typeOrder;\n  var init_const = __esm({\n    "app/prepare/const.ts"() {\n      init_utils2();\n      TIMINGS = false;\n      USE_WASM = true;\n      EMPTY_ARRAY = Object.freeze([]);\n      maxRegExpLength = 65;\n      wellKnownNodeName = /* @__PURE__ */ new Map([\n        ["(root)", "root"],\n        ["(program)", "program"],\n        ["(garbage collector)", "gc"],\n        ["(idle)", "idle"]\n      ]);\n      knownChromeExtensions = {\n        "fmkadmapgofadopljbjfkapdkoienihi": "React Developer Tools",\n        "lmhkpmbekcpmknklioeibfkpmmfibljd": "Redux DevTools",\n        "nhdogjmejiglipccpnnnanhbledajbpd": "Vue.js devtools",\n        "ienfalfjdbdpebioblfackkekamfmbnh": "Angular DevTools",\n        "jdkknkkbebbapilgoeccciglkfbmbnfm": "Apollo Client Devtools",\n        "hcikjlholajopgbgfmmlbmifdfbkijdj": "Rempl",\n        "pamhglogfolfbmlpnenhpeholpnlcclo": "JsonDiscovery",\n        "jlmafbaeoofdegohdhinkhilhclaklkp": "OctoLinker",\n        "dhdgffkkebhmkfjojejmpbldmpobfkfo": "Tampermonkey"\n      };\n      knownRegistry = {\n        "https://jsr.io": { cdn: "jsr", endpoints: packageRegistryEndpoints(\n          { registry: "jsr", pattern: "[atpkg][/version][path]" }\n        ) },\n        "https://npm.jsr.io": { cdn: "jsr", endpoints: packageRegistryEndpoints("npm") },\n        "https://deno.land": { cdn: "denoland", endpoints: packageRegistryEndpoints(\n          { registry: "denoland", pattern: "(?<pkg>std)[version][path]" },\n          { registry: "denoland", pattern: "x/[specifier]" }\n        ) },\n        "https://esm.sh": { cdn: "esmsh", endpoints: packageRegistryEndpoints(\n          { registry: "github", pattern: "v\\\\d+/gh/[pkg][version][path]" },\n          { registry: "npm", pattern: "v\\\\d+/[specifier]" }\n        ) },\n        "https://cdn.jsdelivr.net": { cdn: "jsdelivr", endpoints: packageRegistryEndpoints(\n          { registry: "npm", pattern: "npm/[specifier]" },\n          { registry: "github", pattern: "gh/[pkg][version][path]" }\n        ) },\n        "https://unpkg.com": { cdn: "unpkg", endpoints: packageRegistryEndpoints("npm") },\n        "https://esm.run": { cdn: "jsdelivr", endpoints: packageRegistryEndpoints("npm") },\n        "https://ga.jspm.io": { cdn: "jspm", endpoints: packageRegistryEndpoints(\n          { registry: "npm", pattern: "npm:[specifier]" }\n        ) },\n        "https://cdn.skypack.dev": { cdn: "skypack", endpoints: packageRegistryEndpoints(\n          { registry: "npm", pattern: "-/[pkg][version]-[^\\\\/\\\\-]+?/[^\\\\/]+?,mode=(?<path>.+)" },\n          "npm"\n        ) }\n      };\n      typeColor = {\n        "script": "#fee29ca0",\n        "npm": "#f98e94a0",\n        "github": "#666666a0",\n        "jsr": "#ffee61a0",\n        "denoland": "#ffffffa0",\n        "wasm": "#9481ffa0",\n        "regexp": "#8db2f8a0",\n        "electron": "#9feaf9a0",\n        "deno": "#ffffffa0",\n        // before node, because uses node modules as well\n        "node": "#78b362a0",\n        "internals": "#fcb69aa0",\n        "program": "#edfdd1a0",\n        "chrome-extension": "#7dfacda0",\n        "webpack/runtime": "#888888a0",\n        "gc": "#f1b6fda0",\n        "engine": "#fc9a9aa0",\n        "root": "#444444a0",\n        "idle": "#888888a0",\n        "unknown": "#888888a0"\n      };\n      typeColorComponents = Object.fromEntries(\n        Object.entries(typeColor).map(([type, color]) => [type, [\n          parseInt(color.slice(1, 3), 16),\n          parseInt(color.slice(3, 5), 16),\n          parseInt(color.slice(5, 7), 16)\n        ]])\n      );\n      typeOrder = Object.fromEntries(\n        Object.keys(typeColor).map((type, idx) => [type, idx + 1])\n      );\n    }\n  });\n\n  // app/prepare/formats/cpuprofile.js\n  function isObject2(value) {\n    return typeof value === "object" && value !== null;\n  }\n  function isNode(value) {\n    if (!isObject2(value)) {\n      return false;\n    }\n    if (typeof value.id !== "number") {\n      return false;\n    }\n    if (!isObject2(value.callFrame) || Number.isInteger(value.callFrame.id)) {\n      return false;\n    }\n    return true;\n  }\n  function isArrayLike(value, check) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    return value.length > 0 ? check(value[0]) && (value.length === 1 || check(value[1])) : true;\n  }\n  function isCPUProfile(data) {\n    if (!isObject2(data)) {\n      return false;\n    }\n    if (!isArrayLike(data.nodes, isNode)) {\n      return false;\n    }\n    if (!isArrayLike(data.samples, Number.isInteger)) {\n      return false;\n    }\n    if (!isArrayLike(data.timeDeltas, Number.isInteger)) {\n      return false;\n    }\n    return true;\n  }\n  function convertParentIntoChildrenIfNeeded(data) {\n    const nodes2 = data.nodes;\n    if (nodes2.length < 2 || typeof nodes2[0].parent !== "number" && typeof nodes2[1].parent !== "number") {\n      return;\n    }\n    const nodeWithNoChildrenById = /* @__PURE__ */ new Map();\n    for (const node of data.nodes) {\n      if (!Array.isArray(node.children) || node.children.length === 0) {\n        nodeWithNoChildrenById.set(node.id, node);\n      }\n    }\n    if (nodeWithNoChildrenById.size > 0) {\n      for (const node of data.nodes) {\n        if (typeof node.parent === "number") {\n          const parent = nodeWithNoChildrenById.get(node.parent);\n          if (parent !== void 0) {\n            if (Array.isArray(parent.children)) {\n              parent.children.push(node.id);\n            } else {\n              parent.children = [node.id];\n            }\n          }\n        }\n      }\n    }\n  }\n  var init_cpuprofile = __esm({\n    "app/prepare/formats/cpuprofile.js"() {\n    }\n  });\n\n  // app/prepare/formats/chromium-devtools-enhanced-traces.ts\n  function isDevToolsEnhancedTraces(data) {\n    const { meta } = data || {};\n    if (meta && meta.fileDocumentType === "x-msedge-session-log" && meta.type === "performance") {\n      return true;\n    }\n    return false;\n  }\n  function extractFromDevToolsEnhancedTraces(data) {\n    const scripts = [];\n    const executionContexts = [];\n    for (const script of data.scripts || []) {\n      if (script.sourceText) {\n        scripts.push({\n          id: Number(script.scriptId),\n          url: script.url,\n          source: script.sourceText\n        });\n      }\n    }\n    for (const ctx of data.executionContexts || []) {\n      if (ctx.name) {\n        executionContexts.push({\n          origin: ctx.origin,\n          name: ctx.name\n        });\n      }\n    }\n    const result = {\n      ...data.payload,\n      runtime: "edge",\n      // FIXME: temporary solution, there is no way for now to detect Edge, however this format is supported by Edge only for now\n      executionContexts,\n      scripts\n    };\n    return result;\n  }\n  var init_chromium_devtools_enhanced_traces = __esm({\n    "app/prepare/formats/chromium-devtools-enhanced-traces.ts"() {\n    }\n  });\n\n  // app/prepare/formats/chromium-performance-profile.ts\n  function isChromiumPerformanceProfile(data) {\n    if (!Array.isArray(data)) {\n      return typeof data === "object" && data !== null && "traceEvents" in data ? isChromiumPerformanceProfile(data.traceEvents) : false;\n    }\n    if (data.length === 0) {\n      return true;\n    }\n    const first = data[0];\n    if (!("pid" in first && "tid" in first && "ph" in first && "cat" in first)) {\n      return false;\n    }\n    return true;\n  }\n  function extractFromChromiumPerformanceProfile(events) {\n    const cpuProfileById = /* @__PURE__ */ new Map();\n    const processNameId = /* @__PURE__ */ new Map();\n    if ("traceEvents" in events) {\n      events = events.traceEvents;\n    }\n    events = events.filter(\n      (e) => e.name === "CpuProfile" || e.name === "Profile" || e.name === "ProfileChunk" || e.name === "process_name"\n    ).sort((a, b2) => a.ts - b2.ts);\n    for (const event of events) {\n      if (event.name === "CpuProfile") {\n        const profileId = `${event.pid}:0x1`;\n        const profile = event.args.data.cpuProfile;\n        cpuProfileById.set(profileId, profile);\n      }\n      if (event.name === "Profile") {\n        const profileId = `${event.pid}:${event.id}`;\n        const profile = {\n          name: null,\n          startTime: 0,\n          endTime: 0,\n          nodes: [],\n          samples: [],\n          timeDeltas: [],\n          ...event.args.data\n        };\n        cpuProfileById.set(profileId, profile);\n      }\n      if (event.name === "process_name") {\n        processNameId.set(event.pid, event.args.name);\n      }\n      if (event.name === "ProfileChunk") {\n        const profileId = `${event.pid}:${event.id}`;\n        const cpuProfile = cpuProfileById.get(profileId);\n        const chunk = event.args.data;\n        if (!cpuProfile) {\n          console.warn(`Ignoring ProfileChunk for undeclared Profile with id ${profileId}`);\n          continue;\n        }\n        if (chunk.cpuProfile) {\n          const { nodes: nodes2, samples } = chunk.cpuProfile;\n          if (Array.isArray(nodes2) && nodes2.length > 0) {\n            cpuProfile.nodes.push(...nodes2);\n          }\n          if (samples) {\n            cpuProfile.samples.push(...samples);\n          }\n        }\n        if (chunk.timeDeltas) {\n          cpuProfile.timeDeltas.push(...chunk.timeDeltas);\n        }\n        if (chunk.startTime != null) {\n          cpuProfile.startTime = chunk.startTime;\n        }\n        if (chunk.endTime != null) {\n          cpuProfile.endTime = chunk.endTime;\n        }\n      }\n    }\n    if (cpuProfileById.size === 0) {\n      throw new Error("Could not find CPU profile in Timeline");\n    }\n    const profiles = [];\n    let indexToView = -1;\n    for (const [profileId, profile] of cpuProfileById) {\n      const processName = processNameId.get(parseInt(profileId)) || "Unknown";\n      profile.name = processName;\n      if (processName === "CrRendererMain") {\n        indexToView = profiles.length;\n      }\n      if (!profile.endTime && profile.timeDeltas) {\n        profile.endTime = profile.timeDeltas.reduce(\n          (x, y2) => x + y2,\n          profile.startTime\n        );\n      }\n      profiles.push(profile);\n    }\n    if (indexToView === -1) {\n      indexToView = profiles.reduce(\n        (res, profile, idx, array) => array[res].nodes.length < profile.nodes.length ? idx : res,\n        0\n      );\n    }\n    return {\n      indexToView,\n      profiles\n    };\n  }\n  var init_chromium_performance_profile = __esm({\n    "app/prepare/formats/chromium-performance-profile.ts"() {\n    }\n  });\n\n  // app/prepare/formats/v8-proflog.ts\n  function findBalancePair(str, offset, pattern) {\n    const stack = [];\n    for (let i = offset; i < str.length; i++) {\n      if (stack.length === 0) {\n        if (str[i] === pattern) {\n          return i;\n        }\n      } else if (stack[stack.length - 1] === str[i]) {\n        stack.pop();\n        continue;\n      }\n      switch (str[i]) {\n        case "<":\n          stack.push(">");\n          break;\n        case "(":\n          stack.push(")");\n          break;\n        case "[":\n          stack.push("]");\n          break;\n      }\n    }\n    return str.length;\n  }\n  function cleanupInternalName(name) {\n    name = name.replace(/::\\(.+?\\)/g, "");\n    for (let i = 0; i < name.length; i++) {\n      switch (name[i]) {\n        case "<":\n          name = name.slice(0, i) + name.slice(findBalancePair(name, i + 1, ">") + 1);\n          i--;\n          break;\n        case "(":\n          name = name.slice(0, i) + name.slice(findBalancePair(name, i + 1, ")") + 1);\n          i--;\n          break;\n      }\n    }\n    const wsIndex = name.lastIndexOf(" ");\n    name = wsIndex !== -1 ? name.slice(wsIndex + 1) : name;\n    return name;\n  }\n  function parseName(name) {\n    if (name.startsWith("wasm-function")) {\n      name += " wasm://wasm/" + name;\n    }\n    const nameMatch = name.match(/^(?:get |set )?([#.<>\\[\\]_$a-zA-Z\\xA0-\\uFFFF][#.<>\\[\\]\\-_$a-zA-Z0-9\\xA0-\\uFFFF]*) /);\n    const functionName = nameMatch !== null ? nameMatch[1] : "";\n    const url = nameMatch !== null ? name.slice(nameMatch[0].length) : name[0] === " " ? name.slice(1) : name;\n    return { functionName, url };\n  }\n  function functionTier(kind) {\n    switch (kind) {\n      case "Builtin":\n      case "Ignition":\n      case "Unopt":\n        return "Ignition";\n      case "Baseline":\n      case "Sparkplug":\n        return "Sparkplug";\n      case "Maglev":\n        return "Maglev";\n      case "Turboprop":\n        return "Turboprop";\n      case "Opt":\n      case "Turbofan":\n        return "Turbofan";\n      default:\n        return "Unknown";\n    }\n  }\n  function codeToCallFrameInfo(code) {\n    if (!code || !code.type) {\n      return {\n        name: "(unknown)"\n      };\n    }\n    let name = code.name;\n    let lowlevel = false;\n    switch (code.type) {\n      case "CPP": {\n        if (name[1] === " ") {\n          name = cleanupInternalName(name.slice(2));\n        }\n        break;\n      }\n      case "SHARED_LIB": {\n        name = "(LIB) " + name;\n        lowlevel = true;\n        break;\n      }\n      case "JS": {\n        const { functionName, url } = parseName(name);\n        const locMatch = url.match(/:(\\d+):(\\d+)$/);\n        let file = url;\n        let line = -1;\n        let col = -1;\n        if (locMatch) {\n          file = url.slice(0, -locMatch[0].length);\n          line = parseInt(locMatch[1], 10);\n          col = parseInt(locMatch[2], 10);\n        }\n        return {\n          name: functionName,\n          file,\n          line,\n          col\n        };\n      }\n      case "CODE": {\n        switch (code.kind) {\n          case "LoadIC":\n          case "StoreIC":\n          case "KeyedStoreIC":\n          case "KeyedLoadIC":\n          case "LoadGlobalIC":\n          case "Handler":\n            name = "(IC) " + name;\n            lowlevel = true;\n            break;\n          case "BytecodeHandler":\n            name = "(bytecode) ~" + name;\n            lowlevel = true;\n            break;\n          case "Stub":\n            name = "(stub) " + name;\n            lowlevel = true;\n            break;\n          case "Builtin":\n            name = "(builtin) " + name;\n            lowlevel = true;\n            break;\n          case "RegExp":\n            name = "RegExp: " + name;\n            break;\n        }\n        break;\n      }\n      default: {\n        name = `(${code.type}) ${name}`;\n      }\n    }\n    return { name, lowlevel };\n  }\n  function createCallFrame(functionName, url = "", lineNumber = -1, columnNumber = -1, scriptId = 0, functionId = null) {\n    return {\n      scriptId,\n      functionId,\n      functionName,\n      url,\n      lineNumber,\n      columnNumber\n    };\n  }\n  function createNode(id, callFrame) {\n    return {\n      id,\n      callFrame,\n      children: []\n    };\n  }\n  function isV8Log(data) {\n    if (data && typeof data === "object" && Array.isArray(data.code) && Array.isArray(data.functions) && Array.isArray(data.ticks)) {\n      return true;\n    }\n    return false;\n  }\n  function convertV8LogIntoCpuprofile(v8log) {\n    const scriptIdByUrl = /* @__PURE__ */ new Map([["", 0]]);\n    const getScriptIdByUrl = (url) => scriptIdByUrl.has(url) ? scriptIdByUrl.get(url) : scriptIdByUrl.set(url, scriptIdByUrl.size).size - 1;\n    const vmStateIgnoreStack = new Uint32Array(vmState.length);\n    const vmStateCallFrames = vmState.map(\n      (name) => name !== "js" ? createCallFrame(`(${// https://github.com/v8/v8/blob/2be84efd933f6e1e29b0c508a1035ed7d13d7127/src/profiler/symbolizer.cc#L34\n      name == "other" || name === "external" || name === "logging" ? "program" : name})`) : null\n    );\n    const rootCallFrame = createCallFrame("(root)");\n    const programCallFrame = createCallFrame("(program)");\n    const callFrameById = /* @__PURE__ */ new Map();\n    const rootNode = createNode(1, rootCallFrame);\n    const rootNodeMap = /* @__PURE__ */ new Map();\n    const nodes2 = [rootNode];\n    const nodesTransition = /* @__PURE__ */ new Map([[1, rootNodeMap]]);\n    let nodeIdSeed = 1;\n    let lastTm = 0;\n    const scripts = [];\n    const scriptFunctions = [];\n    const profile = {\n      startTime: 0,\n      endTime: 0,\n      nodes: nodes2,\n      timeDeltas: new Array(v8log.ticks.length),\n      samples: new Array(v8log.ticks.length),\n      scripts,\n      scriptFunctions\n    };\n    vmStateIgnoreStack[VM_STATE_GC] = 1;\n    vmStateIgnoreStack[VM_STATE_IDLE] = 1;\n    v8log.ticks.sort((a, b2) => a.tm - b2.tm);\n    for (let tickIndex = 0; tickIndex < v8log.ticks.length; tickIndex++) {\n      const tick = v8log.ticks[tickIndex];\n      let vmStateCallFrame = vmStateCallFrames[tick.vm];\n      let currentNode = rootNode;\n      let currentNodeMap = rootNodeMap;\n      if (vmStateIgnoreStack[tick.vm] !== 1) {\n        for (let i = tick.s.length - 2; i >= 0; i -= 2) {\n          const id = tick.s[i];\n          if (id === -1) {\n            continue;\n          }\n          let callFrame = callFrameById.get(id);\n          if (callFrame === void 0) {\n            if (id > v8log.code.length) {\n              callFrame = createCallFrame(`0x${id.toString(16)}`);\n            } else {\n              const code = v8log.code[id];\n              if (code.kind === "BytecodeHandler") {\n                if (code.name === "Abort.Wide" || code.name === "Abort.ExtraWide") {\n                  continue;\n                }\n              }\n              const { name, file, line, col, lowlevel } = codeToCallFrameInfo(code);\n              callFrame = lowlevel ? null : createCallFrame(\n                name,\n                file,\n                line,\n                col,\n                code.source ? code.source.script : getScriptIdByUrl(file || ""),\n                typeof code.func === "number" ? code.func : null\n              );\n            }\n            callFrameById.set(id, callFrame);\n          }\n          if (callFrame === null) {\n            continue;\n          }\n          let nextNode = currentNodeMap.get(callFrame);\n          if (nextNode === void 0) {\n            nextNode = createNode(++nodeIdSeed, callFrame);\n            nodes2.push(nextNode);\n            currentNodeMap.set(callFrame, nextNode);\n            currentNode.children.push(nextNode.id);\n            nodesTransition.set(nodeIdSeed, currentNodeMap = /* @__PURE__ */ new Map());\n          } else {\n            currentNodeMap = nodesTransition.get(nextNode.id);\n          }\n          currentNode = nextNode;\n        }\n      }\n      if (vmStateCallFrame === null && currentNode === rootNode) {\n        vmStateCallFrame = programCallFrame;\n      }\n      if (vmStateCallFrame !== null) {\n        let node = currentNodeMap.get(vmStateCallFrame);\n        if (node === void 0) {\n          node = createNode(++nodeIdSeed, vmStateCallFrame);\n          nodes2.push(node);\n          currentNodeMap.set(vmStateCallFrame, node);\n          currentNode.children.push(node.id);\n          nodesTransition.set(nodeIdSeed, /* @__PURE__ */ new Map());\n        }\n        currentNode = node;\n      }\n      profile.samples[tickIndex] = currentNode.id;\n      profile.timeDeltas[tickIndex] = tick.tm - lastTm;\n      lastTm = tick.tm;\n    }\n    profile.endTime = lastTm + profile.timeDeltas.slice().sort()[profile.timeDeltas.length >> 1];\n    const scriptIdToIndex = /* @__PURE__ */ new Map();\n    for (const { id, url, source } of v8log.scripts.filter(Boolean)) {\n      scriptIdToIndex.set(id, scripts.length);\n      scripts.push({\n        id,\n        // treat <unknown> urls as empty strings which is better for futher processing\n        url: url === "<unknown>" ? "" : url[0] === "[" && url[url.length - 1] === "]" ? url.slice(1, -1) : url,\n        source\n      });\n    }\n    for (let i = 0; i < v8log.functions.length; i++) {\n      const fn = v8log.functions[i];\n      const anyFnCode = v8log.code[fn.codes[0]];\n      const source = anyFnCode.source;\n      const { functionName, url } = parseName(anyFnCode.name);\n      const loc = url.match(/\\:(\\d+)\\:(\\d+)/);\n      if (!source) {\n        continue;\n      }\n      scriptFunctions.push({\n        id: i,\n        name: functionName,\n        script: scriptIdToIndex.get(source.script) ?? null,\n        start: source.start,\n        end: source.end,\n        line: loc ? Number(loc[1]) : -1,\n        column: loc ? Number(loc[2]) : -1,\n        states: fn.codes.map((codeIndex) => {\n          const code = v8log.code[codeIndex];\n          const codeSource = code.source || null;\n          return {\n            tm: code.tm || 0,\n            tier: functionTier(code.kind || "Unknown"),\n            positions: codeSource?.positions || "",\n            inlined: codeSource?.inlined || "",\n            fns: codeSource?.fns || []\n          };\n        })\n      });\n    }\n    return profile;\n  }\n  var VM_STATE_GC, VM_STATE_IDLE, vmState;\n  var init_v8_proflog = __esm({\n    "app/prepare/formats/v8-proflog.ts"() {\n      VM_STATE_GC = 1;\n      VM_STATE_IDLE = 7;\n      vmState = [\n        "js",\n        "garbage collector",\n        "parser",\n        "compiler bytecode",\n        "compiler",\n        "other",\n        "external",\n        "idle",\n        "atomics wait",\n        "logging"\n      ];\n    }\n  });\n\n  // app/prepare/index.ts\n  var prepare_exports = {};\n  __export(prepare_exports, {\n    convertValidate: () => convertValidate,\n    supportedFormats: () => supportedFormats,\n    supportedFormatsText: () => supportedFormatsText\n  });\n  function convertValidate(data, rejectData) {\n    let extensions = {};\n    data = data || {};\n    if (isDevToolsEnhancedTraces(data)) {\n      const { traceEvents, runtime, scripts, executionContexts } = extractFromDevToolsEnhancedTraces(data);\n      data = traceEvents;\n      extensions = {\n        runtime,\n        scripts,\n        executionContexts\n      };\n    }\n    if (isChromiumPerformanceProfile(data)) {\n      const result = extractFromChromiumPerformanceProfile(data);\n      data = result.profiles[result.indexToView] || result.profiles[0];\n      if (!data) {\n        rejectData("CPU profile data not found");\n      }\n    } else if (isV8Log(data)) {\n      data = convertV8LogIntoCpuprofile(data);\n    }\n    if (!isCPUProfile(data)) {\n      rejectData("Bad format", {\n        view: "alert-warning",\n        content: [\n          { view: "h3", content: [\n            \'badge:"Error"\',\n            \'text:"Bad format"\'\n          ] },\n          { view: "md", source: [\n            "CPU (pro)file supports the following formats:",\n            ...supportedFormats\n          ] }\n        ]\n      });\n    }\n    convertParentIntoChildrenIfNeeded(data);\n    Object.assign(data, extensions);\n    return data;\n  }\n  var supportedFormats, supportedFormatsText;\n  var init_prepare = __esm({\n    "app/prepare/index.ts"() {\n      init_cpuprofile();\n      init_chromium_devtools_enhanced_traces();\n      init_chromium_performance_profile();\n      init_v8_proflog();\n      supportedFormats = [\n        "* [V8 CPU profile](https://nodejs.org/docs/latest/api/cli.html#--cpu-prof) (.cpuprofile)",\n        "* [V8 log](https://v8.dev/docs/profile) preprocessed with [--preprocess](https://v8.dev/docs/profile#web-ui-for---prof) (.json)",\n        "* [Chromium Performance Profile](https://developer.chrome.com/docs/devtools/performance/reference#save) (.json)",\n        "* [Edge Enhanced Performance Traces](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/experimental-features/share-traces) (.devtools)"\n      ];\n      supportedFormatsText = supportedFormats.map((line) => line.replace(/\\[(.+?)\\]\\(.*?\\)/g, "$1"));\n    }\n  });\n\n  // app/prepare/process-call-frames.ts\n  function resolveCategory(moduleType) {\n    const name = moduleType === "bundle" || moduleType === "webpack/runtime" ? "script" : moduleType;\n    return {\n      ref: name,\n      name\n    };\n  }\n  function resolveRegistryPackage(modulePath) {\n    const moduleUrl = /^https?:\\/\\//.test(modulePath) ? new URL(modulePath) : null;\n    if (moduleUrl !== null && Object.hasOwn(knownRegistry, moduleUrl.origin)) {\n      const registry = knownRegistry[moduleUrl.origin];\n      const registryPath = moduleUrl.pathname;\n      for (const endpoint of registry.endpoints) {\n        const packageMatch = registryPath.match(endpoint.pattern);\n        if (packageMatch !== null) {\n          const packageName = packageMatch.groups?.pkg || "?";\n          const version3 = packageMatch.groups?.version || null;\n          const pathOffset = packageMatch.indices?.groups?.path?.[0] ?? registryPath.length;\n          return {\n            type: "script",\n            name: packageName,\n            path: moduleUrl.origin + (pathOffset !== void 0 ? registryPath.slice(0, pathOffset) : registryPath),\n            version: version3,\n            registry: endpoint.registry,\n            cdn: registry.cdn\n          };\n        }\n      }\n    }\n    if (/\\/node_modules\\//.test(modulePath)) {\n      const pathParts = modulePath.split(/\\/node_modules\\//);\n      const pathLastPart = pathParts.pop() || "";\n      const npmPackageNameMatch = pathLastPart.match(/(?:@[^/]+\\/)?[^/]+/);\n      if (npmPackageNameMatch !== null) {\n        const npmPackageName = npmPackageNameMatch[0];\n        const npmPackagePath = [...pathParts, npmPackageName].join("/node_modules/");\n        return {\n          type: "script",\n          name: npmPackageName,\n          path: npmPackagePath,\n          version: null,\n          registry: "npm",\n          cdn: null\n        };\n      }\n    }\n    return null;\n  }\n  function resolvePackage(cache, moduleRef, nameByOrigin) {\n    let entry = cache.get(moduleRef);\n    if (entry !== void 0) {\n      return entry;\n    }\n    const moduleType = moduleRef.type;\n    let ref = "unknown";\n    let type = "unknown";\n    let name = "(unknown)";\n    let path = null;\n    let version3 = null;\n    let registry = null;\n    let cdn = null;\n    switch (moduleType) {\n      case "script":\n      case "bundle": {\n        const modulePath = moduleRef.path || "";\n        const packageInfo = resolveRegistryPackage(modulePath);\n        if (packageInfo !== null) {\n          ref = packageInfo.path;\n          type = packageInfo.type;\n          name = packageInfo.name;\n          path = packageInfo.path;\n          version3 = packageInfo.version;\n          registry = packageInfo.registry;\n          cdn = packageInfo.cdn;\n        }\n        if (ref === "unknown") {\n          type = "script";\n          if (/^https?:/.test(modulePath)) {\n            const { origin, host } = new URL(modulePath);\n            ref = origin;\n            name = host;\n            path = origin;\n          } else if (modulePath) {\n            const protocolMatch = modulePath.match(/^[a-z\\d]{2,}:/i) || ["file:"];\n            const protocol2 = protocolMatch[0];\n            if (protocol2 !== "file:") {\n              ref = `(${protocol2}script)`;\n              name = ref;\n              path = protocol2;\n            } else {\n              ref = "(script)";\n              name = ref;\n              path = modulePath.slice(0, modulePath.indexOf(":") + 1);\n            }\n          } else {\n            ref = "(compiled script)";\n            name = "(compiled script)";\n          }\n        }\n        break;\n      }\n      case "regexp": {\n        ref = "(regexp)";\n        type = "regexp";\n        name = "(regexp)";\n        path = "";\n        break;\n      }\n      case "node": {\n        ref = "(node)";\n        type = "node";\n        name = "(node.js modules)";\n        path = "node:";\n        break;\n      }\n      case "deno": {\n        ref = "(deno)";\n        type = "deno";\n        name = "(deno modules)";\n        path = "ext:";\n        break;\n      }\n      case "webpack/runtime":\n      case "electron": {\n        ref = `(${moduleType})`;\n        type = moduleType;\n        name = `(${moduleType} modules)`;\n        path = `${moduleType}/`;\n        break;\n      }\n      case "wasm": {\n        ref = "(wasm)";\n        type = "wasm";\n        name = "(wasm)";\n        path = moduleRef.path?.startsWith("wasm://wasm/") ? "wasm://wasm/" : null;\n        break;\n      }\n      case "chrome-extension": {\n        const url = new URL(moduleRef.path || "");\n        ref = url.origin;\n        type = "chrome-extension";\n        name = nameByOrigin.get(url.host) || url.host;\n        path = url.origin;\n        break;\n      }\n      case "root":\n      case "program":\n      case "gc":\n      case "idle":\n      case "internals":\n      case "engine":\n        ref = moduleType;\n        type = moduleType;\n        name = moduleType !== "gc" ? `(${moduleType})` : "(garbage collector)";\n        break;\n    }\n    cache.set(moduleRef, entry = {\n      ref,\n      type,\n      name,\n      path,\n      version: version3,\n      registry,\n      cdn\n    });\n    return entry;\n  }\n  function resolveModule(scriptId, url, functionName, anonymousModuleByScriptId) {\n    const entry = {\n      ref: url || String(scriptId),\n      type: "unknown",\n      name: null,\n      path: null,\n      wellKnown: scriptId === 0 && wellKnownNodeName.get(functionName) || null\n    };\n    if (url === "extensions::SafeBuiltins") {\n      url = "";\n    }\n    if (entry.wellKnown !== null) {\n      entry.ref = functionName;\n      entry.type = entry.wellKnown;\n      entry.name = functionName;\n    } else if (!url || url.startsWith("evalmachine.")) {\n      if (scriptId === 0) {\n        if (functionName.startsWith("RegExp: ")) {\n          entry.ref = "(regexp)";\n          entry.type = "regexp";\n          entry.name = "(regexp)";\n        } else if (functionName === "(parser)" || functionName === "(compiler)" || functionName === "(compiler bytecode)" || functionName === "(atomics wait)") {\n          entry.ref = functionName;\n          entry.type = "engine";\n          entry.name = functionName;\n        } else {\n          entry.type = "internals";\n          entry.name = "(internals)";\n        }\n      } else {\n        let anonymousName = anonymousModuleByScriptId.get(scriptId);\n        if (anonymousName === void 0) {\n          anonymousModuleByScriptId.set(\n            scriptId,\n            anonymousName = `(anonymous module #${anonymousModuleByScriptId.size + 1})`\n          );\n        }\n        entry.type = "script";\n        entry.name = anonymousName;\n      }\n    } else if (url.startsWith("node:electron/") || url.startsWith("electron/")) {\n      entry.type = "electron";\n      entry.path = url;\n    } else if (url.startsWith("webpack/runtime/")) {\n      entry.type = "webpack/runtime";\n      entry.path = url;\n    } else {\n      let protocol2 = (url.match(/^([a-z\\-]+):/i) || [])[1] || "";\n      if (protocol2.length === 1 && /[A-Z]/.test(protocol2)) {\n        protocol2 = "";\n        url = url.slice(2).replace(/\\\\/g, "/");\n      }\n      switch (protocol2) {\n        case "":\n          entry.type = "script";\n          entry.path = "file://" + url;\n          break;\n        case "file":\n        case "http":\n        case "https":\n          entry.type = "script";\n          entry.path = url;\n          break;\n        case "webpack":\n        case "webpack-internal":\n          entry.type = "bundle";\n          entry.path = url.replace(/\\?$/, "");\n          break;\n        case "node":\n        case "chrome-extension":\n        case "wasm":\n          entry.type = protocol2;\n          entry.path = url;\n          break;\n        case "ext":\n          if (/^ext:(core|cli|runtime|deno)/.test(url)) {\n            entry.type = "deno";\n            entry.path = url;\n            break;\n          }\n        default:\n          entry.type = `protocol-${protocol2}`;\n          entry.name = url;\n      }\n    }\n    return entry;\n  }\n  function processCallFrames(callFrames, scripts = [], scriptFunctions = [], executionContexts = []) {\n    const categories = Object.assign(/* @__PURE__ */ new Map(), { unknownTypeOrder: typeOrder.unknown });\n    const packages = /* @__PURE__ */ new Map();\n    const packageRefCache = /* @__PURE__ */ new Map();\n    const modules = /* @__PURE__ */ new Map();\n    const functions = Object.assign(/* @__PURE__ */ new Map(), { anonymous: 0 });\n    const nameByOrigin = new Map([\n      ...executionContexts.map((ctx) => [new URL(ctx.origin).host, ctx.name]),\n      ...Object.entries(knownChromeExtensions)\n    ]);\n    const anonymousModuleByScriptId = /* @__PURE__ */ new Map();\n    const moduleByScriptId = /* @__PURE__ */ new Map();\n    const wellKnownCallFrames = {\n      root: null,\n      program: null,\n      idle: null,\n      gc: null\n    };\n    const inputCallFrames = [...callFrames];\n    for (const fn of scriptFunctions) {\n      const scriptIndex = fn.script;\n      const script = scriptIndex !== null ? scripts[scriptIndex] || null : null;\n      if (script !== null) {\n        inputCallFrames.push({\n          scriptId: script.id,\n          url: script.url,\n          functionName: fn.name,\n          lineNumber: fn.line,\n          columnNumber: fn.column\n        });\n      }\n    }\n    for (const callFrame of inputCallFrames) {\n      const { scriptId, functionName, url, lineNumber, columnNumber } = callFrame;\n      const moduleRef = resolveModule(scriptId, url, functionName, anonymousModuleByScriptId);\n      let callFrameModule = modules.get(moduleRef.ref);\n      if (callFrameModule === void 0) {\n        const categoryRef = resolveCategory(moduleRef.type);\n        let moduleCategory = categories.get(categoryRef.ref);\n        const packageRef = resolvePackage(packageRefCache, moduleRef, nameByOrigin);\n        let modulePackage = packages.get(packageRef.ref);\n        if (moduleCategory === void 0) {\n          categories.set(categoryRef.ref, moduleCategory = {\n            id: typeOrder[categoryRef.name] || categories.unknownTypeOrder++,\n            name: categoryRef.name\n          });\n        }\n        if (modulePackage === void 0) {\n          packages.set(packageRef.ref, modulePackage = {\n            id: packages.size + 1,\n            // starts with 1\n            type: packageRef.type,\n            name: packageRef.name,\n            version: packageRef.version,\n            registry: packageRef.registry,\n            cdn: packageRef.cdn,\n            path: packageRef.path,\n            category: moduleCategory,\n            modules: []\n          });\n        }\n        modules.set(moduleRef.ref, callFrameModule = {\n          id: modules.size + 1,\n          // starts with 1\n          type: moduleRef.type,\n          name: moduleRef.name,\n          path: moduleRef.path,\n          category: moduleCategory,\n          package: modulePackage,\n          packageRelPath: null,\n          functions: []\n        });\n        modulePackage.modules.push(callFrameModule);\n        if (moduleRef.wellKnown !== null) {\n          wellKnownCallFrames[moduleRef.wellKnown] = callFrame;\n        }\n      }\n      const functionRef = `${callFrameModule.id}:${functionName}:${lineNumber}:${columnNumber}`;\n      let callFrameFunction = functions.get(functionRef);\n      if (callFrameFunction === void 0) {\n        const isRegExp3 = callFrameModule.package.type === "regexp";\n        const regexp = isRegExp3 ? functionName.slice("RegExp: ".length) : null;\n        const name = regexp ? regexp.length <= maxRegExpLength ? regexp : `${regexp.slice(0, maxRegExpLength - 1)}\\u2026` : functionName || `(anonymous function #${functions.anonymous++})`;\n        functions.set(functionRef, callFrameFunction = {\n          id: functions.size + 1,\n          // id starts with 1\n          name,\n          category: callFrameModule.category,\n          package: callFrameModule.package,\n          module: callFrameModule,\n          regexp,\n          loc: lineNumber !== -1 && columnNumber !== -1 ? `:${lineNumber}:${columnNumber}` : null\n        });\n        callFrameModule.functions.push(callFrameFunction);\n      }\n      moduleByScriptId.set(callFrame.scriptId, callFrameModule);\n      callFrame.category = callFrameModule.category;\n      callFrame.package = callFrameModule.package;\n      callFrame.module = callFrameModule;\n      callFrame.function = callFrameFunction;\n    }\n    return {\n      categories: [...categories.values()],\n      packages: [...packages.values()],\n      modules: [...modules.values()],\n      functions: [...functions.values()],\n      moduleByScriptId,\n      wellKnownCallFrames\n    };\n  }\n  var init_process_call_frames = __esm({\n    "app/prepare/process-call-frames.ts"() {\n      init_const();\n    }\n  });\n\n  // app/prepare/call-tree.ts\n  var call_tree_exports = {};\n  __export(call_tree_exports, {\n    CallTree: () => CallTree,\n    FocusCallTree: () => FocusCallTree\n  });\n  function makeDictMask(tree, test2) {\n    const { dictionary } = tree;\n    const accept = typeof test2 === "function" ? test2 : (entry) => entry === test2;\n    const mask = new Uint8Array(dictionary.length);\n    for (let i = 0; i < mask.length; i++) {\n      if (accept(dictionary[i])) {\n        mask[i] = 1;\n      }\n    }\n    return mask;\n  }\n  var NULL_ARRAY, CallTree, FocusCallTree;\n  var init_call_tree = __esm({\n    "app/prepare/call-tree.ts"() {\n      NULL_ARRAY = new Uint32Array();\n      CallTree = class {\n        dictionary;\n        // entries\n        sourceIdToNode;\n        // sourceNodeId -> index of nodes\n        sampleIdToNode;\n        // sampleId  -> index of nodes\n        nodes;\n        // nodeIndex -> index of dictionary\n        parent;\n        // nodeIndex -> index of nodes\n        subtreeSize;\n        // nodeIndex -> number of nodes in subtree, 0 when no children\n        nested;\n        // nodeIndex -> index of nodes\n        valueNodes;\n        valueNodesOffset;\n        valueNodesLength;\n        root;\n        entryRefMap;\n        childrenRefMap;\n        constructor(dictionary, sourceIdToNode, nodes2, parent, subtreeSize, nested) {\n          this.dictionary = dictionary;\n          this.sourceIdToNode = sourceIdToNode;\n          this.sampleIdToNode = NULL_ARRAY;\n          this.nodes = nodes2;\n          this.parent = parent || new Uint32Array(nodes2.length);\n          this.subtreeSize = subtreeSize || new Uint32Array(nodes2.length);\n          this.nested = nested || new Uint32Array(nodes2.length);\n          this.valueNodes = new Uint32Array(nodes2.length);\n          this.valueNodesOffset = new Uint32Array(dictionary.length);\n          this.valueNodesLength = new Uint32Array(dictionary.length);\n          this.entryRefMap = /* @__PURE__ */ new Map();\n          this.childrenRefMap = /* @__PURE__ */ new Map();\n          Object.defineProperty(this, "root", {\n            enumerable: true,\n            get: () => this.getEntry(0)\n          });\n        }\n        computeValueNodes() {\n          const { nodes: nodes2, valueNodes, valueNodesLength, valueNodesOffset } = this;\n          for (let i = 0; i < nodes2.length; i++) {\n            valueNodesLength[nodes2[i]]++;\n          }\n          for (let i = 0, offset = 0; i < valueNodesLength.length; i++) {\n            valueNodesOffset[i] = offset;\n            offset += valueNodesLength[i];\n          }\n          for (let i = 0; i < valueNodes.length; i++) {\n            valueNodes[valueNodesOffset[nodes2[i]]++] = i;\n          }\n          for (let i = 0; i < valueNodesLength.length; i++) {\n            valueNodesOffset[i] -= valueNodesLength[i];\n          }\n          return this;\n        }\n        createEntry(nodeIndex) {\n          const entry = {\n            nodeIndex,\n            value: this.dictionary[this.nodes[nodeIndex]],\n            parent: null,\n            subtreeSize: this.subtreeSize[nodeIndex]\n          };\n          if (nodeIndex !== 0) {\n            Object.defineProperty(entry, "parent", {\n              enumerable: true,\n              get: () => this.getEntry(this.parent[nodeIndex])\n            });\n          }\n          if (this.subtreeSize[nodeIndex]) {\n            Object.defineProperty(entry, "children", {\n              enumerable: true,\n              get: () => this.getChildren(nodeIndex)\n            });\n          }\n          return entry;\n        }\n        getEntry(nodeIndex) {\n          const entryRef = this.entryRefMap.get(nodeIndex);\n          let entry;\n          if (entryRef === void 0 || (entry = entryRef.deref()) === void 0) {\n            this.entryRefMap.set(\n              nodeIndex,\n              new WeakRef(entry = this.createEntry(nodeIndex))\n            );\n          }\n          return entry;\n        }\n        getChildren(nodeIndex) {\n          const childrenRef = this.childrenRefMap.get(nodeIndex);\n          let children;\n          if (childrenRef === void 0 || (children = childrenRef.deref()) === void 0) {\n            this.childrenRefMap.set(\n              nodeIndex,\n              new WeakRef(children = [...this.map(this.children(nodeIndex))])\n            );\n          }\n          return children;\n        }\n        getValueSubtreesSize(value, includeSelf = true) {\n          const { dictionary, nodes: nodes2, subtreeSize } = this;\n          let result = 0;\n          let count3 = 0;\n          if (typeof value !== "number") {\n            value = dictionary.indexOf(value);\n          }\n          for (let i = 0; i < nodes2.length; i++) {\n            if (nodes2[i] === value) {\n              const size = subtreeSize[i];\n              result += size;\n              count3++;\n              i += size;\n            }\n          }\n          return includeSelf ? result + count3 : result;\n        }\n        *map(nodeIndexes) {\n          for (const nodeIndex of nodeIndexes) {\n            yield this.getEntry(nodeIndex);\n          }\n        }\n        *selectNodes(value, includeNested = false) {\n          const { dictionary, nested, valueNodes, valueNodesOffset, valueNodesLength } = this;\n          if (typeof value !== "number") {\n            value = dictionary.indexOf(value);\n          }\n          const start = valueNodesOffset[value];\n          const end = start + valueNodesLength[value];\n          for (let i = start; i < end; i++) {\n            const nodeIndex = valueNodes[i];\n            if (includeNested || nested[nodeIndex] === 0) {\n              yield nodeIndex;\n            }\n          }\n        }\n        *selectBy(test2) {\n          const { nodes: nodes2 } = this;\n          const mask = makeDictMask(this, test2);\n          const result = [];\n          for (let i = 0; i < nodes2.length; i++) {\n            if (mask[nodes2[i]]) {\n              yield i;\n            }\n          }\n          return result;\n        }\n        *ancestors(nodeIndex, depth = Infinity) {\n          const { parent } = this;\n          let parentIndex = parent[nodeIndex];\n          while (parentIndex !== nodeIndex) {\n            yield parentIndex;\n            if (--depth <= 0) {\n              break;\n            }\n            nodeIndex = parentIndex;\n            parentIndex = parent[nodeIndex];\n          }\n        }\n        *children(nodeIndex) {\n          const { subtreeSize } = this;\n          const end = nodeIndex + subtreeSize[nodeIndex];\n          while (nodeIndex < end) {\n            yield ++nodeIndex;\n            nodeIndex += subtreeSize[nodeIndex];\n          }\n        }\n        *subtree(nodeIndex) {\n          const end = nodeIndex + this.subtreeSize[nodeIndex];\n          while (nodeIndex < end) {\n            yield ++nodeIndex;\n          }\n        }\n      };\n      FocusCallTree = class extends CallTree {\n        timingsMap;\n        constructor(tree, value) {\n          const outputTreeSize = tree.getValueSubtreesSize(value) + 1;\n          super(tree.dictionary, tree.sourceIdToNode.slice(), new Uint32Array(outputTreeSize));\n          this.timingsMap = new Uint32Array(outputTreeSize);\n          this.nodes[0] = tree.nodes[0];\n          this.subtreeSize[0] = outputTreeSize - 1;\n          let offset = 1;\n          for (const nodeIndex of tree.selectNodes(value)) {\n            const size = tree.subtreeSize[nodeIndex];\n            const newNodeIndex = offset++;\n            const moveDelta = newNodeIndex - nodeIndex;\n            this.timingsMap[newNodeIndex] = nodeIndex;\n            if (size > 0) {\n              const subtreeStart = nodeIndex;\n              const subtreeEnd = subtreeStart + size + 1;\n              for (let i = 1; i <= size; i++) {\n                this.timingsMap[offset] = nodeIndex + i;\n                this.parent[offset] = tree.parent[nodeIndex + i] + moveDelta;\n                offset++;\n              }\n              this.subtreeSize.set(tree.subtreeSize.subarray(subtreeStart, subtreeEnd), newNodeIndex);\n              this.nested.set(tree.nested.subarray(subtreeStart, subtreeEnd), newNodeIndex);\n              this.nodes.set(tree.nodes.subarray(subtreeStart, subtreeEnd), newNodeIndex);\n            } else {\n              this.nodes[newNodeIndex] = tree.nodes[nodeIndex];\n            }\n          }\n        }\n      };\n    }\n  });\n\n  // app/prepare/process-nodes.ts\n  function normalizeLoc(value) {\n    return typeof value === "number" && value >= 0 ? value : -1;\n  }\n  function getCallFrame(callFrame, callFrames, byScriptIdMap, urlByScriptId) {\n    const functionName = callFrame.functionName || "";\n    const lineNumber = normalizeLoc(callFrame.lineNumber);\n    const columnNumber = normalizeLoc(callFrame.columnNumber);\n    let scriptId = callFrame.scriptId;\n    let url = callFrame.url || null;\n    if (typeof scriptId === "string") {\n      if (/^\\d+$/.test(scriptId)) {\n        scriptId = Number(scriptId);\n      } else {\n        let numericScriptId = scriptIdFromString.get(scriptId);\n        if (numericScriptId === void 0) {\n          scriptIdFromString.set(\n            scriptId,\n            numericScriptId = /^:\\d+$/.test(scriptId) ? Number(scriptId.slice(1)) : -scriptIdFromString.size - 1\n          );\n        }\n        scriptId = numericScriptId;\n      }\n    }\n    if (url !== null) {\n      urlByScriptId.set(scriptId, url);\n    } else if (scriptId !== 0) {\n      url = urlByScriptId.get(scriptId) || "";\n    }\n    let byUrlMap = byScriptIdMap.get(scriptId);\n    if (byUrlMap === void 0) {\n      byScriptIdMap.set(scriptId, byUrlMap = /* @__PURE__ */ new Map());\n    }\n    let byFunctionNameMap = byUrlMap.get(url);\n    if (byFunctionNameMap === void 0) {\n      byUrlMap.set(url, byFunctionNameMap = /* @__PURE__ */ new Map());\n    }\n    let byLineNumberMap = byFunctionNameMap.get(functionName);\n    if (byLineNumberMap === void 0) {\n      byFunctionNameMap.set(functionName, byLineNumberMap = /* @__PURE__ */ new Map());\n    }\n    let resultMap = byLineNumberMap.get(lineNumber);\n    if (resultMap === void 0) {\n      byLineNumberMap.set(lineNumber, resultMap = /* @__PURE__ */ new Map());\n    }\n    let result = resultMap.get(columnNumber);\n    if (result === void 0) {\n      result = {\n        id: callFrames.length + 1,\n        scriptId,\n        url,\n        functionName,\n        lineNumber,\n        columnNumber,\n        // these field will be populated on call frames processing step\n        category: null,\n        package: null,\n        module: null,\n        function: null\n      };\n      callFrames.push(result);\n      resultMap.set(columnNumber, result);\n    }\n    return result;\n  }\n  function buildCallFrameTree(nodeId, sourceNodes, sourceIdToNode, nodes2, parent, subtreeSize, cursor = 0) {\n    const idx = sourceIdToNode[nodeId];\n    const node = sourceNodes[idx];\n    const nodeIndex = cursor++;\n    nodes2[nodeIndex] = idx;\n    sourceIdToNode[nodeId] = nodeIndex;\n    if (Array.isArray(node.children) && node.children.length > 0) {\n      for (const childId of node.children) {\n        parent[cursor] = nodeIndex;\n        cursor = buildCallFrameTree(\n          childId,\n          sourceNodes,\n          sourceIdToNode,\n          nodes2,\n          parent,\n          subtreeSize,\n          cursor\n        );\n      }\n      subtreeSize[nodeIndex] = cursor - nodeIndex - 1;\n    }\n    return cursor;\n  }\n  function processNodes(nodes2, maxNodeId) {\n    const initStart = Date.now();\n    const urlByScriptId = /* @__PURE__ */ new Map();\n    const callFramesMap = /* @__PURE__ */ new Map();\n    const callFrames = [];\n    const nodeById = new Uint32Array(maxNodeId + 1);\n    const nodesCount = nodes2.length;\n    for (let i = 0; i < nodesCount; i++) {\n      nodeById[nodes2[i].id] = i;\n    }\n    if (TIMINGS) {\n      console.log(">> init processNodes", Date.now() - initStart);\n    }\n    const buildTreeStart = Date.now();\n    const callFramesTree = new CallTree(callFrames, nodeById, new Uint32Array(nodesCount));\n    buildCallFrameTree(\n      nodes2[0].id,\n      nodes2,\n      callFramesTree.sourceIdToNode,\n      // pass arrays as separate values to reduce property reads, good for performance\n      callFramesTree.nodes,\n      callFramesTree.parent,\n      callFramesTree.subtreeSize\n    );\n    callFramesTree.computeValueNodes();\n    if (TIMINGS) {\n      console.log(">> buildCallFrameTree()", Date.now() - buildTreeStart);\n    }\n    const dedupCallFramesStart = Date.now();\n    for (let i = 0; i < nodes2.length; i++) {\n      const node = nodes2[callFramesTree.nodes[i]];\n      const callFrame = getCallFrame(\n        node.callFrame,\n        callFrames,\n        callFramesMap,\n        urlByScriptId\n      );\n      callFramesTree.nodes[i] = callFrame.id - 1;\n    }\n    if (TIMINGS) {\n      console.log(">> dedup call frames", Date.now() - dedupCallFramesStart);\n    }\n    return {\n      callFrames,\n      callFramesTree\n    };\n  }\n  var scriptIdFromString;\n  var init_process_nodes = __esm({\n    "app/prepare/process-nodes.ts"() {\n      init_call_tree();\n      init_const();\n      scriptIdFromString = /* @__PURE__ */ new Map();\n    }\n  });\n\n  // app/prepare/process-paths.ts\n  function getLongestCommonPath(longestCommonModulePath, modulePath) {\n    let parts = modulePath.split(/\\//);\n    parts.pop();\n    const result = longestCommonModulePath !== null ? longestCommonModulePath.slice(0, Math.min(longestCommonModulePath.length, parts.length)) : parts;\n    parts = parts.slice(0, result.length);\n    for (let i = result.length - 1; i >= 0; i--) {\n      if (result[i] !== parts[i]) {\n        result.pop();\n      }\n    }\n    return result;\n  }\n  function processPaths(packages, modules) {\n    const longestCommonModulePath = /* @__PURE__ */ Object.create(null);\n    for (const module of modules.values()) {\n      const modulePath = module.path || "";\n      if (modulePath) {\n        const pkg = module.package;\n        if (pkg.type === "script" && pkg.path && pkg.path.includes(":") && !/^https?:/.test(pkg.path)) {\n          longestCommonModulePath[pkg.path] = getLongestCommonPath(longestCommonModulePath[pkg.path] || null, modulePath);\n        }\n      }\n    }\n    for (const [pkgPath, longestPath] of Object.entries(longestCommonModulePath)) {\n      if (longestPath !== null && longestPath.length > 0) {\n        const path = longestPath.join("/");\n        for (const pkg of packages.values()) {\n          if (pkg.type === "script" && pkg.path === pkgPath) {\n            pkg.path = path;\n          }\n        }\n      }\n    }\n    for (const module of modules.values()) {\n      const modulePath = module.path || "";\n      if (module.package.path && modulePath.startsWith(module.package.path)) {\n        module.packageRelPath = modulePath.slice(module.package.path.length).replace(/^[\\/\\\\]+/, "");\n      }\n    }\n  }\n  var init_process_paths = __esm({\n    "app/prepare/process-paths.ts"() {\n    }\n  });\n\n  // app/prepare/process-module-names.ts\n  function moduleDisplayName(module) {\n    if (module.name) {\n      return;\n    }\n    switch (module.package.registry) {\n      case "npm":\n        module.name = `${module.package.name}/${module.packageRelPath}`;\n        return;\n    }\n    switch (module.package.type) {\n      case "script":\n      case "wasm":\n        module.name = module.packageRelPath;\n        break;\n      case "node":\n      case "webpack/runtime":\n        module.name = module.path;\n        break;\n    }\n  }\n  function processDisplayNames(modules) {\n    for (const module of modules) {\n      moduleDisplayName(module);\n    }\n  }\n  var init_process_module_names = __esm({\n    "app/prepare/process-module-names.ts"() {\n    }\n  });\n\n  // app/prepare/compute-timings.wasm\n  var compute_timings_default;\n  var init_compute_timings = __esm({\n    "app/prepare/compute-timings.wasm"() {\n      compute_timings_default = "AGFzbQEAAAABEQJgBH9/f38AYAZ/f39/f38AAhMBB2ltcG9ydHMGbWVtb3J5AgAAAwQDAAABB0MDEWFjY3VtdWxhdGVUaW1pbmdzAAARcm9sbHVwVHJlZVRpbWluZ3MAARdyb2xsdXBEaWN0aW9uYXJ5VGltaW5ncwACCoACA0kBA38gAEECdCEEAkADQCAERQ0BIARBBGshBCABIARqKAIAIgVFDQAgAyACIARqKAIAQQJ0aiEGIAYgBigCACAFajYCAAwACwsLVAEDfyABQQJ0IQQCQANAIARBBEwNASAEQQRrIQQgAiAEaigCACADIARqKAIAaiIFRQ0AIAMgACAEaigCAEECdGohBiAGIAYoAgAgBWo2AgAMAAsLC18BBH8gAEECdCEGAkADQCAGRQ0BIAZBBGshBiABIAZqKAIAQQJ0IQcgAiAHaigCACADIAdqKAIAaiIIRQ0AIAUgBCAGaigCAEECdGohCSAJIAkoAgAgCGo2AgAMAAsLCw==";\n    }\n  });\n\n  // app/prepare/compute-timings-wasm-wrapper.ts\n  function extractArrayFromMap(map2) {\n    const result = /* @__PURE__ */ Object.create(null);\n    for (const [key2, value] of Object.entries(map2)) {\n      if ("array" in value) {\n        result[key2] = value.array;\n      }\n    }\n    return result;\n  }\n  function createWasmModule2(source, imports = {}) {\n    const sourceBytes = decodeBase642(source);\n    const importObject = { imports };\n    const module = new WebAssembly.Module(sourceBytes);\n    return new WebAssembly.Instance(module, importObject);\n  }\n  function createWasmApi(memory) {\n    const wasmModule = createWasmModule2(compute_timings_default, { memory });\n    const {\n      accumulateTimings,\n      rollupTreeTimings,\n      rollupDictionaryTimings\n    } = wasmModule.exports;\n    return {\n      computeTimings(map2, clear = true) {\n        if (clear) {\n          map2.samplesTimes.array.fill(0);\n        }\n        accumulateTimings(\n          map2.timeDeltas.array.length,\n          map2.timeDeltas.offset,\n          map2.samples.offset,\n          map2.samplesTimes.offset\n        );\n      },\n      computeTreeTimings(map2, clear = true) {\n        if (clear) {\n          map2.selfTimes.array.fill(0);\n          map2.nestedTimes.array.fill(0);\n        }\n        accumulateTimings(\n          map2.sourceSelfTimes.array.length,\n          map2.sourceSelfTimes.offset,\n          map2.sampleIdToNode.offset,\n          map2.selfTimes.offset\n        );\n        rollupTreeTimings(\n          map2.parent.offset,\n          map2.selfTimes.array.length,\n          map2.selfTimes.offset,\n          map2.nestedTimes.offset\n        );\n      },\n      computeDictionaryTimings(map2, clear = true) {\n        if (clear) {\n          map2.selfTimes.array.fill(0);\n          map2.totalTimes.array.fill(0);\n        }\n        accumulateTimings(\n          map2.samplesSelfTimes.array.length,\n          map2.samplesSelfTimes.offset,\n          map2.sampleIdToDict.offset,\n          map2.selfTimes.offset\n        );\n        rollupDictionaryTimings(\n          map2.totalNodes.array.length,\n          map2.totalNodes.offset,\n          map2.nodeSelfTimes.offset,\n          map2.nodeNestedTimes.offset,\n          map2.totalNodeToDict.offset,\n          map2.totalTimes.offset\n        );\n      }\n    };\n  }\n  function createJavaScriptApi() {\n    return {\n      computeTimings(map2, clear = true) {\n        const {\n          samples,\n          timeDeltas,\n          samplesTimes\n        } = extractArrayFromMap(map2);\n        const samplesCount = samples.length;\n        if (clear) {\n          samplesTimes.fill(0);\n        }\n        for (let i = samplesCount - 1; i >= 0; i--) {\n          samplesTimes[samples[i]] += timeDeltas[i];\n        }\n      },\n      computeTreeTimings(map2, clear = true) {\n        const {\n          sourceSelfTimes,\n          sampleIdToNode,\n          parent,\n          selfTimes,\n          nestedTimes\n        } = extractArrayFromMap(map2);\n        const sourceSelfTimesSize = sourceSelfTimes.length;\n        const nodesCount = selfTimes.length;\n        if (clear) {\n          selfTimes.fill(0);\n          nestedTimes.fill(0);\n        }\n        for (let i = sourceSelfTimesSize - 1; i >= 0; i--) {\n          selfTimes[sampleIdToNode[i]] += sourceSelfTimes[i];\n        }\n        for (let i = nodesCount - 1; i > 0; i--) {\n          nestedTimes[parent[i]] += selfTimes[i] + nestedTimes[i];\n        }\n      },\n      computeDictionaryTimings(map2, clear = true) {\n        const {\n          samplesSelfTimes,\n          nodeSelfTimes,\n          nodeNestedTimes,\n          sampleIdToDict,\n          totalNodes,\n          totalNodeToDict,\n          selfTimes,\n          totalTimes\n        } = extractArrayFromMap(map2);\n        const samplesSelfTimesSize = samplesSelfTimes.length;\n        const nodesCount = totalNodes.length;\n        if (clear) {\n          selfTimes.fill(0);\n          totalTimes.fill(0);\n        }\n        for (let i = samplesSelfTimesSize - 1; i >= 0; i--) {\n          selfTimes[sampleIdToDict[i]] += samplesSelfTimes[i];\n        }\n        for (let i = nodesCount - 1; i >= 0; i--) {\n          const nodeId = totalNodes[i];\n          const selfTime = nodeSelfTimes[nodeId];\n          const nestedTime = nodeNestedTimes[nodeId];\n          totalTimes[totalNodeToDict[i]] += selfTime + nestedTime;\n        }\n      }\n    };\n  }\n  var init_compute_timings_wasm_wrapper = __esm({\n    "app/prepare/compute-timings-wasm-wrapper.ts"() {\n      init_utils2();\n      init_compute_timings();\n    }\n  });\n\n  // app/prepare/compute-timings.ts\n  function binarySearch(array, value) {\n    let left = 0;\n    let right = array.length - 1;\n    while (left <= right) {\n      const mid = left + right >> 1;\n      const midValue = array[mid];\n      if (midValue === value) {\n        return mid;\n      }\n      if (midValue < value) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return right;\n  }\n  function computeTimestamps(timestamps, timeDeltas) {\n    for (let i = 1; i < timestamps.length; i++) {\n      timestamps[i] = timeDeltas[i - 1] + timestamps[i - 1];\n    }\n  }\n  function computeAll(api2, bufferMap, clear = true) {\n    api2.computeTimings(bufferMap.samples, clear);\n    for (const treeMap of bufferMap.tree) {\n      api2.computeTreeTimings(treeMap, clear);\n    }\n    for (const dictMap of bufferMap.dict) {\n      api2.computeDictionaryTimings(dictMap, clear);\n    }\n  }\n  function createMapsFromTree(tree) {\n    const { nodes: nodes2, nested, sampleIdToNode } = tree;\n    const totalNodes = new Uint32Array(nodes2.length);\n    const totalNodeToDict = new Uint32Array(nodes2.length);\n    let k2 = 0;\n    for (let i = 0; i < nodes2.length; i++) {\n      if (nested[i] === 0) {\n        totalNodeToDict[k2] = nodes2[i];\n        totalNodes[k2] = i;\n        k2++;\n      }\n    }\n    return {\n      tree,\n      sampleIdToDict: sampleIdToNode.map((id) => nodes2[id]),\n      totalNodes: totalNodes.slice(0, k2),\n      totalNodeToDict: totalNodeToDict.slice(0, k2)\n    };\n  }\n  function createTreeComputeBuffer(samples, timeDeltas, trees, useWasm = true) {\n    const maps = trees.map(createMapsFromTree);\n    const samplesMapSize = trees[0].sampleIdToNode.length;\n    let bufferSize = (\n      // samples\n      samples.length + // timeDeltas\n      // timestamps\n      2 * timeDeltas.length + // samplesMask\n      // samplesTime\n      2 * samplesMapSize\n    );\n    for (const { tree, sampleIdToDict, totalNodes, totalNodeToDict } of maps) {\n      bufferSize += // sampleIdToNode\n      tree.sampleIdToNode.length + // parent\n      tree.parent.length + // selfTime\n      // nestTime\n      2 * tree.nodes.length;\n      bufferSize += sampleIdToDict.length + totalNodes.length + totalNodeToDict.length + // selfTime\n      // totalTime\n      2 * tree.dictionary.length;\n    }\n    const memory = useWasm ? new WebAssembly.Memory({ initial: Math.ceil(4 * bufferSize / 65535) }) : new Uint32Array(4 * bufferSize);\n    const buffer = new Uint32Array(memory.buffer);\n    let offset = 0;\n    const samplesMap = {\n      buffer,\n      samples: alloc(samples),\n      samplesMask: alloc(samplesMapSize),\n      timeDeltas: alloc(timeDeltas),\n      timestamps: alloc(timeDeltas.length),\n      samplesTimes: alloc(samplesMapSize)\n    };\n    const bufferMap = {\n      memory,\n      samples: samplesMap,\n      tree: [],\n      dict: []\n    };\n    computeTimestamps(samplesMap.timestamps.array, samplesMap.timeDeltas.array);\n    for (const { tree, sampleIdToDict, totalNodes, totalNodeToDict } of maps) {\n      const treeMap = {\n        buffer,\n        tree,\n        sourceSelfTimes: samplesMap.samplesTimes,\n        sampleIdToNode: alloc(tree.sampleIdToNode),\n        parent: alloc(tree.parent),\n        selfTimes: alloc(tree.nodes.length),\n        nestedTimes: alloc(tree.nodes.length)\n      };\n      const dictMap = {\n        buffer,\n        dictionary: tree.dictionary,\n        samplesSelfTimes: samplesMap.samplesTimes,\n        nodeSelfTimes: treeMap.selfTimes,\n        nodeNestedTimes: treeMap.nestedTimes,\n        sampleIdToDict: alloc(sampleIdToDict),\n        totalNodes: alloc(totalNodes),\n        totalNodeToDict: alloc(totalNodeToDict),\n        selfTimes: alloc(tree.dictionary.length),\n        totalTimes: alloc(tree.dictionary.length)\n      };\n      bufferMap.tree.push(treeMap);\n      bufferMap.dict.push(dictMap);\n    }\n    return bufferMap;\n    function alloc(array) {\n      const arrayOffset = offset;\n      const record = { offset, array: null };\n      if (typeof array === "number") {\n        offset += array << 2;\n      } else {\n        buffer.set(array, offset >> 2);\n        offset += array.length << 2;\n      }\n      return {\n        offset: arrayOffset,\n        array: buffer.subarray(record.offset >> 2, offset >> 2)\n      };\n    }\n  }\n  function createTreeCompute(samples, timeDeltas, trees) {\n    const useWasm = USE_WASM;\n    const bufferMap = createTreeComputeBuffer(samples, timeDeltas, trees, useWasm);\n    const {\n      memory,\n      samples: samplesMap,\n      tree: treeMaps,\n      dict: dictMaps\n    } = bufferMap;\n    const computeTimingsApi = useWasm ? createWasmApi(memory) : createJavaScriptApi();\n    computeAll(computeTimingsApi, bufferMap, false);\n    const samplesTimings = new SamplesTiminigs(\n      samples,\n      timeDeltas,\n      samplesMap.timestamps.array,\n      samplesMap.samplesTimes.array.slice()\n    );\n    const samplesTimingsFiltered = new SamplesTiminigsFiltered(\n      samplesMap.samples.array,\n      samplesMap.samplesMask.array,\n      samplesMap.timeDeltas.array,\n      samplesMap.timestamps.array,\n      samplesMap.samplesTimes.array\n    );\n    const treeTimings = treeMaps.map((treeMap) => new TreeTiminigs(\n      treeMap.tree,\n      treeMap.selfTimes.array.slice(),\n      treeMap.nestedTimes.array.slice()\n    ));\n    const treeTimingsFiltered = treeMaps.map((treeMap) => new TreeTiminigs(\n      treeMap.tree,\n      treeMap.selfTimes.array,\n      treeMap.nestedTimes.array\n    ));\n    const dictionaryTimings = dictMaps.map((dictMap) => new DictionaryTiminigs(\n      dictMap.dictionary,\n      dictMap.selfTimes.array.slice(),\n      dictMap.totalTimes.array.slice()\n    ));\n    const dictionaryTimingsFiltered = dictMaps.map((dictMap) => new DictionaryTiminigs(\n      dictMap.dictionary,\n      dictMap.selfTimes.array,\n      dictMap.totalTimes.array\n    ));\n    const { setRange, resetRange } = samplesTimingsFiltered;\n    const notifySubjects = [samplesTimingsFiltered, ...treeTimingsFiltered, ...dictionaryTimingsFiltered];\n    samplesTimingsFiltered.setRange = function(...args) {\n      setRange.call(this, ...args);\n      computeAll(computeTimingsApi, bufferMap);\n      dictionaryTimingsFiltered.forEach((timings) => timings.sync());\n      notifySubjects.forEach((timings) => timings.notify());\n    };\n    samplesTimingsFiltered.resetRange = function(...args) {\n      resetRange.call(this, ...args);\n      computeAll(computeTimingsApi, bufferMap);\n      dictionaryTimingsFiltered.forEach((timings) => timings.sync());\n      notifySubjects.forEach((timings) => timings.notify());\n    };\n    return {\n      samplesTimings,\n      samplesTimingsFiltered,\n      treeTimings,\n      treeTimingsFiltered,\n      dictionaryTimings,\n      dictionaryTimingsFiltered\n    };\n  }\n  var TimingsObserver, SamplesTiminigs, SamplesTiminigsFiltered, TreeTiminigs, DictionaryTiminigs;\n  var init_compute_timings2 = __esm({\n    "app/prepare/compute-timings.ts"() {\n      init_const();\n      init_compute_timings_wasm_wrapper();\n      TimingsObserver = class {\n        listeners = [];\n        on(fn) {\n          let listener = { fn };\n          this.listeners.push(listener);\n          return () => {\n            if (listener !== null) {\n              this.listeners = this.listeners.filter((el) => el !== listener);\n              listener = null;\n            }\n          };\n        }\n        notify() {\n          for (const { fn } of this.listeners) {\n            fn();\n          }\n        }\n      };\n      SamplesTiminigs = class extends TimingsObserver {\n        samples;\n        timeDeltas;\n        timestamps;\n        selfTimes;\n        constructor(samples, timeDeltas, timestamps, selfTimes) {\n          super();\n          this.samples = samples;\n          this.timeDeltas = timeDeltas;\n          this.timestamps = timestamps;\n          this.selfTimes = selfTimes;\n        }\n      };\n      SamplesTiminigsFiltered = class extends SamplesTiminigs {\n        samplesMask;\n        originalTimeDeltas;\n        rangeStart = null;\n        rangeEnd = null;\n        rangeSamples = null;\n        constructor(samples, samplesMask, timeDeltas, timestamps, selfTimes) {\n          super(\n            samples,\n            timeDeltas,\n            timestamps,\n            selfTimes\n          );\n          this.samplesMask = samplesMask;\n          this.originalTimeDeltas = timeDeltas;\n        }\n        resetRange() {\n          this.rangeStart = null;\n          this.rangeEnd = null;\n          this.rangeSamples = null;\n          if (this.timeDeltas !== this.originalTimeDeltas) {\n            this.timeDeltas.set(this.originalTimeDeltas);\n            this.originalTimeDeltas = this.timeDeltas;\n          }\n        }\n        setRange(start, end) {\n          const { timeDeltas, timestamps } = this;\n          let { originalTimeDeltas } = this;\n          if (timeDeltas === originalTimeDeltas) {\n            this.originalTimeDeltas = originalTimeDeltas = timeDeltas.slice();\n          }\n          timeDeltas.fill(0);\n          const startIndex = binarySearch(timestamps, start);\n          const endIndex = binarySearch(timestamps, end);\n          this.rangeStart = start;\n          this.rangeEnd = end;\n          this.rangeSamples = endIndex - startIndex + 1;\n          if (startIndex !== endIndex) {\n            timeDeltas[startIndex] = originalTimeDeltas[startIndex] - (start - timestamps[startIndex]);\n            timeDeltas[endIndex] = end - timestamps[endIndex];\n            if (startIndex + 1 < endIndex) {\n              timeDeltas.set(originalTimeDeltas.subarray(startIndex + 1, endIndex), startIndex + 1);\n            }\n          } else {\n            timeDeltas[startIndex] = end - start;\n          }\n        }\n      };\n      TreeTiminigs = class extends TimingsObserver {\n        tree;\n        selfTimes;\n        nestedTimes;\n        constructor(tree, selfTimes, nestedTimes) {\n          super();\n          this.tree = tree;\n          this.selfTimes = selfTimes;\n          this.nestedTimes = nestedTimes;\n        }\n        getTimings(index) {\n          const selfTime = this.selfTimes[index];\n          const nestedTime = this.nestedTimes[index];\n          return {\n            node: this.tree.getEntry(index),\n            selfTime,\n            nestedTime,\n            totalTime: selfTime + nestedTime\n          };\n        }\n        getValueTimings(valueIndex) {\n          const { tree, selfTimes, nestedTimes } = this;\n          const { nested } = tree;\n          let selfTime = 0;\n          let nestedTime = 0;\n          for (const index of tree.selectNodes(valueIndex, true)) {\n            selfTime += selfTimes[index];\n            if (nested[index] === 0) {\n              nestedTime += nestedTimes[index];\n            }\n          }\n          return {\n            value: tree.dictionary[valueIndex],\n            selfTime,\n            nestedTime,\n            totalTime: selfTime + nestedTime\n          };\n        }\n      };\n      DictionaryTiminigs = class extends TimingsObserver {\n        entries;\n        entriesMap;\n        selfTimes;\n        totalTimes;\n        constructor(dictionary, selfTimes, totalTimes) {\n          super();\n          this.selfTimes = selfTimes;\n          this.totalTimes = totalTimes;\n          this.entries = dictionary.map((entry, entryIndex) => ({\n            entryIndex,\n            entry,\n            selfTime: selfTimes[entryIndex],\n            nestedTime: totalTimes[entryIndex] - selfTimes[entryIndex],\n            totalTime: totalTimes[entryIndex]\n          }));\n          this.entriesMap = this.entries.reduce(\n            (map2, element) => map2.set(element.entry, element),\n            /* @__PURE__ */ new Map()\n          );\n        }\n        getEntry(sourceEntry) {\n          return this.entriesMap.get(sourceEntry) || null;\n        }\n        sync() {\n          const { entries: entries2, selfTimes, totalTimes } = this;\n          for (let i = 0; i < entries2.length; i++) {\n            const entry = entries2[i];\n            const selfTime = selfTimes[i];\n            const totalTime = totalTimes[i];\n            entry.selfTime = selfTime;\n            entry.nestedTime = totalTime - selfTime;\n            entry.totalTime = totalTime;\n          }\n        }\n      };\n    }\n  });\n\n  // app/prepare/process-samples.ts\n  function mergeSamples(samples, timeDeltas) {\n    let k2 = 1;\n    for (let i = 1; i < samples.length; i++) {\n      if (samples[i] !== samples[i - 1]) {\n        timeDeltas[k2] = timeDeltas[i];\n        samples[k2] = samples[i];\n        k2++;\n      } else {\n        timeDeltas[k2 - 1] += timeDeltas[i];\n      }\n    }\n    return {\n      samples: k2 !== samples.length ? samples.slice(0, k2) : samples,\n      timeDeltas: k2 !== timeDeltas.length ? timeDeltas.slice(0, k2) : timeDeltas\n    };\n  }\n  function remapSamples(samples, nodeById) {\n    const tmpMap = new Uint32Array(nodeById.length);\n    const samplesMap = [];\n    let sampledNodesCount = 0;\n    for (let i = 0; i < samples.length; i++) {\n      const id = samples[i];\n      const newSampleId = tmpMap[id];\n      if (newSampleId === 0) {\n        samplesMap.push(nodeById[id]);\n        tmpMap[id] = ++sampledNodesCount;\n        samples[i] = sampledNodesCount - 1;\n      } else {\n        samples[i] = newSampleId - 1;\n      }\n    }\n    return new Uint32Array(samplesMap);\n  }\n  function processSamples(rawSamples, rawTimeDeltas, callFramesTree, functionsTree, modulesTree, packagesTree, categoriesTree) {\n    const mergeSamplesStart = Date.now();\n    const { samples, timeDeltas } = mergeSamples(rawSamples, rawTimeDeltas);\n    TIMINGS && console.log("merge samples", Date.now() - mergeSamplesStart);\n    const remapSamplesStart = Date.now();\n    let sampleIdToNode = remapSamples(samples, callFramesTree.sourceIdToNode);\n    callFramesTree.sampleIdToNode = sampleIdToNode;\n    for (const tree of [functionsTree, modulesTree, packagesTree, categoriesTree]) {\n      tree.sampleIdToNode = sampleIdToNode.map((id) => tree.sourceIdToNode[id]);\n      sampleIdToNode = tree.sampleIdToNode;\n    }\n    TIMINGS && console.log("re-map samples", Date.now() - remapSamplesStart);\n    const computeTimingsStart = Date.now();\n    const names = ["functions", "modules", "packages", "categories"];\n    const {\n      samplesTimings,\n      samplesTimingsFiltered,\n      treeTimings,\n      treeTimingsFiltered,\n      dictionaryTimings,\n      dictionaryTimingsFiltered\n    } = createTreeCompute(samples, timeDeltas, [\n      functionsTree,\n      modulesTree,\n      packagesTree,\n      categoriesTree\n    ]);\n    const result = {\n      samplesTimings,\n      samplesTimingsFiltered\n    };\n    dictionaryTimings.forEach((timings, i) => result[`${names[i]}Timings`] = timings);\n    treeTimings.forEach((timings, i) => result[`${names[i]}TreeTimings`] = timings);\n    dictionaryTimingsFiltered.forEach((timings, i) => result[`${names[i]}TimingsFiltered`] = timings);\n    treeTimingsFiltered.forEach((timings, i) => result[`${names[i]}TreeTimingsFiltered`] = timings);\n    TIMINGS && console.log("Compute timings:", Date.now() - computeTimingsStart);\n    return result;\n  }\n  function gcReparenting(samples, nodes2, maxNodeId) {\n    const gcNode = nodes2.find(\n      (node) => node.callFrame.functionName === "(garbage collector)"\n    );\n    if (gcNode === void 0) {\n      return maxNodeId;\n    }\n    const gcNodeIdByPrevNodeId = /* @__PURE__ */ new Map();\n    const gcNodeId = gcNode.id;\n    const nodeIdToIndex = new Uint32Array(maxNodeId + 1);\n    for (let i = 0; i < nodes2.length; i++) {\n      nodeIdToIndex[nodes2[i].id] = i;\n    }\n    for (let i = 1, prevNodeId = samples[0]; i < samples.length; i++) {\n      const nodeId = samples[i];\n      if (nodeId === gcNodeId) {\n        if (prevNodeId === gcNodeId) {\n          samples[i] = samples[i - 1];\n        } else {\n          let sampleGcNodeId = gcNodeIdByPrevNodeId.get(prevNodeId);\n          if (sampleGcNodeId === void 0) {\n            sampleGcNodeId = ++maxNodeId;\n            const parentNode = nodes2[nodeIdToIndex[prevNodeId]];\n            if (Array.isArray(parentNode.children)) {\n              parentNode.children.push(sampleGcNodeId);\n            } else {\n              parentNode.children = [sampleGcNodeId];\n            }\n            gcNodeIdByPrevNodeId.set(prevNodeId, sampleGcNodeId);\n            nodes2.push({\n              id: sampleGcNodeId,\n              callFrame: gcNode.callFrame\n            });\n          }\n          samples[i] = sampleGcNodeId;\n        }\n      }\n      prevNodeId = nodeId;\n    }\n    return maxNodeId;\n  }\n  var init_process_samples = __esm({\n    "app/prepare/process-samples.ts"() {\n      init_const();\n      init_compute_timings2();\n    }\n  });\n\n  // app/prepare/process-time-deltas.ts\n  function fixDeltasOrder(timeDeltas, samples) {\n    for (let i = 0; i < timeDeltas.length; i++) {\n      const delta = timeDeltas[i];\n      if (delta < 0) {\n        if (i < timeDeltas.length - 1) {\n          timeDeltas[i + 1] += delta;\n        }\n        timeDeltas[i] = i === 0 ? 0 : -delta;\n        if (i > 0) {\n          timeDeltas[i - 1] += delta;\n          const sample = samples[i];\n          samples[i] = samples[i - 1];\n          samples[i - 1] = sample;\n          i -= 2;\n        }\n      }\n    }\n  }\n  function processTimeDeltas(timeDeltas, samples, startTime, endTime, samplesInterval) {\n    fixDeltasOrder(timeDeltas, samples);\n    const startNoSamplesTime = timeDeltas[0];\n    const maybeTotalTime = endTime - startTime - startNoSamplesTime;\n    let deltasSum = 0;\n    for (let i = 1; i < timeDeltas.length; i++) {\n      deltasSum += timeDeltas[i - 1] = timeDeltas[i];\n    }\n    if (typeof samplesInterval !== "number") {\n      samplesInterval = timeDeltas.slice().sort()[timeDeltas.length >> 1];\n    }\n    const maybeLastDelta = maybeTotalTime - deltasSum;\n    const lastDelta = maybeLastDelta > 2.5 * samplesInterval ? samplesInterval : maybeLastDelta;\n    timeDeltas[timeDeltas.length - 1] = lastDelta;\n    deltasSum += lastDelta;\n    const totalTime = deltasSum;\n    const endNoSamplesTime = maybeTotalTime - totalTime;\n    return {\n      startTime,\n      startNoSamplesTime,\n      endTime,\n      endNoSamplesTime,\n      totalTime,\n      samplesInterval\n    };\n  }\n  var init_process_time_deltas = __esm({\n    "app/prepare/process-time-deltas.ts"() {\n    }\n  });\n\n  // app/prepare/detect-runtime.ts\n  function detectRuntime(categories, packages, runtime) {\n    const categoriesSet = new Set(categories.map((category) => category.name));\n    const code = runtime || (categoriesSet.has("electron") ? "electron" : categoriesSet.has("deno") ? "deno" : categoriesSet.has("node") ? "nodejs" : categoriesSet.has("chrome-extension") || packages.find((pkg) => pkg.path && /^https?:/.test(pkg.path)) ? "chromium" : "unknown");\n    return {\n      engine: "V8",\n      code,\n      name: runtimes[code]\n    };\n  }\n  var runtimes;\n  var init_detect_runtime = __esm({\n    "app/prepare/detect-runtime.ts"() {\n      runtimes = {\n        chromium: "Chromium",\n        deno: "Deno",\n        edge: "Edge",\n        electron: "Electron",\n        nodejs: "Node.js",\n        unknown: "Unknown"\n      };\n    }\n  });\n\n  // app/prepare/build-trees.wasm\n  var build_trees_default;\n  var init_build_trees = __esm({\n    "app/prepare/build-trees.wasm"() {\n      build_trees_default = "AGFzbQEAAAABCQFgBX9/f39/AAITAQdpbXBvcnRzBm1lbW9yeQIAAAMCAQAHFwETbWFrZUZpcnN0TmV4dEFycmF5cwAACnIBcAEDfwJAA0AgBSAETg0BIAEgBUECdGooAgAhBiAGQQBKBEAgAiAFQQJ0aiAFQQFqNgIACyAFIAZBAWpqIQcgACAFQQJ0aigCACAAIAdBAnRqKAIARgRAIAMgBUECdGogBzYCAAsgBUEBaiEFDAALCws=";\n    }\n  });\n\n  // app/prepare/build-trees-wasm-wrapper.ts\n  function createWasmModule3(source, imports = {}) {\n    const sourceBytes = decodeBase642(source);\n    const importObject = { imports };\n    const module = new WebAssembly.Module(sourceBytes);\n    return new WebAssembly.Instance(module, importObject);\n  }\n  function createWasmApi2() {\n    const memory = new WebAssembly.Memory({ initial: 16 });\n    const wasmModule = createWasmModule3(build_trees_default, { memory });\n    const { makeFirstNextArrays: makeFirstNextArrays2 } = wasmModule.exports;\n    return {\n      makeFirstNextArrays(parent, subtreeSize) {\n        const arraySize = parent.byteLength;\n        const memoryNeeded = 4 * arraySize;\n        const parentOffset = 0;\n        const subtreeSizeOffset = arraySize;\n        const firstChildOffset = 2 * arraySize;\n        const nextSiblingOffset = 3 * arraySize;\n        if (memoryNeeded > memory.buffer.byteLength) {\n          memory.grow(bytesToWasmMemoryPages(memoryNeeded - memory.buffer.byteLength));\n        }\n        const mem = new Uint8Array(memory.buffer);\n        mem.set(new Uint8Array(parent.buffer), parentOffset);\n        mem.set(new Uint8Array(subtreeSize.buffer), subtreeSizeOffset);\n        mem.fill(0, firstChildOffset, firstChildOffset + 2 * arraySize);\n        makeFirstNextArrays2(\n          parentOffset,\n          subtreeSizeOffset,\n          firstChildOffset,\n          nextSiblingOffset,\n          parent.length\n        );\n        return {\n          firstChild: new Uint32Array(memory.buffer, firstChildOffset, arraySize >> 2),\n          nextSibling: new Uint32Array(memory.buffer, nextSiblingOffset, arraySize >> 2)\n        };\n      }\n    };\n  }\n  function createJavaScriptApi2() {\n    return {\n      makeFirstNextArrays(parent, subtreeSize) {\n        const firstChild = new Uint32Array(parent.length);\n        const nextSibling = new Uint32Array(parent.length);\n        for (let i = 0; i < parent.length; i++) {\n          const size = subtreeSize[i];\n          const nextSinlingCandidate = i + size + 1;\n          if (size > 0) {\n            firstChild[i] = i + 1;\n          }\n          if (parent[i] === parent[nextSinlingCandidate]) {\n            nextSibling[i] = nextSinlingCandidate;\n          }\n        }\n        return {\n          firstChild,\n          nextSibling\n        };\n      }\n    };\n  }\n  function getDefaultWasmApi() {\n    if (wasmApi === null) {\n      wasmApi = createWasmApi2();\n    }\n    return wasmApi;\n  }\n  function getDefaultJavaScriptApi() {\n    if (javaScriptApi === null) {\n      javaScriptApi = createJavaScriptApi2();\n    }\n    return javaScriptApi;\n  }\n  function getDefaultApi() {\n    if (api === null) {\n      api = USE_WASM ? getDefaultWasmApi() : getDefaultJavaScriptApi();\n    }\n    return api;\n  }\n  function getDefaultFunction(name) {\n    return getDefaultApi()[name];\n  }\n  var wasmApi, javaScriptApi, api, makeFirstNextArrays;\n  var init_build_trees_wasm_wrapper = __esm({\n    "app/prepare/build-trees-wasm-wrapper.ts"() {\n      init_const();\n      init_utils2();\n      init_build_trees();\n      wasmApi = null;\n      javaScriptApi = null;\n      api = null;\n      makeFirstNextArrays = getDefaultFunction("makeFirstNextArrays");\n    }\n  });\n\n  // app/prepare/build-trees-utils.ts\n  function isEqualArrays(a, b2) {\n    if (a.length !== b2.length) {\n      return "bad size";\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b2[i]) {\n        return "fail on " + i;\n      }\n    }\n    return "OK";\n  }\n  var init_build_trees_utils = __esm({\n    "app/prepare/build-trees-utils.ts"() {\n    }\n  });\n\n  // app/prepare/build-trees-baseline.ts\n  function rollupTree(inputTree, indexBySource, outputNodes, hierarhyTree, cursor = 0, parentValue = indexBySource[cursor], parentIndex = 0) {\n    const value = indexBySource[cursor];\n    let nodeIndex = parentIndex;\n    if (value !== parentValue) {\n      let childByValueMap = hierarhyTree.get(parentIndex);\n      if (childByValueMap === void 0) {\n        hierarhyTree.set(parentIndex, childByValueMap = /* @__PURE__ */ new Map());\n      }\n      nodeIndex = childByValueMap.get(value);\n      if (nodeIndex === void 0) {\n        childByValueMap.set(value, nodeIndex = outputNodes.length);\n        outputNodes.push(value);\n      }\n    }\n    indexBySource[cursor] = nodeIndex;\n    const end = cursor + inputTree.subtreeSize[cursor];\n    while (cursor++ < end) {\n      rollupTree(\n        inputTree,\n        indexBySource,\n        outputNodes,\n        hierarhyTree,\n        cursor,\n        value,\n        nodeIndex\n      );\n      cursor += inputTree.subtreeSize[cursor];\n    }\n  }\n  function finalizeTree(hierarhyTree, outputTree, outputNodes, nested = new Uint32Array(outputTree.dictionary.length), index = 0, cursor = 0) {\n    const childByValueMap = hierarhyTree.get(index);\n    const value = outputNodes[index];\n    const nodeIndex = cursor++;\n    const valueNested = nested[value];\n    outputTree.nodes[nodeIndex] = value;\n    outputNodes[index] = nodeIndex;\n    if (valueNested !== 0) {\n      outputTree.nested[nodeIndex] = valueNested;\n    }\n    if (childByValueMap !== void 0) {\n      nested[value]++;\n      for (const childIndex of childByValueMap.values()) {\n        outputTree.parent[cursor] = nodeIndex;\n        cursor = finalizeTree(hierarhyTree, outputTree, outputNodes, nested, childIndex, cursor);\n      }\n      outputTree.subtreeSize[nodeIndex] = cursor - nodeIndex - 1;\n      nested[value]--;\n    }\n    return cursor;\n  }\n  function baselineBuildTree(sourceTree, dictionary, dictionaryIndexBySourceTreeNode) {\n    const initTimeStart = Date.now();\n    const sourceToOutputIndex = sourceTree.dictionary.map(dictionaryIndexBySourceTreeNode);\n    const indexBySource = sourceTree.nodes.map((index) => sourceToOutputIndex[index]);\n    const rootIndex = indexBySource[0];\n    const outputNodes = [rootIndex];\n    const hierarhyTree = /* @__PURE__ */ new Map();\n    const rollupTreeStart = Date.now();\n    rollupTree(\n      // input\n      sourceTree,\n      // output\n      indexBySource,\n      outputNodes,\n      hierarhyTree\n    );\n    const finalizeStart = Date.now();\n    const outputTree = new CallTree(dictionary, indexBySource, new Uint32Array(outputNodes.length));\n    finalizeTree(hierarhyTree, outputTree, outputNodes);\n    for (let i = 0; i < indexBySource.length; i++) {\n      indexBySource[i] = outputNodes[indexBySource[i]];\n    }\n    if (TIMINGS) {\n      console.info(\n        "---> buildTree() [baseline]",\n        rollupTreeStart - initTimeStart,\n        "+",\n        finalizeStart - rollupTreeStart,\n        "+",\n        Date.now() - finalizeStart,\n        "=",\n        Date.now() - initTimeStart,\n        "ms"\n      );\n    }\n    return outputTree;\n  }\n  function buildCallTreeAndCompareWithBaseline(sourceTree, dictionary, dictionaryIndexBySourceTreeNode) {\n    const baselineTreeBuildStart = Date.now();\n    const baselineTree = baselineBuildTree(sourceTree, dictionary, dictionaryIndexBySourceTreeNode);\n    const baselineTime = Date.now() - baselineTreeBuildStart;\n    const buildTreeStart = Date.now();\n    const tree = buildCallTree(sourceTree, dictionary, dictionaryIndexBySourceTreeNode);\n    const treeTime = Date.now() - buildTreeStart;\n    const diff = treeTime - baselineTime;\n    const diffSign = Math.sign(diff) !== -1 ? "+" : "";\n    console.info(\n      "Time [baseline]:",\n      baselineTime,\n      "ms",\n      "\\nTime:",\n      treeTime,\n      "ms",\n      "\\nDiff:",\n      diff && baselineTime && treeTime ? `${diffSign}${diff}ms (${diffSign}${Math.round(100 * diff / baselineTime)}%, x${(baselineTime / treeTime).toFixed(1).replace(".0", "")})` : diff ? `${diffSign}${diff}ms` : "\\u2013"\n    );\n    console.info(\n      "Check arrays:",\n      "\\n  nodes:",\n      isEqualArrays(baselineTree.nodes, tree.nodes),\n      "\\n  parent:",\n      isEqualArrays(baselineTree.parent, tree.parent),\n      "\\n  nested:",\n      isEqualArrays(baselineTree.nested, tree.nested),\n      "\\n  subtreeSize:",\n      isEqualArrays(baselineTree.subtreeSize, tree.subtreeSize),\n      "\\n  sourceIdToNode:",\n      isEqualArrays(baselineTree.sourceIdToNode, tree.sourceIdToNode)\n    );\n    return { baselineTree, tree };\n  }\n  var init_build_trees_baseline = __esm({\n    "app/prepare/build-trees-baseline.ts"() {\n      init_build_trees_utils();\n      init_build_trees2();\n      init_call_tree();\n      init_const();\n    }\n  });\n\n  // app/prepare/build-trees.ts\n  function finalizeArrays(dictionarySize, sourceNodes, sourceToNode, sourceToDictionary, nodesSize, firstChild, nextSibling) {\n    const nodes2 = new Uint32Array(nodesSize);\n    const parent = new Uint32Array(nodesSize);\n    const subtreeSize = new Uint32Array(nodesSize);\n    const nested = new Uint32Array(nodesSize);\n    const nestedMask = new Uint32Array(dictionarySize);\n    const remap = new Uint32Array(nodesSize);\n    let index = 0;\n    let cursor = 0;\n    do {\n      const valueIndex = sourceToDictionary[sourceNodes[cursor]];\n      const nestedLevel = nestedMask[valueIndex];\n      const first = firstChild[cursor];\n      let next = nextSibling[cursor];\n      let nodeIndex = index++;\n      nodes2[nodeIndex] = cursor;\n      remap[sourceToNode[cursor]] = nodeIndex;\n      if (nestedLevel !== 0) {\n        nested[nodeIndex] = nestedLevel;\n      }\n      if (first !== 0) {\n        cursor = first;\n        parent[index] = nodeIndex;\n        nestedMask[valueIndex]++;\n      } else if (next !== 0) {\n        cursor = next;\n        parent[index] = parent[nodeIndex];\n      } else {\n        cursor = 0;\n        while (nodeIndex = parent[nodeIndex]) {\n          nestedMask[sourceToDictionary[sourceNodes[nodes2[nodeIndex]]]]--;\n          if (next = nextSibling[nodes2[nodeIndex]]) {\n            parent[index] = parent[nodeIndex];\n            cursor = next;\n            break;\n          }\n        }\n      }\n    } while (cursor !== 0);\n    nodes2[0] = sourceToDictionary[sourceNodes[nodes2[0]]];\n    for (let i = nodes2.length - 1; i > 0; i--) {\n      subtreeSize[parent[i]] += subtreeSize[i] + 1;\n      nodes2[i] = sourceToDictionary[sourceNodes[nodes2[i]]];\n    }\n    for (let i = 0; i < sourceToNode.length; i++) {\n      sourceToNode[i] = remap[sourceToNode[i]];\n    }\n    return { nodes: nodes2, parent, subtreeSize, nested };\n  }\n  function rollupTreeByCommonValues(dictionarySize, sourceNodes, sourceToNode, sourceToDictionary, firstChild, nextSibling) {\n    const valueToNodeEpoch = new Uint32Array(dictionarySize);\n    const valueToNode = new Uint32Array(dictionarySize);\n    const stack = [0];\n    let nodesCount = 1;\n    while (stack.length > 0) {\n      const nodeIndex = stack.pop();\n      const nodeValue = sourceToDictionary[sourceNodes[nodeIndex]];\n      let prevCursor = nodeIndex;\n      let cursor = firstChild[nodeIndex];\n      while (cursor !== 0) {\n        const childValue = sourceToDictionary[sourceNodes[cursor]];\n        if (childValue === nodeValue) {\n          const cursorFirstChild = firstChild[cursor];\n          sourceToNode[cursor] = sourceToNode[nodeIndex];\n          if (prevCursor === nodeIndex) {\n            firstChild[prevCursor] = cursorFirstChild || nextSibling[cursor];\n          } else {\n            nextSibling[prevCursor] = cursorFirstChild || nextSibling[cursor];\n          }\n          if (cursorFirstChild) {\n            if (nextSibling[cursor]) {\n              let lastChild = cursorFirstChild;\n              while (nextSibling[lastChild] !== 0) {\n                lastChild = nextSibling[lastChild];\n              }\n              nextSibling[lastChild] = nextSibling[cursor];\n            }\n            cursor = cursorFirstChild;\n            continue;\n          }\n        } else {\n          if (valueToNodeEpoch[childValue] === nodeIndex + 1) {\n            const cursorFirstChild = firstChild[cursor];\n            const existedCursor = valueToNode[childValue];\n            sourceToNode[cursor] = sourceToNode[existedCursor];\n            nextSibling[prevCursor] = nextSibling[cursor];\n            if (cursorFirstChild) {\n              const existedFirstChild = firstChild[existedCursor];\n              if (existedFirstChild !== 0) {\n                let lastChild = cursorFirstChild;\n                while (nextSibling[lastChild] !== 0) {\n                  lastChild = nextSibling[lastChild];\n                }\n                firstChild[existedCursor] = cursorFirstChild;\n                nextSibling[lastChild] = existedFirstChild;\n              } else {\n                firstChild[existedCursor] = cursorFirstChild;\n                stack.push(existedCursor);\n              }\n            }\n          } else {\n            sourceToNode[cursor] = nodesCount++;\n            valueToNodeEpoch[childValue] = nodeIndex + 1;\n            valueToNode[childValue] = cursor;\n            prevCursor = cursor;\n            if (firstChild[cursor]) {\n              stack.push(cursor);\n            }\n          }\n        }\n        cursor = nextSibling[cursor];\n      }\n    }\n    return nodesCount;\n  }\n  function buildCallTree(sourceTree, dictionary, sourceNodeToDictionaryFn) {\n    const initTimeStart = Date.now();\n    const sourceNodes = sourceTree.nodes;\n    const sourceToDictionary = new Uint32Array(sourceTree.dictionary.length);\n    const sourceToNode = new Uint32Array(sourceNodes.length);\n    const { firstChild, nextSibling } = makeFirstNextArrays(sourceTree.parent, sourceTree.subtreeSize);\n    for (let i = 0; i < sourceTree.dictionary.length; i++) {\n      sourceToDictionary[i] = sourceNodeToDictionaryFn(sourceTree.dictionary[i]);\n    }\n    const rollupTreeStart = Date.now();\n    const nodesCount = rollupTreeByCommonValues(\n      dictionary.length,\n      sourceNodes,\n      sourceToNode,\n      sourceToDictionary,\n      firstChild,\n      nextSibling\n    );\n    const finalizeStart = Date.now();\n    const { nodes: nodes2, parent, subtreeSize, nested } = finalizeArrays(\n      dictionary.length,\n      sourceNodes,\n      sourceToNode,\n      sourceToDictionary,\n      nodesCount,\n      firstChild,\n      nextSibling\n    );\n    const createTreeStart = Date.now();\n    const tree = new CallTree(dictionary, sourceToNode, nodes2, parent, subtreeSize, nested).computeValueNodes();\n    if (TIMINGS) {\n      console.info(\n        "---> buildTree()",\n        rollupTreeStart - initTimeStart,\n        "+",\n        finalizeStart - rollupTreeStart,\n        "+",\n        createTreeStart - finalizeStart,\n        "+",\n        Date.now() - createTreeStart,\n        "=",\n        Date.now() - initTimeStart,\n        "ms"\n      );\n    }\n    return tree;\n  }\n  function buildCallTreeFor(name, sourceTree, dictionary, sourceNodeToDictionaryFn) {\n    TIMINGS && console.group(`Build tree for ${name}`);\n    try {\n      return compareWithBaseline ? buildCallTreeAndCompareWithBaseline(sourceTree, dictionary, sourceNodeToDictionaryFn).tree : buildCallTree(sourceTree, dictionary, sourceNodeToDictionaryFn);\n    } finally {\n      TIMINGS && console.groupEnd();\n    }\n  }\n  function buildTrees(callFramesTree, functions, modules, packages, categories) {\n    const functionsTree = buildCallTreeFor("functions", callFramesTree, functions, (callFrame) => callFrame.function.id - 1);\n    const modulesTree = buildCallTreeFor("modules", functionsTree, modules, (callFrame) => callFrame.module.id - 1);\n    const packagesTree = buildCallTreeFor("packages", modulesTree, packages, (callFrame) => callFrame.package.id - 1);\n    const categoriesTree = buildCallTreeFor("categories", packagesTree, categories, (callFrame) => callFrame.category.id - 1);\n    return {\n      functionsTree,\n      modulesTree,\n      packagesTree,\n      categoriesTree\n    };\n  }\n  var compareWithBaseline;\n  var init_build_trees2 = __esm({\n    "app/prepare/build-trees.ts"() {\n      init_const();\n      init_call_tree();\n      init_build_trees_wasm_wrapper();\n      init_build_trees_baseline();\n      compareWithBaseline = false;\n    }\n  });\n\n  // app/prepare/time-utils.ts\n  var time_utils_exports = {};\n  __export(time_utils_exports, {\n    formatMicrosecondsTime: () => formatMicrosecondsTime\n  });\n  function padZeroLeft(n, d) {\n    return String(n).padStart(d, "0");\n  }\n  function formatMicrosecondsTime(time, duration2) {\n    time = Math.round(time);\n    const m2 = Math.floor(time / (60 * 1e3 * 1e3));\n    const s = Math.floor(time / (1e3 * 1e3)) % 60;\n    const ms = Math.floor(time / 1e3) % 1e3;\n    switch (true) {\n      case duration2 < 1e5:\n        return `${(time / 1e3).toFixed(1)}ms`;\n      case duration2 < 1e6:\n        return `${Math.floor(time / 1e3)}ms`;\n      case duration2 < 6e7:\n        return `${s}.${padZeroLeft(ms, 3)}s`.replace(/(\\.000|0+)s/, "s");\n      default:\n        return `${m2}:${padZeroLeft(s, 2)}.${padZeroLeft(ms, 3)}`.replace(/(\\.000|0+)$/, "");\n    }\n  }\n  var init_time_utils = __esm({\n    "app/prepare/time-utils.ts"() {\n    }\n  });\n\n  // app/prepare/jora-methods.js\n  function shortNum(current, units) {\n    let unitIdx = 0;\n    while (current > 1e3 && unitIdx < units.length - 1) {\n      current /= 1e3;\n      unitIdx++;\n    }\n    const value = unitIdx === 0 ? current : current < 100 ? current.toFixed(1).replace(/\\.0/, "") : Math.round(current);\n    return value + units[unitIdx];\n  }\n  function makeDictMask2(tree, test2) {\n    const { dictionary } = tree;\n    const accept = typeof test2 === "function" ? test2 : (entry) => entry === test2;\n    const mask = new Uint8Array(dictionary.length);\n    for (let i = 0; i < mask.length; i++) {\n      if (accept(dictionary[i])) {\n        mask[i] = 1;\n      }\n    }\n    return mask;\n  }\n  function makeSamplesMask(tree, test2) {\n    const { dictionary, sampleIdToNode, nodes: nodes2 } = tree;\n    const accept = typeof test2 === "function" ? test2 : (entry) => entry === test2;\n    const mask = new Uint8Array(sampleIdToNode.length);\n    for (let i = 0; i < mask.length; i++) {\n      const nodeIndex = sampleIdToNode[i];\n      if (accept(dictionary[nodes2[nodeIndex]], i)) {\n        mask[i] = 1;\n      }\n    }\n    return mask;\n  }\n  function makeSampleBins(n, mask, samples, timeDeltas, totalTime) {\n    const bins = new Float64Array(n);\n    const step = totalTime / n;\n    let end = step;\n    let binIdx = 0;\n    for (let i = 0, offset = 0; i < samples.length; i++) {\n      const accept = mask[samples[i]];\n      const delta = timeDeltas[i];\n      if (offset + delta < end) {\n        if (accept) {\n          bins[binIdx] += delta;\n        }\n      } else {\n        if (accept) {\n          const dx = end - offset;\n          let x = delta - dx;\n          let i2 = 1;\n          while (x > step) {\n            bins[binIdx + i2] = step;\n            i2++;\n            x -= step;\n          }\n          bins[binIdx] += dx;\n          bins[binIdx + i2] = x;\n        }\n        while (offset + delta > end) {\n          binIdx += 1;\n          end += step;\n        }\n      }\n      offset += delta;\n    }\n    return bins;\n  }\n  function countSamples(n, samples, timeDeltas, totalTime) {\n    const bins = new Uint32Array(n);\n    const step = totalTime / n;\n    let end = step;\n    let binIdx = 0;\n    for (let i = 0, offset = 0; i < samples.length; i++) {\n      const delta = timeDeltas[i];\n      if (offset + delta < end) {\n        bins[binIdx]++;\n      } else {\n        const dx = end - offset;\n        let x = delta - dx;\n        let i2 = 1;\n        while (x > step) {\n          bins[binIdx + i2]++;\n          i2++;\n          x -= step;\n        }\n        bins[binIdx]++;\n        bins[binIdx + i2]++;\n        while (offset + delta > end) {\n          binIdx += 1;\n          end += step;\n        }\n      }\n      offset += delta;\n    }\n    return Array.from(bins);\n  }\n  var abbr, methods, jora_methods_default;\n  var init_jora_methods = __esm({\n    "app/prepare/jora-methods.js"() {\n      init_const();\n      init_time_utils();\n      init_call_tree();\n      init_compute_timings2();\n      abbr = {\n        Ignition: "Ig",\n        Sparkplug: "Sp",\n        Maglev: "Mg",\n        Turboprop: "Tp",\n        Turbofan: "Tb"\n      };\n      methods = {\n        order(value) {\n          return typeOrder[value] || 100;\n        },\n        color(value, comp) {\n          const dict = comp ? typeColorComponents : typeColor;\n          return dict[value] || dict.unknown;\n        },\n        abbr(value) {\n          return abbr[value] || value;\n        },\n        totalPercent(value, prec = 2) {\n          const totalTime = (this.context.context || this.context)?.data?.totalTime;\n          const percent = 100 * value / totalTime;\n          const min2 = 1 / Math.pow(10, prec || 1);\n          return percent >= min2 ? percent.toFixed(prec || 1) + "%" : percent !== 0 ? "<" + min2 + "%" : "0%";\n        },\n        duration(value) {\n          const totalTime = (this.context.context || this.context)?.data?.totalTime;\n          const percent = 100 * value / totalTime;\n          return (value / 1e3).toFixed(1) + "ms" + (percent >= 0.01 ? " / " + percent.toFixed(2) + "%" : "");\n        },\n        ms(value) {\n          return (value / 1e3).toFixed(1) + "ms";\n        },\n        bytes(current, bytes = true) {\n          return shortNum(current, [bytes ? "bytes" : "", "Kb", "Mb", "Gb"]);\n        },\n        shortNum(current) {\n          return shortNum(current, ["", "K", "M", "G"]);\n        },\n        formatMicrosecondsTime,\n        select(tree, type, ...args) {\n          let treeTimings = null;\n          if (tree instanceof TreeTiminigs) {\n            treeTimings = tree;\n            tree = tree.tree;\n          }\n          if (tree instanceof CallTree) {\n            let iterator;\n            switch (type) {\n              case "nodes":\n                iterator = typeof args[0] === "function" ? tree.selectBy(...args) : tree.selectNodes(...args);\n                break;\n              case "children":\n                iterator = tree.children(...args);\n                break;\n              case "subtree":\n                iterator = tree.subtree(...args);\n                break;\n              case "parent":\n                iterator = tree.ancestors(args[0], 1);\n                break;\n              case "ancestors":\n                iterator = tree.ancestors(...args);\n                break;\n            }\n            if (iterator !== void 0) {\n              if (treeTimings) {\n                const result = [];\n                for (const node of tree.map(iterator)) {\n                  const selfTime = treeTimings.selfTimes[node.nodeIndex];\n                  const nestedTime = treeTimings.nestedTimes[node.nodeIndex];\n                  result.push({\n                    node,\n                    selfTime,\n                    nestedTime,\n                    totalTime: selfTime + nestedTime\n                  });\n                }\n                return result;\n              }\n              return [...tree.map(iterator)];\n            }\n          }\n        },\n        // TODO: optimize\n        subtreeSamples(tree, subject, includeSelf = false) {\n          const sampleIdToNode = tree.sampleIdToNode;\n          const sampleIds = new Set(sampleIdToNode);\n          const selected = /* @__PURE__ */ new Set();\n          const selectedEntries = /* @__PURE__ */ new Set();\n          const selectedSamples = /* @__PURE__ */ new Set();\n          const mask = new Uint8Array(sampleIdToNode.length);\n          const selfId = typeof subject === "number" ? subject : tree.dictionary.indexOf(subject);\n          for (const nodeIndex of tree.selectNodes(subject)) {\n            if (includeSelf && sampleIds.has(nodeIndex)) {\n              selected.add(nodeIndex);\n            }\n            for (const subtreeNodeIndex of tree.subtree(nodeIndex)) {\n              if (sampleIds.has(subtreeNodeIndex) && (includeSelf || tree.nodes[subtreeNodeIndex] !== selfId)) {\n                selected.add(subtreeNodeIndex);\n                selectedEntries.add(tree.dictionary[tree.nodes[subtreeNodeIndex]]);\n              }\n            }\n          }\n          for (let i = 0; i < sampleIdToNode.length; i++) {\n            if (selected.has(sampleIdToNode[i])) {\n              mask[i] = 1;\n              selectedSamples.add(i);\n            }\n          }\n          return {\n            entries: [...selectedEntries],\n            selectedSamples,\n            mask,\n            sampleSelector: (_, sampleIndex) => selectedSamples.has(sampleIndex)\n          };\n        },\n        binCallsFromMask(mask, n = 500) {\n          const { samples, timeDeltas, totalTime } = this.context.data;\n          const bins = makeSampleBins(n, mask, samples, timeDeltas, totalTime);\n          return Array.from(bins);\n        },\n        getTimings(treeTimings, subject) {\n          if (typeof subject !== "number") {\n            subject = treeTimings.tree.dictionary.indexOf(subject);\n          }\n          return treeTimings.getTimings(subject);\n        },\n        nestedTimings(treeTimings, subject, structureTree) {\n          const timingsTree = treeTimings.tree;\n          const tree = structureTree || timingsTree;\n          const selfId = typeof subject === "number" ? subject : tree.dictionary.indexOf(subject);\n          const dictTimings = new Uint32Array(timingsTree.dictionary.length);\n          const nodes2 = tree.nodes;\n          const sampleIdToNode = tree.sampleIdToNode;\n          const nodesMask = new Uint32Array(tree.nodes.length);\n          const visited = /* @__PURE__ */ new Set();\n          const result = [];\n          for (const nodeIndex of tree.selectNodes(selfId)) {\n            for (const subtreeNodeIndex of tree.subtree(nodeIndex)) {\n              if (nodes2[subtreeNodeIndex] !== selfId) {\n                nodesMask[subtreeNodeIndex] = 1;\n              }\n            }\n          }\n          for (let i = 0; i < sampleIdToNode.length; i++) {\n            if (nodesMask[sampleIdToNode[i]]) {\n              const nodeIndex = timingsTree.sampleIdToNode[i];\n              if (!visited.has(nodeIndex)) {\n                dictTimings[timingsTree.nodes[nodeIndex]] += treeTimings.selfTimes[nodeIndex];\n                visited.add(nodeIndex);\n              }\n            }\n          }\n          for (let i = 0; i < dictTimings.length; i++) {\n            if (dictTimings[i] > 0) {\n              result.push({\n                entry: timingsTree.dictionary[i],\n                selfTime: dictTimings[i]\n              });\n            }\n          }\n          return result;\n        },\n        selectBy(tree, test2) {\n          const { nodes: nodes2 } = tree;\n          const mask = makeDictMask2(tree, test2);\n          const result = [];\n          for (let i = 0; i < nodes2.length; i++) {\n            if (mask[nodes2[i]]) {\n              result.push(tree.getEntry(i));\n            }\n          }\n          return result;\n        },\n        countSamples(n = 500) {\n          const { samples, timeDeltas, totalTime } = this.context.data;\n          return countSamples(n, samples, timeDeltas, totalTime);\n        },\n        binCalls(tree, test2, n = 500) {\n          const { samples, timeDeltas, totalTime } = this.context.data;\n          const mask = makeSamplesMask(tree, test2);\n          const bins = makeSampleBins(n, mask, samples, timeDeltas, totalTime);\n          return Array.from(bins);\n        }\n      };\n      jora_methods_default = methods;\n    }\n  });\n\n  // app/prepare/process-scripts.ts\n  function normalizeUrl(url) {\n    let protocol2 = (url.match(/^([a-z\\-]+):/i) || [])[1] || "";\n    if (protocol2.length === 1 && /[A-Z]/.test(protocol2)) {\n      protocol2 = "";\n      url = url.slice(2);\n    }\n    if (protocol2 === "" && url) {\n      return "file://" + url.replace(/\\\\/g, "/");\n    }\n    return url;\n  }\n  function processScripts(inputScripts = [], inputFunctions = [], moduleByScriptId) {\n    const scripts = [];\n    const scriptFunctions = [];\n    const functionById = /* @__PURE__ */ new Map();\n    for (const script of inputScripts || []) {\n      scripts.push({\n        ...script,\n        url: normalizeUrl(script.url || ""),\n        module: moduleByScriptId.get(script.id) || null,\n        compilation: null,\n        functions: []\n      });\n    }\n    for (const fn of inputFunctions || []) {\n      const script = fn.script !== null ? scripts[fn.script] || null : null;\n      const loc = script && fn.line !== -1 && fn.column !== -1 ? `:${fn.line}:${fn.column}` : null;\n      const newFn = {\n        ...fn,\n        script,\n        loc,\n        function: null,\n        inlinedInto: null\n      };\n      scriptFunctions.push(newFn);\n      functionById.set(newFn.id, newFn);\n      if (script !== null) {\n        if (newFn.start === 0 && newFn.end === script.source.length) {\n          script.compilation = newFn.states;\n        } else {\n          script.functions.push(newFn);\n        }\n      }\n    }\n    for (const script of scripts) {\n      if (script.module === null) {\n        continue;\n      }\n      const locToFn = /* @__PURE__ */ new Map();\n      for (const moduleFn of script.module.functions) {\n        const loc = moduleFn.loc;\n        if (loc !== null) {\n          locToFn.set(loc, moduleFn);\n        }\n      }\n      for (const fn of script.functions) {\n        const moduleFn = locToFn.get(`:${fn.line}:${fn.column}`);\n        if (moduleFn !== void 0) {\n          fn.function = moduleFn;\n        }\n      }\n    }\n    return {\n      scripts,\n      scriptFunctions\n    };\n  }\n  var init_process_scripts = __esm({\n    "app/prepare/process-scripts.ts"() {\n    }\n  });\n\n  // app/prepare.js\n  function prepare_default(input, { rejectData, defineObjectMarker, addValueAnnotation, addQueryHelpers }) {\n    const markAsCallFrame = defineObjectMarker("callFrame", { ref: "id", title: "name" });\n    const markAsFunction = defineObjectMarker("function", { ref: "id", title: "name", page: "function" });\n    const markAsPackage = defineObjectMarker("package", { ref: "id", title: "name", page: "package" });\n    const markAsModule = defineObjectMarker("module", { ref: "id", title: (module) => module.name || module.path, page: "module" });\n    const markAsCategory = defineObjectMarker("category", { ref: "name", title: "name", page: "category" });\n    const markTime = TIMINGS ? createMarkTime() : () => void 0;\n    markTime("convertValidate()");\n    const data = convertValidate(input, rejectData);\n    const nodesCount = data.nodes.length;\n    const samplesCount = data.samples.length;\n    markTime("find max node ID");\n    let maxNodeId = findMaxId(data.nodes);\n    markTime("processTimeDeltas()");\n    const {\n      startTime,\n      startNoSamplesTime,\n      endTime,\n      endNoSamplesTime,\n      totalTime,\n      samplesInterval\n    } = processTimeDeltas(\n      data.timeDeltas,\n      data.samples,\n      data.startTime,\n      data.endTime,\n      data._samplesInterval\n      // could be computed on V8 log convertation into cpuprofile\n    );\n    markTime("convert samples and timeDeltas into TypeArrays");\n    const samples = convertToUint32Array(data.samples);\n    const timeDeltas = convertToUint32Array(data.timeDeltas);\n    markTime("gcReparenting()");\n    maxNodeId = gcReparenting(samples, data.nodes, maxNodeId);\n    markTime("processNodes()");\n    const {\n      callFrames,\n      callFramesTree\n    } = processNodes(data.nodes, maxNodeId);\n    markTime("processCallFrames()");\n    const {\n      wellKnownCallFrames,\n      moduleByScriptId,\n      categories,\n      packages,\n      modules,\n      functions\n    } = processCallFrames(\n      callFrames,\n      data.scripts,\n      data.scriptFunctions,\n      data.executionContexts\n    );\n    markTime("processPaths()");\n    processPaths(packages, modules, functions);\n    markTime("processDisplayNames()");\n    processDisplayNames(modules);\n    markTime("sort dictionaries & remap ids");\n    functions.forEach(remapId);\n    modules.sort((a, b2) => a.type < b2.type ? -1 : a.type > b2.type ? 1 : a.path < b2.path ? -1 : 1).forEach(remapId);\n    packages.sort((a, b2) => a.name < b2.name ? -1 : 1).forEach(remapId);\n    categories.sort((a, b2) => a.id < b2.id ? -1 : 1).forEach(remapId);\n    markTime("apply discovery object markers");\n    callFrames.forEach(markAsCallFrame);\n    functions.forEach(markAsFunction);\n    modules.forEach(markAsModule);\n    packages.forEach(markAsPackage);\n    categories.forEach(markAsCategory);\n    markTime("buildTrees()");\n    const {\n      functionsTree,\n      modulesTree,\n      packagesTree,\n      categoriesTree\n    } = buildTrees(\n      callFramesTree,\n      functions,\n      modules,\n      packages,\n      categories\n    );\n    markTime("processScripts()");\n    const {\n      scripts,\n      scriptFunctions\n    } = processScripts(data.scripts, data.scriptFunctions, moduleByScriptId);\n    markTime("processSamples()");\n    const {\n      samplesTimings,\n      samplesTimingsFiltered,\n      functionsTimings,\n      functionsTimingsFiltered,\n      functionsTreeTimings,\n      functionsTreeTimingsFiltered,\n      modulesTimings,\n      modulesTimingsFiltered,\n      modulesTreeTimings,\n      modulesTreeTimingsFiltered,\n      packagesTimings,\n      packagesTimingsFiltered,\n      packagesTreeTimings,\n      packagesTreeTimingsFiltered,\n      categoriesTimings,\n      categoriesTimingsFiltered,\n      categoriesTreeTimings,\n      categoriesTreeTimingsFiltered\n    } = processSamples(\n      samples,\n      timeDeltas,\n      callFramesTree,\n      functionsTree,\n      modulesTree,\n      packagesTree,\n      categoriesTree\n    );\n    addQueryHelpers(jora_methods_default);\n    addValueAnnotation(\'#.key in ["selfTime", "nestedTime", "totalTime"] and $ and { text: duration() }\');\n    markTime("producing result");\n    const result = {\n      runtime: detectRuntime(categories, packages, data.runtime),\n      sourceInfo: {\n        nodes: nodesCount,\n        samples: samplesCount,\n        samplesInterval\n      },\n      scripts,\n      scriptFunctions,\n      startTime,\n      startNoSamplesTime,\n      endTime,\n      endNoSamplesTime,\n      totalTime,\n      samples: samplesTimings.samples,\n      samplesTimings,\n      samplesTimingsFiltered,\n      timeDeltas: samplesTimings.timeDeltas,\n      wellKnownCallFrames,\n      callFrames,\n      callFramesTree,\n      functions,\n      functionsTimings,\n      functionsTimingsFiltered,\n      functionsTree,\n      functionsTreeTimings,\n      functionsTreeTimingsFiltered,\n      modules,\n      modulesTimings,\n      modulesTimingsFiltered,\n      modulesTree,\n      modulesTreeTimings,\n      modulesTreeTimingsFiltered,\n      packages,\n      packagesTimings,\n      packagesTimingsFiltered,\n      packagesTree,\n      packagesTreeTimings,\n      packagesTreeTimingsFiltered,\n      categories,\n      categoriesTimings,\n      categoriesTimingsFiltered,\n      categoriesTree,\n      categoriesTreeTimings,\n      categoriesTreeTimingsFiltered\n    };\n    markTime("finish");\n    return result;\n  }\n  var init_prepare2 = __esm({\n    "app/prepare.js"() {\n      init_const();\n      init_utils2();\n      init_prepare();\n      init_process_call_frames();\n      init_process_nodes();\n      init_process_paths();\n      init_process_module_names();\n      init_process_samples();\n      init_process_time_deltas();\n      init_detect_runtime();\n      init_build_trees2();\n      init_jora_methods();\n      init_process_scripts();\n    }\n  });\n\n  // discovery-cli:default/prepare.js\n  function prepare_default2(host) {\n    const prepares = [prepare_default].filter((p) => {\n      if (typeof p === "function")\n        return true;\n      console.warn(\'[discovery-cli] "prepare" module should return a function, but got \' + typeof p);\n    });\n    if (prepares.length) {\n      host.setPrepare(async (data, ...args) => {\n        for (const prepare of prepares) {\n          data = await prepare(data, ...args) || data;\n        }\n        return data;\n      });\n    }\n  }\n  var init_prepare3 = __esm({\n    "discovery-cli:default/prepare.js"() {\n      init_prepare2();\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/pages/default.js\n  var default_exports = {};\n  __export(default_exports, {\n    default: () => default_default\n  });\n  function default_default(discovery) {\n    const { supportedFormats: supportedFormats2 } = (init_prepare(), __toCommonJS(prepare_exports));\n    function consumeDemos() {\n      const demos = discovery.context?.model?.meta?.demos;\n      if (demos) {\n        discovery.action.define("demos", () => demos);\n        if (discovery.data) {\n          discovery.cancelScheduledRender();\n        }\n      }\n    }\n    setTimeout(() => {\n      discovery.nav.primary.append({\n        className: "github",\n        content: \'text:"GitHub"\',\n        data: { href: "https://github.com/lahmatiy/cpupro" }\n      });\n      discovery.nav.primary.append({\n        className: "full-page-mode",\n        content: \'text:"Exit full page"\',\n        when: "#.params.flamechartFullpage",\n        onClick: () => toggleFullPageFlamechart(false)\n      });\n      discovery.nav.menu.append({\n        when: "#.actions.unloadData",\n        content: \'text:"Unload cpuprofile"\',\n        onClick(_, ctx) {\n          ctx.hide();\n          ctx.widget.unloadData();\n          ctx.widget.setPageHash("");\n        }\n      });\n      discovery.nav.render(discovery.dom.nav, discovery.data, discovery.getRenderContext());\n      discovery.on("data", consumeDemos);\n      consumeDemos();\n    }, 1);\n    function toggleFullPageFlamechart(fullpageMode) {\n      const params = { ...discovery.pageParams };\n      if (fullpageMode) {\n        params.flamechartFullpage = true;\n      } else {\n        delete params.flamechartFullpage;\n      }\n      discovery.setPageParams(params, true);\n      discovery.cancelScheduledRender();\n      discovery.dom.pageContent.classList.toggle("flamecharts-fullpage", fullpageMode);\n      discovery.nav.render(discovery.dom.nav, discovery.data, discovery.getRenderContext());\n      setTimeout(() => {\n        const flamechartEl = discovery.dom.container.querySelector(".flamecharts .view-flamechart");\n        flamechartEl.classList.add("disable-scrolling");\n        flamechartEl.classList.toggle("lock-scrolling", !fullpageMode);\n      }, 10);\n    }\n    const pageIndicators = {\n      view: "page-indicators",\n      content: [\n        {\n          className: "=`runtime ${runtime.code}`",\n          title: "Runtime",\n          hint: \'md:"#### Runtime\\\\n\\\\nThe runtime is heuristically determined based on modules identified within the profile."\',\n          value: \'=runtime | code != "unknown" ? name : `Unknown/${engine}`\'\n        },\n        {\n          view: "page-indicator-group",\n          content: [\n            {\n              title: "Profiling time",\n              hint: \'md{ source: "#### Profiling time\\\\n\\\\nThe time of the profiling session, excluding the time before the first sample and after the last sample, which are periods with no samples. The total profiling time is calculated by summing the durations of all captured samples and is used as the basis for computing time percentages.\\\\n\\\\nThe time before the first sample represents the start-up overhead of the profiling session, which is minimal if profiling begins at program start but may be longer if initiated during program execution.\\\\n\\\\nThe time after the last sample is typically zero unless it includes overhead from concluding the profiling session or adjustments from excluding idle samples at the end.\\\\n\\\\n- Profiling session time: `{{endTime - startTime | ms()}}`\\\\n- Time before first sample: `{{startNoSamplesTime | ms()}}`\\\\n- Time after last sample: `{{endNoSamplesTime | ms()}}`\\\\n- Profiling time:<br>`{{endTime - startTime | ms()}}` \\u2013 `{{startNoSamplesTime | ms()}}` \\u2013 `{{endNoSamplesTime | ms()}}` = `{{totalTime | ms()}}`" }\',\n              value: "=totalTime.ms()",\n              unit: true\n            },\n            {\n              title: "Samples",\n              hint: \'md{ source: "#### Samples\\\\n\\\\nThe total number of samples captured during the profiling session.\\\\n\\\\nEach sample represents the CPU\\\'s state, including the call stack, at\\xA0a\\xA0specific time interval, revealing which functions are executing at each point.\\\\n\\\\nFor efficiency, CPUpro merges sequentially identical samples, reducing the workload of processing samples.\\\\n\\\\n- Captured samples: `{{#.data.sourceInfo.samples}}`\\\\n- Deduplicated samples: `{{#.data.samples.size()}}`" }\',\n              value: "=sourceInfo.samples"\n            },\n            {\n              title: "Sampling interval",\n              hint: `md:"#### Sampling interval\\\\n\\\\nThe median duration between consecutive samples recorded during profiling. This metric offers an estimate of the average frequency at which the CPU\'s state is captured, reflecting the profiler\'s temporal resolution.\\\\n\\\\nIn V8, you can set the sampling interval at the start of a CPU profiling session. Adjusting this interval helps balance the level of detail captured against the performance impact on the system."`,\n              value: "=sourceInfo.samplesInterval",\n              unit: "\\u03BCs"\n            }\n          ]\n        },\n        {\n          view: "page-indicator-group",\n          content: [\n            {\n              title: "Call tree nodes",\n              hint: `md:"#### Call tree nodes\\\\n\\\\nA **call tree** is a data structure that represents the hierarchy of function calls during the execution of a program. It demostrates the actual sequences of function calls that occurred during the profiling session.\\\\n\\\\nThe metric indicates **the size of the tree** (the number of leafs). Typically, the number of distinct functions is less than the call tree\'s size, reflecting multiple calls to the same functions from various parts of the program."`,\n              value: "=sourceInfo.nodes"\n            },\n            {\n              title: "Call frames",\n              hint: \'md:"#### Call frames\\\\n\\\\nThe count of unique functions encountered during profiling. This metric helps identify the diversity of function executions regardless of their position in the call stacks.\\\\n\\\\nUniqueness is determined by attributes such as `scriptId`, `function name`, `url`, `line number`, and `column number`."\',\n              value: "=callFrames.size()"\n            }\n          ]\n        },\n        {\n          view: "page-indicator-group",\n          className: "filters",\n          content: {\n            view: "update-on-timings-change",\n            timings: "=samplesTimingsFiltered",\n            content: {\n              view: "context",\n              when: "samplesTimingsFiltered.rangeStart != null",\n              content: [\n                {\n                  view: "block",\n                  className: "page-indicator-group-tag"\n                },\n                {\n                  view: "page-indicator",\n                  title: "Samples",\n                  value: "=samplesTimingsFiltered.rangeSamples"\n                },\n                {\n                  view: "page-indicator",\n                  title: "Range",\n                  value: "=`${samplesTimingsFiltered.rangeStart.formatMicrosecondsTime()} \\u2013 ${samplesTimingsFiltered.rangeEnd.formatMicrosecondsTime()}`"\n                }\n              ]\n            }\n          }\n        }\n      ]\n    };\n    const categoriesTimeBars = {\n      view: "timing-bar",\n      data: `categoriesTimings.entries.[selfTime].({\n        text: entry.name,\n        duration: selfTime,\n        color: entry.name.color(),\n        href: entry.marker("category").href\n    }).sort(duration desc)`,\n      segment: {\n        tooltip: [\n          "text:text",\n          "duration:{ time: duration, total: #.data.totalTime }"\n        ]\n      }\n    };\n    const categoriesTimeline = {\n      view: "block",\n      className: "category-timelines",\n      data: `\n        $binCount: 500;\n        $totalTime: #.data.totalTime;\n        $binSamples: $binCount.countSamples();\n\n        categoriesTimings.entries.[selfTime].({\n            $category: entry;\n\n            $category,\n            timings: $,\n            $totalTime,\n            $binCount,\n            binTime: $totalTime / $binCount,\n            $binSamples,\n            bins: #.data.categoriesTree.binCalls($category, $binCount),\n            color: $category.name.color(),\n            href: $category.marker("category").href\n        })\n    `,\n      content: [\n        {\n          view: "time-ruler",\n          duration: "=$[].totalTime",\n          segments: "=$[].binCount",\n          selectionStart: "=#.data.samplesTimingsFiltered.rangeStart",\n          selectionEnd: "=#.data.samplesTimingsFiltered.rangeEnd",\n          onChange: (state, name, el, data, context) => {\n            const timings = context.data.samplesTimingsFiltered;\n            if (state.timeStart !== null) {\n              timings.setRange(state.timeStart, state.timeEnd);\n            } else {\n              timings.resetRange();\n            }\n          },\n          details: [\n            {\n              view: "block",\n              className: "timeline-segment-info",\n              content: [\n                { view: "block", content: "text:`Range: ${#.timeStart.formatMicrosecondsTime(totalTime)} \\u2013 ${#.timeEnd.formatMicrosecondsTime(totalTime)}`" },\n                { view: "block", content: "text:`Samples: ${$[].binSamples[#.segmentStart:#.segmentEnd + 1].sum()}`" },\n                { view: "block", content: ["text:`Duration: `", "duration:{ time: #.timeEnd - #.timeStart, total: totalTime }"] }\n              ]\n            },\n            {\n              view: "list",\n              className: "category-timings-list",\n              itemConfig: {\n                className: \'=bins[#.segmentStart:#.segmentEnd + 1].sum() = 0 ? "no-time"\',\n                postRender: (el, _, data) => el.style.setProperty("--color", data.color),\n                content: [\n                  \'block{ className: "category-name", content: "text:category.name" }\',\n                  "duration{ data: { time: bins[#.segmentStart:#.segmentEnd + 1].sum(), total: #.timeEnd - #.timeStart } }"\n                ]\n              }\n            }\n          ]\n        },\n        {\n          view: "list",\n          className: "category-timelines-list",\n          item: {\n            view: "link",\n            className: "category-timelines-item",\n            content: [\n              {\n                view: "block",\n                className: "label",\n                postRender: (el, _, data) => el.style.setProperty("--color", data.color),\n                content: "text:category.name"\n              },\n              {\n                view: "block",\n                className: "total-percent",\n                content: \'text:timings.selfTime.totalPercent().replace("%", "")\'\n              },\n              {\n                view: "timeline-segments-bin",\n                bins: "=bins",\n                max: "=binTime",\n                binsMax: true,\n                color: "=color"\n              }\n            ]\n          }\n        }\n      ]\n    };\n    const packagesList = {\n      view: "section",\n      data: "packagesTimingsFiltered",\n      header: [],\n      content: {\n        view: "content-filter",\n        content: {\n          view: "update-on-timings-change",\n          debounce: true,\n          content: {\n            view: "table",\n            data: "entries.[totalTime and entry.name ~= #.filter].sort(selfTime desc, totalTime desc)",\n            limit: 15,\n            cols: [\n              { header: "Self time", sorting: "selfTime desc, totalTime desc", content: "duration:{ time: selfTime, total: #.data.totalTime }" },\n              { header: "Total time", sorting: "totalTime desc, selfTime desc", content: "duration:{ time: totalTime, total: #.data.totalTime }" },\n              { header: "Package", className: "main", sorting: "entry.name asc", content: "package-badge:entry" }\n            ]\n          }\n        }\n      }\n    };\n    const modulesList = {\n      view: "section",\n      data: "modulesTimingsFiltered",\n      header: [],\n      content: {\n        view: "content-filter",\n        content: {\n          view: "update-on-timings-change",\n          debounce: true,\n          content: {\n            view: "table",\n            data: `entries\n                    .[totalTime and entry.name ~= #.filter]\n                    .sort(selfTime desc, totalTime desc)\n                `,\n            limit: 15,\n            cols: [\n              { header: "Self time", sorting: "selfTime desc, totalTime desc", content: "duration:{ time: selfTime, total: #.data.totalTime }" },\n              { header: "Total time", sorting: "totalTime desc, selfTime desc", content: "duration:{ time: totalTime, total: #.data.totalTime }" },\n              { header: "Module", className: "main", sorting: "entry.name ascN", content: "module-badge:entry" }\n            ]\n          }\n        }\n      }\n    };\n    const functionList = {\n      view: "section",\n      data: "functionsTimingsFiltered",\n      header: [],\n      content: {\n        view: "content-filter",\n        content: {\n          view: "update-on-timings-change",\n          debounce: true,\n          content: {\n            view: "table",\n            data: "entries.[totalTime and entry.name ~= #.filter].sort(selfTime desc, totalTime desc)",\n            limit: 15,\n            cols: [\n              { header: "Self time", sorting: "selfTime desc, totalTime desc", content: "duration:{ time: selfTime, total: #.data.totalTime }" },\n              { header: "Total time", sorting: "totalTime desc, selfTime desc", content: "duration:{ time: totalTime, total: #.data.totalTime }" },\n              { header: "Function", className: "main", sorting: "entry.name ascN", content: "function-badge:entry" }\n            ]\n          }\n        }\n      }\n    };\n    const flamecharts = {\n      view: "context",\n      modifiers: {\n        view: "block",\n        className: "toolbar",\n        content: [\n          {\n            view: "toggle-group",\n            name: "dataset",\n            data: [\n              { text: "Categories", value: "categoriesTree" },\n              { text: "Packages", value: "packagesTree", active: true },\n              { text: "Modules", value: "modulesTree" },\n              { text: "Functions", value: "functionsTree" }\n            ]\n          },\n          {\n            view: "block",\n            className: "filters",\n            content: [\n              // {\n              //     view: \'checkbox\',\n              //     name: \'showIdle\',\n              //     checked: true,\n              //     content: \'text:"(idle)"\',\n              //     tooltip: {\n              //         showDelay: true,\n              //         className: \'hint-tooltip\',\n              //         content: \'md:"Time when the engine is waiting for tasks or not actively executing any JavaScript code. This could be due to waiting for I/O operations, timer delays, or simply because there\\\'s no code to execute at that moment."\'\n              //     }\n              // },\n              // {\n              //     view: \'checkbox\',\n              //     name: \'showProgram\',\n              //     checked: true,\n              //     content: \'text:"(program)"\',\n              //     tooltip: {\n              //         showDelay: true,\n              //         className: \'hint-tooltip\',\n              //         content: \'text:"Time spent by the engine on tasks other than executing JavaScript code. This includes overheads like JIT compilation, managing execution contexts, and time in engine\\\'s internal code. It reflects the internal processing and environment setup necessary for running JavaScript code, rather than the execution of the code itself."\'\n              //     }\n              // },\n              // {\n              //     view: \'checkbox\',\n              //     name: \'showGC\',\n              //     checked: true,\n              //     content: \'text:"(garbage collector)"\',\n              //     tooltip: {\n              //         showDelay: true,\n              //         className: \'hint-tooltip\',\n              //         content: \'text:"When the CPU profile shows time spent in the garbage collector, it indicates the time consumed in these memory management activities. Frequent or prolonged garbage collection periods might be a sign of inefficient memory use in the application, like creating too many short-lived objects or holding onto unnecessary references."\'\n              //     }\n              // }\n            ]\n          },\n          {\n            view: "toggle",\n            className: "flamechart-fullpage-toggle",\n            content: \'text:"Full page"\',\n            onToggle: () => toggleFullPageFlamechart(true)\n          }\n        ]\n      },\n      content: {\n        view: "flamechart",\n        tree: "=$[#.dataset]",\n        timings: \'=$[#.dataset + "TimingsFiltered"]\',\n        lockScrolling: true,\n        postRender(el, config, data, context) {\n          el.classList.toggle("lock-scrolling", !context.params.flamechartFullpage);\n        }\n      }\n    };\n    const noDataPageContent = {\n      view: "block",\n      className: "welcome-page",\n      content: [\n        {\n          view: "page-header",\n          content: [\n            { view: "block", className: "logo" },\n            \'h1:"cpupro"\',\n            { view: "block", className: "description", content: \'text:"A viewer for CPU profiles captured in V8 runtimes like Node.js, Deno or Chromium browsers"\' }\n          ]\n        },\n        {\n          view: "block",\n          when: "#.actions.uploadFile",\n          className: "upload-data",\n          content: [\n            "preset/upload",\n            {\n              view: "block",\n              className: "upload-notes",\n              content: \'html:"CPUpro is a server-less application that processes profiles locally without transmitting data elsewhere,<br>it securely opens and analyzes your profiles directly on your device."\'\n            }\n          ]\n        },\n        {\n          view: "markdown",\n          source: [\n            "Supported formats:",\n            ...supportedFormats2\n          ]\n        },\n        {\n          view: "block",\n          className: "examples",\n          when: "#.actions.demos",\n          content: [\n            \'text:"Try out example:"\',\n            \'html:"<br>"\',\n            {\n              view: "inline-list",\n              data: \'"demos".callAction()\',\n              whenData: true,\n              item: {\n                view: "button",\n                className: "=runtime",\n                onClick(_, data) {\n                  discovery.loadDataFromUrl(data.url);\n                },\n                content: "text:title"\n              }\n            }\n          ]\n        }\n      ]\n    };\n    discovery.page.define("default", {\n      view: "switch",\n      content: [\n        {\n          when: "no #.datasets",\n          content: noDataPageContent\n        },\n        { content: [\n          {\n            view: "page-header",\n            content: [\n              {\n                view: "h2",\n                content: [\n                  { view: "block", className: "logo" },\n                  \'text:#.datasets[].resource | type = "file" ? name : "Untitled profile"\'\n                ]\n              }\n            ]\n          },\n          pageIndicators,\n          {\n            view: "timeline-profiles",\n            data: "profiles",\n            whenData: true\n          },\n          {\n            view: "expand",\n            expanded: true,\n            className: "timelines trigger-outside",\n            header: categoriesTimeBars,\n            content: categoriesTimeline\n          },\n          {\n            view: "expand",\n            expanded: true,\n            className: "hierarchical-components trigger-outside",\n            postRender: (el, config, data, context) => el.style.setProperty("--total-time-digits", String(context.data.totalTime).replace(/\\D/g, "").length - 2),\n            header: [\n              { view: "block", content: [\n                \'text:"Packages "\',\n                {\n                  view: "update-on-timings-change",\n                  data: "packagesTimingsFiltered",\n                  content: "text-numeric:entries.[totalTime].size()"\n                }\n              ] },\n              { view: "block", content: [\n                \'text:"Modules "\',\n                {\n                  view: "update-on-timings-change",\n                  data: "modulesTimingsFiltered",\n                  content: "text-numeric:entries.[totalTime].size()"\n                }\n              ] },\n              { view: "block", content: [\n                \'text:"Functions "\',\n                {\n                  view: "update-on-timings-change",\n                  data: "functionsTimingsFiltered",\n                  content: "text-numeric:entries.[totalTime].size()"\n                }\n              ] }\n            ],\n            content: [\n              packagesList,\n              modulesList,\n              functionList\n            ]\n          },\n          {\n            view: "expand",\n            expanded: true,\n            className: "flamecharts trigger-outside",\n            header: \'text:"Flame charts"\',\n            content: flamecharts\n          }\n        ] }\n      ]\n    }, {\n      init(pageEl) {\n        pageEl.classList.toggle("flamecharts-fullpage", Boolean(discovery.pageParams.flamechartFullpage));\n      }\n    });\n  }\n  var init_default = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/pages/default.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/pages/category.js\n  var category_exports = {};\n  __export(category_exports, {\n    default: () => category_default\n  });\n  function category_default(discovery) {\n    const pageContent = {\n      content: [\n        {\n          view: "page-header",\n          prelude: [\n            \'badge{ className: "type-badge", text: "Category" }\'\n          ],\n          content: "h1:name"\n        },\n        {\n          view: "subject-with-nested-timeline",\n          data: "{ subject: @, tree: #.data.categoriesTree }"\n        },\n        {\n          view: "update-on-timings-change",\n          timings: "=#.data.categoriesTimingsFiltered",\n          content: {\n            view: "page-indicator-timings",\n            data: `{\n                    full: #.data.categoriesTimings.entries[=>entry = @],\n                    filtered: #.data.categoriesTimingsFiltered.entries[=>entry = @]\n                }`\n          }\n        },\n        {\n          view: "expand",\n          expanded: false,\n          className: "trigger-outside",\n          header: \'text:"Nested time distribution"\',\n          content: "nested-timings-tree:{ subject: @, tree: #.data.categoriesTree, timings: #.data.functionsTimingsFiltered }"\n        },\n        {\n          view: "context",\n          when: \'name in ["script", "chrome-extension"]\',\n          content: {\n            view: "expand",\n            expanded: true,\n            className: "trigger-outside",\n            header: [\n              \'text:"Packages "\',\n              {\n                view: "update-on-timings-change",\n                timings: "=#.data.packagesTimingsFiltered",\n                content: { view: "pill-badge", content: "text-numeric:#.data.packagesTimingsFiltered.entries.[totalTime and entry.category = @].size()" }\n              }\n            ],\n            content: {\n              view: "content-filter",\n              className: "table-content-filter",\n              content: {\n                view: "update-on-timings-change",\n                timings: "=#.data.packagesTimingsFiltered",\n                content: {\n                  view: "table",\n                  data: "#.data.packagesTimingsFiltered.entries.[totalTime and entry.category = @ and entry.name ~= #.filter].sort(selfTime desc, totalTime desc)",\n                  cols: [\n                    { header: "Self time", sorting: "selfTime desc, totalTime desc", content: "duration:{ time: selfTime, total: #.data.totalTime }" },\n                    { header: "Nested time", sorting: "nestedTime desc, totalTime desc", content: "duration:{ time: nestedTime, total: #.data.totalTime }" },\n                    { header: "Total time", sorting: "totalTime desc, selfTime desc", content: "duration:{ time: totalTime, total: #.data.totalTime }" },\n                    { header: "Package", sorting: "entry.name asc", content: "package-badge:entry" },\n                    { header: "Modules", data: "entry.modules" },\n                    { header: "Functions", data: "entry.modules.functions" }\n                  ]\n                }\n              }\n            }\n          }\n        },\n        {\n          view: "expand",\n          expanded: true,\n          className: "trigger-outside",\n          header: [\n            \'text:"Modules "\',\n            {\n              view: "update-on-timings-change",\n              timings: "=#.data.modulesTimingsFiltered",\n              content: { view: "pill-badge", content: "text-numeric:#.data.modulesTimingsFiltered.entries.[totalTime and entry.category = @].size()" }\n            }\n          ],\n          content: {\n            view: "content-filter",\n            className: "table-content-filter",\n            content: {\n              view: "update-on-timings-change",\n              timings: "=#.data.modulesTimingsFiltered",\n              content: {\n                view: "table",\n                data: "#.data.modulesTimingsFiltered.entries.[totalTime and entry.category = @ and entry.name ~= #.filter].sort(selfTime desc, totalTime desc)",\n                cols: [\n                  { header: "Self time", sorting: "selfTime desc, totalTime desc", content: "duration:{ time: selfTime, total: #.data.totalTime }" },\n                  { header: "Nested time", sorting: "nestedTime desc, totalTime desc", content: "duration:{ time: nestedTime, total: #.data.totalTime }" },\n                  { header: "Total time", sorting: "totalTime desc, selfTime desc", content: "duration:{ time: totalTime, total: #.data.totalTime }" },\n                  { header: "Module", sorting: "entry.name ascN", content: "module-badge:entry" },\n                  { header: "Functions", data: "entry.functions" }\n                ]\n              }\n            }\n          }\n        },\n        {\n          view: "flamechart-expand",\n          tree: "=#.data.categoriesTree",\n          timings: "=#.data.categoriesTreeTimingsFiltered",\n          value: "="\n        }\n      ]\n    };\n    discovery.page.define("category", {\n      view: "switch",\n      data: "categories[=>name = #.id]",\n      content: [\n        { when: "no $", content: {\n          view: "alert-warning",\n          content: \'md:"No category with id \\\\"{{#.id}}\\\\" is found\\\\n\\\\n[Back to index page](#)"\'\n        } },\n        pageContent\n      ]\n    });\n  }\n  var init_category = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/pages/category.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/pages/function.js\n  var function_exports = {};\n  __export(function_exports, {\n    default: () => function_default\n  });\n  function function_default(discovery) {\n    const descendantTree = {\n      view: "block",\n      content: [\n        \'h3:"Subtree"\',\n        {\n          view: "tree",\n          className: "call-tree",\n          data: `\n                #.data.functionsTreeTimings.select(\'nodes\', @, true)\n                | sort(totalTime desc, selfTime desc)\n            `,\n          children: `\n                #.data.functionsTreeTimings.select(\'children\', node.nodeIndex)\n                | sort(totalTime desc, selfTime desc, node.value.name ascN)\n            `,\n          item: {\n            view: "context",\n            content: [\n              {\n                view: "switch",\n                content: [\n                  { when: "node.value.id = +#.id", content: {\n                    view: "block",\n                    className: "self",\n                    content: "text:node.value.name"\n                  } },\n                  { content: "auto-link:node.value" }\n                ]\n              },\n              { view: "text", when: "subtreeSize", data: "` (${subtreeSize}) `" },\n              {\n                view: "block",\n                className: "grouped",\n                data: "grouped.size()",\n                whenData: "$ > 1",\n                content: \'text:"\\xD7" + $\'\n              },\n              {\n                view: "self-time"\n              },\n              {\n                view: "nested-time",\n                data: "nestedTime",\n                whenData: true\n              },\n              // { view: \'total-time\', when: \'children\', data: \'totalTime\' },\n              {\n                view: "context",\n                when: "node.value.id != +#.id",\n                content: [\n                  "module-badge:node.value",\n                  "loc-badge:node.value"\n                ]\n              }\n            ]\n          }\n        }\n      ]\n    };\n    const ancestorsTree = {\n      view: "block",\n      content: [\n        \'h3:"Ancestor call sites"\',\n        {\n          view: "tree",\n          className: "call-tree",\n          expanded: 3,\n          data: `\n                #.data.functionsTreeTimings.select(\'nodes\', $, true)\n                | sort(totalTime desc)\n            `,\n          children: `\n                node.parent ? #.data.functionsTreeTimings.select(\'parent\', node.nodeIndex)\n                | sort(totalTime desc)\n            `,\n          item: {\n            view: "context",\n            content: [\n              {\n                view: "switch",\n                content: [\n                  { when: "node.value.id = +#.id", content: {\n                    view: "block",\n                    className: "self",\n                    content: "text:node.value.name"\n                  } },\n                  { content: "auto-link:node.value" }\n                ]\n              },\n              {\n                view: "block",\n                className: "grouped",\n                data: "grouped.size()",\n                whenData: "$ > 1",\n                content: \'text:"\\xD7" + $\'\n              },\n              {\n                view: "total-time"\n              },\n              {\n                view: "context",\n                when: "node.value.id != +#.id",\n                content: [\n                  "module-badge:node.value",\n                  "loc-badge:node.value"\n                ]\n              }\n            ]\n          }\n        }\n      ]\n    };\n    const pageContent = {\n      content: [\n        {\n          view: "page-header",\n          prelude: [\n            \'badge{ className: "type-badge", text: "Function" }\',\n            \'badge{ className: "category-badge", text: module.category.name, href: module.category.marker().href, color: module.category.name.color() }\',\n            "package-badge",\n            \'badge{ text: module | packageRelPath or path or "module", href: module.marker().href }\',\n            "loc-badge"\n          ],\n          content: [\n            { view: "h1", when: "not regexp", data: "name" },\n            { view: "source", when: "regexp", data: \'{ content: regexp, syntax: "regexp", lineNum: false }\' }\n          ]\n        },\n        {\n          view: "subject-with-nested-timeline",\n          data: "{ subject: @, tree: #.data.functionsTree }"\n        },\n        {\n          view: "update-on-timings-change",\n          timings: "=#.data.functionsTimingsFiltered",\n          content: {\n            view: "page-indicator-timings",\n            data: `{\n                    full: #.data.functionsTimings.entries[=>entry = @],\n                    filtered: #.data.functionsTimingsFiltered.entries[=>entry = @]\n                }`\n          }\n        },\n        {\n          view: "expand",\n          when: false,\n          className: "trigger-outside script-source",\n          data: `\n                #.data.scriptFunctions[=> function = @]\n                |? {\n                    $start: script.source.lastIndexOf(\'\\\\n\', start) + 1;\n                    $end: script.source.indexOf(\'\\\\n\', end) | $ != -1 ?: script.source.size();\n\n                    scriptFunction: $,\n                    source: script.source[$start:$end],\n                    $start,\n                    $end\n                }\n            `,\n          expanded: "=source is not undefined",\n          header: [\n            \'text:"Source"\',\n            { view: "switch", content: [\n              { when: "source is not undefined", content: \'html:` \\xA0<span style="color: #888">${source.size().bytes(true)}</html>`\' },\n              { content: \'html:` <span style="color: #888">(unavailable)</span>`\' }\n            ] }\n          ],\n          content: [\n            {\n              view: "source",\n              data: `{\n                        $line: scriptFunction.line or 1;\n                        $start: scriptFunction.start;\n                        $end: scriptFunction.end;\n\n                        ...,\n                        syntax: "js",\n                        content: source | is string ? replace(/\\\\n$/, "") : "// source is unavailable",\n                        lineNum: => $ + $line,\n                        refs: scriptFunction.script.functions.[start >= $start and end <= $end].({\n                            className: \'function\',\n                            range: [start - @.start, end - @.start],\n                            href: \'#\',\n                            marker: states | size() = 1\n                                ? tier[].abbr()\n                                : size() <= 3\n                                    ? tier.(abbr()).join(\' \')\n                                    : tier[].abbr() + \' \\u2026 \' + tier[-1].abbr(),\n                            tooltipData: { states, function },\n                            tooltip: { className: \'hint-tooltip\', content: [\n                                \'text:tooltipData.function.name\',\n                                \'html:"<br>"\',\n                                // {\n                                //     view: \'context\',\n                                //     data: \'#.data.functionsTreeTimingsFiltered.getTimings(tooltipData.function)\',\n                                //     content: [\n                                //         \'self-time\',\n                                //         \'nested-time\',\n                                //         \'total-time\',\n                                //         \'struct:node.value\'\n                                //     ]\n                                // },\n                                // \'html:"<br>"\',\n                                {\n                                    view: \'inline-list\',\n                                    data: \'tooltipData.states\',\n                                    item: \'text:"\\xA0\\u2192 " + tier + (inlined ? " (inlined: " + fns.size() + ")" : "")\'\n                                }\n                            ] }\n                        })\n                    }`,\n              prelude: {\n                view: "block",\n                when: "scriptFunction.script",\n                data: `\n                            scriptFunction | $start; $end; script.functions\n                                .[start <= $start and end >= $end]\n                                .sort(start asc)\n                                .({\n                                    target: @.scriptFunction,\n                                    scriptFunction: $\n                                })\n                        `,\n                content: {\n                  view: "inline-list",\n                  className: "function-path",\n                  whenData: true,\n                  item: { view: "switch", content: [\n                    { when: "scriptFunction = target", content: \'block{ className: "target", content: `text:scriptFunction | function or $ | name or "(anonymous function)"` }\' },\n                    { when: "scriptFunction.function", content: "auto-link:scriptFunction.function" },\n                    { content: \'text:scriptFunction | name or "(anonymous function)"\' }\n                  ] }\n                }\n              }\n            }\n          ]\n        },\n        {\n          view: "expand",\n          expanded: true,\n          className: "trigger-outside",\n          header: \'text:"Nested time distribution"\',\n          content: "nested-timings-tree:{ subject: @, tree: #.data.functionsTree, timings: #.data.functionsTimingsFiltered }"\n        },\n        {\n          view: "context",\n          modifiers: [\n            // {\n            //     view: \'checkbox\',\n            //     name: \'groupByRef\',\n            //     checked: true,\n            //     content: \'text:"Group call sites"\'\n            // }\n          ],\n          content: {\n            view: "expand",\n            expanded: true,\n            className: "trigger-outside",\n            header: \'text:"Call trees"\',\n            content: {\n              view: "hstack",\n              className: "trees",\n              content: [\n                descendantTree,\n                ancestorsTree\n              ]\n            }\n          }\n        },\n        {\n          view: "flamechart-expand",\n          tree: "=#.data.functionsTree",\n          timings: "=#.data.functionsTreeTimingsFiltered",\n          value: "="\n        }\n      ]\n    };\n    discovery.page.define("function", {\n      view: "switch",\n      data: "functions[=>id = +#.id]",\n      content: [\n        { when: "no $", content: {\n          view: "alert-warning",\n          content: \'md:"No function with id \\\\"{{#.id}}\\\\" is found\\\\n\\\\n[Back to index page](#)"\'\n        } },\n        pageContent\n      ]\n    });\n  }\n  var init_function = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/pages/function.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/pages/module.js\n  var module_exports = {};\n  __export(module_exports, {\n    default: () => module_default\n  });\n  function module_default(discovery) {\n    const pageContent = {\n      content: [\n        {\n          view: "page-header",\n          prelude: [\n            \'badge{ className: "type-badge", text: "Module" }\',\n            \'badge{ className: "category-badge", text: category.name, href: category.marker().href, color: category.name.color() }\',\n            "package-badge"\n          ],\n          content: "h1:packageRelPath or name or path"\n        },\n        {\n          view: "subject-with-nested-timeline",\n          data: "{ subject: @, tree: #.data.modulesTree }"\n        },\n        {\n          view: "update-on-timings-change",\n          timings: "=#.data.modulesTimingsFiltered",\n          content: {\n            view: "page-indicator-timings",\n            data: `{\n                    full: #.data.modulesTimings.entries[=>entry = @],\n                    filtered: #.data.modulesTimingsFiltered.entries[=>entry = @]\n                }`\n          }\n        },\n        {\n          view: "expand",\n          when: false,\n          className: "trigger-outside script-source",\n          data: "#.data.scripts[=> module = @]",\n          expanded: "=source is not undefined",\n          header: [\n            \'text:"Source"\',\n            { view: "switch", content: [\n              { when: "source is not undefined", content: \'html:` \\xA0<span style="color: #888">${source.size().bytes(true)}</html>`\' },\n              { content: \'html:` <span style="color: #888">(unavailable)</span>`\' }\n            ] }\n          ],\n          content: `source:{\n                syntax: "js",\n                content: source | is string ? replace(/\\\\n$/, "") : "// source is unavailable",\n                refs: functions.({\n                    className: \'function\',\n                    range: [start, end],\n                    marker: states | size() = 1\n                        ? tier[].abbr()\n                        : size() <= 3\n                            ? tier.(abbr()).join(\' \')\n                            : tier[].abbr() + \' \\u2026 \' + tier[-1].abbr(),\n                    tooltipData: { states, function },\n                    tooltip: [\n                        \'text:tooltipData.function.name\',\n                        \'html:"<br>"\',\n                        {\n                            view: \'inline-list\',\n                            data: \'tooltipData.states\',\n                            item: \'text:"\\xA0\\u2192 " + tier + (inlined ? " (inlined: " + fns.size() + ")" : "")\'\n                        }\n                    ]\n                })\n            }`\n        },\n        {\n          view: "expand",\n          expanded: true,\n          className: "trigger-outside",\n          header: \'text:"Nested time distribution"\',\n          content: "nested-timings-tree:{ subject: @, tree: #.data.modulesTree, timings: #.data.modulesTimingsFiltered }"\n        },\n        {\n          view: "expand",\n          expanded: true,\n          className: "trigger-outside",\n          header: [\n            \'text:"Functions "\',\n            { view: "pill-badge", content: {\n              view: "update-on-timings-change",\n              timings: "=#.data.functionsTimingsFiltered",\n              content: "text-numeric:#.data.functionsTimingsFiltered.entries.[totalTime and entry.module = @].size()"\n            } }\n          ],\n          content: {\n            view: "content-filter",\n            className: "table-content-filter",\n            content: {\n              view: "update-on-timings-change",\n              timings: "=#.data.functionsTimingsFiltered",\n              content: {\n                view: "table",\n                data: "#.data.functionsTimingsFiltered.entries.[totalTime and entry.module = @ and entry.name ~= #.filter].sort(selfTime desc, totalTime desc)",\n                cols: [\n                  { header: "Self time", sorting: "selfTime desc, totalTime desc", content: "duration:{ time: selfTime, total: #.data.totalTime }" },\n                  { header: "Nested time", sorting: "nestedTime desc, totalTime desc", content: "duration:{ time: nestedTime, total: #.data.totalTime }" },\n                  { header: "Total time", sorting: "totalTime desc, selfTime desc", content: "duration:{ time: totalTime, total: #.data.totalTime }" },\n                  { header: "Function", sorting: "entry.name ascN", content: \'auto-link{ data: entry, content: "text-match:{ ..., match: #.filter }" }\' },\n                  { header: "Loc", data: "entry", sorting: "entry.loc ascN", content: ["module-badge", "loc-badge"] }\n                ]\n              }\n            }\n          }\n        },\n        {\n          view: "flamechart-expand",\n          tree: "=#.data.modulesTree",\n          timings: "=#.data.modulesTreeTimingsFiltered",\n          value: "="\n        }\n      ]\n    };\n    discovery.page.define("module", {\n      view: "switch",\n      data: "modules[=>id = +#.id]",\n      content: [\n        { when: "no $", content: {\n          view: "alert-warning",\n          content: \'md:"No module with id \\\\"{{#.id}}\\\\" is found\\\\n\\\\n[Back to index page](#)"\'\n        } },\n        pageContent\n      ]\n    });\n  }\n  var init_module = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/pages/module.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/pages/package.js\n  var package_exports = {};\n  __export(package_exports, {\n    default: () => package_default\n  });\n  function package_default(discovery) {\n    const pageContent = {\n      content: [\n        {\n          view: "page-header",\n          prelude: [\n            \'badge{ className: "type-badge", text: "Package" }\',\n            \'badge{ className: "category-badge", text: category.name, href: category.marker().href, color: category.name.color() }\'\n          ],\n          content: "h1:name"\n        },\n        {\n          view: "subject-with-nested-timeline",\n          data: "{ subject: @, tree: #.data.packagesTree }"\n        },\n        {\n          view: "update-on-timings-change",\n          timings: "=#.data.packagesTimingsFiltered",\n          content: {\n            view: "page-indicator-timings",\n            data: `{\n                    full: #.data.packagesTimings.entries[=>entry = @],\n                    filtered: #.data.packagesTimingsFiltered.entries[=>entry = @]\n                }`\n          }\n        },\n        {\n          view: "expand",\n          expanded: true,\n          className: "trigger-outside",\n          header: \'text:"Nested time distribution"\',\n          content: "nested-timings-tree:{ subject: @, tree: #.data.packagesTree, timings: #.data.packagesTimingsFiltered }"\n        },\n        {\n          view: "expand",\n          expanded: true,\n          className: "trigger-outside",\n          header: [\n            \'text:"Modules "\',\n            { view: "pill-badge", content: {\n              view: "update-on-timings-change",\n              timings: "=#.data.modulesTimingsFiltered",\n              content: "text-numeric:#.data.modulesTimingsFiltered.entries.[totalTime and entry.package = @].size()"\n            } }\n          ],\n          content: {\n            view: "content-filter",\n            className: "table-content-filter",\n            content: {\n              view: "update-on-timings-change",\n              timings: "=#.data.packagesTimingsFiltered",\n              content: {\n                view: "table",\n                data: "#.data.modulesTimingsFiltered.entries.[totalTime and entry.package = @ and entry.name ~= #.filter].sort(selfTime desc, totalTime desc)",\n                cols: [\n                  { header: "Self time", sorting: "selfTime desc, totalTime desc", content: "duration:{ time: selfTime, total: #.data.totalTime }" },\n                  { header: "Nested time", sorting: "nestedTime desc, totalTime desc", content: "duration:{ time: nestedTime, total: #.data.totalTime }" },\n                  { header: "Total time", sorting: "totalTime desc, selfTime desc", content: "duration:{ time: totalTime, total: #.data.totalTime }" },\n                  { header: "Module", sorting: "entry.name ascN", content: "module-badge:entry" },\n                  { header: "Functions", data: "entry.functions" }\n                  // { header: \'Histogram\', content: {\n                  //     view: \'timeline-segments-bin\',\n                  //     bins: \'=#.data.modulesTree.binCalls(entry, 100)\',\n                  //     max: \'=#.data.totalTime / 100\',\n                  //     binsMax: true,\n                  //     color: \'=entry.category.name.color()\',\n                  //     height: 22\n                  // } }\n                ]\n              }\n            }\n          }\n        },\n        {\n          view: "flamechart-expand",\n          tree: "=#.data.packagesTree",\n          timings: "=#.data.packagesTreeTimingsFiltered",\n          value: "="\n        }\n      ]\n    };\n    discovery.page.define("package", {\n      view: "switch",\n      data: "packages[=>id = +#.id]",\n      content: [\n        { when: "no $", content: {\n          view: "alert-warning",\n          content: \'md:"No package with id \\\\"{{#.id}}\\\\" is found\\\\n\\\\n[Back to index page](#)"\'\n        } },\n        pageContent\n      ]\n    });\n  }\n  var init_package = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/pages/package.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/misc/mode-regexp.js\n  var mode_regexp_exports = {};\n  __export(mode_regexp_exports, {\n    default: () => mode_regexp_default\n  });\n  function mode_regexp_default(discovery) {\n    const CodeMirror8 = discovery.view.QueryEditor.CodeMirror;\n    CodeMirror8.defineMode("regexp", function() {\n      var options2 = {\n        extended: false\n      };\n      var delimiters = {\n        "<": ">",\n        "[": "]",\n        "{": "}",\n        "(": ")"\n      };\n      var backslash_in_normal_context = {\n        "0": "non-printing-character",\n        "1": "backreference",\n        "2": "backreference",\n        "3": "backreference",\n        "4": "backreference",\n        "5": "backreference",\n        "6": "backreference",\n        "7": "backreference",\n        "8": "backreference",\n        "9": "backreference",\n        "A": "anchor",\n        // \\A  start of subject\n        "B": "anchor",\n        // \\B  not a word boundary\n        "C": "generic-character-type",\n        // \\C  one data unit, even in UTF mode (best avoided)\n        "D": "generic-character-type",\n        // \\D  any character that is not a decimal digit\n        "E": "err no-error-message",\n        // \\E ends \\Q but never matches \'E\' -- PCRE does not emit any error message\n        "F": "",\n        // \\F matches F\n        "G": "anchor",\n        // \\G  first matching position in subject\n        "H": "generic-character-type",\n        // \\H  any character that is not a horizontal white space character\n        "I": "",\n        // \\I matches I\n        "J": "",\n        // \\J matches J\n        "K": "anchor",\n        // \\K  reset start of match (neither an anchor nor a simple assertion)\n        "L": "err unsupported-escape-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "M": "",\n        // \\M matches M\n        "N": "generic-character-type",\n        // \\N  a character that is not a newline\n        "O": "",\n        // \\O matches O\n        "P": "err malformed-backslash-p-sequence",\n        // malformed \\P or \\p sequence\n        "Q": "escaped-sequence-start",\n        // \\Q starts \\Q...\\E escape sequences.\n        "R": "generic-character-type",\n        // \\R  a newline sequence\n        "S": "generic-character-type",\n        // \\S  any character that is not a white space character\n        "T": "",\n        // \\T matches T\n        "U": "unsupported-escape-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "V": "generic-character-type",\n        // \\V  any character that is not a vertical white space character\n        "W": "generic-character-type",\n        // \\W  any "non-word" character\n        "X": "generic-character-type",\n        // \\X  a Unicode extended grapheme cluster\n        "Y": "",\n        // \\Y matches Y\n        "Z": "anchor",\n        // \\Z  matches at the end of the subject; also matches before a newline at the end of the subject\n        "a": "non-printing-character",\n        // \\a  alarm, that is, the BEL character (hex 07)\n        "b": "anchor",\n        // \\b  word boundary\n        "c": "err backslash-c-at-end-of-pattern",\n        // \\cx "control-x", where x is any ASCII character\n        "d": "generic-character-type",\n        // \\d  any decimal digi\n        "e": "non-printing-character",\n        // \\e  escape (hex 1B)\n        "f": "non-printing-character",\n        // \\f  form feed (hex 0C)\n        "g": "err a-number-reference-must-not-be-zero",\n        // a numbered reference must not be zero\n        "h": "generic-character-type",\n        // \\h  any horizontal white space character\n        "i": "",\n        // \\i matches i\n        "j": "",\n        // \\j matches j\n        "k": "err backslash-k-is-not-followed-by-a-name",\n        // \\k is not followed by a [...] name\n        "l": "unsupported-espace-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "m": "",\n        // \\m matches m\n        "n": "non-printing-character",\n        // \\n  linefeed (hex 0A)\n        "o": "",\n        // \\o matches o\n        "p": "err malformed-backslash-p-sequence",\n        // malformed \\P or \\p sequence\n        "q": "",\n        // \\q matches q\n        "r": "non-printing-character",\n        // \\r  carriage return (hex 0D)\n        "s": "generic-character-type",\n        // \\s  any white space character\n        "t": "non-printing-character",\n        // \\t  tab (hex 09)\n        "u": "err unsupported-escape-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "v": "generic-character-type",\n        // \\v  any vertical white space character\n        "w": "generic-character-type",\n        // any "word" character\n        "x": "non-printing-character",\n        // binary zero (or x if PCRE_JAVASCRIPT_COMPAT)\n        "y": "",\n        // \\y matches y\n        "z": "anchor"\n        // \\z  end of subject\n      };\n      var backslash_in_character_class = {\n        "0": "non-printing-character",\n        // octal code\n        "1": "non-printing-character",\n        // octal code\n        "2": "non-printing-character",\n        // octal code\n        "3": "non-printing-character",\n        // octal code\n        "4": "non-printing-character",\n        // octal code\n        "5": "non-printing-character",\n        // octal code\n        "6": "non-printing-character",\n        // octal code\n        "7": "non-printing-character",\n        // octal code\n        "8": "",\n        // \\8 matches 8\n        "9": "",\n        // \\9 matches 9\n        "A": "",\n        // \\A matches A\n        "B": "",\n        // \\B matches B -- \\B, \\R, and \\X are not special inside a character class.\n        "C": "",\n        // \\C matches C\n        "D": "generic-character-type",\n        // \\D  any character that is not a decimal digit\n        "E": "err no-error-message",\n        // \\E ends \\Q but never matches \'E\' -- PCRE does not emit any error message\n        "F": "",\n        // \\F matches F\n        "G": "",\n        // \\G matches G\n        "H": "generic-character-type",\n        // \\H  any character that is not a horizontal white space character\n        "I": "",\n        // \\I matches I\n        "J": "",\n        // \\J matches J\n        "K": "",\n        // \\K matches K\n        "L": "err unsupported-escape-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "M": "",\n        // \\M matches M\n        "N": "err backslash-n-is-not-supported-in-a-class",\n        // \\N is not allowed in a character class.\n        "O": "",\n        // \\O matches O\n        "P": "err malformed-backslash-p-sequence",\n        // malformed \\P or \\p sequence\n        "Q": "escaped-sequence-start",\n        // \\Q starts \\Q...\\E escape sequences.\n        "R": "",\n        // \\R matches R -- \\B, \\R, and \\X are not special inside a character class.\n        "S": "generic-character-type",\n        // \\S  any character that is not a white space character\n        "T": "",\n        // \\T matches T\n        "U": "unsupported-escape-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "V": "generic-character-type",\n        // \\V  any character that is not a vertical white space character\n        "W": "generic-character-type",\n        // \\W  any "non-word" character\n        "X": "",\n        // \\X matches X -- \\B, \\R, and \\X are not special inside a character class.\n        "Y": "",\n        // \\Y matches Y\n        "Z": "",\n        // \\Z matches Z\n        "a": "non-printing-character",\n        // \\a  alarm, that is, the BEL character (hex 07)\n        "b": "non-printing-character",\n        // inside a character class, \\b is interpreted as the backspace character (hex 08)\n        "c": "err backslash-c-at-end-of-pattern",\n        // \\cx "control-x", where x is any ASCII character\n        "d": "generic-character-type",\n        // \\d  any decimal digi\n        "e": "non-printing-character",\n        // \\e  escape (hex 1B)\n        "f": "non-printing-character",\n        // \\f  form feed (hex 0C)\n        "g": "",\n        // \\g matches g\n        "h": "generic-character-type",\n        // \\h  any horizontal white space character\n        "i": "",\n        // \\i matches i\n        "j": "",\n        // \\j matches j\n        "k": "",\n        // \\k matches k\n        "l": "unsupported-espace-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "m": "",\n        // \\m matches m\n        "n": "non-printing-character",\n        // \\n  linefeed (hex 0A)\n        "o": "",\n        // \\o matches o\n        "p": "err malformed-backslash-p-sequence",\n        // malformed \\P or \\p sequence\n        "q": "",\n        // \\q matches q\n        "r": "non-printing-character",\n        // \\r  carriage return (hex 0D)\n        "s": "generic-character-type",\n        // \\s  any white space character\n        "t": "non-printing-character",\n        // \\t  tab (hex 09)\n        "u": "err unsupported-escape-sequence",\n        // PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\n        "v": "generic-character-type",\n        // \\v  any vertical white space character\n        "w": "generic-character-type",\n        // any "word" character\n        "x": "non-printing-character",\n        // binary zero (or x if PCRE_JAVASCRIPT_COMPAT)\n        "y": "",\n        // \\y matches y\n        "z": ""\n        // \\z matches z\n      };\n      var backslask_p_properties = {\n        // GENERAL CATEGORY PROPERTIES FOR \\p and \\P\n        "C": "Other",\n        "Cc": "Control",\n        "Cf": "Format",\n        "Cn": "Unassigned",\n        "Co": "Private use",\n        "Cs": "Surrogate",\n        "L": "Letter",\n        "Ll": "Lower case letter",\n        "Lm": "Modifier letter",\n        "Lo": "Other letter",\n        "Lt": "Title case letter",\n        "Lu": "Upper case letter",\n        "L&": "Ll, Lu, or Lt",\n        "M": "Mark",\n        "Mc": "Spacing mark",\n        "Me": "Enclosing mark",\n        "Mn": "Non-spacing mark",\n        "N": "Number",\n        "Nd": "Decimal number",\n        "Nl": "Letter number",\n        "No": "Other number",\n        "P": "Punctuation",\n        "Pc": "Connector punctuation",\n        "Pd": "Dash punctuation",\n        "Pe": "Close punctuation",\n        "Pf": "Final punctuation",\n        "Pi": "Initial punctuation",\n        "Po": "Other punctuation",\n        "Ps": "Open punctuation",\n        "S": "Symbol",\n        "Sc": "Currency symbol",\n        "Sk": "Modifier symbol",\n        "Sm": "Mathematical symbol",\n        "So": "Other symbol",\n        "Z": "Separator",\n        "Zl": "Line separator",\n        "Zp": "Paragraph separator",\n        "Zs": "Space separator",\n        // PCRE SPECIAL CATEGORY PROPERTIES FOR \\p and \\P\n        "Xan": "Alphanumeric: union of properties L and N",\n        "Xps": "POSIX space: property Z or tab, NL, VT, FF, CR",\n        "Xsp": "Perl space: property Z or tab, NL, VT, FF, CR",\n        "Xuc": "Univerally-named character: one that can be represented by a Universal Character Name",\n        "Xwd": "Perl word: property Xan or underscore",\n        // SCRIPT NAMES FOR \\p AND \\P\n        "Arabic": true,\n        "Armenian": true,\n        "Avestan": true,\n        "Balinese": true,\n        "Bamum": true,\n        "Bassa_Vah": true,\n        "Batak": true,\n        "Bengali": true,\n        "Bopomofo": true,\n        "Brahmi": true,\n        "Braille": true,\n        "Buginese": true,\n        "Buhid": true,\n        "Canadian_Aboriginal": true,\n        "Carian": true,\n        "Caucasian_Albanian": true,\n        "Chakma": true,\n        "Cham": true,\n        "Cherokee": true,\n        "Common": true,\n        "Coptic": true,\n        "Cuneiform": true,\n        "Cypriot": true,\n        "Cyrillic": true,\n        "Deseret": true,\n        "Devanagari": true,\n        "Duployan": true,\n        "Egyptian_Hieroglyphs": true,\n        "Elbasan": true,\n        "Ethiopic": true,\n        "Georgian": true,\n        "Glagolitic": true,\n        "Gothic": true,\n        "Grantha": true,\n        "Greek": true,\n        "Gujarati": true,\n        "Gurmukhi": true,\n        "Han": true,\n        "Hangul": true,\n        "Hanunoo": true,\n        "Hebrew": true,\n        "Hiragana": true,\n        "Imperial_Aramaic": true,\n        "Inherited": true,\n        "Inscriptional_Pahlavi": true,\n        "Inscriptional_Parthian": true,\n        "Javanese": true,\n        "Kaithi": true,\n        "Kannada": true,\n        "Katakana": true,\n        "Kayah_Li": true,\n        "Kharoshthi": true,\n        "Khmer": true,\n        "Khojki": true,\n        "Khudawadi": true,\n        "Lao": true,\n        "Latin": true,\n        "Lepcha": true,\n        "Limbu": true,\n        "Linear_A": true,\n        "Linear_B": true,\n        "Lisu": true,\n        "Lycian": true,\n        "Lydian": true,\n        "Mahajani": true,\n        "Malayalam": true,\n        "Mandaic": true,\n        "Manichaean": true,\n        "Meetei_Mayek": true,\n        "Mende_Kikakui": true,\n        "Meroitic_Cursive": true,\n        "Meroitic_Hieroglyphs": true,\n        "Miao": true,\n        "Modi": true,\n        "Mongolian": true,\n        "Mro": true,\n        "Myanmar": true,\n        "Nabataean": true,\n        "New_Tai_Lue": true,\n        "Nko": true,\n        "Ogham": true,\n        "Ol_Chiki": true,\n        "Old_Italic": true,\n        "Old_North_Arabian": true,\n        "Old_Permic": true,\n        "Old_Persian": true,\n        "Old_South_Arabian": true,\n        "Old_Turkic": true,\n        "Oriya": true,\n        "Osmanya": true,\n        "Pahawh_Hmong": true,\n        "Palmyrene": true,\n        "Pau_Cin_Hau": true,\n        "Phags_Pa": true,\n        "Phoenician": true,\n        "Psalter_Pahlavi": true,\n        "Rejang": true,\n        "Runic": true,\n        "Samaritan": true,\n        "Saurashtra": true,\n        "Sharada": true,\n        "Shavian": true,\n        "Siddham": true,\n        "Sinhala": true,\n        "Sora_Sompeng": true,\n        "Sundanese": true,\n        "Syloti_Nagri": true,\n        "Syriac": true,\n        "Tagalog": true,\n        "Tagbanwa": true,\n        "Tai_Le": true,\n        "Tai_Tham": true,\n        "Tai_Viet": true,\n        "Takri": true,\n        "Tamil": true,\n        "Telugu": true,\n        "Thaana": true,\n        "Thai": true,\n        "Tibetan": true,\n        "Tifinagh": true,\n        "Tirhuta": true,\n        "Ugaritic": true,\n        "Vai": true,\n        "Warang_Citi": true,\n        "Yi": true\n      };\n      var backslash_p_regex_string = "[pP]\\\\{\\\\^?([\\\\w&]+)\\\\}";\n      var backslash_p_regex = new RegExp(backslash_p_regex_string);\n      var posix_named_sets = {\n        "alnum": "alphanumeric",\n        "alpha": "alphabetic",\n        "ascii": "0-127",\n        "blank": "space or tab",\n        "cntrl": "control character",\n        "digit": "decimal digit",\n        "graph": "printing, excluding space",\n        "lower": "lower case letter",\n        "print": "printing, including space",\n        "punct": "printing, excluding alphanumeric",\n        "space": "white space",\n        "upper": "upper case letter",\n        "word": "same as \\\\w",\n        "xdigit": "hexadecimal digit"\n      };\n      var posix_named_sets_regex_string = "\\\\[:\\\\^?([\\\\w<>]+):]";\n      var posix_named_sets_regex = new RegExp(posix_named_sets_regex_string);\n      var callout_regex_string = "\\\\(\\\\?C(\\\\d{0,3})\\\\)";\n      var callout_regex = new RegExp(callout_regex_string);\n      var assertion_regex_string = "\\\\(\\\\?<?[=!]";\n      var assertion_regex = new RegExp(assertion_regex_string);\n      var condition_callout_regex_string = callout_regex_string + assertion_regex_string;\n      var condition_callout_regex = new RegExp(condition_callout_regex_string);\n      var options_regex_string = "(?:-?[iJmsUx]+)+";\n      var option_sequence_regex_string = "\\\\(\\\\?" + options_regex_string + "\\\\)";\n      var option_sequence_regex = new RegExp(option_sequence_regex_string);\n      var group_options_regex_string = "\\\\(\\\\?" + options_regex_string + ":";\n      var group_options_regex = new RegExp(group_options_regex_string);\n      function delimiter(ch) {\n        return ch in delimiters ? delimiters[ch] : ch;\n      }\n      function current(state) {\n        if (!state.context.length)\n          return false;\n        return state.context[state.context.length - 1];\n      }\n      function consume(stream) {\n        if (!stream.match(/\\w+/))\n          stream.next();\n      }\n      function all_tokens(state, token2) {\n        var result = state.context.join(" ");\n        if (token2) {\n          if (result)\n            result += " ";\n          result += token2;\n        }\n        return result;\n      }\n      function push(state, new_context, new_context_state, token2) {\n        var ret = all_tokens(state, token2);\n        state.context.push(new_context);\n        state.context_state.push(new_context_state || {});\n        return ret;\n      }\n      function pop(state, token2) {\n        var current_context = state.context.pop();\n        state.context_state.pop();\n        if (token2)\n          current_context += " " + token2;\n        return all_tokens(state, current_context);\n      }\n      function current_context_state(state) {\n        return state.context_state[state.context_state.length - 1];\n      }\n      function expect_name(state) {\n        state.name_value = "";\n        return push(state, "name");\n      }\n      function expect_end(state, end_string) {\n        var context_state = current_context_state(state);\n        var end_string_array = [];\n        for (var i = 0; i < end_string.length; ++i)\n          end_string_array.push(end_string[i]);\n        context_state.expected = end_string_array;\n        return context_state;\n      }\n      function read_expected_end(stream, state) {\n        var expected, expected_ch, ch;\n        expected = current_context_state(state).expected;\n        if (expected && expected.length) {\n          expected_ch = expected.shift();\n          ch = stream.next();\n          if (ch === expected_ch) {\n            if (!expected.length) {\n              return pop(state);\n            }\n            return all_tokens(state);\n          }\n          return all_tokens(state, "err erroneous-end-of-token");\n        } else {\n          return false;\n        }\n      }\n      function handle_backslash(stream, state) {\n        stream.eat("\\\\");\n        if (!stream.peek())\n          return "err backslash-at-end-of-pattern";\n        if (stream.match(/[^0-9a-zA-Z]/))\n          return "escaped-character";\n        if (stream.match(/c[ -~]/))\n          return "non-printing-character";\n        if (stream.match(/x[0-9a-fA-F]{0,2}/))\n          return "non-printing-character";\n        if (stream.match(/u[0-9a-fA-F]{4}/))\n          return "non-printing-character";\n        var rem = stream.match(backslash_p_regex);\n        if (rem) {\n          if (rem[1] in backslask_p_properties)\n            return "generic-character-type";\n          else\n            return "err unknown-property-name-after-p";\n        }\n        var in_character_class = current(state) === "character-class";\n        if (!in_character_class) {\n          if (stream.match(/k[<]/, false))\n            return push(state, "backreference");\n          if (stream.match(/[0-9]+/))\n            return "backreference";\n        }\n        var backslash_p = in_character_class ? backslash_in_character_class : backslash_in_normal_context;\n        return backslash_p[stream.next()];\n      }\n      function handle_name(stream, state) {\n        var ret, rem, consume_limit;\n        var ch = stream.next();\n        if (!state.name_value.length && (!ch.match(/\\w/) || ch.match(/\\d/))) {\n          ret = "err erroneous-start-of-name";\n          consume_limit = 0;\n        } else if (state.name_value.length > 31) {\n          ret = "err name-too-long";\n          consume_limit = -1;\n        } else\n          consume_limit = 32 - state.name_value.length - 1;\n        state.name_value += ch;\n        if (consume_limit < 0) {\n          if (rem = stream.match(/^\\w+/))\n            state.name_value += rem[0];\n        } else\n          while (consume_limit--) {\n            if (rem = stream.match(/^\\w/))\n              state.name_value += rem[0];\n            else\n              break;\n          }\n        var next_char = stream.peek();\n        if (!next_char || !next_char.match(/\\w/))\n          return pop(state, ret);\n        return all_tokens(state, ret);\n      }\n      function handle_callout(stream, state) {\n        var rem = stream.match(callout_regex);\n        if (rem) {\n          return Number(rem[1]) < 256 ? "callout" : "err erroneous-callout-number";\n        }\n        return false;\n      }\n      function handle_condition_subroutines(stream, state) {\n        if (stream.peek() === ")") {\n          pop(state);\n          return tokenBase(stream, state);\n        }\n        stream.eat("R");\n        if (stream.eat("&"))\n          return expect_name(state);\n        stream.match(/\\d+/);\n        return pop(state);\n      }\n      function handle_conditions(stream, state) {\n        var condition_state = current_context_state(state);\n        var expected_end = read_expected_end(stream, state);\n        if (expected_end)\n          return expected_end;\n        if (condition_state.ok) {\n          pop(state);\n          return tokenBase(stream, state);\n        }\n        if (stream.match(/DEFINE(?=\\))/)) {\n          return pop(state, "define");\n        }\n        if (stream.match(/R(\\d+|&\\w+|)\\)/, false)) {\n          condition_state.ok = true;\n          push(state, "condition-subroutine");\n          return tokenBase(stream, state);\n        }\n        if (stream.match(/(-|\\+|)\\d+/)) {\n          condition_state.ok = true;\n          return all_tokens(state, "backreference");\n        }\n        var rem = stream.match(/([<\'])/);\n        if (rem) {\n          condition_state.ok = false;\n          expect_end(state, delimiter(rem[1]));\n          return expect_name(state);\n        }\n        if (stream.match(/\\w+/, false)) {\n          condition_state.ok = true;\n          return expect_name(state);\n        }\n        if (stream.match(/\\?<?[=!]/)) {\n          condition_state.ok = true;\n          var group_options = { "leave_closing_parenthesis": true };\n          return push(state, "group" + ++state.groupLevel, group_options, "start-group");\n        }\n        stream.next();\n        return all_tokens(state, "err erroneous-condition");\n      }\n      function handle_start_group(stream, state) {\n        var start_group_state = current_context_state(state);\n        var expected_end = read_expected_end(stream, state);\n        if (expected_end)\n          return expected_end;\n        var rem;\n        if (start_group_state.option_shorthand === 1) {\n          start_group_state.option_shorthand = 2;\n          stream.match(/[^:]+/);\n          return all_tokens(state, "option-sequence");\n        }\n        if (start_group_state.option_shorthand === 2) {\n          stream.eat(":");\n          return pop(state);\n        }\n        if (start_group_state.condition_callout === 1) {\n          start_group_state.condition_callout = 2;\n          return all_tokens(state, handle_callout(stream, state));\n        }\n        if (start_group_state.condition_callout === 2) {\n          stream.eat("(");\n          expect_end(state, ")");\n          return push(state, "condition");\n        }\n        rem = stream.match(/\\(\\?P?([<\'])/);\n        if (rem) {\n          expect_end(state, delimiter(rem[1]));\n          return expect_name(state);\n        }\n        if (stream.match(group_options_regex, false)) {\n          stream.match("(?");\n          start_group_state.option_shorthand = 1;\n          return all_tokens(state);\n        }\n        if (stream.match("(?") && stream.peek() === "(") {\n          start_group_state.condition_callout = stream.match(condition_callout_regex, false) ? 1 : 2;\n          return all_tokens(state);\n        }\n        stream.next();\n        return all_tokens(state, "err erroneous-start-of-start-group");\n      }\n      function handle_backreference(stream, state) {\n        var expected_end = read_expected_end(stream, state);\n        if (expected_end)\n          return expected_end;\n        var rem = stream.match(/k([<\'{])/) || stream.match(/g(\\{)/) || stream.match(/(\\()\\?P=/);\n        if (rem) {\n          expect_end(state, delimiter(rem[1]));\n          return expect_name(state);\n        }\n        stream.next();\n        return all_tokens(state, "err erroneous-backreference");\n      }\n      function handle_subroutine(stream, state) {\n        var expected_end = read_expected_end(stream, state);\n        if (expected_end)\n          return expected_end;\n        var rem = stream.match(/g([<\'])/) || stream.match(/(\\()\\?(P>|&)/);\n        if (rem) {\n          expect_end(state, delimiter(rem[1]));\n          return expect_name(state);\n        }\n        stream.next();\n        return all_tokens(state, "err erroneous-subroutine");\n      }\n      function handle_verb(stream, state) {\n        var expected_end = read_expected_end(stream, state);\n        if (expected_end)\n          return expected_end;\n        expect_end(state, ")");\n        return expect_name(state);\n      }\n      function update_options(state, options3) {\n        var enable = true, new_state = null, i = 0, c = null;\n        for (; i < options3.length; ++i) {\n          c = options3[i];\n          if (c === "-")\n            enable = false;\n          else if (c === "x")\n            new_state = enable;\n        }\n        if (new_state !== null)\n          state.extended = new_state;\n      }\n      function tokenBase(stream, state) {\n        var rem, ret;\n        var ch = stream.peek();\n        if (!ch)\n          return;\n        var currentState = current(state);\n        var groupState;\n        if (currentState === "name")\n          return handle_name(stream, state);\n        if (currentState === "condition")\n          return handle_conditions(stream, state);\n        if (currentState === "condition-subroutine")\n          return handle_condition_subroutines(stream, state);\n        if (currentState === "start-group")\n          return handle_start_group(stream, state);\n        if (currentState === "backreference")\n          return handle_backreference(stream, state);\n        if (currentState === "subroutine")\n          return handle_subroutine(stream, state);\n        if (currentState === "verb")\n          return handle_verb(stream, state);\n        if (currentState === "escaped-sequence") {\n          if (stream.match("\\\\E"))\n            return pop(state, "escaped-sequence-end");\n          consume(stream);\n          return all_tokens(state);\n        }\n        if (stream.match(/\\\\./, false))\n          return all_tokens(state, handle_backslash(stream, state));\n        if (stream.match("[", false)) {\n          if (currentState !== "character-class") {\n            if (stream.match(posix_named_sets_regex)) {\n              return all_tokens(state, "err posix-outside-class-unsupported");\n            }\n            if (stream.match("[[:<:]]") || stream.match("[[:>:]]"))\n              return all_tokens(state, "anchor");\n            push(state, "character-class");\n            stream.eat("[");\n            stream.eat("^");\n            stream.eat("]");\n            return all_tokens(state);\n          }\n        }\n        if (currentState === "character-class") {\n          rem = stream.match(posix_named_sets_regex);\n          if (rem) {\n            if (rem[1] in posix_named_sets)\n              return all_tokens(state, "generic-character-type");\n            else\n              return all_tokens(state, "err unknown-posix-class-name");\n          }\n          if (stream.eat("]"))\n            return pop(state);\n          consume(stream);\n          return all_tokens(state);\n        }\n        if (state.extended && stream.eat("#")) {\n          stream.skipToEnd();\n          return "comment";\n        }\n        if (stream.eat("{")) {\n          if (stream.match(/\\d+\\}/))\n            return all_tokens(state, "quantifier");\n          if (stream.match(/\\d+,\\d*\\}[+?]?/))\n            return all_tokens(state, "quantifier");\n        }\n        if (stream.eat("|")) {\n          return all_tokens(state, "alternation");\n        }\n        if (stream.peek() === "(") {\n          if (stream.match(/\\(\\?P=/, false)) {\n            return push(state, "backreference");\n          }\n          ++state.groupLevel;\n          groupState = "group" + state.groupLevel;\n          push(state, groupState);\n          if (stream.match(assertion_regex)) {\n            return all_tokens(state, "start-group");\n          }\n          if (stream.match(/\\(\\?:/)) {\n            return all_tokens(state, "start-group");\n          }\n          if (stream.match("(?", false)) {\n            push(state, "start-group");\n            return tokenBase(stream, state);\n          }\n          stream.eat("(");\n          return all_tokens(state, "start-group");\n        }\n        if (stream.peek() === ")") {\n          if (currentState && currentState.match(/^group/)) {\n            ret = "start-group";\n            if (current_context_state(state).leave_closing_parenthesis) {\n              ret = "";\n            } else {\n              stream.next();\n            }\n            --state.groupLevel;\n            return pop(state, ret);\n          }\n          stream.next();\n          return all_tokens(state, "err unmatched-closing-parenthesis");\n        }\n        if (stream.eat("^") || stream.eat("$")) {\n          return all_tokens(state, "anchor");\n        }\n        if (stream.eat(".")) {\n          return all_tokens(state, "generic-character-type");\n        }\n        if (stream.eat("?") || stream.eat("*") || stream.eat("+")) {\n          stream.eat(/[+?]/);\n          return all_tokens(state, "quantifier");\n        }\n        consume(stream);\n        return all_tokens(state);\n      }\n      function startState() {\n        return {\n          context: [],\n          context_state: [],\n          groupLevel: 0,\n          name_value: "",\n          extended: options2.extended\n        };\n      }\n      function copyState(o) {\n        const c = startState();\n        for (let i = 0; i < o.context_state.length; ++i) {\n          const oo = o.context_state[i];\n          const oc = {};\n          for (const key2 in oo) {\n            oc[key2] = key2 === "expected" ? oo[key2].slice() : oo[key2];\n          }\n          c.context_state.push(oc);\n        }\n        c.context = o.context.slice();\n        c.groupLevel = o.groupLevel;\n        c.name_value = o.name_value;\n        c.extended = o.extended;\n        return c;\n      }\n      return {\n        startState,\n        copyState,\n        token: tokenBase\n      };\n    });\n    CodeMirror8.defineMIME("text/x-regex", "regexp");\n    CodeMirror8.defineMIME("text/x-pcre-regex", "regexp");\n  }\n  var init_mode_regexp = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/misc/mode-regexp.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/duration.js\n  var duration_exports = {};\n  __export(duration_exports, {\n    default: () => duration_default\n  });\n  function duration_default(discovery) {\n    const delim = \'<span class="num-delim"></span>\';\n    function formatDuration(time) {\n      time /= 1e3;\n      const number = time === 0 ? 0 : time >= 1e3 ? time.toFixed(1).replace(/\\..+$|\\B(?=(\\d{3})+(\\D|$))/g, (m2) => m2 || delim) : time.toFixed(1);\n      return `${number}${delim}`;\n    }\n    discovery.view.define("duration", function(el, config, { time, total }) {\n      const timeEl = document.createElement("span");\n      timeEl.className = "time";\n      timeEl.innerHTML = formatDuration(time);\n      el.append(timeEl);\n      const fractionEl = document.createElement("span");\n      const fraction = 100 * time / total;\n      fractionEl.className = "fraction";\n      fractionEl.innerText = fraction === 0 ? "" : fraction < 0.1 ? "<0.1%" : fraction >= 99.9 ? Math.round(fraction) + "%" : fraction.toFixed(1) + "%";\n      el.append(fractionEl);\n    });\n  }\n  var init_duration = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/duration.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/version.js\n  var version;\n  var init_version = __esm({\n    "node_modules/@discoveryjs/discovery/src/version.js"() {\n      version = "1.0.0-beta.83";\n    }\n  });\n\n  // node_modules/jora/src/version.js\n  var version2;\n  var init_version2 = __esm({\n    "node_modules/jora/src/version.js"() {\n      version2 = "1.0.0-beta.10";\n    }\n  });\n\n  // node_modules/jora/src/utils/misc.js\n  function addToSet(set, value) {\n    if (value !== void 0) {\n      if (Array.isArray(value)) {\n        value.forEach((item) => set.add(item));\n      } else {\n        set.add(value);\n      }\n    }\n    return set;\n  }\n  function addToMapSet(map2, key2, value) {\n    if (map2.has(key2)) {\n      map2.get(key2).add(value);\n    } else {\n      map2.set(key2, /* @__PURE__ */ new Set([value]));\n    }\n  }\n  function getPropertyValue(value, property) {\n    return value && hasOwn(value, property) ? value[property] : void 0;\n  }\n  function isPlainObject(value) {\n    return value !== null && typeof value === "object" && value.constructor === Object;\n  }\n  function isRegExp(value) {\n    return toString.call(value) === "[object RegExp]";\n  }\n  function isArrayLike2(value) {\n    return value && hasOwn(value, "length") && isFinite(value.length);\n  }\n  function isTruthy(value) {\n    if (Array.isArray(value)) {\n      return value.length > 0;\n    }\n    if (isPlainObject(value)) {\n      for (const key2 in value) {\n        if (hasOwn(value, key2)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return Boolean(value);\n  }\n  var hasOwn, toString;\n  var init_misc = __esm({\n    "node_modules/jora/src/utils/misc.js"() {\n      hasOwn = Object.hasOwn || ((subject, key2) => Object.hasOwnProperty.call(subject, key2));\n      toString = Object.prototype.toString;\n    }\n  });\n\n  // node_modules/jora/src/lang/parse.js\n  function Parser() {\n    this.yy = {};\n  }\n  var lexer, parser, parse_default;\n  var init_parse = __esm({\n    "node_modules/jora/src/lang/parse.js"() {\n      lexer = /* @__PURE__ */ function() {\n        const lexer3 = {\n          yy: {},\n          options: { "ranges": true },\n          rules: [/^(?:\\/\\/.*?(?:\\n|\\r\\n?|\\u2028|\\u2029|$)|\\/\\*(?:.|\\s)*?(?:\\*\\/|$))/, /^\\s+/, /^\\//, /^<(?!=)/, /^/, /^(?:(?:[a-zA-Z_]|\\\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*\\(?)/, /^/, (input, state) => {\n            if (input[0] !== (state === "template" ? "}" : "`")) {\n              return null;\n            }\n            for (let i = 1; i < input.length; i++) {\n              if (input[i] === "`") {\n                return i + 1;\n              }\n              if (input[i] === "$" && input[i + 1] === "{") {\n                return i + 2;\n              }\n              if (input[i] === "\\\\") {\n                i++;\n              }\n            }\n            return null;\n          }, (input, state) => {\n            if (input[0] !== (state === "template" ? "}" : "`")) {\n              return null;\n            }\n            for (let i = 1; i < input.length; i++) {\n              if (input[i] === "`") {\n                return i + 1;\n              }\n              if (input[i] === "$" && input[i + 1] === "{") {\n                return i + 2;\n              }\n              if (input[i] === "\\\\") {\n                i++;\n              }\n            }\n            return null;\n          }, /^/, /^\\(/, /^\\)/, /^\\[/, /^\\]/, /^\\{/, /^\\}/, /^(?:(true|false|null|undefined|Infinity|NaN)\\b)/, /^and\\b/, /^or\\b/, /^is\\b/, /^has\\s+no\\b/, /^has\\b/, /^in\\b/, /^not\\s+in\\b/, /^not\\b/, /^no\\b/, /^(?:(asc|desc)(NA?|AN?)?\\b)/, /^(?:(?:[a-zA-Z_]|\\\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*\\()/, /^(?:\\$(?:[a-zA-Z_]|\\\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*\\()/, /^(?:(\\d+\\.|\\.)?\\d+([eE][-+]?\\d+)?\\b)/, /^0[xX][0-9a-fA-F]+/, /^(?:"(?:\\\\[\\\\"]|[^"])*")/, /^(?:\'(?:\\\\[\\\\\']|[^\'])*\')/, /^(?:\\/(?:\\\\.|[^/])+\\/[gimsu]*)/, /^(?:(?:[a-zA-Z_]|\\\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*)/, /^(?:\\$(?:[a-zA-Z_]|\\\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*)/, /^@/, /^#/, /^\\$\\$/, /^\\$/, /^=>/, /^=/, /^!=/, /^~=/, /^>=/, /^<=/, /^</, /^>/, /^\\.\\.\\(/, /^\\.\\(/, /^\\.\\[/, /^\\.\\.\\./, /^\\.\\./, /^\\./, /^\\?\\?/, /^\\?/, /^,/, /^:/, /^;/, /^\\-/, /^\\+/, /^\\*/, /^\\//, /^\\%/, /^(?:\\|)/, /^./, /^$/],\n          conditions: { "preventPrimitive": { "rules": [0, 1, 2, 3, 4, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66], "inclusive": true }, "preventKeyword": { "rules": [5, 6], "inclusive": false }, "template": { "rules": [8, 9], "inclusive": false }, "INITIAL": { "rules": [0, 1, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66], "inclusive": true } },\n          performAction(yy, yy_, __lexelActionId, YY_START) {\n            const YYSTATE = YY_START;\n            switch (__lexelActionId) {\n              case 0: {\n                yy.commentRanges.push(yy_.yylloc.range);\n                break;\n              }\n              case 1: {\n                break;\n              }\n              case 2: {\n                this.popState();\n                return 40;\n                break;\n              }\n              case 3: {\n                this.popState();\n                return 44;\n                break;\n              }\n              case 4: {\n                this.done = false;\n                this.popState();\n                break;\n              }\n              case 5: {\n                this.popState();\n                if (yy_.yytext.endsWith("(")) {\n                  this.unput(yy_.yytext);\n                  return;\n                }\n                yy.pps();\n                yy_.yytext = this.ident(yy_.yytext);\n                return 14;\n                break;\n              }\n              case 6: {\n                this.done = false;\n                this.popState();\n                break;\n              }\n              case 7: {\n                const token2 = yy_.yytext.endsWith("`") ? "TEMPLATE" : "TPL_START";\n                yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + Number(token2 !== "TEMPLATE"));\n                if (token2 === "TEMPLATE") {\n                  yy.pps();\n                }\n                return token2;\n                break;\n              }\n              case 8: {\n                const token2 = yy_.yytext.endsWith("`") ? "TPL_END" : "TPL_CONTINUE";\n                yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + Number(token2 !== "TPL_END"));\n                this.popState();\n                if (token2 === "TPL_END") {\n                  yy.pps();\n                }\n                return token2;\n                break;\n              }\n              case 9: {\n                this.parseError("Unexpected end of input");\n                break;\n              }\n              case 10: {\n                return 21;\n                break;\n              }\n              case 11: {\n                yy.pps();\n                return 22;\n                break;\n              }\n              case 12: {\n                return 61;\n                break;\n              }\n              case 13: {\n                yy.pps();\n                return 63;\n                break;\n              }\n              case 14: {\n                return 84;\n                break;\n              }\n              case 15: {\n                if (this.bracketStack[this.bracketStack.length - 1] !== "TPL_END") {\n                  yy.pps();\n                  return 85;\n                }\n                this.unput("}");\n                this.begin("template");\n                break;\n              }\n              case 16: {\n                yy_.yytext = this.toLiteral(yy_.yytext);\n                return 57;\n                break;\n              }\n              case 17: {\n                return 36;\n                break;\n              }\n              case 18: {\n                return 37;\n                break;\n              }\n              case 19: {\n                return 30;\n                break;\n              }\n              case 20: {\n                return 35;\n                break;\n              }\n              case 21: {\n                return 33;\n                break;\n              }\n              case 22: {\n                return 32;\n                break;\n              }\n              case 23: {\n                return 34;\n                break;\n              }\n              case 24: {\n                return 25;\n                break;\n              }\n              case 25: {\n                return 26;\n                break;\n              }\n              case 26: {\n                return 95;\n                break;\n              }\n              case 27: {\n                yy_.yytext = this.ident(yy_.yytext.slice(0, -1));\n                return 70;\n                break;\n              }\n              case 28: {\n                yy_.yytext = this.ident(yy_.yytext.slice(1, -1));\n                return 72;\n                break;\n              }\n              case 29: {\n                yy.pps();\n                yy_.yytext = Number(yy_.yytext);\n                return 55;\n                break;\n              }\n              case 30: {\n                yy.pps();\n                yy_.yytext = parseInt(yy_.yytext, 16);\n                return 55;\n                break;\n              }\n              case 31: {\n                yy.pps();\n                yy_.yytext = this.toStringLiteral(yy_.yytext);\n                return 54;\n                break;\n              }\n              case 32: {\n                yy.pps();\n                yy_.yytext = this.toStringLiteral(yy_.yytext);\n                return 54;\n                break;\n              }\n              case 33: {\n                yy.pps();\n                yy_.yytext = this.toRegExp(yy_.yytext);\n                return 56;\n                break;\n              }\n              case 34: {\n                yy.pps();\n                yy_.yytext = this.ident(yy_.yytext);\n                return 14;\n                break;\n              }\n              case 35: {\n                yy.pps();\n                yy_.yytext = this.ident(yy_.yytext.slice(1));\n                return 15;\n                break;\n              }\n              case 36: {\n                yy.pps();\n                return 51;\n                break;\n              }\n              case 37: {\n                yy.pps();\n                return 52;\n                break;\n              }\n              case 38: {\n                yy.pps();\n                return 53;\n                break;\n              }\n              case 39: {\n                yy.pps();\n                return 9;\n                break;\n              }\n              case 40: {\n                return 20;\n                break;\n              }\n              case 41: {\n                return 42;\n                break;\n              }\n              case 42: {\n                return 43;\n                break;\n              }\n              case 43: {\n                return 48;\n                break;\n              }\n              case 44: {\n                return 47;\n                break;\n              }\n              case 45: {\n                return 45;\n                break;\n              }\n              case 46: {\n                return 44;\n                break;\n              }\n              case 47: {\n                return 46;\n                break;\n              }\n              case 48: {\n                return 69;\n                break;\n              }\n              case 49: {\n                return 66;\n                break;\n              }\n              case 50: {\n                return 67;\n                break;\n              }\n              case 51: {\n                return 89;\n                break;\n              }\n              case 52: {\n                yy.pps();\n                yy.pks();\n                return 68;\n                break;\n              }\n              case 53: {\n                yy.pps();\n                yy.pks();\n                return 65;\n                break;\n              }\n              case 54: {\n                return 38;\n                break;\n              }\n              case 55: {\n                return 17;\n                break;\n              }\n              case 56: {\n                return 73;\n                break;\n              }\n              case 57: {\n                return 11;\n                break;\n              }\n              case 58: {\n                return 10;\n                break;\n              }\n              case 59: {\n                return 27;\n                break;\n              }\n              case 60: {\n                return 28;\n                break;\n              }\n              case 61: {\n                return 39;\n                break;\n              }\n              case 62: {\n                return 40;\n                break;\n              }\n              case 63: {\n                return 41;\n                break;\n              }\n              case 64: {\n                return 29;\n                break;\n              }\n              case 65: {\n                this.parseError(`Bad input on line ${yy_.yylloc.first_line} column ${yy_.yylloc.first_column}\n` + this.showPosition(), {\n                  text: yy_.yytext,\n                  token: "BAD_TOKEN"\n                });\n                break;\n              }\n              case 66: {\n                return 5;\n                break;\n              }\n            }\n          },\n          setInput(input, yy) {\n            this.yy = yy || this.yy || {};\n            this._input = input;\n            this._more = false;\n            this._backtrack = false;\n            this.done = false;\n            this.currentCondition = "INITIAL";\n            this.conditionStack = ["INITIAL"];\n            this.offset = 0;\n            this.yytext = this.match = "";\n            this.yyleng = 0;\n            this.yylineno = 0;\n            this.yylloc = {\n              first_line: 1,\n              first_column: 0,\n              last_line: 1,\n              last_column: 0\n            };\n            if (true) {\n              this.yylloc.range = [0, 0];\n            }\n            return this;\n          },\n          parseError(str, details) {\n            if (!this.yy.parser) {\n              throw new Error(str);\n            }\n            this.yy.parser.parseError(str, details);\n          },\n          input() {\n            const ch = this._input[this.offset];\n            const newline = /\\n|\\r\\n?|\\u2028|\\u2029/g.test(ch);\n            this.offset++;\n            this.yyleng++;\n            this.yytext = this.match = this.yytext + ch;\n            if (newline) {\n              this.yylineno++;\n              this.yylloc.last_line++;\n              this.yylloc.last_column = 0;\n            } else {\n              this.yylloc.last_column++;\n            }\n            if (true) {\n              this.yylloc.range[1]++;\n            }\n            return ch;\n          },\n          lineColumnForOffset(offset = this.offset, str = this._input, startLine = 1, startColumn = 0) {\n            const rx = /\\n|\\r\\n?|\\u2028|\\u2029/g;\n            let line = startLine;\n            let column = startColumn;\n            let prevLastIndex = 0;\n            let match2;\n            while ((match2 = rx.exec(str)) !== null) {\n              if (match2.index < offset) {\n                line++;\n                column = 0;\n                prevLastIndex = match2.index + match2[0].length;\n              } else {\n                column += offset - prevLastIndex;\n                prevLastIndex = -1;\n                break;\n              }\n            }\n            if (prevLastIndex !== -1) {\n              column += offset - prevLastIndex;\n            }\n            return {\n              line,\n              column\n            };\n          },\n          setMatch(start, end) {\n            const newMatch = this._input.slice(start, end);\n            const firstLoc = start !== this.offset ? this.lineColumnForOffset(start) : {\n              line: this.yylloc.last_line,\n              column: this.yylloc.last_column\n            };\n            const lastLoc = start !== end ? this.lineColumnForOffset(end - start, newMatch, firstLoc.line, firstLoc.column) : firstLoc;\n            this.yytext = this.match = newMatch;\n            this.yyleng = end - start;\n            this.offset = end;\n            this.yylineno = lastLoc.line - 1;\n            this.yylloc = {\n              first_line: firstLoc.line,\n              first_column: firstLoc.column,\n              last_line: lastLoc.line,\n              last_column: lastLoc.column\n            };\n            if (true) {\n              this.yylloc.range = [start, end];\n            }\n          },\n          less(n) {\n            const start = this.offset - this.match.length;\n            this.setMatch(start, start + n);\n          },\n          unput(chunk) {\n            const newMatchLength = this.match.length - chunk.length;\n            if (!this.match.startsWith(chunk, newMatchLength)) {\n              throw new Error("Lexer#unput() should receive a part of matched text only");\n            }\n            this.less(newMatchLength);\n          },\n          more() {\n            this._more = true;\n          },\n          reject() {\n            if (false) {\n              this._backtrack = true;\n              return;\n            }\n            throw new Error("reject() is allowed only when options.backtrack_lexer = true");\n          },\n          showPosition(offset = this.offset - this.match.length) {\n            const input = this._input;\n            const start = Math.max(offset - 20, 0);\n            const end = Math.min(offset + 20, input.length);\n            const pre = (start === 0 ? "" : "...") + input.slice(start, offset).replace(/\\n|\\r\\n?|\\u2028|\\u2029/g, "\\\\n");\n            const post = input.slice(offset, end).replace(/\\n|\\r\\n?|\\u2028|\\u2029/g, "\\\\n") + (end === input.length ? "" : "...");\n            return pre + post + `\n${"-".repeat(pre.length)}^`;\n          },\n          test_match(match2, rule) {\n            let backup;\n            if (false) {\n              backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                  first_line: this.yylloc.first_line,\n                  last_line: this.yylloc.last_line,\n                  first_column: this.yylloc.first_column,\n                  last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n              };\n              if (true) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n              }\n            }\n            this._more = false;\n            this._backtrack = false;\n            this.setMatch(this.offset, this.offset + match2[0].length);\n            this.matches = match2;\n            const token2 = this.performAction.call(\n              this,\n              this.yy,\n              this,\n              rule,\n              this.conditionStack[this.conditionStack.length - 1]\n            );\n            if (!token2 && this._backtrack) {\n              Object.assign(this, backup);\n              return false;\n            }\n            if (!this.eof()) {\n              this.done = false;\n            }\n            if (typeof token2 === "number" && this.yy.parser) {\n              return this.yy.parser.terminals_[token2];\n            }\n            return token2 || false;\n          },\n          eof() {\n            return this.offset === this._input.length;\n          },\n          next() {\n            if (this.done) {\n              return 1;\n            }\n            if (this.eof()) {\n              this.done = true;\n            }\n            if (!this._more) {\n              this.yytext = "";\n              this.match = "";\n            }\n            let match2;\n            let matchRuleId;\n            for (const ruleId of this.conditions[this.currentCondition].rules) {\n              const rule = this.rules[ruleId];\n              const ruleInput = this._input.slice(this.offset);\n              let tempMatch;\n              if (typeof rule === "function") {\n                const ret = rule(ruleInput, this.currentCondition);\n                switch (typeof ret) {\n                  case "string":\n                    tempMatch = [ret];\n                    break;\n                  case "number":\n                    tempMatch = [ruleInput.slice(0, ret)];\n                    break;\n                  default:\n                    tempMatch = ret;\n                }\n              } else {\n                tempMatch = ruleInput.match(rule);\n              }\n              if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {\n                match2 = tempMatch;\n                matchRuleId = ruleId;\n                if (false) {\n                  const token2 = this.test_match(tempMatch, matchRuleId);\n                  if (token2 === false && this._backtrack) {\n                    match2 = false;\n                    continue;\n                  }\n                  return token2;\n                }\n                if (true) {\n                  break;\n                }\n              }\n            }\n            if (match2) {\n              return this.test_match(match2, matchRuleId);\n            }\n            if (this.eof()) {\n              return 1;\n            }\n            this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\\n" + this.showPosition(), {\n              text: "",\n              token: null,\n              line: this.yylineno\n            });\n          },\n          lex() {\n            let token2;\n            while (!token2) {\n              token2 = this.next();\n            }\n            return token2;\n          },\n          begin(condition2) {\n            this.currentCondition = condition2;\n            this.conditionStack.push(condition2);\n          },\n          pushState(condition2) {\n            this.begin(condition2);\n          },\n          popState() {\n            this.conditionStack.pop();\n            return this.currentCondition = this.conditionStack.length ? this.conditionStack[this.conditionStack.length - 1] : "INITIAL";\n          },\n          topState(n) {\n            n = this.conditionStack.length - 1 - Math.abs(n || 0);\n            return n >= 0 ? this.conditionStack[n] : "INITIAL";\n          },\n          stateStackSize() {\n            return this.conditionStack.length;\n          }\n        };\n        return lexer3;\n      }();\n      Parser.prototype = {\n        Parser,\n        lexer,\n        symbols_: { "error": 2, "root": 3, "block": 4, "EOF": 5, "definitions": 6, "e": 7, "def": 8, "$": 9, ";": 10, ":": 11, "$ident": 12, "ident": 13, "IDENT": 14, "$IDENT": 15, "condConsequent": 16, "?": 17, "condAlternate": 18, "query": 19, "=>": 20, "(": 21, ")": 22, "functionArgs": 23, "compareFunction": 24, "NOT": 25, "NO": 26, "-": 27, "+": 28, "|": 29, "IS": 30, "assertion": 31, "IN": 32, "HAS": 33, "NOTIN": 34, "HASNO": 35, "AND": 36, "OR": 37, "??": 38, "*": 39, "/": 40, "%": 41, "=": 42, "!=": 43, "<": 44, "<=": 45, ">": 46, ">=": 47, "~=": 48, "queryRoot": 49, "relativePath": 50, "@": 51, "#": 52, "$$": 53, "STRING": 54, "NUMBER": 55, "REGEXP": 56, "LITERAL": 57, "template": 58, "object": 59, "array": 60, "[": 61, "sliceNotation": 62, "]": 63, "method()": 64, ".": 65, ".(": 66, ".[": 67, "..": 68, "..(": 69, "METHOD(": 70, "arguments": 71, "$METHOD(": 72, ",": 73, "functionArg": 74, "templateString": 75, "templateStart": 76, "templateTail": 77, "templateEnd": 78, "templateContinue": 79, "TEMPLATE": 80, "TPL_START": 81, "TPL_CONTINUE": 82, "TPL_END": 83, "{": 84, "}": 85, "objectEntries": 86, "objectEntry": 87, "objectEntryKeyLiteral": 88, "...": 89, "arrayElements": 90, "arrayElement": 91, "assertionTerm": 92, "assertionList": 93, "compareExpr": 94, "ORDER": 95, "sliceNotationComponent": 96, "$accept": 0, "$end": 1 },\n        terminals_: { 2: "error", 5: "EOF", 9: "$", 10: ";", 11: ":", 14: "IDENT", 15: "$IDENT", 17: "?", 20: "=>", 21: "(", 22: ")", 25: "NOT", 26: "NO", 27: "-", 28: "+", 29: "|", 30: "IS", 32: "IN", 33: "HAS", 34: "NOTIN", 35: "HASNO", 36: "AND", 37: "OR", 38: "??", 39: "*", 40: "/", 41: "%", 42: "=", 43: "!=", 44: "<", 45: "<=", 46: ">", 47: ">=", 48: "~=", 51: "@", 52: "#", 53: "$$", 54: "STRING", 55: "NUMBER", 56: "REGEXP", 57: "LITERAL", 61: "[", 63: "]", 65: ".", 66: ".(", 67: ".[", 68: "..", 69: "..(", 70: "METHOD(", 72: "$METHOD(", 73: ",", 80: "TEMPLATE", 81: "TPL_START", 82: "TPL_CONTINUE", 83: "TPL_END", 84: "{", 85: "}", 89: "...", 95: "ORDER" },\n        productions_: [0, [3, 2], [4, 2], [4, 1], [4, 1], [4, 0], [6, 1], [6, 2], [8, 2], [8, 4], [8, 2], [8, 4], [13, 1], [12, 1], [16, 2], [16, 1], [18, 2], [18, 1], [18, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 1], [7, 2], [7, 2], [7, 2], [7, 2], [7, 3], [7, 4], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [7, 3], [19, 1], [19, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 1], [49, 3], [49, 2], [49, 2], [49, 1], [49, 1], [49, 3], [49, 4], [49, 2], [49, 2], [49, 3], [49, 3], [49, 2], [49, 2], [49, 3], [49, 2], [49, 3], [50, 3], [50, 4], [50, 4], [50, 3], [50, 3], [50, 4], [50, 4], [50, 3], [50, 3], [50, 4], [64, 2], [64, 3], [64, 2], [64, 3], [71, 1], [71, 3], [74, 1], [23, 1], [23, 3], [58, 1], [58, 2], [77, 1], [77, 2], [77, 2], [77, 3], [75, 1], [76, 1], [79, 1], [78, 1], [59, 2], [59, 3], [59, 4], [59, 3], [59, 4], [59, 5], [86, 1], [86, 3], [88, 1], [88, 1], [88, 1], [87, 1], [87, 1], [87, 1], [87, 1], [87, 3], [87, 3], [87, 3], [87, 5], [87, 1], [87, 2], [90, 1], [90, 3], [91, 1], [91, 1], [91, 2], [60, 2], [60, 3], [60, 4], [31, 1], [31, 2], [31, 3], [31, 4], [92, 1], [92, 1], [92, 1], [92, 1], [93, 1], [93, 3], [93, 3], [24, 1], [24, 3], [94, 2], [62, 1], [62, 2], [62, 2], [62, 3], [96, 1], [96, 2]],\n        table: function unpackTable(tables) {\n          function unpackSubtable(table) {\n            const refs = table.match(/[\\x20-\\x2f]/g);\n            const last = refs ? Math.max(...refs.map((ref) => ref.charCodeAt() - 32)) : -1;\n            for (let i = last; i >= 0; i--) {\n              const idx = (32 + i).toString(16);\n              let pattern;\n              table = table.replace(new RegExp("\\\\[\\\\x" + idx + "(.+?)\\\\]"), (_, repl) => pattern = repl).replace(new RegExp("\\\\x" + idx, "g"), pattern);\n            }\n            table = table.replace(/<([^>]+?)>/g, (_, p) => {\n              let n = d64[p[0]];\n              let offset = 1;\n              if (n >> 5 === 1) {\n                n = n & 31 | d64[p[1]] << 5;\n                offset = 2;\n              }\n              return p.slice(offset).repeat(n);\n            });\n            return table;\n          }\n          function decodeNums(encoded) {\n            const nums = [];\n            for (let j2 = 0; j2 < encoded.length; j2++) {\n              const b1 = d64[encoded[j2]];\n              if (b1 & 32) {\n                const b2 = d64[encoded[++j2]];\n                nums.push(b1 & 31 | b2 << 5);\n              } else {\n                nums.push(b1);\n              }\n            }\n            return nums;\n          }\n          const e64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~|=";\n          const d64 = e64.split("").reduce((map2, ch, idx) => (map2[ch] = idx, map2), /* @__PURE__ */ Object.create(null));\n          const [indexTable, indexRows, ...stateTables] = tables.split("=").map(unpackSubtable);\n          const decodedIndexRows = indexRows.split(";").map((row) => {\n            const states = [];\n            for (let i = 0; i < row.length; i++) {\n              for (let j2 = 0, chunk = d64[row[i]]; j2 < 3; j2++) {\n                states.push(chunk >> j2 * 2 & 3);\n              }\n            }\n            return states;\n          });\n          const decodedStateTables = stateTables.map(decodeNums);\n          const result = decodeNums(indexTable).map((rowIdx) => {\n            const rowIndexes = decodedIndexRows[rowIdx];\n            const row = /* @__PURE__ */ Object.create(null);\n            for (let i = 0; i < rowIndexes.length; i++) {\n              const state = rowIndexes[i];\n              if (state !== 0) {\n                const ref = decodedStateTables[state - 1].shift();\n                row[i] = state === 1 ? ref : [state - 1, ref];\n              }\n            }\n            return row;\n          });\n          for (let i = 0; i < decodedStateTables[3].length; i += 2) {\n            result[decodedStateTables[3][i]][decodedStateTables[3][i + 1]] = [3];\n          }\n          return result;\n        }(`ABCDEFGHIJKHHHHLL<NM>NOPMMQRSQRTMUVWMXXMYZEFTO<TH>PMaQRSQRbMMHcdefgBhBHi[ BiBjBj]BFHFHkBMlBmBnBoBpBqBMMrBsB<GM>WMMt[!BkBMMt]BuBfMMvBUMYMwBxByBzBzB0B0BH1<DB2>BuBMd3BMduBfM<E4B>5B6 <DB7>B8B8<EB9>B8BMM~<C!>BbHc|BMeMgChChCMMiCjCmBkClCMsBmCnCuBMMMuBMUMMoCMwBHHHpCqCTMHMuB<FM>bHgBgBMFFMoBlCjCmCMOOMMyByB0BMoCrCsCsCtC3BbMnCnCHMHsCsC=A1[ V[!C["lmkCpqC]]]<FA>[#[$[%[&[\'UqqWJkq]K]C][([)FgCCAAE];]]A];Ag;AwU[*ClmkOpqC]<FA>[+[,U[-qqWJnqK]]C(A]wAA[.A[/kAMAqi]]<Fq>CAAAAD<JA>g;AwADwzwP8|D<GA>||DMz|PDAwDPw;AwA8AwAMA|z<F|>DAAAIjqCMAA8MAAw;AAE!<FA>#wA8AwgMA|z<F|>DAAAMz|DMAA8MAAw;AAVClmkapqC<FA>&S(AwA8AwAMA|z<F|>DAAAMz|DIAA8MAAw;AwAoAwAMA|z<F|>DAAAMz|DMAA8MAAw;AwA8AwAMA|z<F|>DAAAMz|DMAA8MAAw;AAEi"<FA>UqqWZmqKCFgCCgFEB;AAAChCACIAE<IA>C<KA>Q;AwAsAwBMA|z<F|>DAAAMz|DMAA8MAAw;AAAAk<QA>EAIC;AEV*<FA>#E <FA>+A <FA>#AE!<FA>%VlqCAAE;AARClC<MA>KCI<HA>Yl;AwE~lmkOp6y<F|>X-OFg~OAA0;AAEClmkKpqC<FA>\'aC(AAADwzwD8|D<GA>||DMw|PDAw|D;M;AAEi"<FA>UqqWZmqKC)B;AwA8.<Fq>CAAAMz|DMAA8MAA<Cg;AAAAAA>AI<QA>I;<FA>kAIAqi<Fq>C<OA>g;AAU!<FA>$<HA>M<QA>M;AAA8AwgMA|z<F|>DAAAMw|DM<GA>w;AwA8A0AMA6jq|qqqCAAAMz|DMAA8MAAw;AwA8A0AMA|z||q||DAAAMz|DMAA8MAAw<C;AAAAAAAAAAAAAAAAAAAAAC>AAI;AAAg<RA>D<KA>B;AAAgAkAAAqi<Fq>CAAAADAAM<GA>gB;<VA>DAAM;AAEy"<FA>+AE!<FA>,O(AAAChCACA<KA>C<KA>Q;AAAChCACIAE<IA>C<KA>QB;<HA>I;AwA8AkAMA6i<Fq>CAAAMz|DMAA8MAAw;<FA>kAAAqi<Fq>C<JA>FoAAAg;<YA>IAAAI;AAQClC<MA>KCI<HA>Yl;<YA>MAAAM;AAAo<UA>MAAAM;AAAg<UA>MAAAM;AAAClmECAgC<FA>&OFgCO;AAAw<UA>MAAAM;<FA>/<Fq>C<HA>M<GA>g;AwA8A0AMA6z||qqqCAAAMz|DMAA8MAAw;AwA8A0AMA6jqvqqqCAAAMz|DMAA8MAAw;AwA8A0AMA6jquqqqCAAAMz|DMAA8MAAw;AwA8A0AMA|z<F|>DAAAMz|DMAA8MAAw;AwA8A0AMA6z||qvqDAAAMz|DMAA8MAAw;AwA8A0AMA6z||q||DAAAMz|DMAA8MAAw;AAAgAkAAAqi<Fq><CCAAAA><FA>gB;<FA>C<SA>Q;<FA>kAAAqi<Fq>C<OA>g;AAAIAkAAAqi<Fq>C<OA>g;AAE!<FA>UqqWJmqKCFgCCgEE;<VA>D;AAAwAkAAAqi<Fq>CAAAAD<JA>g;<FA>kAAAqi<Fq>CAAAADAAM<GA>g;<HA>IAAAAK;<HA>MAAAAP;AAAClC<MA>KCI<HA>Il;<FA>kAAAqi<Fq><CCAAAA><FA>g;<UA>IgqCMAAAM;AAAIAkAAAqi<Fq>C<HA>MAAAMAAg;<FA>kAAAqi<Fq>C<HA>MAAAMAAg;AAAg=BC[ D[!E["[#F[$QhBgBG]][%[&[\'[(KRSbcd]iB]pBqB]T]]]]zB[)0B$%qC]y[*C[[,+[-0ChBgB]]G%]]5C4C#3C\'6CpBqBT9*~*|*gD+pD-G(lD[.iBpBqB]nDqDToDzDtDuD2D4D5D6D 7D 8D9D~D gE|D"jE-G&hEiEkETpEFsEtEoEqEuE0E+3E-G\'2[/EpBqBT]3E-G\'5/qC7E6!zD8EuD9E+~E+|E+gF+hF+iF+jF+kF+lF+mF+nF+oF+pF+qF+rF+sF+tF+uF+vF+wFyF-G(zF.ToD0F1F2F 3F 4F5F6F qC7F+qCgG0B$%iG-G&hG<EqC>jG+kG+oGqCpGqG+rG+zDsGzDvGuDuGwG+qC0G)1G2GjE-G&3GiEkET0BsEtE7GqEuE|G,gHRSbcd.qCqCqClH0B$%<UqC>pGqCrH+tH<EqC>0H-G&zHT1HqCqCzDvGuD2HqCqCjE-G&6HiEkET~HtE8HuEhI+iI+jI+qC5C4C"lI+qCqCmI+qCzDoIuDzDpIuD~HtE8HuE<FqC>tI+uI+qCqC=[ [!["P[#[$[%[&[\'tBIsBHJ]LMNO][(oB[)fUVWXYZae]]][*jBkBlBmBnBuBvBwBxB]]r]]B]y][+B[,![-[.sB|B~B][/1B2B3B4B5B6B7B8B9BgChCiCjCkClCmCnCoCpC]]]rC]sCtCuCvCwCxCzC#B1CPtB7CsBHJ2CLMNO(*rB8C<EzC#B>hDiDjDkDzCrD%mD*rBsDyDxD1DwDvD0D3D<CtBuBvB!!>zC$mElErBrEtB1DxEyEzEvEnEwEzC&)*rBzC\'1ELMNO(*rBzC\'4ELMNO(*rB-rC DxD1DwDvD0D<TzC#B>3DzCrD%xF*rBtBuBv<CB">BtBuBv+zC#B8F9F~FsB|F|B~B/rC!1CzC#B<C|B~B3B4B5B6BgChCiCjCkClCmCnCoCpC><CgChCiC><CzC#B>lGmGnGrDrD-rC<CzC#B>yDxD1DtG0DyDxD1DwDvD0DzC&)*rBxGyGzG.2B3B4B5B6B7B8B9BgChCiCjCkClCmCnCoCpC,mElErCzC$mElErB5G4GrEtB1DxEyEzEvE6GwEhDiDjD8G9G~GzC#BzCtB1DsBhH(*rB.2B3B4B5B6B7B8B9BgChCiCjCkClCmCnCoCpCiHjH-rCkHjH.2B3B4B5B6B7B8B9BgChCiCjCkClCmCnCoCpC!<E|B~BgChCiCjCkClCmCnCoCpC>|B~B3B4B5B6B9BgChCiCjCkClCmCnCoCpC|B~B3B4B5B6B7B9BgChCiCjCkClCmCnCoCpC|B~B3B4B5B6BgChCiCjCkClCmCnCoCp<CCgChCi><CC|B~BgChCiClCmCnCo><FC|B~BgChCi>ClCmCnCoCrD-mHrCnHoHpHqH-rCzC#BsHuHsBvH|B~B/rC-rCwH-rCxH-rCzC%yH*rBsDrD<C-rC>yDxD1DwDvD0D3H4H5H<C.2B3B4B5B6B7B8B9BgChCiCjCkClCmCnCoCpC>zC$mElErB9HtB1DxEyEzEvE7HwEgI|H<DzC#B>-kIrCsCtCuCvCwCxC!zC#B.2B3B4B5B6B7B8B9BgChCiCjCkClCmCnCoCpC-rCzC#B-rCnI4H5H<CyDxD1DwDvD0D>qI9HtB1DxEyEzEvErIwExH<D-rC>sI<C-rC><CzC#B><C-rC>=FDDDEEE<jBG><gBT><mBN><lBY><kB4B><kB6B><mB0B><mB1B><mB3E><mB2B><mB3B><mB5B><mB7B><mB8B><mB9B><mB~B><mB|B><mBgC><mBhC><lBS><mBlC><mBmC>FFF<mBlD><cP><mBM><mBrD><gBsD>BCCC<jBH><lBS><mB5E>FFF<PU><mB4B><mB6B>jDjDNNNiD<bN>iDN<WZ><Wa><jBb><jBc><jBI><jBK><mBpE>6EmEmEkEkE~E~EnEnE<mBjC><mBsE><mBwE><mBxE><mByE><mBzE><mBN><mBkC><cR><mBpC><mBqC><mBtC><mBuC><RwC><mBmD><mBnD><mBuD><gBtD><mBvD>1D1[ D6D6D7D7D]8D8D9D9DiEiE<D3D><D4D><D5D><RO><mB8C>gDgD<mB~C><Rd><mBf><agB><ahB><aiB><ajB><VkB><UlB><WmB><jBnB><jBoB><mBpB><mBqB><mBrB><dsB><dtB><hBuB><hBvB><hBwB><hBxB><dyB><mBzB><mByC><mB1C><mB2C><mB5C><mB6C><PV><mBnC><mB4E><mBiC><mBqE>7E8E|E|EoEo<mBEt><DE0>E<RQ><mBrC><mBsC><mBvC><RxC><mBoD><mBpD><mBwD><mByD>jEjE<mB9C><mB|C><Re><mBzC><mB0C><mB3C><mB4C><mB7C><PW>kDkDiDiD<mBoC><jBJ><jBL><mBrE>lElEmEmE9<mBEu>E<mBqD><mBxD>2D2 <mBzD>gEgE~D~D|D|DhDhD<PX><mBvE><D1E><D2E><mB0D>gEgEhEhE=BB`),\n        defaultActions: { 50: [2, 1], 200: [2, 155], 245: [2, 157] },\n        performAction(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n          const $0 = $$.length - 1;\n          switch (yystate) {\n            case 1:\n              return yy.buildResult($$[$0 - 1]);\n              break;\n            case 2:\n              this.$ = { type: "Block", definitions: $$[$0 - 1], body: $$[$0], range: this._$.range };\n              break;\n            case 3:\n              this.$ = { type: "Block", definitions: $$[$0], body: { type: "Placeholder", range: [_$[$0].range[1], _$[$0].range[1]] }, range: this._$.range };\n              break;\n            case 4:\n              this.$ = { type: "Block", definitions: [], body: $$[$0], range: this._$.range };\n              break;\n            case 5:\n              this.$ = { type: "Block", definitions: [], body: { type: "Placeholder", range: [_$[$0].range[1], _$[$0].range[1]] }, range: this._$.range };\n              break;\n            case 6:\n            case 96:\n            case 99:\n            case 101:\n            case 117:\n            case 132:\n            case 148:\n            case 151:\n              this.$ = [$$[$0]];\n              break;\n            case 7:\n              $$[$0 - 1].push($$[$0]);\n              break;\n            case 8:\n              this.$ = { type: "Definition", declarator: { type: "Declarator", name: null, range: _$[$0 - 1].range }, value: null, range: this._$.range };\n              break;\n            case 9:\n              this.$ = { type: "Definition", declarator: { type: "Declarator", name: null, range: _$[$0 - 3].range }, value: $$[$0 - 1], range: this._$.range };\n              break;\n            case 10:\n              this.$ = { type: "Definition", declarator: { type: "Declarator", name: $$[$0 - 1].name, range: _$[$0 - 1].range }, value: null, range: this._$.range };\n              break;\n            case 11:\n              this.$ = { type: "Definition", declarator: { type: "Declarator", name: $$[$0 - 3].name, range: _$[$0 - 3].range }, value: $$[$0 - 1], range: this._$.range };\n              break;\n            case 12:\n            case 13:\n            case 98:\n            case 144:\n            case 145:\n              this.$ = { type: "Identifier", name: $$[$0], range: this._$.range };\n              break;\n            case 14:\n            case 16:\n            case 159:\n              this.$ = $$[$0];\n              break;\n            case 15:\n            case 17:\n            case 18:\n            case 158:\n              this.$ = null;\n              break;\n            case 19:\n            case 52:\n            case 53:\n            case 64:\n            case 65:\n            case 134:\n              break;\n            case 20:\n            case 22:\n              this.$ = { type: "Function", arguments: [], body: $$[$0], range: this._$.range };\n              break;\n            case 21:\n              this.$ = { type: "Function", arguments: [{ type: "Identifier", name: $$[$0 - 2] }], body: $$[$0], range: this._$.range };\n              break;\n            case 23:\n              this.$ = { type: "Function", arguments: $$[$0 - 3], body: $$[$0], range: this._$.range };\n              break;\n            case 24:\n              this.$ = { type: "CompareFunction", compares: $$[$0], range: this._$.range };\n              break;\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 67:\n              this.$ = { type: "Prefix", operator: $$[$0 - 1], argument: $$[$0], range: this._$.range };\n              break;\n            case 29:\n              this.$ = { type: "Pipeline", left: $$[$0 - 2], right: $$[$0], range: this._$.range };\n              break;\n            case 30:\n              this.$ = { type: "Pipeline", left: $$[$0 - 3], right: { type: "Block", definitions: $$[$0 - 1], body: $$[$0] }, range: this._$.range };\n              break;\n            case 31:\n              this.$ = { type: "Postfix", operator: $$[$0], argument: $$[$0 - 2], range: this._$.range };\n              break;\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n            case 36:\n            case 37:\n            case 38:\n            case 39:\n            case 40:\n            case 41:\n            case 42:\n            case 43:\n            case 44:\n            case 45:\n            case 46:\n            case 47:\n            case 48:\n            case 49:\n            case 50:\n              this.$ = { type: "Binary", operator: $$[$0 - 1], left: $$[$0 - 2], right: $$[$0], range: this._$.range };\n              break;\n            case 51:\n              this.$ = { type: "Conditional", test: $$[$0 - 2], consequent: $$[$0 - 1], alternate: $$[$0], range: this._$.range };\n              break;\n            case 54:\n              this.$ = { type: "Data", range: this._$.range };\n              break;\n            case 55:\n              this.$ = { type: "Context", range: this._$.range };\n              break;\n            case 56:\n              this.$ = { type: "Current", range: this._$.range };\n              break;\n            case 57:\n              this.$ = { type: "Arg1", range: this._$.range };\n              break;\n            case 58:\n              this.$ = { type: "Reference", name: $$[$0], range: this._$.range };\n              break;\n            case 59:\n            case 60:\n            case 61:\n            case 62:\n            case 107:\n            case 108:\n            case 109:\n            case 110:\n            case 119:\n            case 120:\n            case 121:\n              this.$ = { type: "Literal", value: $$[$0], range: this._$.range };\n              break;\n            case 63:\n              this.$ = { type: "Template", values: $$[$0], range: this._$.range };\n              break;\n            case 66:\n              this.$ = { type: "SliceNotation", value: null, arguments: $$[$0 - 1], range: this._$.range };\n              break;\n            case 68:\n              this.$ = { type: "Conditional", test: null, consequent: $$[$0 - 1], alternate: $$[$0], range: this._$.range };\n              break;\n            case 69:\n            case 73:\n              this.$ = { type: "GetProperty", value: null, property: $$[$0], range: this._$.range };\n              break;\n            case 70:\n            case 74:\n              this.$ = { type: "MethodCall", value: null, method: $$[$0], range: this._$.range };\n              break;\n            case 71:\n              this.$ = { type: "Parentheses", body: $$[$0 - 1], range: this._$.range };\n              break;\n            case 72:\n              this.$ = { type: "Parentheses", body: { type: "Block", definitions: $$[$0 - 2], body: $$[$0 - 1] }, range: this._$.range };\n              break;\n            case 75:\n              this.$ = { type: "Map", value: null, query: $$[$0 - 1], range: this._$.range };\n              break;\n            case 76:\n              this.$ = { type: "Filter", value: null, query: $$[$0 - 1], range: this._$.range };\n              break;\n            case 77:\n              this.$ = { type: "MapRecursive", value: null, query: { type: "GetProperty", value: null, property: $$[$0] }, range: this._$.range };\n              break;\n            case 78:\n              this.$ = { type: "MapRecursive", value: null, query: { type: "MethodCall", value: null, method: $$[$0] }, range: this._$.range };\n              break;\n            case 79:\n              this.$ = { type: "MapRecursive", value: null, query: $$[$0 - 1], range: this._$.range };\n              break;\n            case 80:\n              this.$ = { type: "Pipeline", left: null, right: $$[$0], range: this._$.range };\n              break;\n            case 81:\n              this.$ = { type: "Pipeline", left: null, right: { type: "Block", definitions: $$[$0 - 1], body: $$[$0] }, range: this._$.range };\n              break;\n            case 82:\n              this.$ = { type: "Pick", value: $$[$0 - 2], getter: null, range: this._$.range };\n              break;\n            case 83:\n              this.$ = { type: "Pick", value: $$[$0 - 3], getter: $$[$0 - 1], range: this._$.range };\n              break;\n            case 84:\n              this.$ = { type: "SliceNotation", value: $$[$0 - 3], arguments: $$[$0 - 1], range: this._$.range };\n              break;\n            case 85:\n              this.$ = { type: "GetProperty", value: $$[$0 - 2], property: $$[$0], range: this._$.range };\n              break;\n            case 86:\n              this.$ = { type: "MethodCall", value: $$[$0 - 2], method: $$[$0], range: this._$.range };\n              break;\n            case 87:\n              this.$ = { type: "Map", value: $$[$0 - 3], query: $$[$0 - 1], range: this._$.range };\n              break;\n            case 88:\n              this.$ = { type: "Filter", value: $$[$0 - 3], query: $$[$0 - 1], range: this._$.range };\n              break;\n            case 89:\n              this.$ = { type: "MapRecursive", value: $$[$0 - 2], query: { type: "GetProperty", value: null, property: $$[$0] }, range: this._$.range };\n              break;\n            case 90:\n              this.$ = { type: "MapRecursive", value: $$[$0 - 2], query: { type: "MethodCall", value: null, method: $$[$0] }, range: this._$.range };\n              break;\n            case 91:\n              this.$ = { type: "MapRecursive", value: $$[$0 - 3], query: $$[$0 - 1], range: this._$.range };\n              break;\n            case 92:\n              this.$ = { type: "Method", reference: { type: "Identifier", name: $$[$0 - 1], range: [_$[$0 - 1].range[0], _$[$0 - 1].range[1] - 1] }, arguments: [], range: this._$.range };\n              break;\n            case 93:\n              this.$ = { type: "Method", reference: { type: "Identifier", name: $$[$0 - 2], range: [_$[$0 - 2].range[0], _$[$0 - 2].range[1] - 1] }, arguments: $$[$0 - 1], range: this._$.range };\n              break;\n            case 94:\n              this.$ = { type: "Method", reference: { type: "Reference", name: { type: "Identifier", name: $$[$0 - 1], range: [_$[$0 - 1].range[0], _$[$0 - 1].range[1] - 1] }, range: [_$[$0 - 1].range[0], _$[$0 - 1].range[1] - 1] }, arguments: [], range: this._$.range };\n              break;\n            case 95:\n              this.$ = { type: "Method", reference: { type: "Reference", name: { type: "Identifier", name: $$[$0 - 2], range: [_$[$0 - 2].range[0], _$[$0 - 2].range[1] - 1] }, range: [_$[$0 - 2].range[0], _$[$0 - 2].range[1] - 1] }, arguments: $$[$0 - 1], range: this._$.range };\n              break;\n            case 97:\n            case 100:\n            case 118:\n            case 133:\n            case 152:\n              $$[$0 - 2].push($$[$0]);\n              break;\n            case 102:\n              this.$ = [$$[$0 - 1], ...$$[$0]];\n              break;\n            case 103:\n            case 154:\n              this.$ = [null, $$[$0]];\n              break;\n            case 104:\n            case 156:\n              this.$ = [$$[$0 - 1], $$[$0]];\n              break;\n            case 105:\n              this.$ = [null, $$[$0 - 1], ...$$[$0]];\n              break;\n            case 106:\n              this.$ = [$$[$0 - 2], $$[$0 - 1], ...$$[$0]];\n              break;\n            case 111:\n            case 114:\n              this.$ = { type: "Object", properties: [], range: this._$.range };\n              break;\n            case 112:\n              this.$ = { type: "Object", properties: $$[$0 - 1], range: this._$.range };\n              break;\n            case 113:\n              this.$ = { type: "Object", properties: $$[$0 - 2], range: this._$.range };\n              break;\n            case 115:\n              this.$ = { type: "Block", definitions: $$[$0 - 2], body: { type: "Object", properties: $$[$0 - 1] }, range: this._$.range };\n              break;\n            case 116:\n              this.$ = { type: "Block", definitions: $$[$0 - 3], body: { type: "Object", properties: $$[$0 - 2] }, range: this._$.range };\n              break;\n            case 122:\n              this.$ = { type: "ObjectEntry", key: { type: "Current" }, value: null, range: this._$.range };\n              break;\n            case 123:\n              this.$ = { type: "ObjectEntry", key: { type: "Reference", name: $$[$0] }, value: null, range: this._$.range };\n              break;\n            case 124:\n            case 125:\n              this.$ = { type: "ObjectEntry", key: $$[$0], value: null, range: this._$.range };\n              break;\n            case 126:\n            case 127:\n              this.$ = { type: "ObjectEntry", key: $$[$0 - 2], value: $$[$0], range: this._$.range };\n              break;\n            case 128:\n              this.$ = { type: "ObjectEntry", key: { type: "Identifier", name: "$" + $$[$0 - 2].name }, value: $$[$0], range: this._$.range };\n              break;\n            case 129:\n              this.$ = { type: "ObjectEntry", key: $$[$0 - 3], value: $$[$0], range: this._$.range };\n              break;\n            case 130:\n              this.$ = { type: "Spread", query: null, array: false, range: this._$.range };\n              break;\n            case 131:\n              this.$ = { type: "Spread", query: $$[$0], array: false, range: this._$.range };\n              break;\n            case 135:\n              this.$ = { type: "Spread", query: null, array: true, range: this._$.range };\n              break;\n            case 136:\n              this.$ = { type: "Spread", query: $$[$0], array: true, range: this._$.range };\n              break;\n            case 137:\n              this.$ = { type: "Array", elements: [], range: this._$.range };\n              break;\n            case 138:\n              this.$ = { type: "Array", elements: $$[$0 - 1], range: this._$.range };\n              break;\n            case 139:\n              this.$ = { type: "Array", elements: $$[$0 - 2], range: this._$.range };\n              break;\n            case 140:\n              this.$ = { type: "Assertion", negation: false, assertion: $$[$0], range: this._$.range };\n              break;\n            case 141:\n              this.$ = { type: "Assertion", negation: true, assertion: $$[$0], range: this._$.range };\n              break;\n            case 142:\n              this.$ = { type: "Assertion", negation: false, assertion: $$[$0 - 1], range: this._$.range };\n              break;\n            case 143:\n              this.$ = { type: "Assertion", negation: true, assertion: $$[$0 - 1], range: this._$.range };\n              break;\n            case 146:\n              this.$ = { type: "Method", reference: { type: "Reference", name: $$[$0] }, arguments: [], range: this._$.range };\n              break;\n            case 147:\n              this.$ = { type: "Identifier", name: String($$[$0]), range: this._$.range };\n              break;\n            case 149:\n            case 150:\n              $$[$0 - 2].push($$[$0 - 1], $$[$0]);\n              break;\n            case 153:\n              this.$ = { type: "Compare", query: $$[$0 - 1], order: $$[$0], range: this._$.range };\n              break;\n            case 155:\n              this.$ = [null, $$[$0 - 1], $$[$0]];\n              break;\n            case 157:\n              this.$ = [$$[$0 - 2], $$[$0 - 1], $$[$0]];\n              break;\n          }\n        },\n        trace(...args) {\n          if (this.DEBUG) {\n            Jison.print(...args);\n          }\n        },\n        parseError(str, hash) {\n          if (hash.recoverable) {\n            this.trace(str);\n          } else {\n            const error = new Error(str);\n            error.hash = hash;\n            throw error;\n          }\n        },\n        parse(input, ...parseArgs) {\n          const SHIFT = 1;\n          const REDUCE = 2;\n          const ACCEPT = 3;\n          const TERROR = 2;\n          const EOF = 1;\n          const popStack = (n) => {\n            stack.length -= 2 * n;\n            vstack.length -= n;\n            lstack.length -= n;\n          };\n          const lex = (\n            /** @replace token stack */\n            () => {\n              let token2 = lexer3.lex() || EOF;\n              if (typeof token2 !== "number") {\n                token2 = this.symbols_[token2] || token2;\n              }\n              return token2;\n            }\n          );\n          const lexer3 = Object.create(this.lexer);\n          const ranges = lexer3.options && lexer3.options.ranges;\n          const sharedYY = {\n            // shared state\n            ...this.yy,\n            parser: this,\n            lexer: lexer3\n          };\n          lexer3.setInput(input, sharedYY);\n          if (typeof sharedYY.parseError === "function") {\n            this.parseError = sharedYY.parseError;\n          }\n          if (typeof lexer3.yylloc == "undefined") {\n            lexer3.yylloc = {};\n          }\n          const table = this.table;\n          const yyval = {};\n          let yylloc = lexer3.yylloc;\n          const stack = [0];\n          const vstack = [null];\n          const lstack = [yylloc];\n          let tstack = [];\n          let yytext = "";\n          let yylineno = 0;\n          let yyleng = 0;\n          let recovering = 0;\n          let symbol;\n          let preErrorSymbol;\n          while (true) {\n            let state = stack[stack.length - 1];\n            let action;\n            if (this.defaultActions[state]) {\n              action = this.defaultActions[state];\n            } else {\n              if (symbol === null || typeof symbol == "undefined") {\n                symbol = lex();\n              }\n              action = table[state] && table[state][symbol];\n            }\n            if (!action || !action[0]) {\n              let locateNearestErrorRecoveryRule = function(state2) {\n                let stackProbe = stack.length - 1;\n                let depth = 0;\n                while (true) {\n                  if (TERROR.toString() in table[state2]) {\n                    return depth;\n                  }\n                  if (state2 === 0 || stackProbe < 2) {\n                    return false;\n                  }\n                  stackProbe -= 2;\n                  state2 = stack[stackProbe];\n                  ++depth;\n                }\n              };\n              let errorRuleDepth;\n              let errStr = "";\n              if (!recovering) {\n                const expected = [];\n                for (const p in table[state]) {\n                  if (p in this.terminals_ && p > TERROR) {\n                    expected.push("\'" + this.terminals_[p] + "\'");\n                  }\n                }\n                errStr = lexer3.showPosition ? "Parse error on line " + (yylineno + 1) + ":\\n" + lexer3.showPosition() + "\\nExpecting " + expected.join(", ") + ", got \'" + (this.terminals_[symbol] || symbol) + "\'" : "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol === EOF ? "end of input" : "\'" + (this.terminals_[symbol] || symbol) + "\'");\n                this.parseError(errStr, {\n                  text: lexer3.match,\n                  token: this.terminals_[symbol] || symbol,\n                  line: lexer3.yylineno,\n                  loc: yylloc,\n                  expected\n                });\n              } else if (preErrorSymbol !== EOF) {\n              }\n              if (recovering === 3) {\n                if (symbol === EOF || preErrorSymbol === EOF) {\n                  throw new Error(errStr || "Parsing halted while starting to recover from another error.");\n                }\n                yyleng = lexer3.yyleng;\n                yytext = lexer3.yytext;\n                yylineno = lexer3.yylineno;\n                yylloc = lexer3.yylloc;\n                symbol = lex();\n              }\n              if (errorRuleDepth === false) {\n                throw new Error(errStr || "Parsing halted. No suitable error recovery rule available.");\n              }\n              popStack(errorRuleDepth);\n              preErrorSymbol = symbol == TERROR ? null : symbol;\n              symbol = TERROR;\n              state = stack[stack.length - 1];\n              action = table[state] && table[state][TERROR];\n              recovering = 3;\n            }\n            if (Array.isArray(action[0]) && action.length > 1) {\n              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);\n            }\n            switch (action[0]) {\n              case SHIFT:\n                stack.push(symbol);\n                vstack.push(lexer3.yytext);\n                lstack.push(lexer3.yylloc);\n                stack.push(action[1]);\n                symbol = null;\n                if (!preErrorSymbol) {\n                  yyleng = lexer3.yyleng;\n                  yytext = lexer3.yytext;\n                  yylineno = lexer3.yylineno;\n                  yylloc = lexer3.yylloc;\n                  if (recovering > 0) {\n                    recovering--;\n                  }\n                } else {\n                  symbol = preErrorSymbol;\n                  preErrorSymbol = null;\n                }\n                break;\n              case REDUCE: {\n                const len = this.productions_[action[1]][1];\n                const first = lstack[lstack.length - (len || 1)];\n                const last = lstack[lstack.length - 1];\n                yyval.$ = vstack[vstack.length - len];\n                yyval._$ = {\n                  first_line: first.first_line,\n                  last_line: last.last_line,\n                  first_column: first.first_column,\n                  last_column: last.last_column\n                };\n                if (ranges) {\n                  yyval._$.range = [\n                    first.range[0],\n                    last.range[1]\n                  ];\n                }\n                const actionResult = this.performAction.call(\n                  yyval,\n                  yytext,\n                  yyleng,\n                  yylineno,\n                  sharedYY,\n                  action[1],\n                  vstack,\n                  lstack,\n                  ...parseArgs\n                );\n                if (typeof actionResult !== "undefined") {\n                  return actionResult;\n                }\n                if (len) {\n                  popStack(len);\n                }\n                stack.push(this.productions_[action[1]][0]);\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                stack.push(table[stack[stack.length - 2]][stack[stack.length - 1]]);\n                break;\n              }\n              case ACCEPT:\n                return true;\n            }\n          }\n        }\n      };\n      parser = function buildParsers(strictParser) {\n        function patch(subject, patches) {\n          Object.entries(patches).forEach(\n            ([key2, patch2]) => subject[key2] = patch2(subject[key2])\n          );\n        }\n        const humanTokens = /* @__PURE__ */ new Map([\n          ["EOF", ["<end of input>"]],\n          ["IDENT", ["ident"]],\n          ["$IDENT", ["$ident"]],\n          ["NOT", ["\'not\'"]],\n          ["NO", ["\'no\'"]],\n          ["IS", ["\'is\'"]],\n          ["IN", ["\'in\'"]],\n          ["HAS", ["\'has\'"]],\n          ["NOTIN", ["\'not in\'"]],\n          ["HASNO", ["\'has no\'"]],\n          ["AND", ["\'and\'"]],\n          ["OR", ["\'or\'"]],\n          ["STRING", ["string"]],\n          ["TPL_START", ["template"]],\n          ["TEMPLATE", ["template"]],\n          ["NUMBER", ["number"]],\n          ["REGEXP", ["regexp"]],\n          ["LITERAL", ["\'true\'", "\'false\'", "\'null\'", "\'undefined\'", "\'NaN\'", "\'Infinity\'"]],\n          ["ORDER", ["\'asc\'", "\'desc\'", "\'ascN\'", "\'descN\'"]],\n          ["METHOD(", ["\'method(\'"]],\n          ["$METHOD(", ["\'$method(\'"]]\n        ]);\n        const tokenForHumans = (token2) => humanTokens.get(token2) || `\'${token2}\'`;\n        const parseError = function(rawMessage, details = {}, yy) {\n          if (details.recoverable) {\n            this.trace(rawMessage);\n          } else {\n            if (Array.isArray(details.inside)) {\n              const start = yy.lexer.offset - yy.lexer.match.length;\n              yy.lexer.setMatch(\n                start + details.inside[0],\n                start + details.inside[1]\n              );\n            }\n            const yylloc = yy.lexer.yylloc;\n            const message = [\n              rawMessage.split(/\\n/)[0],\n              "",\n              yy.lexer.showPosition()\n            ];\n            const expected = !Array.isArray(details.expected) ? null : [...new Set([].concat(\n              ...details.expected.map((token2) => tokenForHumans(token2.slice(1, -1)))\n            ))];\n            if (expected) {\n              message.push(\n                "",\n                "Expecting " + expected.join(", ") + " got " + tokenForHumans(details.token)\n              );\n            }\n            const error = new SyntaxError(message.join("\\n"));\n            error.details = {\n              rawMessage,\n              text: details.text,\n              token: details.token,\n              expected,\n              loc: {\n                range: yylloc.range,\n                start: {\n                  line: yylloc.first_line,\n                  column: yylloc.first_column,\n                  offset: yylloc.range[0]\n                },\n                end: {\n                  line: yylloc.last_line,\n                  column: yylloc.last_column,\n                  offset: yylloc.range[1]\n                }\n              }\n            };\n            throw error;\n          }\n        };\n        const lineTerminator = /* @__PURE__ */ new Set(["\\n", "\\r", "\\u2028", "\\u2029"]);\n        const literals = /* @__PURE__ */ new Map([\n          ["undefined", void 0],\n          ["null", null],\n          ["false", false],\n          ["true", true],\n          ["Infinity", Infinity],\n          ["NaN", NaN]\n        ]);\n        Object.assign(strictParser.lexer, {\n          ident: (value) => value.replace(/\\\\u[0-9a-fA-F]{4}/g, (m2) => String.fromCharCode(parseInt(m2.slice(2), 16))),\n          toLiteral: (value) => literals.get(value),\n          toStringLiteral(value, multiline = false, end = 1) {\n            const valueEnd = value.length - end;\n            let result = "";\n            for (let i = 1; i < valueEnd; i++) {\n              if (!multiline && lineTerminator.has(value[i])) {\n                this.parseError("Invalid line terminator", { inside: [i, i + 1] });\n              }\n              if (value[i] !== "\\\\") {\n                result += value[i];\n                continue;\n              }\n              if (i === valueEnd - 1) {\n                this.parseError("Invalid backslash", { inside: [i, i + 1] });\n              }\n              const next = value[++i];\n              switch (next) {\n                case "\\r":\n                  i += value[i + 1] === "\\n";\n                  break;\n                case "\\n":\n                case "\\u2028":\n                case "\\u2029":\n                  break;\n                case "0":\n                  result += "\\0";\n                  break;\n                case "b":\n                  result += "\\b";\n                  break;\n                case "n":\n                  result += "\\n";\n                  break;\n                case "r":\n                  result += "\\r";\n                  break;\n                case "f":\n                  result += "\\f";\n                  break;\n                case "t":\n                  result += "\t";\n                  break;\n                case "v":\n                  result += "\\v";\n                  break;\n                case "u": {\n                  const [hex = ""] = value.slice(i + 1, i + 5).match(/^[0-9a-f]*/i) || [];\n                  if (hex.length === 4) {\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    i += 4;\n                    break;\n                  }\n                  this.parseError("Invalid Unicode escape sequence", {\n                    inside: [i - 1, Math.min(i + 1 + hex.length, valueEnd)]\n                  });\n                  break;\n                }\n                case "x": {\n                  const [hex = ""] = value.slice(i + 1, i + 3).match(/^[0-9a-f]*/i) || [];\n                  if (hex.length === 2) {\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    i += 2;\n                    break;\n                  }\n                  this.parseError("Invalid hexadecimal escape sequence", {\n                    inside: [i - 1, Math.min(i + 1 + hex.length, valueEnd)]\n                  });\n                  break;\n                }\n                default:\n                  result += next;\n              }\n            }\n            return result;\n          },\n          toRegExp(value) {\n            const flagsIndex = value.lastIndexOf("/") + 1;\n            const flags = value.substr(flagsIndex);\n            flags.split("").forEach((flag, idx, array) => {\n              const duplicateIndex = array.indexOf(flag, idx + 1);\n              if (duplicateIndex !== -1) {\n                this.parseError("Duplicate flag in regexp", {\n                  inside: [flagsIndex + duplicateIndex, flagsIndex + duplicateIndex + 1]\n                });\n              }\n            });\n            return new RegExp(\n              value.substr(1, value.lastIndexOf("/") - 1),\n              flags\n            );\n          }\n        });\n        patch(strictParser.lexer, {\n          setInput: (origSetInput) => function(input, yy) {\n            const commentRanges = [];\n            yy.commentRanges = commentRanges;\n            yy.buildResult = (ast) => ({\n              ast,\n              commentRanges\n            });\n            yy.parseError = function(...args) {\n              return parseError.call(this, ...args, yy);\n            };\n            yy.pks = () => {\n              if (!this.eof()) {\n                this.begin("preventKeyword");\n              }\n            };\n            yy.pps = () => {\n              if (!this.eof()) {\n                this.begin("preventPrimitive");\n              }\n            };\n            this.bracketStack = [];\n            this.prevToken = null;\n            this.prevYylloc = {\n              first_line: 1,\n              last_line: 1,\n              first_column: 0,\n              last_column: 0,\n              range: [0, 0]\n            };\n            return origSetInput.call(this, input, yy);\n          }\n        });\n        const tolerantParser = new strictParser.Parser();\n        tolerantParser.lexer = { ...strictParser.lexer };\n        tolerantParser.yy = { ...strictParser.yy };\n        const keywords = [\n          "AND",\n          "OR",\n          "IN",\n          "NOTIN",\n          "HAS",\n          "HASNO",\n          "IS"\n        ];\n        const words = [...keywords, "NOT", "NO", "ORDER"];\n        const operators = [\n          "+",\n          "-",\n          "*",\n          "/",\n          "%",\n          "|",\n          "=",\n          "!=",\n          "~=",\n          ">=",\n          "<=",\n          "<",\n          ">"\n        ];\n        const prev = [\n          null,\n          "?",\n          ":",\n          ";",\n          ",",\n          ".",\n          "..",\n          "(",\n          ".(",\n          "..(",\n          "METHOD(",\n          "$METHOD(",\n          "[",\n          ".[",\n          "=>",\n          ...operators,\n          ...keywords,\n          "NOT",\n          "NO"\n        ];\n        const defaultNext = [\n          ",",\n          "?",\n          ":",\n          ";",\n          "EOF",\n          "]",\n          ")",\n          "}",\n          "TPL_CONTINUE",\n          "TPL_END",\n          ...operators,\n          ...keywords,\n          "ORDER"\n        ];\n        const tokenPair = new Map(prev.map((token2) => [token2, new Set(defaultNext)]));\n        for (const token2 of [".(", "..(", "METHOD(", "$METHOD("]) {\n          tokenPair.get(token2).delete(")");\n        }\n        for (const token2 of ["[", ".["]) {\n          tokenPair.get(token2).delete("]");\n        }\n        patch(tolerantParser.lexer, {\n          lex: (origLex) => function patchedLex() {\n            const prevOffset = this.offset;\n            const nextToken = origLex.call(this);\n            if (tokenPair.has(this.prevToken) && tokenPair.get(this.prevToken).has(nextToken)) {\n              const yylloc = {\n                first_line: this.prevYylloc.last_line,\n                last_line: this.yylloc.first_line,\n                first_column: this.prevYylloc.last_column,\n                last_column: this.yylloc.first_column,\n                range: [this.prevYylloc.range[1], this.yylloc.range[0]]\n              };\n              this.unput(this.match);\n              this.pushState("preventPrimitive");\n              this.done = false;\n              this.yytext = "";\n              this.yylloc = this.prevYylloc = yylloc;\n              if (prevOffset !== this.offset && words.includes(nextToken)) {\n                switch (this._input[prevOffset]) {\n                  case " ":\n                  case "\t":\n                    yylloc.last_column--;\n                    yylloc.range[1]--;\n                    break;\n                  case "\\n": {\n                    const lastN = this._input.lastIndexOf("\\n", prevOffset - 1);\n                    yylloc.last_line--;\n                    yylloc.last_column = lastN === -1 ? yylloc.last_column - 1 : prevOffset - lastN;\n                    yylloc.range[1]--;\n                    break;\n                  }\n                }\n              }\n              return this.prevToken = "IDENT";\n            }\n            this.prevYylloc = this.yylloc;\n            if (words.includes(nextToken)) {\n              switch (this._input[this.offset]) {\n                case " ":\n                case "\t":\n                  this.prevYylloc = {\n                    ...this.prevYylloc,\n                    last_column: this.prevYylloc.last_column + 1,\n                    range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]\n                  };\n                  break;\n                case "\\n":\n                  this.prevYylloc = {\n                    ...this.prevYylloc,\n                    last_line: this.prevYylloc.last_line + 1,\n                    last_column: 0,\n                    range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]\n                  };\n                  break;\n              }\n            }\n            return this.prevToken = nextToken;\n          }\n        });\n        const openBalance = /* @__PURE__ */ new Map([\n          ["(", ")"],\n          [".(", ")"],\n          ["..(", ")"],\n          ["METHOD(", ")"],\n          ["$METHOD(", ")"],\n          ["[", "]"],\n          [".[", "]"],\n          ["{", "}"],\n          ["TPL_START", "TPL_END"]\n        ]);\n        const closeBalance = /* @__PURE__ */ new Set([")", "]", "}", "TPL_END"]);\n        const balanceScopeLex = (origLex) => function patchedLex() {\n          const token2 = origLex.call(this);\n          if (closeBalance.has(token2)) {\n            const expected = this.bracketStack.pop();\n            if (expected !== token2) {\n              this.parseError(`Expected "${expected}" got "${token2}"`);\n            }\n          }\n          if (openBalance.has(token2)) {\n            this.bracketStack.push(openBalance.get(token2));\n          }\n          return token2;\n        };\n        patch(strictParser.lexer, {\n          lex: balanceScopeLex\n        });\n        patch(tolerantParser.lexer, {\n          lex: balanceScopeLex\n        });\n        return {\n          parse(source, tolerantMode) {\n            return tolerantMode ? tolerantParser.parse(source) : strictParser.parse(source);\n          },\n          *tokenize(source, tolerantMode, loc) {\n            const parser3 = tolerantMode ? tolerantParser : strictParser;\n            const lexer3 = Object.create(parser3.lexer);\n            lexer3.setInput(source, { parser: parser3 });\n            while (!lexer3.done) {\n              const token2 = {\n                type: lexer3.lex(),\n                value: lexer3.match,\n                offset: lexer3.yylloc.range[0]\n              };\n              if (loc) {\n                token2.loc = {\n                  range: lexer3.yylloc.range,\n                  start: {\n                    line: lexer3.yylloc.first_line,\n                    column: lexer3.yylloc.first_column\n                  },\n                  end: {\n                    line: lexer3.yylloc.last_line,\n                    column: lexer3.yylloc.last_column\n                  }\n                };\n              }\n              yield token2;\n            }\n          }\n        };\n      }(new Parser());\n      parse_default = parser;\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Arg1.js\n  var Arg1_exports = {};\n  __export(Arg1_exports, {\n    compile: () => compile,\n    stringify: () => stringify,\n    walk: () => walk\n  });\n  function compile(node, ctx) {\n    ctx.put(ctx.scope.arg1 ? "arguments[1]" : "undefined");\n  }\n  function walk() {\n  }\n  function stringify(node, ctx) {\n    ctx.put("$$");\n  }\n  var init_Arg1 = __esm({\n    "node_modules/jora/src/lang/nodes/Arg1.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Array.js\n  var Array_exports = {};\n  __export(Array_exports, {\n    compile: () => compile2,\n    stringify: () => stringify2,\n    suggest: () => suggest,\n    walk: () => walk2\n  });\n  function suggest(node, ctx) {\n    if (node.elements.length === 0) {\n      ctx.queryRoot(node.range[0] + 1, node.range[1] - 1);\n    }\n  }\n  function compile2(node, ctx) {\n    ctx.put("[");\n    ctx.list(node.elements, ",");\n    ctx.put("]");\n  }\n  function walk2(node, ctx) {\n    ctx.list(node.elements);\n  }\n  function stringify2(node, ctx) {\n    ctx.put("[");\n    ctx.list(node.elements, ",");\n    ctx.put("]");\n  }\n  var init_Array = __esm({\n    "node_modules/jora/src/lang/nodes/Array.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Assertion.js\n  var Assertion_exports = {};\n  __export(Assertion_exports, {\n    compile: () => compile3,\n    stringify: () => stringify3,\n    suggest: () => suggest2,\n    walk: () => walk3\n  });\n  function suggest2(node, ctx) {\n    if (!Array.isArray(node.assertion)) {\n      ctx.range(node.assertion.range, "var");\n      ctx.range(node.assertion.range, "assertion");\n    }\n  }\n  function compile3(node, ctx) {\n    if (Array.isArray(node.assertion)) {\n      ctx.put(node.negation ? "!(" : "(");\n      for (let i = 0; i < node.assertion.length; i++) {\n        if (i % 2 === 0) {\n          ctx.node(node.assertion[i]);\n        } else {\n          switch (node.assertion[i]) {\n            case "and":\n              ctx.put("&&");\n              break;\n            case "or":\n              ctx.put("||");\n              break;\n            default:\n              ctx.error("Bad conjuction operator in assertion", node);\n          }\n        }\n      }\n      ctx.put(")");\n    } else {\n      if (node.negation) {\n        ctx.put("!");\n      }\n      switch (node.assertion.type) {\n        case "Identifier":\n          if (node.assertion.name) {\n            ctx.put("!!");\n            if (ctx.tolerant) {\n              ctx.put("(typeof ");\n            }\n            ctx.put("a.");\n            ctx.put(node.assertion.name);\n            if (ctx.tolerant) {\n              ctx.put(\'==="function"?a.\');\n              ctx.put(node.assertion.name);\n            }\n            ctx.put(".call(mctx,");\n            ctx.nodeOrCurrent();\n            ctx.put(")");\n            if (ctx.tolerant) {\n              ctx.put(":false)");\n            }\n            if (ctx.usedAssertions.has(node.assertion.name)) {\n              ctx.usedAssertions.get(node.assertion.name).push(node.assertion.range);\n            } else {\n              ctx.usedAssertions.set(node.assertion.name, node.assertion.range);\n            }\n          } else {\n            ctx.put("false");\n          }\n          break;\n        case "Method":\n          ctx.put("!!");\n          ctx.node(node.assertion);\n          break;\n        default:\n          ctx.error(\'Unknown assertion node type "\' + node.assertion.type + \'"\', node.assertion);\n      }\n    }\n  }\n  function walk3(node, ctx) {\n    if (Array.isArray(node.assertion)) {\n      for (let i = 0; i < node.assertion.length; i++) {\n        if (i % 2 === 0) {\n          ctx.node(node.assertion[i]);\n        }\n      }\n    } else {\n      ctx.node(node.assertion);\n    }\n  }\n  function stringify3(node, ctx) {\n    if (node.negation) {\n      ctx.put("not ");\n    }\n    if (Array.isArray(node.assertion)) {\n      ctx.put("(");\n      for (let i = 0; i < node.assertion.length; i++) {\n        if (i % 2 === 0) {\n          ctx.node(node.assertion[i]);\n        } else {\n          ctx.put(" ");\n          ctx.put(node.assertion[i]);\n          ctx.put(" ");\n        }\n      }\n      ctx.put(")");\n    } else {\n      ctx.node(node.assertion);\n    }\n  }\n  var init_Assertion = __esm({\n    "node_modules/jora/src/lang/nodes/Assertion.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Binary.js\n  var Binary_exports = {};\n  __export(Binary_exports, {\n    compile: () => compile4,\n    stringify: () => stringify4,\n    suggest: () => suggest3,\n    walk: () => walk4\n  });\n  function valueSubset(ctx, values, dict) {\n    if (dict.type === "Array") {\n      if (dict.elements.length === 0) {\n        ctx.range([dict.range[0] + 1, dict.range[1] - 1], "value-subset", values, false);\n        return;\n      }\n      const excludeValues = [];\n      for (const { type, range, value } of dict.elements) {\n        if (range && (type === "Literal" || type === "Identifier")) {\n          excludeValues.push(value);\n        }\n      }\n      const related = excludeValues.length ? ctx.literalList(excludeValues) : false;\n      for (const { type, range, value } of dict.elements) {\n        if (range) {\n          if (type === "Literal" || type === "Identifier" || type === "GetProperty" && value === null) {\n            ctx.range(range, "value-subset", values, related);\n          }\n        }\n      }\n    }\n  }\n  function suggest3(node, ctx) {\n    switch (node.operator) {\n      case "in":\n        ctx.range(node.left.range, "in-value", node.right, null);\n        valueSubset(ctx, node.left, node.right);\n        break;\n      case "not in":\n        valueSubset(ctx, node.left, node.right);\n        break;\n      case "has":\n        ctx.range(node.right.range, "in-value", node.left, null);\n        valueSubset(ctx, node.right, node.left);\n        break;\n      case "has no":\n        valueSubset(ctx, node.right, node.left);\n        break;\n      case "=":\n      case "!=":\n        ctx.range(node.right.range, "value", node.left, null);\n        break;\n    }\n  }\n  function compile4(node, ctx) {\n    if (node.operator in binary === false) {\n      ctx.error(\'Unknown operator "\' + node.operator + \'"\', node);\n      return;\n    }\n    switch (node.operator) {\n      case "and":\n        ctx.put("!");\n      case "or": {\n        const tmpVar = ctx.allocateVar();\n        ctx.put(`${ctx.buildinFn("bool")}(${tmpVar}=`);\n        ctx.node(node.left);\n        ctx.put(`)?${tmpVar}:`);\n        ctx.scope.captureCurrent.disabled = true;\n        ctx.node(node.right);\n        ctx.scope.captureCurrent.disabled = false;\n        break;\n      }\n      case "??": {\n        const tmpVar = ctx.allocateVar();\n        ctx.put(`(${tmpVar}=`);\n        ctx.node(node.left);\n        ctx.put(`,${tmpVar}!==null&&${tmpVar}!==undefined)?${tmpVar}:`);\n        ctx.scope.captureCurrent.disabled = true;\n        ctx.node(node.right);\n        ctx.scope.captureCurrent.disabled = false;\n        break;\n      }\n      case "has no":\n        ctx.put("!");\n      case "has":\n        ctx.put(ctx.buildinFn("in"));\n        ctx.put("(");\n        ctx.node(node.right);\n        ctx.put(",");\n        ctx.node(node.left);\n        ctx.put(")");\n        break;\n      default:\n        ctx.put(ctx.buildinFn(binary[node.operator]));\n        ctx.put("(");\n        ctx.node(node.left);\n        ctx.put(",");\n        ctx.node(node.right);\n        ctx.put(")");\n    }\n  }\n  function walk4(node, ctx) {\n    ctx.node(node.left);\n    ctx.node(node.right);\n  }\n  function stringify4(node, ctx) {\n    ctx.node(node.left);\n    if (/^[a-z]/i.test(node.operator)) {\n      ctx.put(" ");\n      ctx.put(node.operator);\n      ctx.put(" ");\n    } else {\n      ctx.put(node.operator);\n    }\n    ctx.node(node.right);\n  }\n  var binary;\n  var init_Binary = __esm({\n    "node_modules/jora/src/lang/nodes/Binary.js"() {\n      binary = {\n        "in": "in",\n        "not in": "notIn",\n        "has": "has",\n        "has no": "hasNo",\n        "and": "and",\n        "or": "or",\n        "??": "nullish",\n        "+": "add",\n        "-": "sub",\n        "*": "mul",\n        "/": "div",\n        "%": "mod",\n        "=": "eq",\n        "!=": "ne",\n        "<": "lt",\n        "<=": "lte",\n        ">": "gt",\n        ">=": "gte",\n        "~=": "match"\n      };\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Block.js\n  var Block_exports = {};\n  __export(Block_exports, {\n    compile: () => compile5,\n    stringify: () => stringify5,\n    suggest: () => suggest4,\n    walk: () => walk5\n  });\n  function suggest4(node, ctx) {\n    if (node.body === null) {\n      ctx.queryRoot(node.range[1]);\n    }\n  }\n  function compile5(node, ctx) {\n    if (node.definitions.length) {\n      ctx.createScope(\n        () => {\n          ctx.put("(()=>{");\n          ctx.list(node.definitions);\n          ctx.put("return ");\n          ctx.nodeOrCurrent(node.body);\n          ctx.put("})()");\n        },\n        (scopeStart, sp) => {\n          return scopeStart + sp + ";";\n        },\n        ctx.scope.$ref\n      );\n    } else if (node.body && node.body.type === "Object") {\n      ctx.put("(");\n      ctx.nodeOrCurrent(node.body);\n      ctx.put(")");\n    } else {\n      ctx.nodeOrCurrent(node.body);\n    }\n  }\n  function walk5(node, ctx) {\n    ctx.list(node.definitions);\n    ctx.nodeOrNothing(node.body);\n  }\n  function stringify5(node, ctx) {\n    ctx.list(node.definitions);\n    ctx.nodeOrNothing(node.body);\n  }\n  var init_Block = __esm({\n    "node_modules/jora/src/lang/nodes/Block.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Compare.js\n  var Compare_exports = {};\n  __export(Compare_exports, {\n    compile: () => compile6,\n    stringify: () => stringify6,\n    walk: () => walk6\n  });\n  function compile6(node, ctx) {\n    if (node.order.startsWith("desc")) {\n      ctx.put("-");\n    }\n    ctx.createScope(\n      () => {\n        const cmpFn = comparator[node.order.slice(3 + node.order.startsWith("desc"))] || comparator[""];\n        ctx.put(ctx.buildinFn(cmpFn));\n        ctx.put("((_q=$=>(");\n        ctx.node(node.query);\n        ctx.put("))(a),_q(b))");\n      },\n      (scopeStart, sp) => {\n        return scopeStart + sp + ",";\n      }\n    );\n  }\n  function walk6(node, ctx) {\n    ctx.node(node.query);\n  }\n  function stringify6(node, ctx) {\n    ctx.node(node.query);\n    ctx.put(" ");\n    ctx.put(node.order);\n  }\n  var comparator;\n  var init_Compare = __esm({\n    "node_modules/jora/src/lang/nodes/Compare.js"() {\n      comparator = {\n        "": "cmp",\n        "N": "cmpNatural",\n        "A": "cmpAnalytical",\n        "NA": "cmpNaturalAnalytical",\n        "AN": "cmpNaturalAnalytical"\n      };\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/CompareFunction.js\n  var CompareFunction_exports = {};\n  __export(CompareFunction_exports, {\n    compile: () => compile7,\n    stringify: () => stringify7,\n    walk: () => walk7\n  });\n  function compile7(node, ctx) {\n    ctx.put("(a, b)=>{let _q;return ");\n    ctx.list(node.compares, "||");\n    ctx.put("||0}");\n  }\n  function walk7(node, ctx) {\n    ctx.list(node.compares);\n  }\n  function stringify7(node, ctx) {\n    ctx.list(node.compares, ",");\n  }\n  var init_CompareFunction = __esm({\n    "node_modules/jora/src/lang/nodes/CompareFunction.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Conditional.js\n  var Conditional_exports = {};\n  __export(Conditional_exports, {\n    compile: () => compile8,\n    stringify: () => stringify8,\n    walk: () => walk8\n  });\n  function compile8(node, ctx) {\n    ctx.put(ctx.buildinFn("bool"));\n    ctx.put("(");\n    ctx.scope.captureCurrent.disabled = true;\n    ctx.nodeOrCurrent(node.test);\n    ctx.put(")?");\n    ctx.nodeOrCurrent(node.consequent);\n    ctx.put(":");\n    if (node.alternate) {\n      ctx.node(node.alternate);\n    } else {\n      ctx.put("undefined");\n    }\n    ctx.scope.captureCurrent.disabled = false;\n  }\n  function walk8(node, ctx) {\n    ctx.nodeOrNothing(node.test);\n    ctx.nodeOrNothing(node.consequent);\n    ctx.nodeOrNothing(node.alternate);\n  }\n  function stringify8(node, ctx) {\n    ctx.nodeOrNothing(node.test);\n    ctx.put("?");\n    ctx.nodeOrNothing(node.consequent);\n    if (node.alternate) {\n      ctx.put(":");\n      ctx.node(node.alternate);\n    }\n  }\n  var init_Conditional = __esm({\n    "node_modules/jora/src/lang/nodes/Conditional.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Context.js\n  var Context_exports = {};\n  __export(Context_exports, {\n    compile: () => compile9,\n    stringify: () => stringify9,\n    walk: () => walk9\n  });\n  function compile9(node, ctx) {\n    ctx.put("context");\n  }\n  function walk9() {\n  }\n  function stringify9(node, ctx) {\n    ctx.put("#");\n  }\n  var init_Context = __esm({\n    "node_modules/jora/src/lang/nodes/Context.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Current.js\n  var Current_exports = {};\n  __export(Current_exports, {\n    compile: () => compile10,\n    stringify: () => stringify10,\n    suggest: () => suggest5,\n    walk: () => walk10\n  });\n  function suggest5(node, ctx) {\n    if (node.range) {\n      ctx.range(node.range, "var");\n    }\n  }\n  function compile10(node, ctx) {\n    ctx.put(ctx.scope.$ref);\n  }\n  function walk10() {\n  }\n  function stringify10(node, ctx) {\n    ctx.put("$");\n  }\n  var init_Current = __esm({\n    "node_modules/jora/src/lang/nodes/Current.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Data.js\n  var Data_exports = {};\n  __export(Data_exports, {\n    compile: () => compile11,\n    stringify: () => stringify11,\n    walk: () => walk11\n  });\n  function compile11(node, ctx) {\n    ctx.put("data");\n  }\n  function walk11() {\n  }\n  function stringify11(node, ctx) {\n    ctx.put("@");\n  }\n  var init_Data = __esm({\n    "node_modules/jora/src/lang/nodes/Data.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Declarator.js\n  var Declarator_exports = {};\n  __export(Declarator_exports, {\n    compile: () => compile12,\n    stringify: () => stringify12,\n    walk: () => walk12\n  });\n  function compile12(node, ctx) {\n    if (node.name) {\n      ctx.put("$" + node.name);\n    }\n  }\n  function walk12() {\n  }\n  function stringify12(node, ctx) {\n    ctx.put(node.name ? "$" + node.name : "$");\n  }\n  var init_Declarator = __esm({\n    "node_modules/jora/src/lang/nodes/Declarator.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/build.js\n  function GetProperty(value, property) {\n    return {\n      type: "GetProperty",\n      value,\n      property\n    };\n  }\n  function Identifier(name) {\n    return {\n      type: "Identifier",\n      name\n    };\n  }\n  var init_build = __esm({\n    "node_modules/jora/src/lang/build.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Definition.js\n  var Definition_exports = {};\n  __export(Definition_exports, {\n    compile: () => compile13,\n    stringify: () => stringify13,\n    suggest: () => suggest6,\n    walk: () => walk13\n  });\n  function suggest6(node, ctx) {\n    if (node.value === null) {\n      ctx.range(node.declarator.range, "path");\n    }\n  }\n  function compile13(node, ctx) {\n    if (node.declarator.name === null) {\n      ctx.node(node.declarator);\n      ctx.nodeOrCurrent(node.value);\n      ctx.put(";");\n      return;\n    }\n    if (ctx.scope.own.includes(node.declarator.name)) {\n      ctx.error(`Identifier "$${node.declarator.name}" has already been declared`, node.declarator);\n      return;\n    }\n    if (reservedVars.includes(node.declarator.name)) {\n      ctx.error(`Identifier "$${node.declarator.name}" is reserved for future use`, node.declarator);\n      return;\n    }\n    ctx.put("const ");\n    ctx.node(node.declarator);\n    ctx.put("=");\n    ctx.node(node.value || GetProperty(null, Identifier(node.declarator.name)));\n    ctx.put(";");\n    ctx.scope.push(node.declarator.name);\n    ctx.scope.own.push(node.declarator.name);\n  }\n  function walk13(node, ctx) {\n    ctx.node(node.declarator);\n    ctx.nodeOrNothing(node.value);\n  }\n  function stringify13(node, ctx) {\n    ctx.node(node.declarator);\n    if (node.value !== null) {\n      ctx.put(":");\n      ctx.node(node.value);\n    }\n    ctx.put(";");\n  }\n  var reservedVars;\n  var init_Definition = __esm({\n    "node_modules/jora/src/lang/nodes/Definition.js"() {\n      init_build();\n      reservedVars = ["data", "context", "ctx", "array", "idx", "index"];\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Filter.js\n  var Filter_exports = {};\n  __export(Filter_exports, {\n    compile: () => compile14,\n    stringify: () => stringify14,\n    walk: () => walk14\n  });\n  function compile14(node, ctx) {\n    ctx.put(ctx.buildinFn("filter"));\n    ctx.put("(");\n    ctx.nodeOrCurrent(node.value);\n    ctx.createScope(\n      () => {\n        ctx.put(",$=>");\n        ctx.node(node.query);\n      },\n      (scopeStart, sp) => {\n        ctx.put(")");\n        return scopeStart + "(" + sp + ",";\n      }\n    );\n    ctx.put(")");\n  }\n  function walk14(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.node(node.query);\n  }\n  function stringify14(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.put(".[");\n    ctx.node(node.query);\n    ctx.put("]");\n  }\n  var init_Filter = __esm({\n    "node_modules/jora/src/lang/nodes/Filter.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Function.js\n  var Function_exports = {};\n  __export(Function_exports, {\n    compile: () => compile15,\n    stringify: () => stringify15,\n    walk: () => walk15\n  });\n  function compile15(node, ctx) {\n    ctx.createScope(\n      () => {\n        const args = node.arguments.map((arg) => "$" + arg.name);\n        ctx.scope.arg1 = true;\n        ctx.scope.$ref = args[0] || "$";\n        for (const arg of node.arguments) {\n          ctx.scope.push(arg.name);\n        }\n        ctx.put("function(");\n        ctx.put(String(args) || "$");\n        ctx.put("){return ");\n        ctx.node(node.body);\n        ctx.put("}");\n      },\n      (scopeStart, sp) => {\n        return scopeStart + sp + ",";\n      }\n    );\n  }\n  function walk15(node, ctx) {\n    ctx.node(node.body);\n  }\n  function stringify15(node, ctx) {\n    ctx.put("=>");\n    ctx.node(node.body);\n  }\n  var init_Function = __esm({\n    "node_modules/jora/src/lang/nodes/Function.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/GetProperty.js\n  var GetProperty_exports = {};\n  __export(GetProperty_exports, {\n    compile: () => compile16,\n    stringify: () => stringify16,\n    suggest: () => suggest7,\n    walk: () => walk16\n  });\n  function suggest7(node, ctx) {\n    ctx.range(node.property.range, "path", node.value || void 0, !node.value);\n    if (node.value === null) {\n      ctx.range(node.property.range, "var");\n    }\n    if (node.range && node.value === null && node.property.range[0] !== node.range[0]) {\n      ctx.queryRoot(node.range[0]);\n    }\n  }\n  function compile16(node, ctx) {\n    ctx.put(ctx.buildinFn("map"));\n    ctx.put("(");\n    ctx.nodeOrCurrent(node.value);\n    ctx.put(",");\n    if (node.property.type === "Identifier") {\n      ctx.put(JSON.stringify(node.property.name));\n    } else {\n      ctx.node(node.property);\n    }\n    ctx.put(")");\n  }\n  function walk16(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.node(node.property);\n  }\n  function stringify16(node, ctx) {\n    ctx.nodeOrNothing(node.value) && ctx.put(".");\n    ctx.node(node.property);\n  }\n  var init_GetProperty = __esm({\n    "node_modules/jora/src/lang/nodes/GetProperty.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Identifier.js\n  var Identifier_exports = {};\n  __export(Identifier_exports, {\n    compile: () => compile17,\n    stringify: () => stringify17,\n    walk: () => walk17\n  });\n  function compile17(node, ctx) {\n    ctx.put(node.name);\n  }\n  function walk17() {\n  }\n  function stringify17(node, ctx) {\n    ctx.put(node.name);\n  }\n  var init_Identifier = __esm({\n    "node_modules/jora/src/lang/nodes/Identifier.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Literal.js\n  var Literal_exports = {};\n  __export(Literal_exports, {\n    compile: () => compile18,\n    stringify: () => stringify18,\n    walk: () => walk18\n  });\n  function compile18(node, ctx) {\n    ctx.put(typeof node.value === "string" ? JSON.stringify(node.value) : String(node.value));\n  }\n  function walk18() {\n  }\n  function stringify18(node, ctx) {\n    ctx.put(\n      typeof node.value === "string" ? JSON.stringify(node.value) : String(node.value)\n    );\n  }\n  var init_Literal = __esm({\n    "node_modules/jora/src/lang/nodes/Literal.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Map.js\n  var Map_exports = {};\n  __export(Map_exports, {\n    compile: () => compile19,\n    stringify: () => stringify19,\n    walk: () => walk19\n  });\n  function compile19(node, ctx) {\n    ctx.put(ctx.buildinFn("map"));\n    ctx.put("(");\n    ctx.nodeOrCurrent(node.value);\n    ctx.createScope(\n      () => {\n        ctx.put(",$=>");\n        ctx.node(node.query);\n      },\n      (scopeStart, sp) => {\n        ctx.put(")");\n        return scopeStart + "(" + sp + ",";\n      }\n    );\n    ctx.put(")");\n  }\n  function walk19(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.node(node.query);\n  }\n  function stringify19(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.put(".(");\n    ctx.node(node.query);\n    ctx.put(")");\n  }\n  var init_Map = __esm({\n    "node_modules/jora/src/lang/nodes/Map.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/MapRecursive.js\n  var MapRecursive_exports = {};\n  __export(MapRecursive_exports, {\n    compile: () => compile20,\n    stringify: () => stringify20,\n    walk: () => walk20\n  });\n  function compile20(node, ctx) {\n    ctx.put(ctx.buildinFn("mapRecursive"));\n    ctx.put("(");\n    ctx.nodeOrCurrent(node.value);\n    ctx.createScope(\n      () => {\n        ctx.put(",$=>");\n        ctx.node(node.query);\n      },\n      (scopeStart, sp) => {\n        ctx.put(")");\n        return scopeStart + "(" + sp + ",";\n      }\n    );\n    ctx.put(")");\n  }\n  function walk20(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.node(node.query);\n  }\n  function stringify20(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.put("..");\n    if (ctx.isSimpleGetPropertyQuery(node.query) || ctx.isSimpleMethodCallQuery(node.query)) {\n      ctx.node(node.query);\n    } else {\n      ctx.put("(");\n      ctx.node(node.query);\n      ctx.put(")");\n    }\n  }\n  var init_MapRecursive = __esm({\n    "node_modules/jora/src/lang/nodes/MapRecursive.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Method.js\n  var Method_exports = {};\n  __export(Method_exports, {\n    compile: () => compile21,\n    stringify: () => stringify21,\n    suggest: () => suggest8,\n    walk: () => walk21\n  });\n  function suggest8(node, ctx) {\n    if (node.arguments.length === 0) {\n      ctx.queryRoot(node.range[1] - 1);\n    }\n  }\n  function compile21(node, ctx, relatedNode) {\n    const dictMethod = node.reference.type === "Identifier";\n    if (ctx.tolerant) {\n      ctx.put("(typeof ");\n    }\n    if (dictMethod) {\n      if (ctx.usedMethods.has(node.reference.name)) {\n        ctx.usedMethods.get(node.reference.name).push(node.reference.range);\n      } else {\n        ctx.usedMethods.set(node.reference.name, [node.reference.range]);\n      }\n      ctx.put("m.");\n    }\n    ctx.node(node.reference);\n    if (ctx.tolerant) {\n      ctx.put(\'==="function"?\');\n      if (dictMethod) {\n        ctx.put("m.");\n      }\n      ctx.node(node.reference);\n    }\n    ctx.put(dictMethod ? ".call(mctx," : "(");\n    ctx.nodeOrCurrent(relatedNode);\n    if (node.arguments.length) {\n      ctx.put(",");\n      ctx.list(node.arguments, ",");\n    }\n    ctx.put(")");\n    if (ctx.tolerant) {\n      ctx.put(":undefined)");\n    }\n  }\n  function walk21(node, ctx) {\n    ctx.node(node.reference);\n    ctx.list(node.arguments);\n  }\n  function stringify21(node, ctx) {\n    ctx.node(node.reference);\n    ctx.put("(");\n    ctx.list(node.arguments, ",");\n    ctx.put(")");\n  }\n  var init_Method = __esm({\n    "node_modules/jora/src/lang/nodes/Method.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/MethodCall.js\n  var MethodCall_exports = {};\n  __export(MethodCall_exports, {\n    compile: () => compile22,\n    stringify: () => stringify22,\n    walk: () => walk22\n  });\n  function compile22(node, ctx) {\n    ctx.node(node.method, node.value);\n  }\n  function walk22(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    ctx.node(node.method);\n  }\n  function stringify22(node, ctx) {\n    ctx.nodeOrNothing(node.value) && ctx.put(".");\n    ctx.node(node.method);\n  }\n  var init_MethodCall = __esm({\n    "node_modules/jora/src/lang/nodes/MethodCall.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Object.js\n  var Object_exports = {};\n  __export(Object_exports, {\n    compile: () => compile23,\n    stringify: () => stringify23,\n    suggest: () => suggest9,\n    walk: () => walk23\n  });\n  function suggest9(node, ctx) {\n    if (node.properties.length === 0) {\n      ctx.queryRoot(node.range[0] + 1, node.range[1] - 1);\n    }\n  }\n  function compile23(node, ctx) {\n    ctx.put("{");\n    ctx.list(node.properties, ",");\n    ctx.put("}");\n  }\n  function walk23(node, ctx) {\n    ctx.list(node.properties);\n  }\n  function stringify23(node, ctx) {\n    ctx.put("{");\n    ctx.list(node.properties, ",");\n    ctx.put("}");\n  }\n  var init_Object = __esm({\n    "node_modules/jora/src/lang/nodes/Object.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/ObjectEntry.js\n  var ObjectEntry_exports = {};\n  __export(ObjectEntry_exports, {\n    compile: () => compile24,\n    stringify: () => stringify24,\n    suggest: () => suggest10,\n    walk: () => walk24\n  });\n  function suggest10(node, ctx) {\n    if (node.value === null) {\n      switch (node.key.type) {\n        case "Literal":\n        case "Identifier":\n          ctx.range(node.range, "path");\n          ctx.range(node.range, "var");\n          break;\n        case "Current":\n        case "Reference":\n          ctx.range(node.range, "var");\n          break;\n      }\n    }\n  }\n  function compile24(node, ctx) {\n    let value = node.value;\n    switch (node.key.type) {\n      case "Current":\n        ctx.put("...null");\n        return;\n      case "Literal":\n        ctx.node(node.key);\n        value = value || GetProperty(null, Identifier(String(node.key.value)));\n        break;\n      case "Identifier":\n        ctx.node(node.key);\n        value = value || GetProperty(null, Identifier(node.key.name));\n        break;\n      case "Reference":\n        ctx.node(node.key.name);\n        value = value || node.key;\n        break;\n      default:\n        ctx.put("[");\n        ctx.node(node.key);\n        ctx.put("]");\n    }\n    ctx.put(":");\n    ctx.node(value);\n  }\n  function walk24(node, ctx) {\n    ctx.node(node.key);\n    ctx.nodeOrNothing(node.value);\n  }\n  function stringify24(node, ctx) {\n    if (noBracketKeyType.has(node.key.type)) {\n      ctx.node(node.key);\n      if (node.value === null) {\n        return;\n      }\n    } else {\n      ctx.put("[");\n      ctx.node(node.key);\n      ctx.put("]");\n    }\n    ctx.put(":");\n    ctx.node(node.value);\n  }\n  var noBracketKeyType;\n  var init_ObjectEntry = __esm({\n    "node_modules/jora/src/lang/nodes/ObjectEntry.js"() {\n      init_build();\n      noBracketKeyType = /* @__PURE__ */ new Set([\n        "Literal",\n        "Identifier",\n        "Reference",\n        "Current"\n      ]);\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Parentheses.js\n  var Parentheses_exports = {};\n  __export(Parentheses_exports, {\n    compile: () => compile25,\n    stringify: () => stringify25,\n    walk: () => walk25\n  });\n  function compile25(node, ctx) {\n    ctx.put("(");\n    ctx.node(node.body);\n    ctx.put(")");\n  }\n  function walk25(node, ctx) {\n    ctx.node(node.body);\n  }\n  function stringify25(node, ctx) {\n    ctx.put("(");\n    ctx.node(node.body);\n    ctx.put(")");\n  }\n  var init_Parentheses = __esm({\n    "node_modules/jora/src/lang/nodes/Parentheses.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Pick.js\n  var Pick_exports = {};\n  __export(Pick_exports, {\n    compile: () => compile26,\n    stringify: () => stringify26,\n    suggest: () => suggest11,\n    walk: () => walk26\n  });\n  function suggest11(node, ctx) {\n    if (node.getter === null) {\n      const pos = node.range[1] - 1;\n      ctx.range([pos, pos], "key", node.value, false);\n      ctx.queryRoot(pos);\n    } else if (node.getter.type === "GetProperty" || node.getter.type === "Reference" || node.getter.type === "Literal" && typeof node.getter.value === "string") {\n      ctx.range(node.getter.range, "key", node.value, false);\n    }\n  }\n  function compile26(node, ctx) {\n    ctx.put(ctx.buildinFn("pick"));\n    ctx.put("(");\n    ctx.node(node.value);\n    if (node.getter) {\n      ctx.put(",");\n      ctx.node(node.getter);\n    }\n    ctx.put(")");\n  }\n  function walk26(node, ctx) {\n    ctx.node(node.value);\n    if (node.getter !== null) {\n      ctx.node(node.getter);\n    }\n  }\n  function stringify26(node, ctx) {\n    ctx.node(node.value);\n    ctx.put("[");\n    if (node.getter !== null) {\n      ctx.node(node.getter);\n    }\n    ctx.put("]");\n  }\n  var init_Pick = __esm({\n    "node_modules/jora/src/lang/nodes/Pick.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Pipeline.js\n  var Pipeline_exports = {};\n  __export(Pipeline_exports, {\n    compile: () => compile27,\n    stringify: () => stringify27,\n    walk: () => walk27\n  });\n  function compile27(node, ctx) {\n    ctx.createScope(\n      () => {\n        ctx.put("($=>(");\n        ctx.node(node.right);\n        ctx.put("))");\n      },\n      (scopeStart, sp) => {\n        return scopeStart + sp + ",";\n      }\n    );\n    ctx.put("(");\n    ctx.nodeOrCurrent(node.left);\n    ctx.put(")");\n  }\n  function walk27(node, ctx) {\n    ctx.node(node.left);\n    ctx.node(node.right);\n  }\n  function stringify27(node, ctx) {\n    ctx.node(node.left);\n    ctx.put("|");\n    ctx.node(node.right);\n  }\n  var init_Pipeline = __esm({\n    "node_modules/jora/src/lang/nodes/Pipeline.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Placeholder.js\n  var Placeholder_exports = {};\n  __export(Placeholder_exports, {\n    compile: () => compile28,\n    stringify: () => stringify28,\n    suggest: () => suggest12,\n    walk: () => walk28\n  });\n  function suggest12(node, ctx) {\n    ctx.queryRoot(node.range[1]);\n  }\n  function compile28(node, ctx) {\n    ctx.put(ctx.scope.$ref);\n  }\n  function walk28() {\n  }\n  function stringify28() {\n  }\n  var init_Placeholder = __esm({\n    "node_modules/jora/src/lang/nodes/Placeholder.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Postfix.js\n  var Postfix_exports = {};\n  __export(Postfix_exports, {\n    compile: () => compile29,\n    stringify: () => stringify29,\n    walk: () => walk29\n  });\n  function compile29(node, ctx) {\n    if (node.operator && node.operator.type) {\n      ctx.createScope(\n        () => {\n          ctx.put("($=>(");\n          ctx.node(node.operator);\n          ctx.put("))");\n        },\n        (scopeStart, sp) => {\n          return scopeStart + sp + ",";\n        }\n      );\n      ctx.put("(");\n      ctx.node(node.argument);\n      ctx.put(")");\n      return;\n    }\n    switch (node.operator) {\n      default: {\n        ctx.error(\'Unknown operator "\' + node.operator + \'"\', node);\n      }\n    }\n  }\n  function walk29(node, ctx) {\n    ctx.node(node.argument);\n    if (node.operator && node.operator.type) {\n      ctx.node(node.operator);\n    }\n  }\n  function stringify29(node, ctx) {\n    ctx.node(node.argument);\n    ctx.put(" ");\n    ctx.node(node.operator);\n  }\n  var init_Postfix = __esm({\n    "node_modules/jora/src/lang/nodes/Postfix.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Prefix.js\n  var Prefix_exports = {};\n  __export(Prefix_exports, {\n    compile: () => compile30,\n    stringify: () => stringify30,\n    walk: () => walk30\n  });\n  function compile30(node, ctx) {\n    switch (node.operator) {\n      case "no":\n      case "not":\n        ctx.put("!");\n        ctx.put(ctx.buildinFn("bool"));\n        ctx.put("(");\n        ctx.node(node.argument);\n        ctx.put(")");\n        break;\n      case "+":\n      case "-":\n        ctx.put(node.operator);\n        ctx.node(node.argument);\n        break;\n      case "is":\n        ctx.put("!!(");\n        ctx.node(node.argument);\n        ctx.put(")");\n        break;\n      default: {\n        ctx.error(\'Unknown operator "\' + node.operator + \'"\', node);\n      }\n    }\n  }\n  function walk30(node, ctx) {\n    ctx.node(node.argument);\n    if (node.operator && node.operator.type) {\n      ctx.node(node.operator);\n    }\n  }\n  function stringify30(node, ctx) {\n    ctx.put(node.operator);\n    if (node.operator !== "-" && node.operator !== "+") {\n      ctx.put(" ");\n    }\n    ctx.node(node.argument);\n  }\n  var init_Prefix = __esm({\n    "node_modules/jora/src/lang/nodes/Prefix.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Reference.js\n  var Reference_exports = {};\n  __export(Reference_exports, {\n    compile: () => compile31,\n    stringify: () => stringify31,\n    suggest: () => suggest13,\n    walk: () => walk31\n  });\n  function suggest13(node, ctx) {\n    if (node.range) {\n      ctx.range(node.range, "var");\n    }\n  }\n  function compile31(node, ctx) {\n    if (!ctx.scope.includes(node.name.name) && ctx.tolerant) {\n      ctx.put("(typeof $");\n      ctx.node(node.name);\n      ctx.put(\'!=="undefined"?$\');\n      ctx.node(node.name);\n      ctx.put(":undefined)");\n      return;\n    }\n    ctx.put("$");\n    ctx.node(node.name);\n  }\n  function walk31(node, ctx) {\n    ctx.node(node.name);\n  }\n  function stringify31(node, ctx) {\n    ctx.put("$");\n    ctx.node(node.name);\n  }\n  var init_Reference = __esm({\n    "node_modules/jora/src/lang/nodes/Reference.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/SliceNotation.js\n  var SliceNotation_exports = {};\n  __export(SliceNotation_exports, {\n    compile: () => compile32,\n    stringify: () => stringify32,\n    walk: () => walk32\n  });\n  function compile32(node, ctx) {\n    ctx.put(ctx.buildinFn("slice"));\n    ctx.put("(");\n    ctx.nodeOrCurrent(node.value);\n    node.arguments.slice(0, 3).forEach((item) => {\n      ctx.put(",");\n      item ? ctx.node(item) : ctx.put("undefined");\n    });\n    ctx.put(")");\n  }\n  function walk32(node, ctx) {\n    ctx.nodeOrNothing(node.value);\n    for (const arg of node.arguments.slice(0, 3)) {\n      if (arg) {\n        ctx.node(arg);\n      }\n    }\n  }\n  function stringify32(node, ctx) {\n    const [a, b2, c] = node.arguments;\n    ctx.nodeOrNothing(node.value);\n    ctx.put("[");\n    if (a) {\n      ctx.node(a);\n    }\n    ctx.put(":");\n    if (b2) {\n      ctx.node(b2);\n    }\n    if (c) {\n      ctx.put(":");\n      ctx.node(c);\n    }\n    ctx.put("]");\n  }\n  var init_SliceNotation = __esm({\n    "node_modules/jora/src/lang/nodes/SliceNotation.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Spread.js\n  var Spread_exports = {};\n  __export(Spread_exports, {\n    compile: () => compile33,\n    stringify: () => stringify33,\n    suggest: () => suggest14,\n    walk: () => walk33\n  });\n  function suggest14(node, ctx) {\n    if (node.query === null) {\n      ctx.queryRoot(node.range[1]);\n    }\n  }\n  function compile33(node, ctx) {\n    if (node.array) {\n      ctx.put("...");\n      ctx.put(ctx.buildinFn("ensureArray"));\n      ctx.put("(");\n      ctx.nodeOrCurrent(node.query);\n      ctx.put(")");\n      return;\n    }\n    ctx.put("...");\n    ctx.nodeOrCurrent(node.query);\n  }\n  function walk33(node, ctx) {\n    ctx.nodeOrNothing(node.query);\n  }\n  function stringify33(node, ctx) {\n    ctx.put("...");\n    ctx.nodeOrNothing(node.query);\n  }\n  var init_Spread = __esm({\n    "node_modules/jora/src/lang/nodes/Spread.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/Template.js\n  var Template_exports = {};\n  __export(Template_exports, {\n    compile: () => compile34,\n    stringify: () => stringify34,\n    suggest: () => suggest15,\n    walk: () => walk34\n  });\n  function suggest15(node, ctx) {\n    for (const [idx, v2] of Object.entries(node.values)) {\n      if (v2 === null) {\n        ctx.queryRoot(node.values[Number(idx) - 1].range[1]);\n      }\n    }\n  }\n  function compile34(node, ctx) {\n    for (const [k2, v2] of Object.entries(node.values)) {\n      const idx = Number(k2);\n      if (v2 === null) {\n        continue;\n      }\n      if (idx !== 0) {\n        ctx.put("+");\n      }\n      if (idx % 2 === 0) {\n        ctx.put(\'"\' + encodeString(v2.value, compileEscape) + \'"\');\n      } else {\n        ctx.put("(");\n        ctx.node(v2);\n        ctx.put(")");\n      }\n    }\n  }\n  function walk34(node, ctx) {\n    for (const v2 of node.values) {\n      if (v2 !== null) {\n        ctx.node(v2);\n      }\n    }\n  }\n  function stringify34(node, ctx) {\n    const lastIdx = node.values.length - 1;\n    for (const [k2, v2] of Object.entries(node.values)) {\n      const idx = Number(k2);\n      if (idx % 2 === 0) {\n        ctx.put(idx === 0 ? "`" : "}");\n        ctx.put(encodeString(v2.value, stringifyEscape));\n        ctx.put(idx === lastIdx ? "`" : "${");\n      } else if (v2 !== null) {\n        ctx.node(v2);\n      }\n    }\n  }\n  function encodeString(s, map2) {\n    let result = "";\n    for (let i = 0; i < s.length; i++) {\n      result += map2.get(s[i]) || s[i];\n    }\n    return result;\n  }\n  var compileEscape, stringifyEscape;\n  var init_Template = __esm({\n    "node_modules/jora/src/lang/nodes/Template.js"() {\n      compileEscape = /* @__PURE__ */ new Map([\n        ["\\b", "\\\\b"],\n        ["\\n", "\\\\n"],\n        ["\\r", "\\\\r"],\n        ["\\f", "\\\\f"],\n        ["\t", "\\\\t"],\n        ["\\v", "\\\\v"],\n        ["\\u2028", "\\\\u2028"],\n        ["\\u2029", "\\\\u2029"],\n        ["\\\\", "\\\\\\\\"],\n        [\'"\', \'\\\\"\']\n      ]);\n      stringifyEscape = /* @__PURE__ */ new Map([\n        ["\\b", "\\\\b"],\n        ["\\f", "\\\\f"],\n        ["\t", "\\\\t"],\n        ["\\v", "\\\\v"],\n        ["\\\\", "\\\\\\\\"],\n        ["$", "\\\\$"]\n      ]);\n    }\n  });\n\n  // node_modules/jora/src/lang/nodes/index.js\n  var nodes, extract, build, compile35, walk35, stringify35, suggest16;\n  var init_nodes = __esm({\n    "node_modules/jora/src/lang/nodes/index.js"() {\n      init_Arg1();\n      init_Array();\n      init_Assertion();\n      init_Binary();\n      init_Block();\n      init_Compare();\n      init_CompareFunction();\n      init_Conditional();\n      init_Context();\n      init_Current();\n      init_Data();\n      init_Declarator();\n      init_Definition();\n      init_Filter();\n      init_Function();\n      init_GetProperty();\n      init_Identifier();\n      init_Literal();\n      init_Map();\n      init_MapRecursive();\n      init_Method();\n      init_MethodCall();\n      init_Object();\n      init_ObjectEntry();\n      init_Parentheses();\n      init_Pick();\n      init_Pipeline();\n      init_Placeholder();\n      init_Postfix();\n      init_Prefix();\n      init_Reference();\n      init_SliceNotation();\n      init_Spread();\n      init_Template();\n      nodes = {\n        Arg1: Arg1_exports,\n        Array: Array_exports,\n        Assertion: Assertion_exports,\n        Binary: Binary_exports,\n        Block: Block_exports,\n        Compare: Compare_exports,\n        Conditional: Conditional_exports,\n        Context: Context_exports,\n        Current: Current_exports,\n        Data: Data_exports,\n        Declarator: Declarator_exports,\n        Definition: Definition_exports,\n        Filter: Filter_exports,\n        Function: Function_exports,\n        GetProperty: GetProperty_exports,\n        Identifier: Identifier_exports,\n        Literal: Literal_exports,\n        Map: Map_exports,\n        MapRecursive: MapRecursive_exports,\n        Method: Method_exports,\n        MethodCall: MethodCall_exports,\n        Object: Object_exports,\n        ObjectEntry: ObjectEntry_exports,\n        Parentheses: Parentheses_exports,\n        Pick: Pick_exports,\n        Pipeline: Pipeline_exports,\n        Placeholder: Placeholder_exports,\n        Postfix: Postfix_exports,\n        Prefix: Prefix_exports,\n        Reference: Reference_exports,\n        SliceNotation: SliceNotation_exports,\n        CompareFunction: CompareFunction_exports,\n        Spread: Spread_exports,\n        Template: Template_exports\n      };\n      extract = (type) => new Map(\n        Object.entries(nodes).map(([key2, value]) => [key2, value[type]]).filter(([, value]) => typeof value === "function")\n      );\n      build = {};\n      extract("build").forEach(\n        (value, key2) => build[key2] = value\n      );\n      compile35 = extract("compile");\n      walk35 = extract("walk");\n      stringify35 = extract("stringify");\n      suggest16 = extract("suggest");\n    }\n  });\n\n  // node_modules/jora/src/lang/walk.js\n  function walk36(ast, options2) {\n    function walk37(node) {\n      if (walk35.has(node.type)) {\n        enter(node);\n        walk35.get(node.type)(node, ctx);\n        leave(node);\n      } else {\n        throw new Error(\'Unknown node type "\' + node.type + \'"\');\n      }\n    }\n    const ctx = {\n      node: walk37,\n      nodeOrNothing(node) {\n        if (node !== null) {\n          walk37(node);\n        }\n      },\n      list(list) {\n        list.forEach(walk37);\n      }\n    };\n    let enter = () => {\n    };\n    let leave = () => {\n    };\n    if (typeof options2 === "function") {\n      options2 = { enter: options2 };\n    }\n    if (options2) {\n      if (typeof options2.enter === "function") {\n        enter = options2.enter;\n      }\n      if (typeof options2.leave === "function") {\n        leave = options2.leave;\n      }\n    }\n    walk37(ast);\n  }\n  var init_walk = __esm({\n    "node_modules/jora/src/lang/walk.js"() {\n      init_nodes();\n    }\n  });\n\n  // node_modules/jora/src/lang/suggest.js\n  function isSuggestProhibitedChar(str, offset) {\n    return offset >= 0 && offset < str.length && /[a-zA-Z_$0-9]/.test(str[offset]);\n  }\n  function isWhiteSpace(str, offset) {\n    const code = str.charCodeAt(offset);\n    return code === 9 || code === 10 || code === 13 || code === 32;\n  }\n  function onlyWsInRange(str, start, end) {\n    for (; start < end; start++) {\n      if (!isWhiteSpace(str, start)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function getSuggestRanges(from, to, input, commentRanges, noSuggestOnEofPos) {\n    const ranges = [];\n    for (let i = 0; i < commentRanges.length; i++) {\n      const [commentFrom, commentTo] = commentRanges[i];\n      if (commentFrom >= to) {\n        break;\n      }\n      if (commentFrom < from) {\n        continue;\n      }\n      ranges.push(from, commentFrom);\n      from = commentTo;\n    }\n    if (from !== input.length || !noSuggestOnEofPos) {\n      ranges.push(from, to);\n    }\n    return ranges;\n  }\n  function processSuggestRanges(suggestRanges, source, commentRanges, noSuggestOnEofPos) {\n    const result = [];\n    for (let i = 0; i < suggestRanges.length; i++) {\n      let [start, end, type, related] = suggestRanges[i];\n      if (onlyWsInRange(source, start, end)) {\n        while (start >= 0 && isWhiteSpace(source, start - 1)) {\n          start--;\n        }\n        while (end < source.length && isWhiteSpace(source, end)) {\n          end++;\n        }\n        if (isSuggestProhibitedChar(source, start - 1)) {\n          if (start === end) {\n            continue;\n          }\n          start++;\n        }\n        if (isSuggestProhibitedChar(source, end)) {\n          if (start === end) {\n            continue;\n          }\n          end--;\n        }\n      }\n      const ranges = getSuggestRanges(start, end, source, commentRanges, noSuggestOnEofPos);\n      for (let j2 = 0; j2 < ranges.length; j2 += 2) {\n        result.push([ranges[j2], ranges[j2 + 1], type, related]);\n      }\n    }\n    return result;\n  }\n  function collectNodeSuggestions(ast) {\n    let currentNode = null;\n    const literalList = [];\n    const suggestions = Object.assign(/* @__PURE__ */ new Map(), { literalList });\n    const add2 = (node, range) => {\n      if (!suggestions.has(node)) {\n        suggestions.set(node, [range]);\n      } else {\n        suggestions.get(node).push(range);\n      }\n    };\n    const ctx = {\n      range(range, type, node = currentNode, related = true) {\n        add2(node, [...range, type, related]);\n      },\n      literalList(values) {\n        const name = "l" + literalList.length;\n        literalList.push([name, values]);\n        return name;\n      },\n      queryRoot(start, end = start) {\n        add2(currentNode, [start, end, "var", true]);\n        add2(currentNode, [start, end, "path", true]);\n      }\n    };\n    walk36(ast, (node) => {\n      if (suggest16.has(node.type)) {\n        const prevNode = currentNode;\n        currentNode = node;\n        suggest16.get(node.type)(node, ctx);\n        currentNode = prevNode;\n      }\n    });\n    return suggestions;\n  }\n  function suggest17(source, { ast, commentRanges }) {\n    const suggestions = collectNodeSuggestions(ast);\n    const noSuggestOnEofPos = (\n      // edge case when source ends with a comment with no newline\n      commentRanges.length && commentRanges[commentRanges.length - 1][1] === source.length && !/[\\r\\n]$/.test(source)\n    );\n    for (const [node, rawRanges] of suggestions) {\n      suggestions.set(node, processSuggestRanges(rawRanges, source, commentRanges, noSuggestOnEofPos));\n    }\n    return suggestions;\n  }\n  var init_suggest = __esm({\n    "node_modules/jora/src/lang/suggest.js"() {\n      init_nodes();\n      init_walk();\n    }\n  });\n\n  // node_modules/jora/src/lang/stringify.js\n  function isSimpleGetPropertyQuery(node) {\n    if (node.type !== "GetProperty") {\n      return false;\n    }\n    return true;\n  }\n  function isSimpleMethodCallQuery(node) {\n    if (node.type !== "MethodCall") {\n      return false;\n    }\n    return true;\n  }\n  function stringify36(ast) {\n    function walk37(node) {\n      if (stringify35.has(node.type)) {\n        stringify35.get(node.type)(node, ctx);\n      } else {\n        throw new Error(\'Unknown node type "\' + node.type + \'"\');\n      }\n    }\n    const buffer = [];\n    const ctx = {\n      isSimpleGetPropertyQuery,\n      isSimpleMethodCallQuery,\n      put(chunk) {\n        buffer.push(chunk);\n      },\n      node: walk37,\n      nodeOrNothing(node) {\n        if (node !== null) {\n          walk37(node);\n          return true;\n        }\n      },\n      list(list, sep) {\n        if (!sep) {\n          list.forEach(walk37);\n          return;\n        }\n        list.forEach((element, idx) => {\n          if (idx > 0) {\n            ctx.put(sep);\n          }\n          walk37(element);\n        });\n      }\n    };\n    walk37(ast);\n    return buffer.join("");\n  }\n  var init_stringify = __esm({\n    "node_modules/jora/src/lang/stringify.js"() {\n      init_nodes();\n    }\n  });\n\n  // node_modules/jora/src/lang/error.js\n  function createCustomError(name, message, extensions) {\n    const error = Object.assign(Object.create(SyntaxError.prototype), extensions);\n    const errorStack = new Error();\n    error.name = name;\n    error.message = message;\n    Object.defineProperty(error, "stack", {\n      get: function() {\n        return (errorStack.stack || "").replace(/^(.+\\n){1,3}/, name + ": " + message + "\\n");\n      }\n    });\n    return error;\n  }\n  var init_error = __esm({\n    "node_modules/jora/src/lang/error.js"() {\n    }\n  });\n\n  // node_modules/jora/src/lang/compile.js\n  function compile36(ast, tolerant, suggestions) {\n    return compileInternal(ast, "query", tolerant, suggestions);\n  }\n  function compileMethod(ast, tolerant, suggestions) {\n    return compileInternal(ast, "method", tolerant, suggestions);\n  }\n  function compileInternal(ast, kind, tolerant = false, suggestions = null) {\n    function newStatPoint(values) {\n      const spName = "s" + spNames.length;\n      spNames.push(values ? [spName, values] : [spName]);\n      return spName;\n    }\n    function getNodeSpName(node) {\n      let spName = nodeSpName.get(node);\n      if (!spName) {\n        nodeSpName.set(node, spName = newStatPoint());\n      }\n      return spName;\n    }\n    function addSuggestPoint(start, end, type, spName, related) {\n      let range = [start, end, JSON.stringify(type)];\n      if (type === "var") {\n        if (!ctx.scope.length) {\n          return;\n        }\n        range.push(JSON.stringify(ctx.scope));\n      } else {\n        if (!spName) {\n          spName = newStatPoint();\n        }\n        range.push(spName);\n        if (related) {\n          range.push(typeof related === "string" ? related : getNodeSpName(related));\n        }\n      }\n      normalizedSuggestRanges.push(range);\n      return spName;\n    }\n    function createScope(fn, defCurrent, $ref = "$") {\n      const prevScope = ctx.scope;\n      const scopeStart = buffer.length;\n      ctx.scope = ctx.scope.slice();\n      ctx.scope.own = [];\n      ctx.scope.firstCurrent = null;\n      ctx.scope.captureCurrent = [];\n      ctx.scope.arg1 = prevScope.arg1 || kind === "method";\n      ctx.scope.$ref = $ref;\n      fn();\n      if (ctx.scope.captureCurrent.length) {\n        const spName = ctx.scope.captureCurrent.reduce(\n          (spName2, range) => addSuggestPoint(...range, spName2),\n          void 0\n        );\n        const stat = "stat(" + spName + "," + ctx.scope.$ref + ")";\n        if (ctx.scope.firstCurrent) {\n          buffer[ctx.scope.firstCurrent] = stat;\n        } else {\n          buffer[scopeStart] = defCurrent(buffer[scopeStart], stat);\n        }\n      }\n      ctx.scope = prevScope;\n    }\n    function walk37(node, relatedNode) {\n      let spName = false;\n      if (suggestions !== null) {\n        if (suggestions.has(node)) {\n          for (const [start, end, type, related] of suggestions.get(node)) {\n            if (type === "var") {\n              addSuggestPoint(start, end, type);\n            } else if (related === true) {\n              ctx.scope.captureCurrent.push([start, end, type]);\n            } else {\n              if (!spName) {\n                spName = getNodeSpName(node);\n                buffer.push("stat(" + spName + ",");\n              }\n              if (type) {\n                addSuggestPoint(start, end, type, spName, related);\n              }\n            }\n          }\n        }\n        if (node.type === "Current" && ctx.scope.firstCurrent === null && ctx.scope.captureCurrent.disabled !== true) {\n          ctx.scope.firstCurrent = buffer.length;\n        }\n      }\n      if (compile35.has(node.type)) {\n        compile35.get(node.type)(node, ctx, relatedNode);\n      } else {\n        throw new Error(\'Unknown node type "\' + node.type + \'"\');\n      }\n      if (spName) {\n        buffer.push(")");\n      }\n    }\n    const spNames = [];\n    const nodeSpName = /* @__PURE__ */ new WeakMap();\n    const allocatedVars = [];\n    const normalizedSuggestRanges = [];\n    const buffer = [\n      { toString() {\n        if (kind === "query") {\n          return [\n            "((data,context)=>{",\n            ...ctx.usedMethods.size || ctx.usedAssertions.size ? [\n              "const method = (name,...args)=>m[name].apply(mctx,args);",\n              "const assertion = (name,...args)=>a[name].apply(mctx,args);",\n              "const mctx = Object.freeze({context,method,assertion});"\n            ] : []\n          ].join("\\n") + "\\n";\n        }\n        if (kind === "method") {\n          return [\n            "(function(data){",\n            "const mctx = this;",\n            "const context = mctx.context;"\n          ].join("\\n") + "\\n";\n        }\n        throw new Error("Unknown kind: " + kind);\n      } },\n      { toString() {\n        return allocatedVars.length > 0 ? "let " + allocatedVars + ";\\n" : "";\n      } },\n      { toString() {\n        return spNames.length > 0 ? [\n          "const stat=(s,v)=>(s.add(v),v);\\n",\n          "const " + spNames.map(\n            ([name, values]) => name + "=new Set(" + (values ? JSON.stringify(values) : "") + ")"\n          ) + ";\\n"\n        ].join("") : "";\n      } },\n      { toString() {\n        const lists = suggestions && Array.isArray(suggestions.literalList) && suggestions.literalList.map(([name, values]) => name + "=" + JSON.stringify(values));\n        return lists && lists.length ? "const " + lists + ";\\n" : "";\n      } },\n      suggestions === null ? "return " : "return{\\nvalue: "\n    ];\n    const initCtx = {};\n    const usedBuildinMethods = /* @__PURE__ */ new Set();\n    const ctx = {\n      tolerant,\n      usedAssertions: /* @__PURE__ */ new Map(),\n      usedMethods: /* @__PURE__ */ new Map(),\n      suggestions: suggestions !== null,\n      buildinFn(name) {\n        usedBuildinMethods.add(name);\n        return "f." + name;\n      },\n      scope: [],\n      createScope,\n      error: (message, node) => {\n        const error = new SyntaxError(message);\n        if (node && node.range) {\n          error.details = {\n            loc: {\n              range: node.range\n            }\n          };\n        }\n        if (!tolerant) {\n          throw error;\n        }\n      },\n      allocateVar() {\n        const name = "tmp" + allocatedVars.length;\n        allocatedVars.push(name);\n        return name;\n      },\n      put: (chunk) => buffer.push(chunk),\n      node: walk37,\n      nodeOrCurrent(node, relatedNode) {\n        walk37(node || { type: "Current" }, relatedNode);\n      },\n      list(list, sep, relatedNode) {\n        list.forEach((node, idx) => {\n          if (idx > 0) {\n            buffer.push(sep);\n          }\n          walk37(node, relatedNode);\n        });\n      }\n    };\n    createScope(\n      () => walk37(ast),\n      (scopeStart, sp) => {\n        buffer.push(")");\n        return "(" + sp + "," + scopeStart;\n      },\n      "data"\n    );\n    if (!tolerant) {\n      const { usedMethods, usedAssertions } = ctx;\n      if (usedAssertions.size) {\n        buffer.unshift(" this.assertAssertions(a)||");\n        initCtx.assertAssertions = function(providedAssertions) {\n          for (const [assertion, range] of usedAssertions.entries()) {\n            if (!hasOwn(providedAssertions, assertion)) {\n              return () => {\n                throw Object.assign(\n                  new Error(`Assertion "${assertion}" is not defined`),\n                  { details: { loc: { range } } }\n                );\n              };\n            }\n          }\n        };\n      }\n      if (usedMethods.size) {\n        buffer.unshift(" this.assertMethods(m)||");\n        initCtx.assertMethods = function(providedMethods) {\n          for (const [method, ranges] of usedMethods.entries()) {\n            if (!hasOwn(providedMethods, method)) {\n              return () => {\n                throw Object.assign(\n                  new Error(\n                    `Method "${method}" is not defined. If that\'s a custom method make sure you added it with "methods" section in options`\n                  ),\n                  { details: { loc: { range: ranges[0] } } }\n                );\n              };\n            }\n          }\n        };\n      }\n    }\n    if (suggestions !== null) {\n      buffer.push(\n        ",\\nstats: [" + normalizedSuggestRanges.map((s) => "[" + s + "]") + "],\\nmethods: m,\\nassertions: a\\n}"\n      );\n    }\n    try {\n      const fn = new Function("f,m,a", "return" + buffer.join("") + "})");\n      return Object.assign(fn.bind(initCtx), {\n        toString() {\n          return fn.toString().replace(/^(\\S+\\s+)anonymous([^)\\s]+)\\s*\\)/, "$1query$2)");\n        }\n      });\n    } catch (e) {\n      throw createCustomError("SyntaxError", "Jora query compilation error", {\n        compiledSource: buffer.join(""),\n        details: e\n      });\n    }\n  }\n  var init_compile = __esm({\n    "node_modules/jora/src/lang/compile.js"() {\n      init_misc();\n      init_error();\n      init_nodes();\n    }\n  });\n\n  // node_modules/@discoveryjs/natural-compare/src/index.js\n  var TYPE_EOF, TYPE_WS, TYPE_DELIM, TYPE_NUM, TYPE_WORD, TYPE_WS_OR_DELIM, TYPE_NUM_OR_WORD, DEBUG, DEBUG_TYPE_NAME, isSortableValue, safeCharCodeAt, isSign, isDigit, isWS, isDelim, isWord, isNumberStart, findEndOfType, consumeNumber, getToken, compare, createCompareFn, naturalCompare, naturalAnalyticalCompare;\n  var init_src = __esm({\n    "node_modules/@discoveryjs/natural-compare/src/index.js"() {\n      TYPE_EOF = 0;\n      TYPE_WS = 1;\n      TYPE_DELIM = 2;\n      TYPE_NUM = 4;\n      TYPE_WORD = 8;\n      TYPE_WS_OR_DELIM = TYPE_WS | TYPE_DELIM;\n      TYPE_NUM_OR_WORD = TYPE_NUM | TYPE_WORD;\n      DEBUG = false;\n      DEBUG_TYPE_NAME = {\n        [TYPE_EOF]: "eof",\n        [TYPE_WS]: "ws",\n        [TYPE_DELIM]: "delim",\n        [TYPE_NUM]: "number",\n        [TYPE_WORD]: "word"\n      };\n      isSortableValue = (value) => typeof value === "number" || typeof value === "string";\n      safeCharCodeAt = (source, offset) => offset < source.length ? source.charCodeAt(offset) : 0;\n      isSign = (code) => code === 43 || code === 45;\n      isDigit = (code) => code >= 48 && code <= 57;\n      isWS = (code) => code === 9 || // \\t\n      code === 10 || // \\n\n      code === 12 || // \\f\n      code === 13 || // \\r\n      code === 32;\n      isDelim = (code) => code > 32 && code < 256 && // ascii char\n      (code < 65 || code > 90) && // not A..Z\n      (code < 97 || code > 122) && // not a..z\n      !isDigit(code) && // not 0..9\n      !isSign(code) || code === 8470;\n      isWord = (code) => code && !isWS(code) && !isDelim(code) && !isDigit(code);\n      isNumberStart = (first, second, third) => {\n        if (isSign(first)) {\n          if (isDigit(second)) {\n            return 2;\n          }\n          return second === 46 && isDigit(third) ? 3 : 0;\n        }\n        if (isDigit(first)) {\n          return 1;\n        }\n        return 0;\n      };\n      findEndOfType = (source, offset, isType) => {\n        while (isType(safeCharCodeAt(source, ++offset))) {\n        }\n        return offset;\n      };\n      consumeNumber = (source, offset, preventFloat) => {\n        let code = safeCharCodeAt(source, offset);\n        if (isSign(code)) {\n          code = safeCharCodeAt(source, offset += 1);\n        }\n        if (isDigit(code)) {\n          offset = findEndOfType(source, offset, isDigit);\n          code = safeCharCodeAt(source, offset);\n        }\n        if (code === 46 && isDigit(safeCharCodeAt(source, offset + 1))) {\n          if (preventFloat) {\n            return offset;\n          }\n          const expectedEnd = findEndOfType(source, offset + 1, isDigit);\n          code = safeCharCodeAt(source, expectedEnd);\n          if (code === 46) {\n            return offset;\n          }\n          offset = expectedEnd;\n        }\n        if (code === 69 || code === 101) {\n          let sign = 1;\n          code = safeCharCodeAt(source, offset + 1);\n          if (isSign(code)) {\n            sign = 2;\n            code = safeCharCodeAt(source, offset + 2);\n          }\n          if (isDigit(code)) {\n            offset = findEndOfType(source, offset + sign, isDigit);\n          }\n        }\n        return offset;\n      };\n      getToken = (source, offset, preventFloat, preventSign) => {\n        if (offset >= source.length) {\n          return TYPE_EOF;\n        }\n        const code = safeCharCodeAt(source, offset);\n        if (isWS(code)) {\n          return TYPE_WS | findEndOfType(source, offset, isWS) - offset << 4;\n        }\n        if (isDelim(code) || preventSign && isSign(code)) {\n          return TYPE_DELIM | findEndOfType(source, offset, isDelim) - offset << 4;\n        }\n        if (isNumberStart(code, safeCharCodeAt(source, offset + 1), safeCharCodeAt(source, offset + 2))) {\n          return TYPE_NUM | consumeNumber(source, offset, preventFloat) - offset << 4;\n        }\n        return TYPE_WORD | findEndOfType(source, offset, isWord) - offset << 4;\n      };\n      compare = (a, b2, analytical) => {\n        let offsetA = 0;\n        let offsetB = 0;\n        let preventFloat = false;\n        let preventSign = false;\n        let postCmpResult = 0;\n        let postCmpResultType = 0;\n        let firstPart = true;\n        while (true) {\n          const partA = getToken(a, offsetA, preventFloat, preventSign);\n          const partB = getToken(b2, offsetB, preventFloat, preventSign);\n          const typeA = partA & 15;\n          const lenA = partA >> 4;\n          const typeB = partB & 15;\n          const lenB = partB >> 4;\n          if (DEBUG) {\n            console.log({\n              typeA: DEBUG_TYPE_NAME[typeA],\n              lenA,\n              substrA: a.substr(offsetA, lenA),\n              typeB: DEBUG_TYPE_NAME[typeB],\n              lenB,\n              substrB: b2.substr(offsetB, lenB)\n            });\n          }\n          if (typeA !== typeB) {\n            if (firstPart && typeA & TYPE_WS_OR_DELIM && typeB & TYPE_NUM_OR_WORD) {\n              postCmpResult = 1;\n              postCmpResultType = typeA;\n              offsetA += lenA;\n              continue;\n            }\n            if (firstPart && typeB & TYPE_WS_OR_DELIM && typeA & TYPE_NUM_OR_WORD) {\n              postCmpResult = -1;\n              postCmpResultType = typeB;\n              offsetB += lenB;\n              continue;\n            }\n            return typeA - typeB;\n          }\n          if (typeA === TYPE_EOF) {\n            return postCmpResult;\n          }\n          firstPart = false;\n          preventFloat = false;\n          preventSign = false;\n          const minLength = lenA < lenB ? lenA : lenB;\n          let substrDiff = lenA - lenB;\n          let cA = "";\n          let cB = "";\n          for (let i = 0; i < minLength; i++) {\n            cA = a[offsetA + i];\n            cB = b2[offsetB + i];\n            if (cA !== cB) {\n              substrDiff = cA < cB ? -1 : 1;\n              break;\n            }\n          }\n          if (typeA & TYPE_WS_OR_DELIM) {\n            preventFloat = a[offsetA + lenA - 1] === ".";\n            if (substrDiff !== 0) {\n              if (typeA > postCmpResultType) {\n                postCmpResultType = typeA;\n                postCmpResult = substrDiff;\n              }\n            }\n          } else if (typeA & TYPE_NUM) {\n            preventSign = true;\n            if (substrDiff !== 0) {\n              const numDiff = a.substr(offsetA, lenA) - b2.substr(offsetB, lenB);\n              if (numDiff !== 0) {\n                return analytical ? -numDiff : numDiff;\n              }\n              if (typeA > postCmpResultType) {\n                const afc = safeCharCodeAt(a, offsetA);\n                const bfc = safeCharCodeAt(b2, offsetB);\n                const order = afc === 45 ? -1 : 1;\n                postCmpResultType = typeA;\n                postCmpResult = afc !== bfc && (afc === 45 || bfc === 43) ? -1 : afc !== bfc && (afc === 43 || bfc === 45) ? 1 : (lenA - lenB || substrDiff) < 0 ? -order : order;\n                if (analytical) {\n                  postCmpResult = -postCmpResult;\n                }\n              }\n            }\n          } else {\n            if (substrDiff !== 0) {\n              if (cA !== cB) {\n                const sA = a.substr(offsetA, lenA);\n                const sB = b2.substr(offsetB, lenB);\n                const siA = sA.toLowerCase();\n                const siB = sB.toLowerCase();\n                if (siA !== siB) {\n                  return siA < siB ? -1 : 1;\n                }\n                return sA < sB ? -1 : 1;\n              }\n              return substrDiff;\n            }\n          }\n          offsetA += lenA;\n          offsetB += lenB;\n        }\n      };\n      createCompareFn = (analytical) => (a, b2) => {\n        DEBUG && console.log("Compare", a, b2);\n        if (isSortableValue(a) && isSortableValue(b2)) {\n          const ret = Math.sign(compare(String(a), String(b2), analytical));\n          DEBUG && console.log("Result:", ret);\n          return ret;\n        }\n        DEBUG && console.log("Result: (non-comparable)");\n        return 0;\n      };\n      naturalCompare = createCompareFn(false);\n      naturalAnalyticalCompare = createCompareFn(true);\n    }\n  });\n\n  // node_modules/jora/src/utils/compare.js\n  function cmpType(value) {\n    switch (typeof value) {\n      case "boolean":\n        return TYPE_BOOLEAN;\n      case "number":\n        return value !== value ? (\n          /* NaN */\n          TYPE_NAN\n        ) : TYPE_NUMBER;\n      case "string":\n        return TYPE_STRING;\n      case "object":\n        return value === null ? TYPE_NULL : TYPE_OBJECT;\n      case "undefined":\n        return TYPE_UNDEFINED;\n      default:\n        return TYPE_OTHER;\n    }\n  }\n  function cmp(a, b2) {\n    const typeA = cmpType(a);\n    const typeB = cmpType(b2);\n    return typeA !== typeB ? typeA < typeB ? -1 : 1 : a < b2 ? -1 : a > b2 ? 1 : 0;\n  }\n  function cmpAnalytical(a, b2) {\n    const typeA = cmpType(a);\n    const typeB = cmpType(b2);\n    if (typeA !== typeB) {\n      return typeA < typeB ? -1 : 1;\n    }\n    if (typeA === TYPE_NUMBER) {\n      return b2 - a;\n    }\n    return a < b2 ? -1 : a > b2 ? 1 : 0;\n  }\n  function cmpNatural(a, b2) {\n    const typeA = cmpType(a);\n    const typeB = cmpType(b2);\n    if ((typeA === TYPE_NUMBER || typeA === TYPE_STRING) && (typeB === TYPE_NUMBER || typeB === TYPE_STRING)) {\n      return naturalCompare(a, b2);\n    }\n    return typeA !== typeB ? typeA < typeB ? -1 : 1 : a < b2 ? -1 : a > b2 ? 1 : 0;\n  }\n  function cmpNaturalAnalytical(a, b2) {\n    const typeA = cmpType(a);\n    const typeB = cmpType(b2);\n    if ((typeA === TYPE_NUMBER || typeA === TYPE_STRING) && (typeB === TYPE_NUMBER || typeB === TYPE_STRING)) {\n      return naturalAnalyticalCompare(a, b2, true);\n    }\n    return typeA !== typeB ? typeA < typeB ? -1 : 1 : a < b2 ? -1 : a > b2 ? 1 : 0;\n  }\n  function getterToCmp(getter2, cmp2) {\n    return getter2.length === 1 ? (a, b2) => cmp2(getter2(a), getter2(b2)) : getter2;\n  }\n  var TYPE_BOOLEAN, TYPE_NAN, TYPE_NUMBER, TYPE_STRING, TYPE_NULL, TYPE_OBJECT, TYPE_OTHER, TYPE_UNDEFINED;\n  var init_compare = __esm({\n    "node_modules/jora/src/utils/compare.js"() {\n      init_src();\n      TYPE_BOOLEAN = 1;\n      TYPE_NAN = 2;\n      TYPE_NUMBER = 3;\n      TYPE_STRING = 4;\n      TYPE_NULL = 5;\n      TYPE_OBJECT = 6;\n      TYPE_OTHER = 7;\n      TYPE_UNDEFINED = 8;\n    }\n  });\n\n  // node_modules/jora/src/lang/compile-buildin.js\n  function ensureArray(value) {\n    return Array.isArray(value) ? value : [value];\n  }\n  function add(a, b2) {\n    if (Array.isArray(a) || Array.isArray(b2)) {\n      return [...new Set([].concat(a, b2))];\n    }\n    return a + b2;\n  }\n  function sub(a, b2) {\n    if (Array.isArray(a)) {\n      const result = new Set(a);\n      if (Array.isArray(b2)) {\n        b2.forEach((item) => result.delete(item));\n      } else {\n        result.delete(b2);\n      }\n      return [...result];\n    }\n    return a - b2;\n  }\n  function mul(a, b2) {\n    return a * b2;\n  }\n  function div(a, b2) {\n    return a / b2;\n  }\n  function mod(a, b2) {\n    return a % b2;\n  }\n  function eq(a, b2) {\n    return Object.is(a, b2);\n  }\n  function ne(a, b2) {\n    return !Object.is(a, b2);\n  }\n  function lt2(a, b2) {\n    return a < b2;\n  }\n  function lte(a, b2) {\n    return a <= b2;\n  }\n  function gt2(a, b2) {\n    return a > b2;\n  }\n  function gte(a, b2) {\n    return a >= b2;\n  }\n  function in_(a, b2) {\n    if (isPlainObject(b2)) {\n      return hasOwn(b2, a);\n    }\n    return b2 ? internalIndexOf(b2, a) !== -1 : false;\n  }\n  function match(value, pattern) {\n    if (typeof pattern === "function") {\n      return some(value, pattern);\n    }\n    if (isRegExp(pattern)) {\n      return some(value, pattern.test.bind(pattern));\n    }\n    if (pattern === null || pattern === void 0) {\n      return true;\n    }\n    return false;\n  }\n  function pick(current, ref = () => true) {\n    if (!current) {\n      return void 0;\n    }\n    if (typeof ref === "function") {\n      if (Array.isArray(current) || typeof current === "string") {\n        for (let i = 0; i < current.length; i++) {\n          if (isTruthy(ref(current[i], i))) {\n            return current[i];\n          }\n        }\n      }\n      for (const key2 in current) {\n        if (hasOwn(current, key2)) {\n          if (isTruthy(ref(current[key2], key2))) {\n            return current[key2];\n          }\n        }\n      }\n      return void 0;\n    }\n    if (Array.isArray(current) || typeof current === "string") {\n      return isFinite(ref) ? current[ref < 0 ? current.length + Number(ref) : Number(ref) || 0] : void 0;\n    }\n    return hasOwn(current, ref) ? current[ref] : void 0;\n  }\n  function indexOf(dict, value, fromIndex) {\n    return dict ? internalIndexOf(dict, value, fromIndex) : -1;\n  }\n  function internalIndexOf(dict, value, fromIndex = 0) {\n    if (Number.isNaN(value)) {\n      if (isArrayLike2(dict)) {\n        for (let i = parseInt(fromIndex, 10) || 0; i < dict.length; i++) {\n          if (Number.isNaN(dict[i])) {\n            return i;\n          }\n        }\n      }\n    }\n    if (typeof dict.indexOf === "function") {\n      return dict.indexOf(value, fromIndex);\n    }\n    return -1;\n  }\n  function lastIndexOf(dict, value, fromIndex) {\n    return dict ? internalLastIndexOf(dict, value, fromIndex) : -1;\n  }\n  function internalLastIndexOf(dict, value, fromIndex) {\n    if (Number.isNaN(value)) {\n      if (isArrayLike2(dict)) {\n        for (let i = parseInt(fromIndex, 10) || dict.length - 1; i >= 0; i--) {\n          if (Number.isNaN(dict[i])) {\n            return i;\n          }\n        }\n      }\n    }\n    if (typeof dict.lastIndexOf === "function") {\n      return dict.lastIndexOf(value, parseInt(fromIndex, 10) || dict.length - 1);\n    }\n    return -1;\n  }\n  function map(value, getter2) {\n    const fn = typeof getter2 === "function" ? getter2 : (current) => getPropertyValue(current, getter2);\n    if (Array.isArray(value)) {\n      return [\n        ...value.reduce(\n          (set, item) => addToSet(set, fn(item)),\n          /* @__PURE__ */ new Set()\n        )\n      ];\n    }\n    return value !== void 0 ? fn(value) : value;\n  }\n  function mapRecursive(value, getter2) {\n    const result = /* @__PURE__ */ new Set();\n    addToSet(result, map(value, getter2));\n    result.forEach(\n      (current) => addToSet(result, map(current, getter2))\n    );\n    return [...result];\n  }\n  function some(value, fn) {\n    return Array.isArray(value) ? value.some((current) => isTruthy(fn(current))) : isTruthy(fn(value));\n  }\n  function filter(value, fn) {\n    if (Array.isArray(value)) {\n      return value.filter((current) => isTruthy(fn(current)));\n    }\n    return isTruthy(fn(value)) ? value : void 0;\n  }\n  function slice(value, from = 0, to = value && value.length, step = 1) {\n    if (!isArrayLike2(value)) {\n      return [];\n    }\n    from = parseInt(from, 10) || 0;\n    to = parseInt(to, 10) || value.length;\n    step = parseInt(step, 10) || 1;\n    if (step !== 1) {\n      const result = [];\n      from = from < 0 ? Math.max(0, value.length + from) : Math.min(value.length, from);\n      to = to < 0 ? Math.max(0, value.length + to) : Math.min(value.length, to);\n      for (let i = step > 0 ? from : to - 1; i >= from && i < to; i += step) {\n        result.push(value[i]);\n      }\n      return result;\n    }\n    if (typeof value === "string") {\n      return value.slice(from, to);\n    }\n    return Array.prototype.slice.call(value, from, to);\n  }\n  var compile_buildin_default;\n  var init_compile_buildin = __esm({\n    "node_modules/jora/src/lang/compile-buildin.js"() {\n      init_compare();\n      init_misc();\n      compile_buildin_default = Object.freeze({\n        ensureArray,\n        bool: isTruthy,\n        and: (a, b2) => isTruthy(a) ? b2 : a,\n        or: (a, b2) => isTruthy(a) ? a : b2,\n        add,\n        sub,\n        mul,\n        div,\n        mod,\n        eq,\n        ne,\n        lt: lt2,\n        lte,\n        gt: gt2,\n        gte,\n        in: in_,\n        notIn: (a, b2) => !in_(a, b2),\n        has: (a, b2) => in_(b2, a),\n        hasNo: (a, b2) => !in_(b2, a),\n        cmp,\n        cmpAnalytical,\n        cmpNatural,\n        cmpNaturalAnalytical,\n        match,\n        pick,\n        indexOf,\n        lastIndexOf,\n        map,\n        mapRecursive,\n        some,\n        filter,\n        slice\n      });\n    }\n  });\n\n  // node_modules/jora/src/utils/stable-sort.js\n  function isSortStable(n) {\n    return Array.from({ length: n }, (_, idx) => ({ idx })).sort((a, b2) => a.idx % 2 - b2.idx % 2).every(\n      (a, idx) => idx < n / 2 ? a.idx >> 1 === idx : Math.ceil(n / 2) + (a.idx >> 1) === idx\n    );\n  }\n  function stableSort(array, cmp2) {\n    if (array.length <= stableSortSize) {\n      return array.slice().sort(cmp2);\n    }\n    return array.map((value, idx) => ({ value, idx })).sort(\n      (a, b2) => (a.value === void 0 ? b2.value !== void 0 : b2.value === void 0 ? -1 : cmp2(a.value, b2.value)) || a.idx - b2.idx\n    ).map((item) => item.value);\n  }\n  var stableSortSize;\n  var init_stable_sort = __esm({\n    "node_modules/jora/src/utils/stable-sort.js"() {\n      stableSortSize = isSortStable(20) ? Infinity : isSortStable(10) ? 10 : 0;\n    }\n  });\n\n  // node_modules/jora/src/utils/heap.js\n  var defaultMinCompare, defaultMaxCompare, Heap, MaxHeap, MinHeap;\n  var init_heap = __esm({\n    "node_modules/jora/src/utils/heap.js"() {\n      defaultMinCompare = (a, b2) => a - b2;\n      defaultMaxCompare = (a, b2) => b2 - a;\n      Heap = class {\n        constructor(maxSize, compare2, accept, disallowDuplicates = false) {\n          this.maxSize = maxSize || Infinity;\n          this.compare = compare2 || defaultMaxCompare;\n          this.accept = accept || null;\n          this.values = [];\n          this.valuesSet = disallowDuplicates ? /* @__PURE__ */ new Set() : null;\n        }\n        add(value) {\n          if (this.accept !== null && !this.accept(value)) {\n            return;\n          }\n          if (this.valuesSet !== null && this.valuesSet.has(value)) {\n            return;\n          }\n          if (this.values.length < this.maxSize) {\n            if (this.valuesSet !== null) {\n              this.valuesSet.add(value);\n            }\n            this.values.push(value);\n            this.heapifyUp(this.values.length - 1);\n          } else if (this.compare(this.values[0], value) > 0) {\n            if (this.valuesSet !== null) {\n              this.valuesSet.delete(this.values[0]);\n              this.valuesSet.add(value);\n            }\n            this.values[0] = value;\n            this.heapifyDown();\n          }\n        }\n        addArray(array) {\n          for (let i = 0; i < array.length; i++) {\n            this.add(array[i]);\n          }\n        }\n        extract() {\n          const topValue = this.values[0];\n          const lastValue = this.values.pop();\n          if (this.values.length > 0) {\n            this.values[0] = lastValue;\n            this.heapifyDown();\n          }\n          if (this.valuesSet !== null) {\n            this.valuesSet.delete(topValue);\n          }\n          return topValue;\n        }\n        heapifyUp(idx) {\n          const values = this.values;\n          let idxValue = values[idx];\n          while (idx > 0) {\n            const parentIdx = idx - 1 >> 1;\n            const parentValue = values[parentIdx];\n            if (this.compare(parentValue, idxValue) > 0) {\n              break;\n            }\n            values[parentIdx] = idxValue;\n            values[idx] = parentValue;\n            idx = parentIdx;\n          }\n        }\n        heapifyDown() {\n          const values = this.values;\n          const size = values.length;\n          const halfSize = size >> 1;\n          let idx = 0;\n          let idxValue = values[idx];\n          let largestIdx = idx;\n          let largestValue = idxValue;\n          while (idx < halfSize) {\n            const left = 2 * idx + 1;\n            const leftValue = values[left];\n            const right = left + 1;\n            if (this.compare(leftValue, idxValue) > 0) {\n              largestIdx = left;\n              largestValue = leftValue;\n            }\n            if (right < size) {\n              const rightValue = values[right];\n              if (this.compare(rightValue, largestValue) > 0) {\n                largestIdx = right;\n                largestValue = rightValue;\n              }\n            }\n            if (largestIdx === idx) {\n              break;\n            }\n            values[idx] = largestValue;\n            values[largestIdx] = idxValue;\n            idx = largestIdx;\n            largestValue = idxValue;\n          }\n        }\n        [Symbol.iterator]() {\n          return this.values.slice().sort(this.compare)[Symbol.iterator]();\n        }\n      };\n      MaxHeap = class extends Heap {\n      };\n      MinHeap = class extends Heap {\n        constructor(maxSize, compare2, accept, allowDuplicates) {\n          super(\n            maxSize,\n            compare2 ? (a, b2) => -compare2(a, b2) : defaultMinCompare,\n            accept,\n            allowDuplicates\n          );\n        }\n      };\n    }\n  });\n\n  // node_modules/jora/src/utils/process-numeric-array.js\n  function toNumber(value) {\n    return value !== null && typeof value === "object" ? NaN : Number(value);\n  }\n  function processNumericArray(current, getter2, apply) {\n    if (isArrayLike2(current)) {\n      if (typeof getter2 !== "function") {\n        getter2 = self2;\n      }\n      for (const value of current) {\n        const mappedValue = getter2(value);\n        if (mappedValue !== void 0) {\n          apply(toNumber(mappedValue));\n        }\n      }\n    }\n  }\n  var self2;\n  var init_process_numeric_array = __esm({\n    "node_modules/jora/src/utils/process-numeric-array.js"() {\n      init_misc();\n      self2 = (value) => value;\n    }\n  });\n\n  // node_modules/jora/src/utils/percentile.js\n  function percentile(array, k2, getter2, formula, compare2) {\n    if (array.length === 0 || !isFinite(k2) || k2 < 0 || k2 > 100) {\n      return void 0;\n    }\n    let arrayLength = 0;\n    let rank = k2 * (array.length - 1) / 100;\n    let lowerRank = Math.floor(rank);\n    let upperRank = Math.ceil(rank);\n    let hasNaNs = false;\n    const heap = k2 < 50 ? new MinHeap(upperRank + 1, compare2) : new MaxHeap(array.length - lowerRank, compare2);\n    processNumericArray(array, getter2, (value) => {\n      if (Number.isNaN(value)) {\n        hasNaNs = true;\n      }\n      heap.add(value);\n      arrayLength++;\n    });\n    if (hasNaNs) {\n      return NaN;\n    }\n    if (array.length !== arrayLength) {\n      if (arrayLength === 0) {\n        return;\n      }\n      rank = k2 * (arrayLength - 1) / 100;\n      lowerRank = Math.floor(rank);\n      upperRank = Math.ceil(rank);\n      const maxSize = k2 < 50 ? upperRank + 1 : arrayLength - lowerRank;\n      for (let i = heap.values.length; i > maxSize; i--) {\n        heap.extract();\n      }\n    }\n    if (lowerRank !== upperRank) {\n      const a = heap.extract();\n      const b2 = heap.values[0];\n      return a <= b2 ? a + (b2 - a) * (rank - lowerRank) : b2 + (a - b2) * (rank - lowerRank);\n    }\n    return heap.values[0];\n  }\n  var init_percentile = __esm({\n    "node_modules/jora/src/utils/percentile.js"() {\n      init_heap();\n      init_process_numeric_array();\n    }\n  });\n\n  // node_modules/jora/src/utils/statistics.js\n  function sumAndCount(current, getter2) {\n    let sum2 = void 0;\n    let correction = 0;\n    let count3 = 0;\n    processNumericArray(current, getter2, (num) => {\n      count3++;\n      if (sum2 === void 0) {\n        sum2 = num;\n      } else {\n        const transition = sum2;\n        const absTransition = Math.abs(transition);\n        const absNum = Math.abs(num);\n        sum2 += num;\n        if (absTransition !== Infinity && absNum !== Infinity) {\n          if (absTransition >= absNum) {\n            correction += transition - sum2 + num;\n          } else {\n            correction += num - sum2 + transition;\n          }\n        }\n      }\n    });\n    if (sum2 !== void 0) {\n      sum2 += correction;\n    }\n    return { sum: sum2, count: count3 };\n  }\n  function numbers(current, getter2) {\n    const result = [];\n    processNumericArray(current, getter2, result.push.bind(result));\n    return result;\n  }\n  function count(current, getter2) {\n    let count3 = 0;\n    if (isArrayLike2(current)) {\n      if (typeof getter2 !== "function") {\n        getter2 = self3;\n      }\n      for (const value of current) {\n        if (getter2(value) !== void 0) {\n          count3++;\n        }\n      }\n    }\n    return count3;\n  }\n  function sum(current, getter2) {\n    return sumAndCount(current, getter2).sum;\n  }\n  function mean(current, getter2) {\n    const { sum: sum2, count: count3 } = sumAndCount(current, getter2);\n    if (count3 > 0) {\n      return sum2 / count3;\n    }\n  }\n  function variance(current, getter2) {\n    let count3 = 0;\n    let mean2 = 0;\n    let M2 = 0;\n    processNumericArray(current, getter2, (num) => {\n      count3 += 1;\n      let delta = num - mean2;\n      mean2 += delta / count3;\n      M2 += delta * (num - mean2);\n    });\n    if (count3 > 0) {\n      return M2 / count3;\n    }\n  }\n  function stdev(current, getter2) {\n    const v2 = variance(current, getter2);\n    if (v2 !== void 0) {\n      return Math.sqrt(v2);\n    }\n  }\n  function min(current, cmp2 = cmpNatural) {\n    let min2;\n    if (current && isFinite(current.length) && typeof cmp2 === "function") {\n      cmp2 = getterToCmp(cmp2, cmpNatural);\n      for (let i = 0; i < current.length; i++) {\n        const value = current[i];\n        if ((min2 === void 0 || cmp2(value, min2) < 0) && cmp2(value, void 0) !== 0) {\n          min2 = value;\n        }\n      }\n    }\n    return min2;\n  }\n  function max(current, cmp2 = cmpNatural) {\n    let max2;\n    if (current && isFinite(current.length) && typeof cmp2 === "function") {\n      cmp2 = getterToCmp(cmp2, cmpNatural);\n      for (let i = 0; i < current.length; i++) {\n        const value = current[i];\n        if ((max2 === void 0 || cmp2(value, max2) >= 0) && cmp2(value, void 0) !== 0) {\n          max2 = value;\n        }\n      }\n    }\n    return max2;\n  }\n  function percentile2(current, p, getter2) {\n    if (isArrayLike2(current)) {\n      return percentile(current, p, getter2);\n    }\n  }\n  function median(current, getter2) {\n    return percentile2(current, 50, getter2);\n  }\n  var self3;\n  var init_statistics = __esm({\n    "node_modules/jora/src/utils/statistics.js"() {\n      init_compare();\n      init_percentile();\n      init_process_numeric_array();\n      init_misc();\n      self3 = (value) => value;\n    }\n  });\n\n  // node_modules/jora/src/methods.js\n  function noop() {\n  }\n  function self4(value) {\n    return value;\n  }\n  function matchEntry(match2) {\n    if (match2 === null) {\n      return null;\n    }\n    return {\n      matched: match2.slice(),\n      start: match2.index,\n      end: match2.index + match2[0].length,\n      input: match2.input,\n      groups: match2.groups || null\n    };\n  }\n  function replaceMatchEntry(args) {\n    const last = args.pop();\n    const groups = typeof last === "string" ? null : last;\n    const input = groups === null ? last : args.pop();\n    const start = args.pop();\n    return {\n      matched: args,\n      start,\n      end: start + args[0].length,\n      input,\n      groups\n    };\n  }\n  var replaceAll, methods_default;\n  var init_methods = __esm({\n    "node_modules/jora/src/methods.js"() {\n      init_compile_buildin();\n      init_compare();\n      init_stable_sort();\n      init_statistics();\n      init_misc();\n      replaceAll = String.prototype.replaceAll || function(pattern, replacement) {\n        return isRegExp(pattern) ? this.replace(pattern, replacement) : this.split(pattern).join(String(replacement));\n      };\n      methods_default = Object.freeze({\n        bool: compile_buildin_default.bool,\n        filter: compile_buildin_default.filter,\n        map: compile_buildin_default.map,\n        pick: compile_buildin_default.pick,\n        indexOf: compile_buildin_default.indexOf,\n        lastIndexOf: compile_buildin_default.lastIndexOf,\n        keys(current) {\n          return Object.keys(current || {});\n        },\n        values(current) {\n          const values = /* @__PURE__ */ new Set();\n          for (const key2 in current) {\n            if (hasOwn(current, key2)) {\n              addToSet(values, current[key2]);\n            }\n          }\n          return [...values];\n        },\n        entries(current) {\n          const entries2 = [];\n          for (const key2 in current) {\n            if (hasOwn(current, key2)) {\n              entries2.push({ key: key2, value: current[key2] });\n            }\n          }\n          return entries2;\n        },\n        fromEntries(current) {\n          const result = /* @__PURE__ */ Object.create(null);\n          if (Array.isArray(current)) {\n            for (const entry of current) {\n              if (entry) {\n                result[entry.key] = entry.value;\n              }\n            }\n          }\n          return result;\n        },\n        size(current) {\n          if (isPlainObject(current)) {\n            return Object.keys(current).length;\n          }\n          return current && current.length || 0;\n        },\n        sort(current, comparator2 = cmp) {\n          if (!Array.isArray(current)) {\n            return current;\n          }\n          if (typeof comparator2 === "function" && comparator2.length !== 2) {\n            const getter2 = comparator2;\n            comparator2 = (a, b2) => {\n              a = getter2(a);\n              b2 = getter2(b2);\n              if (Array.isArray(a) && Array.isArray(b2)) {\n                if (a.length !== b2.length) {\n                  return a.length < b2.length ? -1 : 1;\n                }\n                for (let i = 0; i < a.length; i++) {\n                  const ret = cmp(a[i], b2[i]);\n                  if (ret !== 0) {\n                    return ret;\n                  }\n                }\n                return 0;\n              }\n              return cmp(a, b2);\n            };\n          }\n          return stableSort(current, comparator2);\n        },\n        reverse(current) {\n          return Array.isArray(current) ? current.slice().reverse() : current;\n        },\n        slice(current, from, to) {\n          return compile_buildin_default.slice(current, from, to);\n        },\n        group(current, keyGetter, valueGetter) {\n          const map2 = /* @__PURE__ */ new Map();\n          const result = [];\n          if (typeof keyGetter !== "function") {\n            keyGetter = noop;\n          }\n          if (typeof valueGetter !== "function") {\n            valueGetter = self4;\n          }\n          if (!Array.isArray(current)) {\n            current = [current];\n          }\n          for (const item of current) {\n            const keys = keyGetter(item);\n            if (Array.isArray(keys)) {\n              for (const key2 of keys) {\n                addToMapSet(map2, key2, valueGetter(item));\n              }\n            } else {\n              addToMapSet(map2, keys, valueGetter(item));\n            }\n          }\n          for (const [key2, value] of map2) {\n            result.push({ key: key2, value: [...value] });\n          }\n          return result;\n        },\n        join(current, separator) {\n          return Array.isArray(current) ? current.join(separator) : String(current);\n        },\n        match(current, pattern, matchAll2) {\n          const input = String(current);\n          const flags = isRegExp(pattern) ? pattern.flags : "";\n          if (matchAll2 || flags.includes("g")) {\n            const result = [];\n            let cursor = new RegExp(pattern, (flags || "").replace(/g|$/, "g"));\n            let match2;\n            while (match2 = cursor.exec(input)) {\n              result.push(matchEntry(match2));\n            }\n            return result;\n          }\n          return matchEntry(input.match(pattern));\n        },\n        reduce(current, fn, initValue = void 0) {\n          if (Array.isArray(current)) {\n            return initValue !== void 0 ? current.reduce((res, current2) => fn(current2, res), initValue) : current.reduce((res, current2) => fn(current2, res));\n          }\n          return fn(current, initValue);\n        },\n        // array/string\n        split(current, pattern) {\n          if (Array.isArray(current)) {\n            const patternFn = typeof pattern === "function" ? pattern : Object.is.bind(null, pattern);\n            const result = [];\n            let start = 0;\n            let end = 0;\n            for (; end < current.length; end++) {\n              if (patternFn(current[end])) {\n                result.push(current.slice(start, end));\n                start = end + 1;\n              }\n            }\n            result.push(current.slice(start, end));\n            return result;\n          }\n          return String(current).split(pattern);\n        },\n        replace(current, pattern, replacement) {\n          if (Array.isArray(current)) {\n            const patternFn = typeof pattern === "function" ? pattern : Object.is.bind(null, pattern);\n            return current.map(\n              typeof replacement === "function" ? (current2) => patternFn(current2) ? replacement(current2) : current2 : (current2) => patternFn(current2) ? replacement : current2\n            );\n          }\n          if (isRegExp(pattern) && !pattern.flags.includes("g")) {\n            pattern = new RegExp(pattern, pattern.flags + "g");\n          }\n          return replaceAll.call(\n            String(current),\n            pattern,\n            typeof replacement === "function" ? (...args) => replacement(replaceMatchEntry(args)) : replacement\n          );\n        },\n        // strings\n        toLowerCase(current, locales) {\n          return String(current).toLocaleLowerCase(locales);\n        },\n        toUpperCase(current, locales) {\n          return String(current).toLocaleUpperCase(locales);\n        },\n        trim(current) {\n          return String(current).trim();\n        },\n        // all Math static method with exclusion of \'max\', \'min\', \'log\', `log1p` and \'random\'\n        ...[\n          "abs",\n          "acos",\n          "acosh",\n          "asin",\n          "asinh",\n          "atan",\n          "atan2",\n          "atanh",\n          "cbrt",\n          "ceil",\n          "clz32",\n          "cos",\n          "cosh",\n          "exp",\n          "expm1",\n          "floor",\n          "fround",\n          "hypot",\n          "imul",\n          "log10",\n          "log2",\n          "pow",\n          "round",\n          "sign",\n          "sin",\n          "sinh",\n          "sqrt",\n          "tan",\n          "tanh",\n          "trunc"\n        ].reduce((res, method) => {\n          res[method] = Math[method];\n          return res;\n        }, {}),\n        ln: Math.log,\n        ln1p: Math.log1p,\n        // statistics\n        numbers,\n        count,\n        sum,\n        avg: mean,\n        variance,\n        stdev,\n        min,\n        max,\n        percentile: percentile2,\n        p: percentile2,\n        // alias for percentile()\n        median\n      });\n    }\n  });\n\n  // node_modules/jora/src/assertions.js\n  var assertions_default;\n  var init_assertions = __esm({\n    "node_modules/jora/src/assertions.js"() {\n      init_misc();\n      assertions_default = Object.freeze({\n        function: (value) => typeof value === "function",\n        symbol: (value) => typeof value === "symbol",\n        primitive: (value) => value === null || typeof value !== "object" && typeof value !== "function",\n        string: (value) => typeof value === "string",\n        number: (value) => typeof value === "number",\n        int: Number.isInteger,\n        finite: (value) => Number.isFinite(value),\n        nan: (value) => Number.isNaN(value),\n        infinity: (value) => value === Infinity || value === -Infinity,\n        boolean: (value) => value === true || value === false,\n        null: (value) => value === null,\n        undefined: (value) => value === void 0,\n        nullish: (value) => value === null || value === void 0,\n        object: isPlainObject,\n        array: Array.isArray,\n        regexp: isRegExp,\n        truthy: isTruthy,\n        falsy: (value) => !isTruthy(value)\n      });\n    }\n  });\n\n  // node_modules/jora/src/stat.js\n  function addObjectKeysToSet(object, set) {\n    Object.keys(object).forEach(set.add, set);\n  }\n  function valuesToSuggestions(context, values, related, suggestions = /* @__PURE__ */ new Set()) {\n    const addValue = (value) => {\n      switch (typeof value) {\n        case "string":\n        case "number":\n          suggestions.add(value);\n          break;\n      }\n    };\n    switch (context) {\n      case "path": {\n        const keys = /* @__PURE__ */ new Set();\n        for (const value of values) {\n          if (Array.isArray(value)) {\n            for (const item of value) {\n              if (isPlainObject(item)) {\n                addObjectKeysToSet(item, keys);\n              }\n            }\n          } else if (isPlainObject(value)) {\n            addObjectKeysToSet(value, keys);\n          }\n        }\n        keys.forEach(suggestions.add, suggestions);\n        break;\n      }\n      case "key": {\n        const keys = /* @__PURE__ */ new Set();\n        for (const value of values) {\n          if (value !== null && typeof value === "object" && !Array.isArray(value)) {\n            addObjectKeysToSet(value, keys);\n          }\n        }\n        keys.forEach(suggestions.add, suggestions);\n        break;\n      }\n      case "value":\n        for (const value of values) {\n          addValue(value);\n        }\n        break;\n      case "in-value": {\n        const keys = /* @__PURE__ */ new Set();\n        for (const value of values) {\n          if (Array.isArray(value)) {\n            value.forEach(addValue);\n          } else if (isPlainObject(value)) {\n            addObjectKeysToSet(value, keys);\n          }\n        }\n        keys.forEach(suggestions.add, suggestions);\n        break;\n      }\n      case "var":\n        for (const value of values) {\n          suggestions.add("$" + value);\n        }\n        break;\n      case "value-subset": {\n        const ignoreValues = new Set(related);\n        for (const value of values) {\n          if (!ignoreValues.has(value)) {\n            addValue(value);\n          }\n        }\n        break;\n      }\n    }\n    return suggestions;\n  }\n  function findSourcePosRanges(source, pos, points, includeEmpty = false) {\n    const ranges = [];\n    for (let [from, to, context, values, related = null] of points) {\n      if (pos >= from && pos <= to && (includeEmpty || values.size || values.length)) {\n        let text = source.substring(from, to);\n        if (!/\\S/.test(text)) {\n          from = to = pos;\n          text = "";\n        }\n        ranges.push({\n          context,\n          from,\n          to,\n          text,\n          values,\n          related\n        });\n      }\n    }\n    return ranges;\n  }\n  function normalizeFunctionOption(value, fn) {\n    if (typeof value === "function") {\n      return value;\n    }\n    if (value === true) {\n      return fn;\n    }\n    return false;\n  }\n  function normalizeFilterPattern(value) {\n    if (/^(["\']).*\\1$/.test(value)) {\n      try {\n        if (value[0] === "\'") {\n          value = `"${value.slice(1, -1).replace(\n            /\\\\.|"/g,\n            (m2) => m2 === "\\\\\'" ? "\'" : m2 === \'"\' ? \'\\\\"\' : m2\n          )}"`;\n        }\n        return JSON.parse(value);\n      } catch (e) {\n      }\n    }\n    return value;\n  }\n  function defaultFilterFactory(pattern) {\n    return (value) => (typeof value === "string" ? value : String(value)).toLowerCase().indexOf(pattern) !== -1;\n  }\n  var contextToType, stat_default;\n  var init_stat = __esm({\n    "node_modules/jora/src/stat.js"() {\n      init_compile_buildin();\n      init_heap();\n      init_misc();\n      contextToType = {\n        "path": "property",\n        "key": "value",\n        "value": "value",\n        "in-value": "value",\n        "value-subset": "value",\n        "var": "variable",\n        "assertion": "assertion"\n      };\n      stat_default = (source, { value, stats, assertions }) => ({\n        get value() {\n          return value;\n        },\n        stat(pos, includeEmpty) {\n          return findSourcePosRanges(source, pos, stats, includeEmpty);\n        },\n        suggestion(pos, options2) {\n          let { limit = Infinity, sort, filter: filterFactory } = options2 || {};\n          sort = normalizeFunctionOption(sort, compile_buildin_default.cmp);\n          filterFactory = normalizeFunctionOption(filterFactory, defaultFilterFactory);\n          const storageType = sort && isFinite(limit) ? MaxHeap : Set;\n          const ranges = findSourcePosRanges(source, pos, stats, true);\n          const typeSuggestions = /* @__PURE__ */ new Map();\n          const result = [];\n          for (const range of ranges) {\n            const { context, text, from, to, values, related } = range;\n            const type = contextToType[context];\n            if (!typeSuggestions.has(type)) {\n              let storage;\n              switch (storageType) {\n                case MaxHeap:\n                  storage = new MaxHeap(\n                    limit,\n                    sort,\n                    filterFactory && filterFactory(normalizeFilterPattern(text)),\n                    true\n                  );\n                  break;\n                case Set:\n                  storage = /* @__PURE__ */ new Set();\n                  break;\n              }\n              typeSuggestions.set(type, {\n                type,\n                from,\n                to,\n                text,\n                suggestions: storage\n              });\n            }\n            const { suggestions } = typeSuggestions.get(type);\n            switch (context) {\n              case "assertion":\n                if (suggestions.size === 0 || suggestions.values && suggestions.values.length === 0) {\n                  for (const value2 of Object.keys(assertions)) {\n                    suggestions.add(value2);\n                  }\n                }\n                break;\n              default:\n                valuesToSuggestions(context, values, related, suggestions);\n            }\n          }\n          if (storageType === Set) {\n            for (const entry of typeSuggestions.values()) {\n              let { suggestions } = entry;\n              if (sort) {\n                suggestions = [...suggestions].sort(sort);\n              }\n              if (filterFactory || isFinite(limit)) {\n                const result2 = [];\n                const accept = filterFactory ? filterFactory(normalizeFilterPattern(entry.text)) : () => true;\n                for (const value2 of suggestions) {\n                  if (accept(value2) && result2.push(value2) >= limit) {\n                    break;\n                  }\n                }\n                suggestions = result2;\n              }\n              entry.suggestions = suggestions;\n            }\n          }\n          for (const entry of typeSuggestions.values()) {\n            entry.suggestions = Array.isArray(entry.suggestions) ? entry.suggestions : [...entry.suggestions];\n            if (entry.suggestions.length) {\n              result.push(entry);\n            }\n          }\n          return result.length ? result : null;\n        }\n      });\n    }\n  });\n\n  // node_modules/jora/src/index.js\n  function defineDictFunction(dict, name, value, queryMethods, queryAssertions) {\n    if (typeof value === "string") {\n      Object.defineProperty(dict, name, {\n        configurable: true,\n        get() {\n          const compiledFn = compileFunction(value, "method")(compile_buildin_default, queryMethods, queryAssertions);\n          const fn = compiledFn;\n          Object.defineProperty(dict, name, { enumerable: true, value: fn });\n          return fn;\n        }\n      });\n    } else if (typeof value === "function") {\n      Object.defineProperty(dict, name, { enumerable: true, value });\n    }\n  }\n  function buildQueryMethodsAndAssertions(customMethods, customAssertions) {\n    if (!customMethods && !customAssertions) {\n      return {\n        queryMethods: methods_default,\n        queryAssertions: assertions_default\n      };\n    }\n    const queryMethods = { ...methods_default };\n    const queryAssertions = { ...assertions_default };\n    for (const [name, value] of Object.entries(customMethods || {})) {\n      if (hasOwn(methods_default, name)) {\n        throw new Error(`Builtin method "${name}" can\'t be overridden`);\n      }\n      defineDictFunction(queryMethods, name, value, queryMethods, queryAssertions);\n    }\n    for (const [name, value] of Object.entries(customAssertions || {})) {\n      if (hasOwn(assertions_default, name)) {\n        throw new Error(`Builtin assertion "${name}" can\'t be overridden`);\n      }\n      defineDictFunction(queryAssertions, name, value, queryMethods, queryAssertions);\n    }\n    return { queryMethods, queryAssertions };\n  }\n  function defaultDebugHandler(sectionName, value) {\n    console.log(`[${sectionName}]`);\n    if (typeof value === "string") {\n      console.log(value);\n    } else if (value !== void 0) {\n      console.dir(value, { depth: null });\n    }\n    console.log();\n  }\n  function compileFunction(source, kind, statMode, tolerantMode, debug) {\n    debug = typeof debug === "function" ? debug : Boolean(debug) ? defaultDebugHandler : false;\n    if (debug) {\n      debug("=========================");\n      debug("Compile query from source", source);\n    }\n    const parseResult = parse_default.parse(source, tolerantMode);\n    if (debug) {\n      debug("AST", parseResult.ast);\n      debug("Restored source", stringify36(parseResult.ast));\n    }\n    const suggestions = statMode ? suggest17(source, parseResult) : null;\n    if (debug && suggestions) {\n      const esc = (s) => JSON.stringify(s).slice(1, -1);\n      const ranges = [].concat(\n        ...[...suggestions.entries()].map(([node, ranges2]) => ranges2.map((range) => [node, ...range]))\n      );\n      let prevRange = [];\n      let prevPrefix = null;\n      debug("Stat/suggestion ranges", ranges.sort((a, b2) => a[1] - b2[1]).map(([node, ...range]) => {\n        const [start, end, type, related] = range;\n        let prelude;\n        if (start === prevRange[0] && end === prevRange[1]) {\n          prelude = " ".repeat(prevPrefix.length);\n        } else {\n          const pre = esc(source.slice(0, start)).length;\n          const long = esc(source.substring(start, end)).length;\n          prevRange = range;\n          prevPrefix = " ".repeat(pre) + (!long ? "\\\\" : "~".repeat(long)) + " " + start + ":" + end;\n          prelude = esc(source) + "\\n" + prevPrefix;\n        }\n        return prelude + " [" + type + "] on " + node.type + (related === true ? " (current)" : related && related.type ? " & " + related.type : "");\n      }).join("\\n"));\n    }\n    const fn = kind === "method" ? compileMethod(parseResult.ast, tolerantMode, suggestions) : compile36(parseResult.ast, tolerantMode, suggestions);\n    if (debug) {\n      debug("Compiled code", fn.toString());\n    }\n    return fn;\n  }\n  function createQuery(source, options2) {\n    options2 = options2 || {};\n    const statMode = Boolean(options2.stat);\n    const tolerantMode = Boolean(options2.tolerant);\n    const cache = statMode ? tolerantMode ? cacheTollerantStat : cacheStrictStat : tolerantMode ? cacheTollerant : cacheStrict;\n    const { methods: customMethods, assertions: customAssertions } = options2 || {};\n    const { queryMethods, queryAssertions } = buildQueryMethodsAndAssertions(customMethods, customAssertions);\n    let fn;\n    source = String(source);\n    if (cache.has(source) && !options2.debug) {\n      fn = cache.get(source);\n    } else {\n      fn = compileFunction(source, "query", statMode, tolerantMode, options2.debug);\n      cache.set(source, fn);\n    }\n    fn = fn(compile_buildin_default, queryMethods, queryAssertions);\n    return statMode ? Object.assign((data, context) => stat_default(source, fn(data, context)), { query: fn }) : fn;\n  }\n  function setup2(options2) {\n    const cacheStrict2 = /* @__PURE__ */ new Map();\n    const cacheStrictStat2 = /* @__PURE__ */ new Map();\n    const cacheTollerant2 = /* @__PURE__ */ new Map();\n    const cacheTollerantStat2 = /* @__PURE__ */ new Map();\n    const { methods: customMethods, assertions: customAssertions } = options2 || {};\n    const { queryMethods, queryAssertions } = buildQueryMethodsAndAssertions(customMethods, customAssertions);\n    return function query(source, queryOptions) {\n      queryOptions = queryOptions || {};\n      const statMode = Boolean(queryOptions.stat);\n      const tolerantMode = Boolean(queryOptions.tolerant);\n      const cache = statMode ? tolerantMode ? cacheTollerantStat2 : cacheStrictStat2 : tolerantMode ? cacheTollerant2 : cacheStrict2;\n      let fn;\n      source = String(source);\n      if (cache.has(source) && !queryOptions.debug) {\n        fn = cache.get(source);\n      } else {\n        const perform = compileFunction(\n          source,\n          "query",\n          statMode,\n          tolerantMode,\n          queryOptions.debug\n        )(\n          compile_buildin_default,\n          queryMethods,\n          queryAssertions\n        );\n        fn = statMode ? Object.assign((data, context) => stat_default(source, perform(data, context)), { query: perform }) : perform;\n        cache.set(source, fn);\n      }\n      return fn;\n    };\n  }\n  var cacheStrict, cacheStrictStat, cacheTollerant, cacheTollerantStat, src_default;\n  var init_src2 = __esm({\n    "node_modules/jora/src/index.js"() {\n      init_version2();\n      init_misc();\n      init_parse();\n      init_suggest();\n      init_walk();\n      init_stringify();\n      init_compile();\n      init_compile_buildin();\n      init_methods();\n      init_assertions();\n      init_stat();\n      cacheStrict = /* @__PURE__ */ new Map();\n      cacheStrictStat = /* @__PURE__ */ new Map();\n      cacheTollerant = /* @__PURE__ */ new Map();\n      cacheTollerantStat = /* @__PURE__ */ new Map();\n      src_default = Object.assign(createQuery, {\n        version: version2,\n        buildin: compile_buildin_default,\n        methods: methods_default,\n        assertions: assertions_default,\n        setup: setup2,\n        syntax: {\n          tokenize: parse_default.tokenize,\n          parse: parse_default.parse,\n          suggest: suggest17,\n          walk: walk36,\n          stringify: stringify36,\n          compile: compile36,\n          compileMethod\n        }\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/compare.js\n  var compare_exports = {};\n  __export(compare_exports, {\n    deepEqual: () => deepEqual,\n    equal: () => equal\n  });\n  function equal(a, b2, compare2 = Object.is) {\n    if (a === b2) {\n      return true;\n    }\n    if (!a || typeof a !== "object" || !b2 || typeof b2 !== "object") {\n      return false;\n    }\n    for (const key2 in a) {\n      if (hasOwn2(a, key2)) {\n        if (!hasOwn2(b2, key2) || !compare2(a[key2], b2[key2], compare2)) {\n          return false;\n        }\n      }\n    }\n    for (const key2 in b2) {\n      if (hasOwn2(b2, key2)) {\n        if (!hasOwn2(a, key2)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  var hasOwn2, deepEqual;\n  var init_compare2 = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/compare.js"() {\n      hasOwn2 = Object.hasOwn || ((obj, key2) => Object.prototype.hasOwnProperty.call(obj, key2));\n      deepEqual = (a, b2) => equal(a, b2, equal);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/dict.js\n  var entries, Dictionary;\n  var init_dict = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/dict.js"() {\n      init_emitter();\n      entries = /* @__PURE__ */ new WeakMap();\n      Dictionary = class extends Emitter {\n        constructor(allowRevoke) {\n          super();\n          entries.set(this, /* @__PURE__ */ new Map());\n          if (allowRevoke) {\n            this.revoke = (key2) => {\n              entries.get(this).delete(key2);\n              this.emit("revoke", key2);\n            };\n          }\n        }\n        define(key2, value) {\n          entries.get(this).set(key2, value);\n          this.emit("define", key2, value);\n          return value;\n        }\n        isDefined(key2) {\n          return entries.get(this).has(key2);\n        }\n        has(key2) {\n          return entries.get(this).has(key2);\n        }\n        get(key2) {\n          return entries.get(this).get(key2);\n        }\n        get names() {\n          return [...entries.get(this).keys()];\n        }\n        get keys() {\n          return entries.get(this).keys();\n        }\n        get values() {\n          return entries.get(this).values();\n        }\n        get entries() {\n          return entries.get(this).entries();\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/action.js\n  var actionMap, ActionManager;\n  var init_action = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/action.js"() {\n      init_dict();\n      actionMap = /* @__PURE__ */ new WeakMap();\n      ActionManager = class extends Dictionary {\n        constructor() {\n          super(true);\n          actionMap.set(this, /* @__PURE__ */ Object.create(null));\n        }\n        define(name, callback) {\n          if (typeof callback !== "function") {\n            throw new Error("callback is not a function");\n          }\n          actionMap.set(this, Object.freeze({\n            ...actionMap.get(this),\n            [name]: callback\n          }));\n          super.define(name, Object.freeze({\n            name,\n            callback\n          }));\n        }\n        revoke(name) {\n          if (this.has(name)) {\n            const map2 = { ...actionMap.get(this) };\n            delete map2[name];\n            actionMap.set(this, Object.freeze(map2));\n          }\n          super.revoke(name);\n        }\n        get actionMap() {\n          return actionMap.get(this);\n        }\n        call(name, ...args) {\n          if (!this.has(name)) {\n            throw new Error(`action "${name}" doesn\'t exist`);\n          }\n          const { callback } = this.get(name);\n          return callback(...args);\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/page.js\n  var CONFIG, BUILDIN_NOT_FOUND, PageRenderer;\n  var init_page = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/page.js"() {\n      init_dict();\n      init_publisher();\n      init_dom();\n      CONFIG = Symbol("config");\n      BUILDIN_NOT_FOUND = {\n        name: "not-found",\n        render: (el, { name }) => {\n          el.style.cssText = "color:#a00";\n          el.innerText = `Page \\`${name}\\` not found`;\n        }\n      };\n      PageRenderer = class extends Dictionary {\n        constructor(host) {\n          super();\n          this.host = host;\n          this.lastPage = null;\n          this.lastPageId = null;\n          this.pageOverscrolled = new Publisher(false);\n          this.setPageOverscroll = () => {\n          };\n          if (typeof IntersectionObserver === "function") {\n            const pageOverscrollTriggerEl = createElement("div", { style: "position:absolute" });\n            const root = host.dom.content;\n            let overscrollObserver = null;\n            let unsubscribe = () => {\n            };\n            if (overscrollObserver) {\n              overscrollObserver.disconnect();\n              overscrollObserver = null;\n            }\n            if (root) {\n              overscrollObserver = new IntersectionObserver(\n                (entries2) => this.pageOverscrolled.set(!entries2[entries2.length - 1].isIntersecting),\n                { root }\n              );\n              this.setPageOverscroll = (newPageEl) => {\n                overscrollObserver.unobserve(pageOverscrollTriggerEl);\n                unsubscribe();\n                if (newPageEl) {\n                  newPageEl.prepend(pageOverscrollTriggerEl);\n                  overscrollObserver.observe(pageOverscrollTriggerEl);\n                  unsubscribe = this.pageOverscrolled.subscribeSync(\n                    (overscrolled) => newPageEl.classList.toggle("page_overscrolled", overscrolled)\n                  );\n                }\n              };\n            }\n          }\n        }\n        define(name, render2, options2) {\n          super.define(name, Object.freeze({\n            name,\n            render: typeof render2 === "function" ? render2.bind(this.host.view) : (el, data, context) => this.host.view.render(el, render2, data, context),\n            options: Object.freeze({ ...options2 }),\n            [CONFIG]: render2\n          }));\n        }\n        render(prevPageEl, name, data, context) {\n          const renderStartTime = Date.now();\n          let page = this.get(name);\n          let rendered;\n          if (!page) {\n            page = this.get("not-found") || BUILDIN_NOT_FOUND;\n            data = { name };\n          }\n          const { reuseEl, init, keepScrollOffset = true } = page.options || {};\n          const pageChanged = this.lastPage !== name;\n          const pageRef = context && context.id;\n          const pageRefChanged = this.lastPageId !== pageRef;\n          const newPageEl = reuseEl && !pageChanged ? prevPageEl : document.createElement("article");\n          const parentEl = prevPageEl.parentNode;\n          this.lastPage = name;\n          this.lastPageId = pageRef;\n          newPageEl.id = prevPageEl.id;\n          newPageEl.classList.add("page", "page-" + name);\n          if (pageChanged && typeof init === "function") {\n            init(newPageEl);\n          }\n          try {\n            rendered = page.render(newPageEl, data, context);\n          } catch (e) {\n            rendered = this.host.view.render(newPageEl, "alert-danger", String(e) + " (see details in console)");\n            this.host.log("error", "Page render error:", e);\n          }\n          if (pageChanged || pageRefChanged || !keepScrollOffset) {\n            parentEl.scrollTop = 0;\n          }\n          if (newPageEl !== prevPageEl) {\n            prevPageEl.replaceWith(newPageEl);\n            this.setPageOverscroll(newPageEl);\n          }\n          return {\n            pageEl: newPageEl,\n            config: page[CONFIG],\n            renderState: Promise.resolve(rendered).finally(() => this.host.log(\n              "perf",\n              `Page "${page.name}" rendered in ${Date.now() - renderStartTime}ms`\n            ))\n          };\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/view.js\n  function regConfigTransition(res, from) {\n    configTransitions.set(res, from);\n    return res;\n  }\n  function collectViewTree(viewRenderer, node, parent, ignoreNodes) {\n    if (ignoreNodes.has(node)) {\n      return;\n    }\n    if (viewRenderer.fragmentEls.has(node)) {\n      for (const info of viewRenderer.fragmentEls.get(node)) {\n        const child = parent.children.find((child2) => child2.view === info);\n        if (child) {\n          parent = child;\n        } else {\n          parent.children.push(parent = {\n            node: null,\n            parent,\n            view: info,\n            children: []\n          });\n        }\n      }\n    }\n    if (rootViewEls.has(node)) {\n      parent.children.push(parent = {\n        node,\n        parent,\n        viewRoot: rootViewEls.get(node),\n        children: []\n      });\n    } else if (viewRenderer.viewEls.has(node)) {\n      parent.children.push(parent = {\n        node,\n        parent,\n        view: viewRenderer.viewEls.get(node),\n        children: []\n      });\n    }\n    if (node.nodeType === 1) {\n      for (let child = node.firstChild; child; child = child.nextSibling) {\n        collectViewTree(viewRenderer, child, parent, ignoreNodes);\n      }\n    }\n  }\n  function createDefaultRenderErrorView(view) {\n    return {\n      name: false,\n      options: STUB_OBJECT,\n      render(el, config) {\n        el.className = "discovery-buildin-view-render-error";\n        el.dataset.type = config.type;\n        el.textContent = config.reason;\n        if ("config" in config) {\n          const configEl = el.appendChild(document.createElement("span"));\n          configEl.className = "toggle-config";\n          configEl.textContent = "show config...";\n          configEl.addEventListener("click", () => {\n            if (el.classList.toggle("expanded")) {\n              configEl.textContent = "hide config...";\n              view.render(el, { view: "struct", expanded: 1 }, config.config);\n            } else {\n              configEl.textContent = "show config...";\n              el.lastChild.remove();\n            }\n          });\n        }\n      }\n    };\n  }\n  function condition(type, viewRenderer, config, queryData, context, inputData, inputDataIndex, placeholder) {\n    if (!hasOwnProperty2.call(config, type) || config[type] === void 0) {\n      return true;\n    }\n    if (viewRenderer.host.queryBool(config[type] === true ? "" : config[type], queryData, context)) {\n      return true;\n    }\n    viewRenderer.viewEls.set(placeholder, {\n      skipped: type,\n      config,\n      inputData,\n      inputDataIndex,\n      data: queryData,\n      context\n    });\n    return false;\n  }\n  function computeClassName(host, className, data, context) {\n    let classNames2 = className;\n    if (typeof classNames2 === "string" && classNames2.startsWith("=")) {\n      classNames2 = host.queryFn(classNames2.slice(1));\n    }\n    if (typeof classNames2 === "function") {\n      classNames2 = classNames2(data, context);\n    }\n    if (typeof classNames2 === "string") {\n      classNames2 = classNames2.trim().split(/\\s+/);\n    }\n    if (Array.isArray(classNames2)) {\n      classNames2 = classNames2.map((item) => typeof item === "function" ? item(data, context) : item).filter(Boolean);\n      if (classNames2.length) {\n        return classNames2;\n      }\n    }\n    return null;\n  }\n  function renderDom(viewRenderer, renderer, placeholder, config, props, data, context, inputData, inputDataIndex) {\n    const { tag } = renderer.options;\n    const el = tag === false || tag === null ? document.createDocumentFragment() : document.createElement(tag || "div");\n    let pipeline = Promise.resolve(renderer.render(el, props, data, context));\n    if (typeof config.postRender === "function") {\n      pipeline = pipeline.then(() => config.postRender(el, config, data, context));\n    }\n    return pipeline.then(function() {\n      const info = {\n        config,\n        props,\n        inputData,\n        inputDataIndex,\n        data,\n        context\n      };\n      if (el.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n        viewRenderer.viewEls.set(el, info);\n        if (renderer.name) {\n          el.classList.add(`view-${renderer.name}`);\n        }\n        if (config.className) {\n          const classNames2 = computeClassName(viewRenderer.host, config.className, data, context);\n          if (classNames2 !== null) {\n            el.classList.add(...classNames2);\n          }\n        }\n        if (props.tooltip) {\n          attachTooltip(viewRenderer.host, el, props.tooltip, data, context);\n        }\n      } else {\n        for (let child of el.childNodes) {\n          if (viewRenderer.fragmentEls.has(child)) {\n            viewRenderer.fragmentEls.get(child).unshift(info);\n          } else {\n            viewRenderer.fragmentEls.set(child, [info]);\n          }\n        }\n      }\n      placeholder.replaceWith(el);\n    });\n  }\n  function createRenderContext(viewRenderer, name) {\n    return {\n      name,\n      // block() {\n      //     return `view-${name}`;\n      // },\n      // blockMod(modifierName, value = true) {\n      //     return `${this.block()}_${modifierName}${value === true ? \'\' : \'_\' + value}`;\n      // },\n      // element(elementName) {\n      //     return `${this.block()}__${elementName}`;\n      // },\n      // elementMod(elementName, modifierName, value = true) {\n      //     return `${this.element(elementName)}_${modifierName}${value === true ? \'\' : \'_\' + value}`;\n      // },\n      normalizeConfig: viewRenderer.normalizeConfig.bind(viewRenderer),\n      ensureValidConfig: viewRenderer.ensureValidConfig.bind(viewRenderer),\n      composeConfig: viewRenderer.composeConfig.bind(viewRenderer),\n      propsFromConfig: viewRenderer.propsFromConfig.bind(viewRenderer),\n      render: viewRenderer.render.bind(viewRenderer),\n      listLimit: viewRenderer.listLimit.bind(viewRenderer),\n      renderList: viewRenderer.renderList.bind(viewRenderer),\n      maybeMoreButtons: viewRenderer.maybeMoreButtons.bind(viewRenderer),\n      renderMoreButton: viewRenderer.renderMoreButton.bind(viewRenderer),\n      tooltip(el, config, data, context) {\n        if (el && el.nodeType === 1) {\n          attachTooltip(viewRenderer.host, el, config, data, context);\n        } else {\n          viewRenderer.host.log("warn", "A tooltip can be attached to a HTML element only");\n        }\n      }\n    };\n  }\n  function attachTooltip(host, el, config, data, context) {\n    el.classList.add("discovery-view-has-tooltip");\n    tooltipEls.set(el, [config, data, context]);\n    if (!host.view.tooltip) {\n      host.view.tooltip = createTooltip(host);\n    }\n  }\n  function isPopupConfig(value) {\n    return value && !Array.isArray(value) && typeof value !== "string" && typeof value !== "function" && !value.view;\n  }\n  function createTooltip(host) {\n    let classNames2 = null;\n    const popup = new host.view.Popup({\n      className: "discovery-buildin-view-tooltip",\n      hoverTriggers: ".discovery-view-has-tooltip",\n      position: "pointer",\n      showDelay(triggerEl) {\n        let [config] = tooltipEls.get(triggerEl) || [];\n        if (isPopupConfig(config)) {\n          return config.showDelay;\n        }\n      },\n      render(el, triggerEl) {\n        let [config, data, context] = tooltipEls.get(triggerEl) || [];\n        let position = "pointer";\n        let positionMode = "natural";\n        let pointerOffsetX = 3;\n        let pointerOffsetY = 3;\n        let content = config;\n        if (classNames2 !== null) {\n          el.classList.remove(...classNames2);\n          classNames2 = null;\n        }\n        if (isPopupConfig(config)) {\n          classNames2 = computeClassName(host, config.className, data, context);\n          if (classNames2 !== null) {\n            el.classList.add(...classNames2);\n          }\n          position = config.position || position;\n          positionMode = config.positionMode || positionMode;\n          if (Number.isFinite(config.pointerOffsetX)) {\n            pointerOffsetX = config.pointerOffsetX;\n          }\n          if (Number.isFinite(config.pointerOffsetY)) {\n            pointerOffsetY = config.pointerOffsetY;\n          }\n          content = config.content;\n        }\n        popup.position = position;\n        popup.positionMode = positionMode;\n        popup.pointerOffsetX = pointerOffsetX;\n        popup.pointerOffsetY = pointerOffsetY;\n        if (content) {\n          return host.view.render(el, content, data, context);\n        }\n        return host.view.render(el, {\n          view: host.view.defaultRenderErrorRenderer.render,\n          reason: "Element marked as having a tooltip but related data is not found"\n        });\n      }\n    });\n    return popup;\n  }\n  function render(viewRenderer, container, config, inputData, inputDataIndex, context) {\n    if (Array.isArray(config)) {\n      return Promise.all(config.map(\n        (config2) => render(viewRenderer, container, config2, inputData, inputDataIndex, context)\n      ));\n    }\n    const queryData = inputData && typeof inputDataIndex === "number" ? inputData[inputDataIndex] : inputData;\n    let renderer = null;\n    switch (typeof config.view) {\n      case "function":\n        renderer = {\n          name: false,\n          options: STUB_OBJECT,\n          render: config.view\n        };\n        break;\n      case "string":\n        if (config.view === "render") {\n          const {\n            config: configQuery = "",\n            context: contextQuery = ""\n          } = config;\n          renderer = {\n            name: false,\n            options: { tag: false },\n            render: (el, _, _data) => {\n              const _config = configQuery !== "" ? viewRenderer.host.query(configQuery, queryData, context) : _data;\n              const _context = viewRenderer.host.query(contextQuery, context, queryData);\n              return viewRenderer.render(\n                el,\n                _config,\n                _data !== _config ? _data : queryData,\n                _context\n              );\n            }\n          };\n        } else if (config.view.startsWith("preset/")) {\n          const presetName = config.view.substr(7);\n          renderer = {\n            name: false,\n            options: { tag: false },\n            render: viewRenderer.host.preset.isDefined(presetName) ? viewRenderer.host.preset.get(presetName).render : () => {\n            }\n          };\n        } else {\n          renderer = viewRenderer.get(config.view);\n        }\n        break;\n    }\n    if (!renderer) {\n      const errorMsg = typeof config.view === "string" ? "View `" + config.view + "` is not found" : "Render is not a function";\n      viewRenderer.host.log("error", errorMsg, config);\n      renderer = viewRenderer.defaultRenderErrorRenderer;\n      config = { type: "config", reason: errorMsg, config };\n    }\n    if (!container) {\n      container = document.createDocumentFragment();\n    }\n    const placeholder = container.appendChild(document.createComment(""));\n    if (condition("when", viewRenderer, config, queryData, context, inputData, inputDataIndex, placeholder)) {\n      const getData = "data" in config ? Promise.resolve(viewRenderer.host.query(config.data, queryData, context)) : Promise.resolve(queryData);\n      return getData.then(\n        (outputData) => condition("whenData", viewRenderer, config, outputData, context, inputData, inputDataIndex, placeholder) ? renderDom(\n          viewRenderer,\n          renderer,\n          placeholder,\n          config,\n          viewRenderer.propsFromConfig(config, outputData, context),\n          outputData,\n          context,\n          inputData,\n          inputDataIndex\n        ) : null\n        // placeholder.remove()\n      ).catch((e) => {\n        renderDom(viewRenderer, viewRenderer.defaultRenderErrorRenderer, placeholder, STUB_OBJECT, {\n          type: "render",\n          reason: String(e),\n          config\n        });\n        viewRenderer.host.log("error", "View render error:", e);\n      });\n    }\n    return Promise.resolve();\n  }\n  var STUB_OBJECT, hasOwnProperty2, tooltipEls, rootViewEls, configTransitions, configOnlyProps, ViewRenderer;\n  var init_view = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/view.js"() {\n      init_dict();\n      STUB_OBJECT = Object.freeze({});\n      ({ hasOwnProperty: hasOwnProperty2 } = Object);\n      tooltipEls = /* @__PURE__ */ new WeakMap();\n      rootViewEls = /* @__PURE__ */ new WeakMap();\n      configTransitions = /* @__PURE__ */ new WeakMap();\n      configOnlyProps = /* @__PURE__ */ new Set([\n        "view",\n        "when",\n        "data",\n        "whenData",\n        "postRender",\n        "className"\n      ]);\n      ViewRenderer = class extends Dictionary {\n        constructor(host) {\n          super();\n          this.host = host;\n          this.defaultRenderErrorRenderer = createDefaultRenderErrorView(this);\n          this.viewEls = /* @__PURE__ */ new WeakMap();\n          this.fragmentEls = /* @__PURE__ */ new WeakMap();\n        }\n        define(name, render2, options2) {\n          super.define(name, Object.freeze({\n            name,\n            options: Object.freeze({ ...options2 }),\n            render: typeof render2 === "function" ? render2.bind(createRenderContext(this, name)) : (el, _, data, context) => this.render(el, render2, data, context)\n          }));\n        }\n        normalizeConfig(config) {\n          if (!config) {\n            return null;\n          }\n          if (Array.isArray(config)) {\n            return config.reduce(\n              (res, item) => res.concat(this.normalizeConfig(item) || []),\n              []\n            );\n          }\n          if (typeof config === "string") {\n            const [, prefix, op, query] = config.match(/^(\\S+?)([:{])((?:.|\\s)+)$/) || [];\n            if (prefix) {\n              if (op === "{") {\n                try {\n                  return regConfigTransition(\n                    this.host.queryToConfig(prefix, op + query),\n                    config\n                  );\n                } catch (error) {\n                  return regConfigTransition(\n                    this.badConfig(config, error),\n                    config\n                  );\n                }\n              }\n              return regConfigTransition({\n                view: prefix,\n                data: query\n              }, config);\n            }\n            return regConfigTransition({\n              view: config\n            }, config);\n          } else if (typeof config === "function") {\n            return regConfigTransition({\n              view: config\n            }, config);\n          }\n          return config;\n        }\n        badConfig(config, error) {\n          const errorMsg = error && error.message || "Unknown error";\n          this.host.log("error", errorMsg, { config, error });\n          return {\n            view: this.defaultRenderErrorRenderer.render,\n            type: "config",\n            reason: errorMsg,\n            config\n          };\n        }\n        ensureValidConfig(config) {\n          if (Array.isArray(config)) {\n            return config.map((item) => this.ensureValidConfig(item));\n          }\n          if (!config || !config.view) {\n            return this.badConfig(config, new Error(!config ? "Config is not a valid value" : "Option `view` is missed"));\n          }\n          return config;\n        }\n        composeConfig(config, extension) {\n          config = this.normalizeConfig(config);\n          extension = this.normalizeConfig(extension);\n          if (config && extension) {\n            return Array.isArray(config) ? config.map((item) => regConfigTransition({ ...item, ...extension }, [item, extension])) : regConfigTransition({ ...config, ...extension }, [config, extension]);\n          }\n          return config || extension;\n        }\n        propsFromConfig(config, data, context) {\n          const props = regConfigTransition({}, config);\n          for (const [key2, value] of Object.entries(config)) {\n            if (!configOnlyProps.has(key2)) {\n              props[key2] = typeof value === "string" && value.startsWith("=") ? this.host.query(value.slice(1), data, context) : value;\n            }\n          }\n          return props;\n        }\n        render(container, config, data, context, dataIndex) {\n          return render(\n            this,\n            container,\n            this.ensureValidConfig(this.normalizeConfig(config)),\n            data,\n            dataIndex,\n            context\n          );\n        }\n        listLimit(value, defaultValue) {\n          if (value === false) {\n            return false;\n          }\n          if (!value || isNaN(value)) {\n            return defaultValue;\n          }\n          return Math.max(parseInt(value, 10), 0) || defaultValue;\n        }\n        renderList(container, itemConfig, data, context, offset = 0, limit = false, moreContainer) {\n          if (limit === false) {\n            limit = data.length;\n          }\n          const result = Promise.all(\n            data.slice(offset, offset + limit).map(\n              (_, sliceIndex, slice2) => this.render(container, itemConfig, data, {\n                ...context,\n                index: offset + sliceIndex,\n                array: data,\n                sliceIndex,\n                slice: slice2\n              }, offset + sliceIndex)\n            )\n          );\n          this.maybeMoreButtons(\n            moreContainer || container,\n            null,\n            data.length,\n            offset + limit,\n            limit,\n            (offset2, limit2) => this.renderList(container, itemConfig, data, context, offset2, limit2, moreContainer)\n          );\n          return result;\n        }\n        maybeMoreButtons(container, beforeEl, count3, offset, limit, renderMore) {\n          const restCount = count3 - offset;\n          const buttons = restCount <= 0 ? null : document.createElement("span");\n          if (restCount > limit) {\n            this.renderMoreButton(\n              buttons,\n              "Show " + limit + " more...",\n              () => renderMore(offset, limit)\n            );\n          }\n          if (restCount > 0) {\n            this.renderMoreButton(\n              buttons,\n              "Show all the rest " + restCount + " items...",\n              () => renderMore(offset, Infinity)\n            );\n          }\n          if (buttons !== null) {\n            buttons.className = "more-buttons";\n            container.insertBefore(buttons, beforeEl);\n          }\n          return buttons;\n        }\n        renderMoreButton(container, caption, fn) {\n          const moreButton = document.createElement("button");\n          moreButton.className = "more-button";\n          moreButton.innerHTML = caption;\n          moreButton.addEventListener("click", () => {\n            container.remove();\n            fn();\n          });\n          container.appendChild(moreButton);\n        }\n        attachTooltip(el, config, data, context) {\n          attachTooltip(this.host, el, config, data, context);\n        }\n        adoptFragment(fragment, probe) {\n          const info = this.fragmentEls.get(probe);\n          if (info) {\n            for (const node of fragment.childNodes) {\n              this.fragmentEls.set(node, info);\n            }\n          }\n        }\n        setViewRoot(node, name, props) {\n          rootViewEls.set(node, {\n            name,\n            ...props\n          });\n        }\n        getViewTree(ignore) {\n          const ignoreNodes = new Set(ignore || []);\n          const result = [];\n          collectViewTree(this, this.host.dom.container, { parent: null, children: result }, ignoreNodes);\n          return result;\n        }\n        getViewStackTrace(el) {\n          const { container: root } = this.host.dom;\n          if (!root || el instanceof Node === false || !root.contains(el)) {\n            return null;\n          }\n          const stack = [];\n          let cursor = el;\n          while (cursor !== root) {\n            if (this.viewEls.has(cursor)) {\n              stack.push(this.viewEls.get(cursor));\n            }\n            cursor = cursor.parentNode;\n          }\n          if (stack.length === 0) {\n            return null;\n          }\n          return stack.reverse();\n        }\n        getViewConfigTransitionTree(value) {\n          let deps = configTransitions.get(value) || [];\n          if (!Array.isArray(deps)) {\n            deps = [deps];\n          }\n          return {\n            value,\n            deps: deps.map(this.getViewConfigTransitionTree, this)\n          };\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/preset.js\n  var PresetRenderer;\n  var init_preset = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/preset.js"() {\n      init_dict();\n      PresetRenderer = class extends Dictionary {\n        constructor(view) {\n          super();\n          this.view = view;\n        }\n        define(name, config) {\n          config = JSON.parse(JSON.stringify(config));\n          super.define(name, Object.freeze({\n            name,\n            render: (el, _, data, context) => this.view.render(el, config, data, context),\n            config\n          }));\n        }\n        render(container, name, data, context) {\n          let preset = this.get(name);\n          if (!preset) {\n            const errorMsg = "Preset `" + name + "` is not found";\n            console.error(errorMsg, name);\n            const el = container.appendChild(document.createElement("div"));\n            el.className = "discovery-buildin-view-config-error";\n            el.textContent = errorMsg;\n            return Promise.resolve();\n          }\n          return preset.render(container, null, data, context);\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/layout.js\n  var layout_exports = {};\n  __export(layout_exports, {\n    getBoundingRect: () => getBoundingRect,\n    getOffsetParent: () => getOffsetParent,\n    getOverflowParent: () => getOverflowParent,\n    getPageOffset: () => getPageOffset,\n    getViewportRect: () => getViewportRect\n  });\n  function getOffsetParent(node) {\n    let offsetParent = node.offsetParent;\n    while (offsetParent !== null && offsetParent !== documentElement && getComputedStyle(offsetParent).position === "static") {\n      offsetParent = offsetParent.offsetParent;\n    }\n    return offsetParent || documentElement;\n  }\n  function getOverflowParent(node) {\n    let overflowParent = node.parentNode;\n    while (overflowParent !== null && overflowParent !== documentElement && getComputedStyle(overflowParent).overflow === "visible") {\n      overflowParent = overflowParent.parentNode;\n    }\n    return overflowParent || documentElement;\n  }\n  function getPageOffset(element) {\n    let top = 0;\n    let left = 0;\n    if (element && element.getBoundingClientRect) {\n      const rect = element.getBoundingClientRect();\n      top = -rect.top;\n      left = -rect.left;\n    } else {\n      if (standartsMode) {\n        top = window.pageYOffset || documentElement.scrollTop;\n        left = window.pageXOffset || documentElement.scrollLeft;\n      } else {\n        const { body } = document;\n        if (element !== body) {\n          top = body.scrollTop - body.clientTop;\n          left = body.scrollLeft - body.clientLeft;\n        }\n      }\n    }\n    return {\n      left,\n      top\n    };\n  }\n  function getBoundingRect(element, relElement) {\n    const offset = getPageOffset(relElement);\n    let top = 0;\n    let left = 0;\n    let right = 0;\n    let bottom = 0;\n    if (element && element.getBoundingClientRect) {\n      ({ top, left, right, bottom } = element.getBoundingClientRect());\n    }\n    return {\n      top: top + offset.top,\n      left: left + offset.left,\n      right: right + offset.left,\n      bottom: bottom + offset.top,\n      width: right - left,\n      height: bottom - top\n    };\n  }\n  function getViewportRect(element, relElement) {\n    const topViewport = standartsMode ? document.documentElement : document.body;\n    let { top, left } = element === topViewport && !relElement ? getPageOffset() : getBoundingRect(element, relElement);\n    let width;\n    let height;\n    if (!element || element === window) {\n      width = window.innerWidth || 0;\n      height = window.innerHeight || 0;\n    } else {\n      top += element.clientTop;\n      left += element.clientLeft;\n      width = element.clientWidth;\n      height = element.clientHeight;\n    }\n    return {\n      top,\n      left,\n      right: left + width,\n      bottom: top + height,\n      width,\n      height\n    };\n  }\n  var documentElement, standartsMode;\n  var init_layout = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/layout.js"() {\n      ({ documentElement } = document);\n      standartsMode = document.compatMode === "CSS1Compat";\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/pointer.js\n  var pointer_exports = {};\n  __export(pointer_exports, {\n    pointerXY: () => pointerXY\n  });\n  var lastPointerXYPublisher, pointerXY;\n  var init_pointer = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/pointer.js"() {\n      init_dom();\n      init_publisher();\n      lastPointerXYPublisher = new Publisher(\n        { x: 0, y: 0 },\n        (newCoords, oldCoords) => newCoords.x !== oldCoords.x || newCoords.y !== oldCoords.y\n      );\n      document.addEventListener(\n        "pointermove",\n        ({ x, y: y2 }) => lastPointerXYPublisher.set({ x, y: y2 }),\n        passiveCaptureOptions\n      );\n      pointerXY = lastPointerXYPublisher.readonly;\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/debounce.js\n  function isObject3(value) {\n    const type = typeof value;\n    return value != null && (type === "object" || type === "function");\n  }\n  function debounce(func, options2) {\n    if (typeof options2 === "number") {\n      options2 = { wait: options2 };\n    }\n    if (!isObject3(options2)) {\n      return func;\n    }\n    let { wait } = options2;\n    let lastArgs;\n    let lastThis;\n    let maxWait;\n    let result;\n    let timerId;\n    let lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    if (typeof func !== "function") {\n      throw new TypeError("Expected a function");\n    }\n    wait = Math.max(0, Number(wait) || 0);\n    leading = Boolean(options2.leading);\n    maxing = "maxWait" in options2;\n    maxWait = maxing ? Math.max(Number(options2.maxWait) || 0, wait) : maxWait;\n    trailing = "trailing" in options2 ? Boolean(options2.trailing) : trailing;\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = void 0;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n    function startTimer(pendingFunc, wait2) {\n      return setTimeout(pendingFunc, wait2);\n    }\n    function cancelTimer(id) {\n      clearTimeout(id);\n    }\n    function leadingEdge(time) {\n      lastInvokeTime = time;\n      timerId = startTimer(timerExpired, wait);\n      return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      const timeWaiting = wait - timeSinceLastCall;\n      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n    function timerExpired() {\n      const time = Date.now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n      timerId = void 0;\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = void 0;\n      return result;\n    }\n    function cancel() {\n      if (timerId !== void 0) {\n        cancelTimer(timerId);\n      }\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = void 0;\n    }\n    function flush() {\n      return timerId === void 0 ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n      return timerId !== void 0;\n    }\n    function debounced(...args) {\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n      if (isInvoking) {\n        if (timerId === void 0) {\n          return leadingEdge(lastCallTime);\n        }\n        if (maxing) {\n          timerId = startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === void 0) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n  }\n  var init_debounce = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/debounce.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/extensions/inspector/view-tree.js\n  function scrollIntoViewIfNeeded2(element) {\n    const viewportEl = getOverflowParent(element);\n    const elementRect = getBoundingRect(element, viewportEl);\n    const scrollMarginTop = 0;\n    const scrollMarginLeft = 0;\n    const { scrollTop, scrollLeft, clientWidth, clientHeight } = viewportEl;\n    const viewportTop = scrollTop + scrollMarginTop;\n    const viewportLeft = scrollLeft + scrollMarginLeft;\n    const viewportRight = scrollLeft + clientWidth;\n    const viewportBottom = scrollTop + clientHeight;\n    const elementTop = scrollTop + elementRect.top;\n    const elementLeft = scrollLeft + elementRect.left;\n    const elementRight = elementLeft + elementRect.width;\n    let scrollToTop = scrollTop;\n    let scrollToLeft = scrollLeft;\n    if (elementTop < viewportTop || elementTop > viewportBottom) {\n      scrollToTop = elementTop - scrollMarginTop;\n    }\n    if (elementLeft < viewportLeft) {\n      scrollToLeft = elementLeft - scrollMarginLeft;\n    } else if (elementRight > viewportRight) {\n      scrollToLeft = Math.max(elementLeft, scrollLeft - (elementRight - viewportRight)) - scrollMarginLeft;\n    }\n    viewportEl?.scrollTo(scrollToLeft, scrollToTop);\n  }\n  function resetViewTreeScrollTopBeforeSelect() {\n    viewTreeScrollTopBeforeSelect = 0;\n  }\n  function viewTree(el, { selectTreeViewLeaf, detailsSidebarLeafExpanded }) {\n    return {\n      view: "tree",\n      when: "#.selectedView",\n      data: "$[0]",\n      className: "sidebar",\n      limitLines: false,\n      itemConfig: {\n        collapsible: "=not viewRoot",\n        expanded: (leaf) => leaf.viewRoot || detailsSidebarLeafExpanded.has(leaf),\n        onToggle: (state, _, leaf) => state ? detailsSidebarLeafExpanded.add(leaf) : detailsSidebarLeafExpanded.delete(leaf)\n      },\n      item: {\n        view: "switch",\n        content: [\n          {\n            when: "viewRoot",\n            content: {\n              view: "block",\n              className: "view-root",\n              content: "text:viewRoot.name"\n            }\n          },\n          {\n            when: "$ = #.selectedView",\n            content: [\n              {\n                view: "block",\n                className: [\n                  (data) => data.view?.skipped ? "skipped" : false,\n                  "selected"\n                ],\n                content: \'text:view.config.view or "#root" | is string ?: "\\u0192n"\',\n                postRender(el_) {\n                  requestAnimationFrame(() => {\n                    el.querySelector(".sidebar").scrollTop = viewTreeScrollTopBeforeSelect;\n                    scrollIntoViewIfNeeded2(el_);\n                  });\n                }\n              },\n              ...sidebarLeafBadges\n            ]\n          },\n          {\n            content: [\n              {\n                view: "link",\n                className: (data) => data.view?.skipped ? "skipped" : false,\n                data: \'{ text: view.config.view or "#root" | is string ?: "\\u0192n", href: false, view, self: $ }\',\n                onClick(_, data) {\n                  viewTreeScrollTopBeforeSelect = el.querySelector(".sidebar")?.scrollTop || 0;\n                  selectTreeViewLeaf(data.self);\n                }\n              },\n              ...sidebarLeafBadges\n            ]\n          }\n        ]\n      }\n    };\n  }\n  var viewTreeScrollTopBeforeSelect, sidebarLeafBadges;\n  var init_view_tree = __esm({\n    "node_modules/@discoveryjs/discovery/src/extensions/inspector/view-tree.js"() {\n      init_layout();\n      viewTreeScrollTopBeforeSelect = 0;\n      sidebarLeafBadges = [\n        {\n          view: "badge",\n          when: \'view.data != parent.(view or viewRoot).data or "data" in view.config\',\n          data: { text: "D" },\n          tooltip: \'text:"Data value was changed"\'\n        },\n        {\n          view: "badge",\n          when: "view.context != parent.(view or viewRoot).context",\n          data: { text: "C" },\n          tooltip: \'text:"Context value was changed"\'\n        }\n      ];\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/extensions/inspector/props-config.js\n  var propsConfigView;\n  var init_props_config = __esm({\n    "node_modules/@discoveryjs/discovery/src/extensions/inspector/props-config.js"() {\n      propsConfigView = {\n        view: "block",\n        className: ["content", "props-config"],\n        data: "#.view | view or viewRoot",\n        content: [\n          {\n            view: "block",\n            className: "content-section skip",\n            when: "skipped",\n            content: \'block{ content: "badge:{ text: skipped }" }\'\n          },\n          {\n            view: "block",\n            className: "content-section render",\n            when: "config.view is not string",\n            content: \'source:{ content: config.view + "", syntax: "js" }\'\n          },\n          {\n            view: "block",\n            when: "props != undefined",\n            className: "content-section props",\n            content: {\n              view: "struct",\n              expanded: 2,\n              data: "props"\n            }\n          },\n          {\n            view: "block",\n            className: "content-section config",\n            content: [\n              {\n                view: "struct",\n                expanded: 1,\n                data: "config"\n              },\n              {\n                view: "tree",\n                data: (data, context) => context.host.view.getViewConfigTransitionTree(data.config).deps,\n                whenData: true,\n                expanded: 3,\n                children: "deps",\n                item: {\n                  view: "struct",\n                  expanded: 1,\n                  data: "value"\n                }\n              }\n            ]\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/extensions/inspector/data.js\n  function normalizeSource(text) {\n    text = text.replace(/^(?:\\s*[\\n]+)+?([ \\t]*)/, "$1").trimRight();\n    text = text.replace(/\\n[ \\t]+\\n/g, "\\n\\n");\n    const lines = text.split(/\\n+/);\n    const startLine = Number(text.match(/^\\s/) === null);\n    let minOffset = 1e3;\n    for (var i = startLine; i < lines.length; i++) {\n      const m2 = lines[i].match(/^\\s*/);\n      if (m2[0].length < minOffset) {\n        minOffset = m2[0].length;\n      }\n      if (minOffset == 0) {\n        break;\n      }\n    }\n    if (minOffset > 0) {\n      text = text.replace(new RegExp("(^|\\\\n) {" + minOffset + "}", "g"), "$1");\n    }\n    return text;\n  }\n  var dataTransitionsList, dataView;\n  var init_data = __esm({\n    "node_modules/@discoveryjs/discovery/src/extensions/inspector/data.js"() {\n      dataTransitionsList = {\n        view: "list",\n        className: "data-flow-transitions",\n        limit: 1,\n        when: ".[view]",\n        data: `\n        [null]    // to show empty list on first render\n        + .[view] // filter viewRoot\n        .(\n            $parent;\n            $parentName: parent.view.config.view;\n            $queryData: view | inputDataIndex != undefined ? inputData[inputDataIndex] : inputData;\n\n            view | [\n                ...\'data\' in config ? { inputData: $queryData, transition: config.data, name: config.view, view: $, $parent } : [],\n                ...inputDataIndex != undefined ? { inputData, transition: \\`$[\\${inputDataIndex}]\\`, name: \\`\\${$parentName} \\u2192 \\${config.view}\\`, view: $, $parent } : []\n            ]\n        )\n    `,\n        whenData: "size() > 1",\n        itemConfig: {\n          when: true\n          // to show empty list on first render\n        },\n        item: [\n          {\n            view: "block",\n            className: "root-data",\n            when: "inputData = ..parent.viewRoot[].data",\n            content: \'badge:"Root data"\'\n          },\n          {\n            view: "struct",\n            data: "inputData"\n          },\n          {\n            view: "block",\n            className: "data-flow-transition",\n            content: [{\n              view: "switch",\n              content: [\n                {\n                  when: "transition is (string or undefined)",\n                  content: {\n                    view: "context",\n                    data(data) {\n                      const content = normalizeSource(data.transition);\n                      const refs = [];\n                      return {\n                        content,\n                        refs\n                      };\n                    },\n                    content: {\n                      view: "source",\n                      data: `{\n                                    ...,\n                                    syntax: "jora",\n                                    lineNum: false\n                                }`\n                    }\n                  }\n                },\n                {\n                  content: {\n                    view: "struct",\n                    data: "transition"\n                  }\n                }\n              ]\n            }, {\n              view: "block",\n              className: "view-name",\n              content: "text:name"\n            }]\n          }\n        ]\n      };\n      dataView = {\n        view: "block",\n        className: "content-section data",\n        data: "#.view",\n        content: [\n          { view: "context", data: "..parent", content: dataTransitionsList },\n          { view: "context", content: { ...dataTransitionsList, limit: false } },\n          {\n            view: "block",\n            className: "root-data",\n            when: "view or viewRoot | data = ([@] + @..parent).viewRoot[].data",\n            content: \'badge:"Root data"\'\n          },\n          {\n            view: "struct",\n            expanded: 1,\n            data: "view or viewRoot | data"\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/extensions/inspector.js\n  function isBoxChanged(oldBox, newBox) {\n    if (oldBox === null) {\n      return true;\n    }\n    for (const prop of ["top", "left", "width", "height"]) {\n      if (oldBox[prop] !== newBox[prop]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var inspector_default;\n  var init_inspector = __esm({\n    "node_modules/@discoveryjs/discovery/src/extensions/inspector.js"() {\n      init_dom();\n      init_layout();\n      init_pointer();\n      init_debounce();\n      init_view_tree();\n      init_props_config();\n      init_data();\n      inspector_default = (host) => {\n        let inspectorActivated = false;\n        let lastOverlayEl = null;\n        let lastHoverViewTreeLeaf = null;\n        let selectedTreeViewLeaf = null;\n        let hideTimer = null;\n        let syncOverlayTimer;\n        const detailsSidebarLeafExpanded = /* @__PURE__ */ new Set();\n        const viewByEl = /* @__PURE__ */ new Map();\n        const overlayByViewNode = /* @__PURE__ */ new Map();\n        const cancelHintEl = createElement("div", "cancel-hint view-alert view-alert-warning");\n        const overlayLayerEl = createElement("div", {\n          class: "discovery-view-inspector-overlay",\n          onclick: () => selectTreeViewLeaf(\n            lastHoverViewTreeLeaf && !selectedTreeViewLeaf ? lastHoverViewTreeLeaf : null\n          )\n        }, [cancelHintEl]);\n        const syncOverlayState = debounce(() => {\n          if (!inspectorActivated || selectedTreeViewLeaf !== null) {\n            return;\n          }\n          const tree = host.view.getViewTree([popup.el]);\n          const overlayToRemove = /* @__PURE__ */ new Set([...overlayByViewNode.keys()]);\n          const walk37 = function walk38(leafs, parentEl) {\n            for (const leaf of leafs) {\n              if (!leaf.node || !leaf.view && !leaf.viewRoot) {\n                if (leaf.children.length) {\n                  walk38(leaf.children, parentEl);\n                }\n                continue;\n              }\n              const box = getBoundingRect(leaf.node, parentEl);\n              let overlay = overlayByViewNode.get(leaf.node) || null;\n              if (overlay === null) {\n                overlay = {\n                  el: parentEl.appendChild(createElement("div", leaf.viewRoot ? "overlay view-root" : "overlay")),\n                  box: null\n                };\n                if (leaf.node.nodeType === 1) {\n                  overlay.el.style.zIndex = getComputedStyle(leaf.node).zIndex;\n                }\n                if (leaf.viewRoot && leaf.viewRoot.inspectable !== false) {\n                  overlay.el.dataset.inspectable = true;\n                }\n                overlayByViewNode.set(leaf.node, overlay);\n                viewByEl.set(overlay.el, leaf);\n              } else {\n                overlayToRemove.delete(leaf.node);\n              }\n              if (isBoxChanged(overlay.box, box)) {\n                overlay.el.style.top = `${box.top}px`;\n                overlay.el.style.left = `${box.left}px`;\n                overlay.el.style.width = `${box.width}px`;\n                overlay.el.style.height = `${box.height}px`;\n                overlay.box = box;\n              }\n              if (leaf.children.length) {\n                if (leaf.node.nodeType === 1) {\n                  overlay.el.style.overflow = getComputedStyle(leaf.node).overflow !== "visible" ? "hidden" : "visible";\n                }\n                walk38(leaf.children, overlay.el);\n              }\n            }\n          };\n          walk37(tree, overlayLayerEl);\n          for (const node of overlayToRemove) {\n            overlayByViewNode.get(node).el.remove();\n            overlayByViewNode.delete(node);\n          }\n          updateState();\n        }, { maxWait: 0, wait: 50 });\n        const updateState = () => {\n          const { x, y: y2 } = pointerXY.value;\n          onHover(\n            [...host.dom.container.parentNode.elementsFromPoint(x | 0, y2 | 0) || []].find((el) => viewByEl.has(el)) || null\n          );\n        };\n        const keyPressedEventListener = (e) => {\n          if (e.key === "Escape" || e.keyCode === 27 || e.which === 27) {\n            host.inspectMode.set(false);\n          }\n        };\n        const enableInspect = () => {\n          if (!inspectorActivated) {\n            inspectorActivated = true;\n            document.addEventListener("scroll", syncOverlayState, passiveCaptureOptions);\n            document.addEventListener("keydown", keyPressedEventListener, true);\n            pointerXY.subscribe(syncOverlayState);\n            syncOverlayTimer = setInterval(syncOverlayState, 500);\n            host.dom.container.append(overlayLayerEl);\n            syncOverlayState();\n          }\n        };\n        const disableInspect = () => {\n          if (inspectorActivated) {\n            inspectorActivated = false;\n            clearInterval(syncOverlayTimer);\n            document.removeEventListener("scroll", syncOverlayState, passiveCaptureOptions);\n            document.removeEventListener("keydown", keyPressedEventListener, true);\n            pointerXY.unsubscribe(syncOverlayState);\n            inspectByQuick = false;\n            delete cancelHintEl.dataset.alt;\n            overlayLayerEl.remove();\n            hide();\n          }\n        };\n        const selectTreeViewLeaf = (leaf) => {\n          selectedTreeViewLeaf = leaf || null;\n          if (leaf) {\n            const { innerWidth, innerHeight } = window;\n            const { left, top, width, height } = popup.el.getBoundingClientRect();\n            popup.el.style.top = `${top}px`;\n            popup.el.style.left = `${left}px`;\n            popup.el.style.right = `${innerWidth - (left + width)}px`;\n            popup.el.style.bottom = `${innerHeight - (top + height)}px`;\n            popup.frozen = true;\n            requestAnimationFrame(() => {\n              popup.show();\n              popup.freeze();\n            });\n            delete cancelHintEl.dataset.alt;\n          } else if (inspectByQuick) {\n            host.inspectMode.set(false);\n          } else {\n            detailsSidebarLeafExpanded.clear();\n            resetViewTreeScrollTopBeforeSelect();\n            hide();\n            syncOverlayState();\n          }\n        };\n        const hide = () => {\n          if (lastOverlayEl) {\n            lastOverlayEl.classList.remove("hovered");\n          }\n          lastOverlayEl = null;\n          lastHoverViewTreeLeaf = null;\n          selectedTreeViewLeaf = null;\n          popup.hide();\n        };\n        const onHover = (overlayEl) => {\n          if (overlayEl === lastOverlayEl) {\n            return;\n          }\n          if (lastOverlayEl !== null) {\n            lastOverlayEl.classList.remove("hovered");\n          }\n          lastOverlayEl = overlayEl;\n          if (overlayEl === null) {\n            hideTimer = setTimeout(hide, 100);\n            return;\n          }\n          overlayEl.classList.add("hovered");\n          const leaf = viewByEl.get(overlayEl) || null;\n          if (leaf === null) {\n            lastHoverViewTreeLeaf = null;\n            return;\n          }\n          if (lastHoverViewTreeLeaf !== null && leaf.view === lastHoverViewTreeLeaf.view) {\n            return;\n          }\n          lastHoverViewTreeLeaf = leaf;\n          clearTimeout(hideTimer);\n          popup.show();\n        };\n        const popup = new host.view.Popup({\n          className: "discovery-inspect-details-popup",\n          position: "pointer",\n          hideIfEventOutside: false,\n          hideOnResize: false,\n          render(el) {\n            const targetLeaf = selectedTreeViewLeaf || lastHoverViewTreeLeaf;\n            const stack = [];\n            let cursor = targetLeaf;\n            while (cursor !== null && (cursor.view || cursor.viewRoot)) {\n              if (cursor !== targetLeaf && selectedTreeViewLeaf !== null) {\n                detailsSidebarLeafExpanded.add(cursor);\n              }\n              stack.unshift(cursor);\n              cursor = cursor.parent;\n            }\n            return host.view.render(el, {\n              view: "context",\n              modifiers: [viewTree(el, {\n                selectTreeViewLeaf,\n                detailsSidebarLeafExpanded\n              })],\n              content: {\n                view: "context",\n                modifiers: {\n                  view: "block",\n                  className: "toolbar",\n                  content: [\n                    {\n                      view: "toggle-group",\n                      className: "stack-view-chain",\n                      name: "view",\n                      data: ".({ value: $ })",\n                      value: "=$[-1].value",\n                      toggleConfig: {\n                        className: [\n                          (data) => data.value.viewRoot ? "view-root" : false,\n                          (data) => data.value.view && data.value.view.skipped ? "skipped" : false\n                        ],\n                        content: [\n                          \'text:value | viewRoot.name or view.config.view | is string ?: "\\u0192n"\'\n                          // {\n                          //     view: \'list\',\n                          //     when: false, // postponed for future releases\n                          //     className: \'data-flow-changes\',\n                          //     data: `\n                          //         $self: value | viewRoot or view;\n                          //         $parent: value.parent | viewRoot or view or #.host;\n                          //         [\'data\', \'context\'].[$parent[$] != $self[$]]\n                          //     `,\n                          //     whenData: true,\n                          //     itemConfig: {\n                          //         view: \'block\',\n                          //         className: data => data,\n                          //         content: \'text:$[0]\'\n                          //     }\n                          // }\n                        ]\n                      }\n                    },\n                    {\n                      view: "button",\n                      when: selectedTreeViewLeaf !== null,\n                      content: \'text:"Close inspector"\',\n                      onClick() {\n                        host.inspectMode.set(false);\n                      }\n                    }\n                  ]\n                },\n                content: [\n                  propsConfigView,\n                  {\n                    view: "block",\n                    className: ["content", "data-context"],\n                    content: [\n                      dataView,\n                      {\n                        view: "block",\n                        className: "content-section context",\n                        data: "$[-1] | view or viewRoot",\n                        content: {\n                          view: "struct",\n                          expanded: 1,\n                          data: "context"\n                        }\n                      }\n                    ]\n                  }\n                ]\n              }\n            }, stack, {\n              selectedView: selectedTreeViewLeaf,\n              host\n            });\n          }\n        });\n        host.action.define("startInspect", enableInspect);\n        host.action.define("stopInspect", disableInspect);\n        host.inspectMode.subscribeSync(\n          (enabled) => enabled ? enableInspect() : disableInspect()\n        );\n        let inspectByQuick = false;\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/button.usage.js\n  var button_usage_default;\n  var init_button_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/button.usage.js"() {\n      button_usage_default = (view, group) => ({\n        demo: {\n          view,\n          onClick: Function(\'return () => alert("Hello world!")\')(),\n          data: {\n            text: "Button"\n          }\n        },\n        examples: [\n          {\n            title: "Variations",\n            demo: group.map((name) => `${name}:{ text: "${name}" }`)\n          },\n          {\n            title: "Disabled state",\n            demo: group.map((name) => ({\n              view: name,\n              disabled: true,\n              data: { text: name }\n            }))\n          },\n          {\n            title: "Button as a link",\n            demo: {\n              view: "button",\n              data: {\n                text: "Click me",\n                href: "#url",\n                external: true\n              }\n            }\n          }\n        ]\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/button.js\n  function button_default(host) {\n    function render2(el, config, data, context) {\n      const { content, disabled = false, onClick: onClick3 } = config;\n      const { text = "", href, external } = data || {};\n      el.classList.add("view-button");\n      if (host.query(disabled, data, context)) {\n        el.disabled = true;\n      } else if (typeof onClick3 === "function") {\n        el.addEventListener("click", () => onClick3(el, data, context));\n        el.classList.add("onclick");\n      } else if (href) {\n        el.addEventListener("click", () => createElement("a", {\n          href,\n          target: external ? "_blank" : ""\n        }).click());\n      }\n      if (content) {\n        return host.view.render(el, content, data, context);\n      } else {\n        el.textContent = text;\n      }\n    }\n    host.view.define("button", render2, { tag: "button", usage: button_usage_default });\n    host.view.define("button-primary", render2, { tag: "button", usage: button_usage_default });\n    host.view.define("button-danger", render2, { tag: "button", usage: button_usage_default });\n    host.view.define("button-warning", render2, { tag: "button", usage: button_usage_default });\n  }\n  var init_button = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/button.js"() {\n      init_button_usage();\n      init_dom();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/checkbox-list.usage.js\n  var checkbox_list_usage_default;\n  var init_checkbox_list_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/checkbox-list.usage.js"() {\n      checkbox_list_usage_default = {\n        demo: {\n          view: "checkbox-list",\n          checkbox: {\n            content: "text"\n          },\n          data: [\n            "one",\n            "two",\n            "three"\n          ]\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/checkbox-list.js\n  function checkbox_list_default(host) {\n    host.view.define("checkbox-list", function(el, config, data, context) {\n      const { name = "filter", checkbox, checkboxValue = "$", emptyText, limit, onChange: onChange4, onInit } = config;\n      const state = /* @__PURE__ */ new Set();\n      if (emptyText !== false && emptyText !== "") {\n        el.setAttribute("emptyText", emptyText || "Empty list");\n      }\n      if (!Array.isArray(data) && data) {\n        data = [data];\n      }\n      if (Array.isArray(data)) {\n        return host.view.renderList(el, this.composeConfig({\n          view: "checkbox",\n          ...checkbox,\n          onInit: (checked, _, itemData, itemContext) => {\n            if (checked) {\n              state.add(host.query(checkboxValue, itemData, itemContext));\n            }\n          },\n          onChange: (checked, _, itemData, itemContext) => {\n            const size = state.size;\n            const value = host.query(checkboxValue, itemData, itemContext);\n            if (checked) {\n              state.add(value);\n            } else {\n              state.delete(value);\n            }\n            if (size !== state.size && typeof onChange4 === "function") {\n              onChange4([...state], name);\n            }\n          }\n        }), data, context, 0, host.view.listLimit(limit, 25)).then(() => {\n          if (typeof onInit === "function") {\n            onInit([...state], name);\n          }\n        });\n      }\n    }, { usage: checkbox_list_usage_default });\n  }\n  var init_checkbox_list = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/checkbox-list.js"() {\n      init_checkbox_list_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/checkbox.usage.js\n  var checkbox_usage_default;\n  var init_checkbox_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/checkbox.usage.js"() {\n      checkbox_usage_default = {\n        demo: {\n          view: "checkbox",\n          content: \'text:"checkbox caption"\'\n        },\n        examples: [\n          {\n            title: "Checked state",\n            beforeDemo: "Checked state is set up with `checked` property. Its value can be a query",\n            demo: [\n              {\n                view: "checkbox",\n                checked: true,\n                content: \'text:"should be checked"\'\n              },\n              {\n                view: "checkbox",\n                checked: "1 > 5",\n                content: `text:"shouldn\'t be checked"`\n              },\n              {\n                view: "checkbox",\n                checked: "1 < 5",\n                content: \'text:"should be checked"\'\n              }\n            ]\n          },\n          {\n            title: "Readonly checkbox",\n            demo: {\n              view: "checkbox",\n              readonly: true,\n              content: \'text:"checkbox caption"\'\n            }\n          },\n          {\n            title: "On change",\n            demo: {\n              view: "checkbox",\n              // eslint-disable-next-line no-unused-vars\n              onChange: new Function("return (value, name, data, context) => alert(`Changed to ${value}!`)")(),\n              content: \'text:"click me!"\'\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/checkbox.js\n  function checkbox_default(host) {\n    function renderContent(contentEl, content, data, context, name, inputEl) {\n      if (contentEl === null) {\n        return;\n      }\n      const localContext = name ? { ...context, [name]: inputEl.checked } : context;\n      contentEl.innerHTML = "";\n      return host.view.render(contentEl, content, data, localContext);\n    }\n    host.view.define("checkbox", function(el, config, data, context) {\n      const { name, checked, readonly, content, onInit, onChange: onChange4 } = config;\n      const inputEl = el.appendChild(createElement("input"));\n      const contentEl = content ? el.appendChild(createElement("span", "view-checkbox__label")) : null;\n      inputEl.type = "checkbox";\n      inputEl.checked = checked !== void 0 ? host.queryBool(checked, data, context) : Boolean(context[name]);\n      inputEl.readOnly = readonly;\n      inputEl.addEventListener("click", (e) => {\n        if (readonly) {\n          e.preventDefault();\n        }\n      });\n      inputEl.addEventListener("change", () => {\n        if (typeof onChange4 === "function") {\n          onChange4(inputEl.checked, name, data, context);\n          renderContent(contentEl, content, data, context, name, inputEl);\n        }\n      });\n      if (typeof onInit === "function") {\n        onInit(inputEl.checked, name, data, context);\n      }\n      return renderContent(contentEl, content, data, context, name, inputEl);\n    }, {\n      tag: "label",\n      usage: checkbox_usage_default\n    });\n  }\n  var init_checkbox = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/checkbox.js"() {\n      init_dom();\n      init_checkbox_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/content-filter.usage.js\n  var content_filter_usage_default;\n  var init_content_filter_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/content-filter.usage.js"() {\n      content_filter_usage_default = {\n        demo: {\n          view: "content-filter",\n          data: ["foo", "bar", "baz"],\n          content: {\n            view: "list",\n            data: ".[$ ~= #.filter]"\n          }\n        },\n        examples: [\n          {\n            title: "Using with text-match",\n            demo: {\n              view: "content-filter",\n              data: [{ name: "foo" }, { name: "bar" }, { name: "baz" }],\n              name: "customName",\n              content: {\n                view: "list",\n                data: ".[name ~= #.customName]",\n                item: "text-match:{ text: name, match: #.customName }"\n              }\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/content-filter.js\n  function content_filter_default(host) {\n    host.view.define("content-filter", function(el, config, data, context) {\n      const { name = "filter", type = "regexp", placeholder, content, onInit, onChange: onChange4 } = config;\n      return host.view.render(el, {\n        view: "context",\n        modifiers: {\n          view: "input",\n          name,\n          type,\n          placeholder: placeholder || "Filter"\n        },\n        content: {\n          view: "block",\n          className: "content",\n          content,\n          onInit,\n          onChange: onChange4\n        }\n      }, data, context);\n    }, {\n      usage: content_filter_usage_default\n    });\n  }\n  var init_content_filter = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/content-filter.js"() {\n      init_content_filter_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/dropdown.usage.js\n  var dropdown_usage_default;\n  var init_dropdown_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/dropdown.usage.js"() {\n      dropdown_usage_default = {\n        demo: {\n          view: "context",\n          modifiers: {\n            view: "dropdown",\n            name: "demo",\n            value: { foo: "two", bar: "hello" },\n            resetValue: { foo: "one", bar: "" },\n            caption: "text:`${#.demo.foo} / ${#.demo.bar}`",\n            content: [\n              { view: "select", name: "foo", data: ["one", "two", "three", "four"] },\n              { view: "input", name: "bar" }\n            ]\n          },\n          content: [\n            { view: "block", content: \'text:"Modified context (see values in \\\\"demo\\\\" section):"\' },\n            { view: "struct", expanded: 1, data: "#" }\n          ]\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/dropdown.js\n  function simpleCompare(a, b2) {\n    if (!a || !b2) {\n      return a === b2;\n    }\n    if (typeof a !== "object" || typeof b2 !== "object") {\n      return a === b2;\n    }\n    for (const k2 in a) {\n      if (hasOwnProperty3.call(a, k2) && a[k2] !== b2[k2]) {\n        return false;\n      }\n    }\n    for (const k2 in b2) {\n      if (hasOwnProperty3.call(b2, k2) && a[k2] !== b2[k2]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function dropdown_default(host) {\n    host.view.define("dropdown", function(el, config, data, context) {\n      function isEqual2(a, b2) {\n        return typeof compare2 === "function" ? compare2(a, b2) : simpleCompare(a, b2);\n      }\n      function renderCaption() {\n        captionEl.innerHTML = "";\n        return host.view.render(\n          captionEl,\n          caption || "text",\n          data,\n          { ...context, [name || "__self"]: currentValue }\n        );\n      }\n      function applyNewValue(newValue) {\n        currentValue = newValue;\n        if (typeof onChange4 === "function") {\n          onChange4(currentValue, name, data, context);\n        }\n        dropdownPopup.hide();\n        renderCaption();\n      }\n      function renderButtons(initContext, sessionContext) {\n        if (buttonsEl) {\n          const state = {\n            changed: !isEqual2(initContext, sessionContext)\n          };\n          buttonsEl.innerHTML = "";\n          host.view.render(buttonsEl, [\n            {\n              view: "button-primary",\n              disabled: "=not changed",\n              content: \'text:"Apply"\',\n              onClick(el2, data2, sessionContext2) {\n                applyNewValue(sessionContext2);\n              }\n            },\n            {\n              view: "button",\n              when: () => resetValue && !isEqual2(resetValue, currentValue),\n              content: \'text:"Reset"\',\n              onClick() {\n                applyNewValue(resetValue);\n              }\n            },\n            {\n              view: "button",\n              disabled: "=not changed",\n              content: \'text:"Cancel"\',\n              onClick() {\n                dropdownPopup.hide();\n              }\n            }\n          ], state, sessionContext);\n        }\n      }\n      const {\n        name,\n        resetValue,\n        value,\n        placeholder,\n        caption,\n        content,\n        compare: compare2,\n        onInit,\n        onChange: onChange4\n      } = config;\n      let currentValue = "value" in config ? value : context[name];\n      let dropdownPopup = null;\n      const captionEl = el.appendChild(document.createElement("div"));\n      let buttonsEl;\n      if (placeholder) {\n        el.dataset.placeholder = placeholder;\n      }\n      el.tabIndex = 0;\n      el.addEventListener("click", () => {\n        if (dropdownPopup === null) {\n          dropdownPopup = new host.view.Popup({ className: "view-dropdown-popup" });\n        }\n        let sessionContext = { ...currentValue };\n        let initContext;\n        dropdownPopup.toggle(\n          el,\n          (popupEl) => host.view.render(popupEl, [\n            {\n              view: "block",\n              className: "content",\n              content: host.view.composeConfig(content, {\n                onInit(value2, name2) {\n                  sessionContext[name2] = value2;\n                },\n                onChange(value2, name2) {\n                  sessionContext[name2] = value2;\n                  renderButtons(initContext, sessionContext);\n                }\n              })\n            },\n            {\n              view: "block",\n              className: "confirm",\n              postRender(el2) {\n                buttonsEl = el2;\n              }\n            }\n          ], data, { ...context, ...currentValue }).then(() => {\n            initContext = { ...sessionContext };\n            renderButtons(initContext, sessionContext);\n          })\n        );\n      });\n      captionEl.className = "view-dropdown__caption";\n      if (typeof onInit === "function") {\n        onInit(currentValue, name, data, context);\n      }\n      return renderCaption();\n    }, { usage: dropdown_usage_default });\n  }\n  var hasOwnProperty3;\n  var init_dropdown = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/dropdown.js"() {\n      init_dropdown_usage();\n      ({ hasOwnProperty: hasOwnProperty3 } = Object.prototype);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/safe-filter-rx.js\n  function buildRx(pattern, flags) {\n    try {\n      return new RegExp("((?:" + pattern + ")+)", flags);\n    } catch (e) {\n    }\n    return new RegExp("((?:" + pattern.replace(/[\\[\\]\\(\\)\\?\\+\\*\\{\\}\\\\]/g, "\\\\$&") + ")+)", flags);\n  }\n  function safeFilterRx(pattern, flags = "i") {\n    const rx = buildRx(pattern, flags);\n    rx.rawSource = pattern;\n    return rx;\n  }\n  var init_safe_filter_rx = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/safe-filter-rx.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/input.usage.js\n  var onChange, input_usage_default;\n  var init_input_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/input.usage.js"() {\n      onChange = new Function("return (value) => alert(`Changed to ${value}!`)")();\n      input_usage_default = {\n        examples: [\n          {\n            title: "Input with value",\n            demo: {\n              view: "input",\n              value: \'"value"\'\n            }\n          },\n          {\n            title: "Input with placeholder",\n            demo: {\n              view: "input",\n              placeholder: "placeholder"\n            }\n          },\n          {\n            title: "Input type number with min and max",\n            demo: {\n              view: "input",\n              htmlType: "number",\n              htmlMin: 10,\n              htmlMax: 20\n            }\n          },\n          {\n            title: "Input with onChange",\n            demo: {\n              view: "input",\n              onChange\n            }\n          },\n          {\n            title: "Input with onChange debounced",\n            demo: {\n              view: "input",\n              onChange,\n              debounce: 300\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/input.js\n  function input_default(host) {\n    const factories = {\n      regexp: (pattern) => pattern ? safeFilterRx(pattern) : null,\n      text: (pattern) => pattern\n    };\n    host.view.define("input", function(el, config, data, context) {\n      const {\n        name,\n        value,\n        type = "text",\n        placeholder,\n        onInit,\n        onChange: onChange4,\n        htmlType = "text",\n        htmlMin,\n        htmlMax,\n        debounce: debounce2\n      } = config;\n      const factory = factories[type] || factories.text;\n      const inputEl = el.appendChild(document.createElement("input"));\n      let lastInput = value ? host.query(value, data, context) : context[name];\n      if (typeof lastInput !== "string") {\n        lastInput = "";\n      }\n      inputEl.type = htmlType;\n      inputEl.value = lastInput;\n      inputEl.placeholder = [\n        placeholder || "",\n        factory !== factories.text ? "(" + type + ")" : ""\n      ].filter(Boolean).join(" ");\n      if (typeof htmlMin !== "undefined") {\n        inputEl.min = htmlMin;\n      }\n      if (htmlMax) {\n        inputEl.max = htmlMax;\n      }\n      inputEl.addEventListener("input", debounce(() => {\n        const newInput = inputEl.value.trim();\n        if (lastInput !== newInput) {\n          lastInput = newInput;\n          if (typeof onChange4 === "function") {\n            onChange4(factory(newInput), name, data, context);\n          }\n        }\n      }, debounce2));\n      if (typeof onInit === "function") {\n        onInit(factory(inputEl.value.trim()), name, data, context);\n      }\n    }, { usage: input_usage_default });\n  }\n  var init_input = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/input.js"() {\n      init_safe_filter_rx();\n      init_debounce();\n      init_input_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/menu.usage.js\n  var onChange2, menu_usage_default;\n  var init_menu_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/menu.usage.js"() {\n      onChange2 = new Function("return (value) => alert(`Changed to ${value.text}!`)")();\n      menu_usage_default = {\n        demo: {\n          view: "menu",\n          data: [\n            { text: "one", href: "#" },\n            { text: "two", href: "#" },\n            { text: "three", href: "#" }\n          ]\n        },\n        examples: [\n          {\n            title: "With limit",\n            demo: {\n              view: "menu",\n              data: [\n                { text: "one", href: "#" },\n                { text: "two", href: "#" },\n                { text: "three", href: "#" }\n              ],\n              limit: 2\n            }\n          },\n          {\n            title: "With custom item",\n            demo: {\n              view: "menu",\n              data: [\n                { text: "one", href: "#" },\n                { text: "two", href: "#" },\n                { text: "three", href: "#" }\n              ],\n              item: "h1:text"\n            }\n          },\n          {\n            title: "On chage handler",\n            demo: {\n              view: "menu",\n              onChange: onChange2,\n              data: [\n                { text: "one", href: "#" },\n                { text: "two", href: "#" },\n                { text: "three", href: "#" }\n              ]\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/menu.js\n  function menu_default(host) {\n    host.view.define("menu", function(el, config, data, context) {\n      const { name = "filter", item, itemConfig, limit, emptyText, onClick: onClick3, onInit, onChange: onChange4 } = config;\n      if (emptyText !== false && emptyText !== "") {\n        el.setAttribute("emptyText", emptyText || "No items");\n      }\n      if (Array.isArray(data)) {\n        const composedItemConfig = this.composeConfig({\n          view: "menu-item",\n          content: item,\n          onClick: typeof onClick3 === "function" ? onClick3 : typeof onChange4 === "function" ? (data2) => onChange4(data2, name) : void 0\n        }, itemConfig);\n        return host.view.renderList(\n          el,\n          composedItemConfig,\n          data,\n          context,\n          0,\n          host.view.listLimit(limit, 25)\n        ).then(() => {\n          if (typeof onInit === "function") {\n            onInit(host.query(".[selected].pick()", data, context), name);\n          }\n        });\n      }\n    }, { usage: menu_usage_default });\n  }\n  var init_menu = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/menu.js"() {\n      init_menu_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/menu-item.usage.js\n  var menu_item_usage_default;\n  var init_menu_item_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/menu-item.usage.js"() {\n      menu_item_usage_default = {\n        demo: {\n          view: "menu",\n          data: [\n            { text: "one", href: "#" },\n            { text: "two", href: "#" },\n            { text: "three", href: "#" }\n          ]\n        },\n        examples: [\n          {\n            title: "Preselected item",\n            demo: {\n              view: "menu",\n              data: [\n                { text: "one", href: "#" },\n                { text: "two", href: "#", selected: true },\n                { text: "three", href: "#" }\n              ]\n            }\n          },\n          {\n            title: "Disabled item",\n            demo: {\n              view: "menu",\n              data: [\n                { text: "one", href: "#" },\n                { text: "two", href: "#", disabled: true },\n                { text: "three", href: "#" }\n              ]\n            }\n          },\n          {\n            title: "External links",\n            demo: {\n              view: "menu",\n              data: [\n                { text: "one", external: true, href: "https://github.com/discoveryjs/discovery" },\n                { text: "two", external: true, href: "https://github.com/discoveryjs/discovery" },\n                { text: "three", external: true, href: "https://github.com/discoveryjs/discovery" }\n              ]\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/menu-item.js\n  function menu_item_default(host) {\n    host.view.define("menu-item", function(el, config, data, context) {\n      const { content, onClick: onClick3 } = config;\n      const { text, selected = false, disabled = false, href, external } = data || {};\n      if (disabled) {\n        el.classList.add("disabled");\n      } else if (typeof onClick3 === "function") {\n        el.addEventListener("click", () => onClick3(data, context));\n        el.classList.add("onclick");\n      } else if (href) {\n        el.href = href;\n        el.target = external ? "_blank" : "";\n      }\n      if (selected) {\n        el.classList.add("selected");\n      }\n      if (content) {\n        return host.view.render(el, content, data, context);\n      } else {\n        el.textContent = typeof data === "string" ? data : text || "Untitled item";\n      }\n    }, {\n      tag: "a",\n      usage: menu_item_usage_default\n    });\n  }\n  var init_menu_item = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/menu-item.js"() {\n      init_menu_item_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/nav-button.usage.js\n  var onClick, nav_button_usage_default;\n  var init_nav_button_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/nav-button.usage.js"() {\n      onClick = () => alert("changed!");\n      nav_button_usage_default = {\n        demo: {\n          view: "nav-button",\n          data: { text: "I am nav button" }\n        },\n        examples: [\n          {\n            title: "With href",\n            demo: {\n              view: "nav-button",\n              data: { text: "I am nav button", href: "#" }\n            }\n          },\n          {\n            title: "External link",\n            demo: {\n              view: "nav-button",\n              data: { text: "I am nav button", external: true, href: "https://github.com/discoveryjs/discovery" }\n            }\n          },\n          {\n            title: "On click handler",\n            demo: {\n              view: "nav-button",\n              data: { text: "I am nav button" },\n              onClick\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/nav-button.js\n  function nav_button_default(host) {\n    host.view.define("nav-button", function(el, config, data, context) {\n      const { name, content, disabled = false, onClick: onClick3 } = config;\n      const { text = "", href, external } = data || {};\n      if (name) {\n        el.dataset.name = name;\n      }\n      if (host.query(disabled, data, context)) {\n        el.classList.add("disabled");\n      } else if (typeof onClick3 === "function") {\n        el.addEventListener("click", (event) => onClick3(el, data, context, event));\n        el.classList.add("onclick");\n      } else if (href) {\n        el.href = href;\n        el.target = external ? "_blank" : "";\n      }\n      if (content) {\n        return host.view.render(el, content, data, context);\n      } else {\n        el.textContent = text;\n      }\n    }, {\n      tag: "a",\n      usage: nav_button_usage_default\n    });\n  }\n  var init_nav_button = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/nav-button.js"() {\n      init_nav_button_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/progress.usage.js\n  var progress_usage_default;\n  var init_progress_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/progress.usage.js"() {\n      progress_usage_default = {\n        demo: {\n          view: "progress",\n          progress: 0.5,\n          content: \'text:"Loading..."\'\n        },\n        examples: [\n          {\n            title: "With no label (content)",\n            demo: {\n              view: "progress",\n              progress: 0.25\n            }\n          },\n          {\n            title: "Custom color",\n            demo: {\n              view: "progress",\n              progress: 0.85,\n              color: "#bdab77",\n              content: \'text:"Yellow progress"\'\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/progress.js\n  function progress_default(host) {\n    host.view.define("progress", function(el, config, data, context) {\n      const { content, progress, color } = config;\n      const progressEl = el.appendChild(createElement("div", {\n        class: "progress",\n        style: `--progress: ${Math.max(0, Math.min(1, Number(progress)))};--color: ${color || "unset"};`\n      }));\n      if (content) {\n        const contentEl = el.insertBefore(createElement("div", { class: "content" }), progressEl);\n        return host.view.render(contentEl, content, data, context);\n      }\n    }, { usage: progress_usage_default });\n  }\n  var init_progress = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/progress.js"() {\n      init_dom();\n      init_progress_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/select.usage.js\n  var onChange3, select_usage_default;\n  var init_select_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/select.usage.js"() {\n      onChange3 = new Function("return (value) => alert(`Changed to ${value}!`)")();\n      select_usage_default = {\n        demo: {\n          view: "select",\n          data: ["one", "two", "three", "four"]\n        },\n        examples: [\n          {\n            title: "Select with value",\n            demo: {\n              view: "select",\n              value: \'"three"\',\n              data: ["one", "two", "three", "four"]\n            }\n          },\n          {\n            title: "Select with reset option",\n            demo: {\n              view: "select",\n              resetItem: true,\n              value: \'"three"\',\n              data: ["one", "two", "three", "four"]\n            }\n          },\n          {\n            title: "Select with placeholder",\n            demo: {\n              view: "select",\n              placeholder: "placeholder",\n              data: ["one", "two", "three", "four"]\n            }\n          },\n          {\n            title: "Select with onChange",\n            demo: {\n              view: "select",\n              onChange: onChange3,\n              data: ["one", "two", "three", "four"]\n            }\n          },\n          {\n            title: "Select with custom options",\n            demo: {\n              view: "select",\n              item: "h1:text",\n              data: ["one", "two", "three", "four"]\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/select.js\n  function select_default(host) {\n    const defaultItemRender = "text-match:{ text, match: #.filter }";\n    const variantQuery = "{ value: $, text: #.selectVariantTextQuery.query($, #) }";\n    const variantsPopup = new host.view.Popup({\n      className: "view-select-popup"\n    });\n    host.view.define("select", function(el, config, data, context) {\n      function renderCaption() {\n        el.innerHTML = "";\n        if (currentValue !== void 0) {\n          return host.view.render(el, host.view.composeConfig({\n            view: "menu-item",\n            data: variantQuery,\n            content: item\n          }, itemConfig), currentValue, variantsPopupContext);\n        }\n      }\n      const {\n        name,\n        value,\n        text = "$",\n        placeholder,\n        limit,\n        minItemsFilter = 10,\n        resetItem = false,\n        item = defaultItemRender,\n        itemConfig,\n        beforeItems,\n        afterItems,\n        onInit,\n        onChange: onChange4\n      } = config;\n      let currentValue = value ? host.query(value, data, context) : context[name];\n      let variantsPopupContext = {\n        ...context,\n        selectMinItemsFilter: minItemsFilter,\n        selectCurrentValue: currentValue,\n        selectVariantTextQuery: text,\n        selectResetItem: resetItem ? [{ value: void 0, text: "", ...resetItem, resetItem: true }] : []\n      };\n      const popupContent = [];\n      if (beforeItems) {\n        popupContent.push(host.view.composeConfig(beforeItems, { onInit, onChange: onChange4 }));\n      }\n      popupContent.push({\n        view: "context",\n        data: `.(${variantQuery})`,\n        modifiers: {\n          view: "input",\n          when: "size() >= #.selectMinItemsFilter",\n          type: "regexp",\n          name: "filter",\n          className: "view-select__filter",\n          placeholder: "Filter"\n        },\n        content: {\n          view: "menu",\n          className: "view-select__variants",\n          data: "#.selectResetItem + .[no #.filter or text~=#.filter]",\n          limit,\n          itemConfig: host.view.composeConfig({\n            className: [\n              (data2) => data2.resetItem ? "reset-item" : "",\n              (data2) => data2.value === currentValue ? "selected" : ""\n            ]\n          }, itemConfig),\n          item,\n          onClick(data2) {\n            variantsPopup.hide();\n            if (currentValue !== data2.value) {\n              currentValue = data2.value;\n              variantsPopupContext = {\n                ...variantsPopupContext,\n                selectCurrentValue: currentValue\n              };\n              renderCaption();\n              if (typeof onChange4 === "function") {\n                onChange4(data2.value, name, data2, context);\n              }\n            }\n          }\n        }\n      });\n      if (afterItems) {\n        popupContent.push(host.view.composeConfig(afterItems, { onInit, onChange: onChange4 }));\n      }\n      if (placeholder) {\n        el.dataset.placeholder = placeholder;\n      }\n      el.tabIndex = 0;\n      el.addEventListener("click", () => {\n        variantsPopup.toggle(\n          el,\n          (popupEl) => host.view.render(popupEl, popupContent, data, variantsPopupContext).then(() => (popupEl.querySelector(".view-select__filter input") || { focus() {\n          } }).focus())\n        );\n      });\n      if (typeof onInit === "function") {\n        onInit(currentValue, name, data, context);\n      }\n      return renderCaption();\n    }, { usage: select_usage_default });\n  }\n  var init_select = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/select.js"() {\n      init_select_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/tabs.usage.js\n  var tabs_usage_default;\n  var init_tabs_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/tabs.usage.js"() {\n      tabs_usage_default = {\n        demo: {\n          view: "tabs",\n          name: "tabs",\n          tabs: [\n            { value: "one", text: "One" },\n            { value: "two", text: "Two" },\n            { value: "three", text: "Three" }\n          ],\n          content: {\n            view: "switch",\n            content: [\n              {\n                when: \'#.tabs="one"\',\n                content: \'text:"One"\'\n              },\n              {\n                when: \'#.tabs="two"\',\n                content: \'text:"Two"\'\n              },\n              {\n                when: \'#.tabs="three"\',\n                content: \'text:"Three"\'\n              }\n            ]\n          }\n        },\n        examples: [\n          {\n            title: "With before and after content",\n            demo: {\n              view: "tabs",\n              name: "example",\n              tabs: [\n                { value: "one", text: "One" },\n                { value: "two", text: "Two" },\n                { value: "three", text: "Three" }\n              ],\n              beforeTabs: \'text:"<Content before tabs>"\',\n              afterTabs: \'text:"<Content after tabs>"\',\n              content: \'text:"Selected: " + #.example\'\n            }\n          },\n          {\n            title: "On change handler",\n            demo: {\n              view: "tabs",\n              name: "example",\n              tabs: [\n                { value: "one", text: "One" },\n                { value: "two", text: "Two" },\n                { value: "three", text: "Three" }\n              ],\n              onChange: new Function(\'return (value) => alert("changed to " + value)\')(),\n              content: \'text:"Selected: " + #.example\'\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/tabs.js\n  function tabs_default(host) {\n    host.view.define("tabs", function(el, config, data, context) {\n      async function renderContent(value) {\n        const handler = inited ? onChange4 : onInit;\n        if (currentValue === value) {\n          return;\n        }\n        const renderContext = beforeTabs || afterTabs || content ? { ...context, [name]: value } : null;\n        currentValue = value;\n        inited = true;\n        if (Array.isArray(tabs)) {\n          tabsEl.innerHTML = "";\n          if (beforeTabs) {\n            beforeTabsEl.innerHTML = "";\n            await host.view.render(beforeTabsEl, beforeTabs, data, renderContext);\n            tabsEl.appendChild(beforeTabsEl);\n          }\n          await Promise.all(tabs.map(\n            (tab) => host.view.render(tabsEl, host.view.composeConfig(tab, {\n              active: tab.value === currentValue\n            }), data, context)\n          ));\n          if (afterTabs) {\n            afterTabsEl.innerHTML = "";\n            await host.view.render(afterTabsEl, afterTabs, data, renderContext);\n            tabsEl.appendChild(afterTabsEl);\n          }\n        }\n        if (content) {\n          contentEl.innerHTML = "";\n          await host.view.render(contentEl, content, data, renderContext);\n        }\n        if (typeof handler === "function") {\n          handler(currentValue, name, data, context);\n        }\n      }\n      const { content, beforeTabs, afterTabs, onInit, onChange: onChange4 } = config;\n      let { name, tabs, tabConfig } = config;\n      const tabsEl = el.appendChild(document.createElement("div"));\n      let contentEl = null;\n      let beforeTabsEl = null;\n      let afterTabsEl = null;\n      let inited = false;\n      let currentValue = NaN;\n      let initValue = "value" in config ? config.value : name in context ? context[name] : void 0;\n      tabs = host.query(tabs, data, context);\n      tabConfig = host.view.composeConfig({\n        view: "tab",\n        onClick: renderContent\n      }, tabConfig);\n      tabsEl.className = "view-tabs-buttons";\n      if (beforeTabs) {\n        beforeTabsEl = document.createElement("div");\n        beforeTabsEl.className = "view-tabs-buttons-before";\n      }\n      if (afterTabs) {\n        afterTabsEl = document.createElement("div");\n        afterTabsEl.className = "view-tabs-buttons-after";\n      }\n      if (content) {\n        contentEl = el.appendChild(document.createElement("div"));\n        contentEl.className = "view-tabs-content";\n      }\n      if (typeof name !== "string") {\n        name = "filter";\n      }\n      if (Array.isArray(tabs)) {\n        tabs = tabs.map((tab) => {\n          const type = typeof tab;\n          if (type === "string" || type === "number" || type === "boolean") {\n            tab = { value: tab };\n          }\n          if (initValue === void 0 || tab.active) {\n            initValue = tab.value;\n          }\n          return host.view.composeConfig(\n            tabConfig,\n            tab\n          );\n        });\n      } else {\n        tabs = [];\n      }\n      return renderContent(initValue);\n    }, { usage: tabs_usage_default });\n  }\n  var init_tabs = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/tabs.js"() {\n      init_tabs_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/tab.usage.js\n  var onClick2, tab_usage_default;\n  var init_tab_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/tab.usage.js"() {\n      onClick2 = () => alert("clicked!");\n      tab_usage_default = {\n        demo: {\n          view: "tabs",\n          name: "tabs",\n          tabs: [\n            { value: "one", text: "One" },\n            { value: "two", text: "Two" },\n            { value: "three", text: "Three" }\n          ],\n          content: {\n            view: "switch",\n            content: [\n              {\n                when: \'#.tabs="one"\',\n                content: \'text:"One"\'\n              },\n              {\n                when: \'#.tabs="two"\',\n                content: \'text:"Two"\'\n              },\n              {\n                when: \'#.tabs="three"\',\n                content: \'text:"Three"\'\n              }\n            ]\n          }\n        },\n        examples: [\n          {\n            title: "Active & disabled tab",\n            demo: {\n              view: "tabs",\n              name: "tabs",\n              tabs: [\n                { value: "one", text: "One" },\n                { value: "two", text: "Two", active: true },\n                { value: "three", text: "Three", disabled: true }\n              ],\n              content: {\n                view: "switch",\n                content: [\n                  {\n                    when: \'#.tabs="one"\',\n                    content: \'text:"One"\'\n                  },\n                  {\n                    when: \'#.tabs="two"\',\n                    content: \'text:"Two"\'\n                  },\n                  {\n                    when: \'#.tabs="three"\',\n                    content: \'text:"Three"\'\n                  }\n                ]\n              }\n            }\n          },\n          {\n            title: "On click handler",\n            demo: {\n              view: "tabs",\n              name: "tabs",\n              tabs: [\n                { value: "one", text: "One", onClick: onClick2 },\n                { value: "two", text: "Two", onClick: onClick2 },\n                { value: "three", text: "Three", onClick: onClick2 }\n              ],\n              content: {\n                view: "switch",\n                content: [\n                  {\n                    when: \'#.tabs="one"\',\n                    content: \'text:"One"\'\n                  },\n                  {\n                    when: \'#.tabs="two"\',\n                    content: \'text:"Two"\'\n                  },\n                  {\n                    when: \'#.tabs="three"\',\n                    content: \'text:"Three"\'\n                  }\n                ]\n              }\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/tab.js\n  function tab_default(host) {\n    host.view.define("tab", function(el, config, data, context) {\n      const {\n        content,\n        active = false,\n        disabled = false,\n        onClick: onClick3,\n        value,\n        text = String(value).replace(/^./, (m2) => m2.toUpperCase())\n      } = config;\n      if (host.query(disabled, data, context)) {\n        el.classList.add("disabled");\n      } else if (typeof onClick3 === "function") {\n        el.addEventListener("click", () => onClick3(value));\n        el.classList.add("onclick");\n      }\n      if (active) {\n        el.classList.add("active");\n      }\n      if (content) {\n        return host.view.render(el, content, data, context);\n      } else {\n        el.textContent = text;\n      }\n    }, { usage: tab_usage_default });\n  }\n  var init_tab = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/tab.js"() {\n      init_tab_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/toggle-group.usage.js\n  var toggle_group_usage_default;\n  var init_toggle_group_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/toggle-group.usage.js"() {\n      toggle_group_usage_default = {\n        demo: {\n          view: "context",\n          modifiers: {\n            view: "toggle-group",\n            name: "toggleValue",\n            data: [\n              { value: "one", text: "One" },\n              { value: "two", text: "Two" },\n              { value: "three", text: "Three" }\n            ]\n          },\n          content: {\n            view: "switch",\n            content: [\n              {\n                when: \'#.toggleValue="one"\',\n                content: \'text:"One"\'\n              },\n              {\n                when: \'#.toggleValue="two"\',\n                content: \'text:"Two"\'\n              },\n              {\n                when: \'#.toggleValue="three"\',\n                content: \'text:"Three"\'\n              }\n            ]\n          }\n        },\n        examples: [\n          {\n            title: "With before and after content",\n            demo: {\n              view: "toggle-group",\n              data: [\n                { value: "one", text: "One" },\n                { value: "two", text: "Two" },\n                { value: "three", text: "Three" }\n              ],\n              beforeToggles: \'text:"<Content before toggles>"\',\n              afterToggles: \'text:"<Content after toggles>"\'\n            }\n          },\n          {\n            title: "On change handler",\n            demo: {\n              view: "toggle-group",\n              name: "example",\n              onChange: new Function(\'return (value) => alert("changed to " + value)\')(),\n              data: [\n                { value: "one", text: "One" },\n                { value: "two", text: "Two" },\n                { value: "three", text: "Three" }\n              ]\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/toggle.js\n  function toggle_default(host) {\n    host.view.define("toggle", function(el, config, data, context) {\n      const {\n        content,\n        disabled = false,\n        onToggle: onToggle2,\n        value,\n        text = String(value).replace(/^./, (m2) => m2.toUpperCase())\n      } = config;\n      let {\n        checked = false\n      } = config;\n      if (disabled) {\n        el.classList.add("disabled");\n      } else if (typeof onToggle2 === "function") {\n        el.addEventListener("click", () => {\n          checked = !checked;\n          onToggle2(checked, value);\n        });\n        el.classList.add("onclick");\n      }\n      if (checked) {\n        el.classList.add("checked");\n      }\n      if (content) {\n        return host.view.render(el, content, data, context);\n      } else {\n        el.textContent = text;\n      }\n    }, { usage: toggle_group_usage_default });\n  }\n  var init_toggle = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/toggle.js"() {\n      init_toggle_group_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/controls/toggle-group.js\n  function toggle_group_default(host) {\n    host.view.define("toggle-group", function(el, config, data, context) {\n      async function render2(_, value) {\n        const handler = inited ? onChange4 : onInit;\n        if (currentValue === value) {\n          return;\n        }\n        currentValue = value;\n        inited = true;\n        if (Array.isArray(toggles)) {\n          el.innerHTML = "";\n          if (beforeToggles) {\n            beforeTogglesEl.innerHTML = "";\n            await host.view.render(beforeTogglesEl, beforeToggles, data, { ...context, [name]: value });\n            el.appendChild(beforeTogglesEl);\n          }\n          if (afterToggles) {\n            afterTogglesEl.innerHTML = "";\n            await host.view.render(afterTogglesEl, afterToggles, data, { ...context, [name]: value });\n            el.appendChild(afterTogglesEl);\n          }\n          await Promise.all(toggles.map(\n            (toggle, idx) => host.view.render(el, host.view.composeConfig(toggle, {\n              checked: toggle.value === currentValue\n            }), data[idx], context)\n          ));\n        }\n        if (typeof handler === "function") {\n          handler(currentValue, name, data, context);\n        }\n      }\n      const { beforeToggles, afterToggles, onInit, onChange: onChange4 } = config;\n      let { name, toggleConfig } = config;\n      let toggles = [];\n      let beforeTogglesEl = null;\n      let afterTogglesEl = null;\n      let inited = false;\n      let currentValue = NaN;\n      let initValue = "value" in config ? config.value : name in context ? context[name] : void 0;\n      toggleConfig = host.view.composeConfig({\n        view: "toggle",\n        onToggle: render2\n      }, toggleConfig);\n      if (beforeToggles) {\n        beforeTogglesEl = document.createElement("div");\n        beforeTogglesEl.className = "view-toggle-group-before";\n      }\n      if (afterToggles) {\n        afterTogglesEl = document.createElement("div");\n        afterTogglesEl.className = "view-toggle-group-after";\n      }\n      if (typeof name !== "string") {\n        name = "filter";\n      }\n      if (Array.isArray(data)) {\n        toggles = data.map((toggle) => {\n          const type = typeof toggle;\n          if (type === "string" || type === "number" || type === "boolean") {\n            toggle = { value: toggle };\n          }\n          if (initValue === void 0 || toggle.active) {\n            initValue = toggle.value;\n          }\n          return host.view.composeConfig(\n            toggleConfig,\n            toggle\n          );\n        });\n      }\n      return render2(true, initValue);\n    }, { usage: toggle_group_usage_default });\n  }\n  var init_toggle_group = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/controls/toggle-group.js"() {\n      init_toggle_group_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/html.js\n  var html_exports = {};\n  __export(html_exports, {\n    escapeHtml: () => escapeHtml2,\n    numDelim: () => numDelim2\n  });\n  function escapeHtml2(str) {\n    return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");\n  }\n  function numDelim2(value, escape2 = true) {\n    const strValue = escape2 && typeof value !== "number" ? escapeHtml2(String(value)) : String(value);\n    if (strValue.length > 3) {\n      return strValue.replace(\n        /\\.\\d+(eE[-+]?\\d+)?|\\B(?=(\\d{3})+(\\D|$))/g,\n        (m2) => m2 || \'<span class="num-delim"></span>\'\n      );\n    }\n    return strValue;\n  }\n  var init_html = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/html.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/size.js\n  var size_exports = {};\n  __export(size_exports, {\n    ContentRect: () => ContentRect\n  });\n  var resizeObserverSupported, ContentRect;\n  var init_size = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/size.js"() {\n      init_publisher();\n      resizeObserverSupported = typeof ResizeObserver === "function";\n      ContentRect = class extends Publisher {\n        constructor() {\n          super();\n          this.el = null;\n          if (resizeObserverSupported) {\n            this.observer = new ResizeObserver((entries2) => {\n              for (let entry of entries2) {\n                this.set(entry.contentRect);\n              }\n            });\n          }\n        }\n        observe(el) {\n          el = el || null;\n          if (this.observer && this.el !== el) {\n            if (this.el !== null) {\n              this.observer.unobserve(this.el);\n            }\n            if (el !== null) {\n              this.observer.observe(el);\n            }\n          }\n          this.el = el;\n        }\n      };\n    }\n  });\n\n  // node_modules/codemirror/lib/codemirror.js\n  var require_codemirror = __commonJS({\n    "node_modules/codemirror/lib/codemirror.js"(exports, module) {\n      (function(global2, factory) {\n        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());\n      })(exports, function() {\n        "use strict";\n        var userAgent = navigator.userAgent;\n        var platform = navigator.platform;\n        var gecko = /gecko\\/\\d/i.test(userAgent);\n        var ie_upto10 = /MSIE \\d/.test(userAgent);\n        var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n        var edge = /Edge\\/(\\d+)/.exec(userAgent);\n        var ie = ie_upto10 || ie_11up || edge;\n        var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n        var webkit = !edge && /WebKit\\//.test(userAgent);\n        var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n        var chrome = !edge && /Chrome\\/(\\d+)/.exec(userAgent);\n        var chrome_version = chrome && +chrome[1];\n        var presto = /Opera\\//.test(userAgent);\n        var safari = /Apple Computer/.test(navigator.vendor);\n        var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n        var phantom = /PhantomJS/.test(userAgent);\n        var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n        var android = /Android/.test(userAgent);\n        var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n        var mac = ios || /Mac/.test(platform);\n        var chromeOS = /\\bCrOS\\b/.test(userAgent);\n        var windows = /win/i.test(platform);\n        var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n        if (presto_version) {\n          presto_version = Number(presto_version[1]);\n        }\n        if (presto_version && presto_version >= 15) {\n          presto = false;\n          webkit = true;\n        }\n        var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n        var captureRightClick = gecko || ie && ie_version >= 9;\n        function classTest(cls) {\n          return new RegExp("(^|\\\\s)" + cls + "(?:$|\\\\s)\\\\s*");\n        }\n        var rmClass = function(node, cls) {\n          var current = node.className;\n          var match2 = classTest(cls).exec(current);\n          if (match2) {\n            var after = current.slice(match2.index + match2[0].length);\n            node.className = current.slice(0, match2.index) + (after ? match2[1] + after : "");\n          }\n        };\n        function removeChildren(e) {\n          for (var count3 = e.childNodes.length; count3 > 0; --count3) {\n            e.removeChild(e.firstChild);\n          }\n          return e;\n        }\n        function removeChildrenAndAdd(parent, e) {\n          return removeChildren(parent).appendChild(e);\n        }\n        function elt(tag, content, className, style) {\n          var e = document.createElement(tag);\n          if (className) {\n            e.className = className;\n          }\n          if (style) {\n            e.style.cssText = style;\n          }\n          if (typeof content == "string") {\n            e.appendChild(document.createTextNode(content));\n          } else if (content) {\n            for (var i2 = 0; i2 < content.length; ++i2) {\n              e.appendChild(content[i2]);\n            }\n          }\n          return e;\n        }\n        function eltP(tag, content, className, style) {\n          var e = elt(tag, content, className, style);\n          e.setAttribute("role", "presentation");\n          return e;\n        }\n        var range;\n        if (document.createRange) {\n          range = function(node, start, end, endNode) {\n            var r = document.createRange();\n            r.setEnd(endNode || node, end);\n            r.setStart(node, start);\n            return r;\n          };\n        } else {\n          range = function(node, start, end) {\n            var r = document.body.createTextRange();\n            try {\n              r.moveToElementText(node.parentNode);\n            } catch (e) {\n              return r;\n            }\n            r.collapse(true);\n            r.moveEnd("character", end);\n            r.moveStart("character", start);\n            return r;\n          };\n        }\n        function contains(parent, child) {\n          if (child.nodeType == 3) {\n            child = child.parentNode;\n          }\n          if (parent.contains) {\n            return parent.contains(child);\n          }\n          do {\n            if (child.nodeType == 11) {\n              child = child.host;\n            }\n            if (child == parent) {\n              return true;\n            }\n          } while (child = child.parentNode);\n        }\n        function activeElt(rootNode2) {\n          var doc2 = rootNode2.ownerDocument || rootNode2;\n          var activeElement;\n          try {\n            activeElement = rootNode2.activeElement;\n          } catch (e) {\n            activeElement = doc2.body || null;\n          }\n          while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n            activeElement = activeElement.shadowRoot.activeElement;\n          }\n          return activeElement;\n        }\n        function addClass(node, cls) {\n          var current = node.className;\n          if (!classTest(cls).test(current)) {\n            node.className += (current ? " " : "") + cls;\n          }\n        }\n        function joinClasses(a, b2) {\n          var as = a.split(" ");\n          for (var i2 = 0; i2 < as.length; i2++) {\n            if (as[i2] && !classTest(as[i2]).test(b2)) {\n              b2 += " " + as[i2];\n            }\n          }\n          return b2;\n        }\n        var selectInput = function(node) {\n          node.select();\n        };\n        if (ios) {\n          selectInput = function(node) {\n            node.selectionStart = 0;\n            node.selectionEnd = node.value.length;\n          };\n        } else if (ie) {\n          selectInput = function(node) {\n            try {\n              node.select();\n            } catch (_e) {\n            }\n          };\n        }\n        function doc(cm) {\n          return cm.display.wrapper.ownerDocument;\n        }\n        function root(cm) {\n          return rootNode(cm.display.wrapper);\n        }\n        function rootNode(element) {\n          return element.getRootNode ? element.getRootNode() : element.ownerDocument;\n        }\n        function win(cm) {\n          return doc(cm).defaultView;\n        }\n        function bind(f) {\n          var args = Array.prototype.slice.call(arguments, 1);\n          return function() {\n            return f.apply(null, args);\n          };\n        }\n        function copyObj(obj, target, overwrite) {\n          if (!target) {\n            target = {};\n          }\n          for (var prop2 in obj) {\n            if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {\n              target[prop2] = obj[prop2];\n            }\n          }\n          return target;\n        }\n        function countColumn(string, end, tabSize, startIndex, startValue) {\n          if (end == null) {\n            end = string.search(/[^\\s\\u00a0]/);\n            if (end == -1) {\n              end = string.length;\n            }\n          }\n          for (var i2 = startIndex || 0, n = startValue || 0; ; ) {\n            var nextTab = string.indexOf("\t", i2);\n            if (nextTab < 0 || nextTab >= end) {\n              return n + (end - i2);\n            }\n            n += nextTab - i2;\n            n += tabSize - n % tabSize;\n            i2 = nextTab + 1;\n          }\n        }\n        var Delayed = function() {\n          this.id = null;\n          this.f = null;\n          this.time = 0;\n          this.handler = bind(this.onTimeout, this);\n        };\n        Delayed.prototype.onTimeout = function(self5) {\n          self5.id = 0;\n          if (self5.time <= +/* @__PURE__ */ new Date()) {\n            self5.f();\n          } else {\n            setTimeout(self5.handler, self5.time - +/* @__PURE__ */ new Date());\n          }\n        };\n        Delayed.prototype.set = function(ms, f) {\n          this.f = f;\n          var time = +/* @__PURE__ */ new Date() + ms;\n          if (!this.id || time < this.time) {\n            clearTimeout(this.id);\n            this.id = setTimeout(this.handler, ms);\n            this.time = time;\n          }\n        };\n        function indexOf2(array, elt2) {\n          for (var i2 = 0; i2 < array.length; ++i2) {\n            if (array[i2] == elt2) {\n              return i2;\n            }\n          }\n          return -1;\n        }\n        var scrollerGap = 50;\n        var Pass = { toString: function() {\n          return "CodeMirror.Pass";\n        } };\n        var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };\n        function findColumn(string, goal, tabSize) {\n          for (var pos = 0, col = 0; ; ) {\n            var nextTab = string.indexOf("\t", pos);\n            if (nextTab == -1) {\n              nextTab = string.length;\n            }\n            var skipped = nextTab - pos;\n            if (nextTab == string.length || col + skipped >= goal) {\n              return pos + Math.min(skipped, goal - col);\n            }\n            col += nextTab - pos;\n            col += tabSize - col % tabSize;\n            pos = nextTab + 1;\n            if (col >= goal) {\n              return pos;\n            }\n          }\n        }\n        var spaceStrs = [""];\n        function spaceStr(n) {\n          while (spaceStrs.length <= n) {\n            spaceStrs.push(lst(spaceStrs) + " ");\n          }\n          return spaceStrs[n];\n        }\n        function lst(arr) {\n          return arr[arr.length - 1];\n        }\n        function map2(array, f) {\n          var out = [];\n          for (var i2 = 0; i2 < array.length; i2++) {\n            out[i2] = f(array[i2], i2);\n          }\n          return out;\n        }\n        function insertSorted(array, value, score) {\n          var pos = 0, priority = score(value);\n          while (pos < array.length && score(array[pos]) <= priority) {\n            pos++;\n          }\n          array.splice(pos, 0, value);\n        }\n        function nothing() {\n        }\n        function createObj(base, props) {\n          var inst;\n          if (Object.create) {\n            inst = Object.create(base);\n          } else {\n            nothing.prototype = base;\n            inst = new nothing();\n          }\n          if (props) {\n            copyObj(props, inst);\n          }\n          return inst;\n        }\n        var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n        function isWordCharBasic(ch) {\n          return /\\w/.test(ch) || ch > "\\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n        }\n        function isWordChar(ch, helper) {\n          if (!helper) {\n            return isWordCharBasic(ch);\n          }\n          if (helper.source.indexOf("\\\\w") > -1 && isWordCharBasic(ch)) {\n            return true;\n          }\n          return helper.test(ch);\n        }\n        function isEmpty(obj) {\n          for (var n in obj) {\n            if (obj.hasOwnProperty(n) && obj[n]) {\n              return false;\n            }\n          }\n          return true;\n        }\n        var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n        function isExtendingChar(ch) {\n          return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n        }\n        function skipExtendingChars(str, pos, dir) {\n          while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {\n            pos += dir;\n          }\n          return pos;\n        }\n        function findFirst(pred, from, to) {\n          var dir = from > to ? -1 : 1;\n          for (; ; ) {\n            if (from == to) {\n              return from;\n            }\n            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n            if (mid == from) {\n              return pred(mid) ? from : to;\n            }\n            if (pred(mid)) {\n              to = mid;\n            } else {\n              from = mid + dir;\n            }\n          }\n        }\n        function iterateBidiSections(order, from, to, f) {\n          if (!order) {\n            return f(from, to, "ltr", 0);\n          }\n          var found = false;\n          for (var i2 = 0; i2 < order.length; ++i2) {\n            var part = order[i2];\n            if (part.from < to && part.to > from || from == to && part.to == from) {\n              f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);\n              found = true;\n            }\n          }\n          if (!found) {\n            f(from, to, "ltr");\n          }\n        }\n        var bidiOther = null;\n        function getBidiPartAt(order, ch, sticky) {\n          var found;\n          bidiOther = null;\n          for (var i2 = 0; i2 < order.length; ++i2) {\n            var cur = order[i2];\n            if (cur.from < ch && cur.to > ch) {\n              return i2;\n            }\n            if (cur.to == ch) {\n              if (cur.from != cur.to && sticky == "before") {\n                found = i2;\n              } else {\n                bidiOther = i2;\n              }\n            }\n            if (cur.from == ch) {\n              if (cur.from != cur.to && sticky != "before") {\n                found = i2;\n              } else {\n                bidiOther = i2;\n              }\n            }\n          }\n          return found != null ? found : bidiOther;\n        }\n        var bidiOrdering = /* @__PURE__ */ function() {\n          var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";\n          var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";\n          function charType(code) {\n            if (code <= 247) {\n              return lowTypes.charAt(code);\n            } else if (1424 <= code && code <= 1524) {\n              return "R";\n            } else if (1536 <= code && code <= 1785) {\n              return arabicTypes.charAt(code - 1536);\n            } else if (1774 <= code && code <= 2220) {\n              return "r";\n            } else if (8192 <= code && code <= 8203) {\n              return "w";\n            } else if (code == 8204) {\n              return "b";\n            } else {\n              return "L";\n            }\n          }\n          var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n          var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n          function BidiSpan(level, from, to) {\n            this.level = level;\n            this.from = from;\n            this.to = to;\n          }\n          return function(str, direction) {\n            var outerType = direction == "ltr" ? "L" : "R";\n            if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {\n              return false;\n            }\n            var len = str.length, types = [];\n            for (var i2 = 0; i2 < len; ++i2) {\n              types.push(charType(str.charCodeAt(i2)));\n            }\n            for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {\n              var type = types[i$12];\n              if (type == "m") {\n                types[i$12] = prev;\n              } else {\n                prev = type;\n              }\n            }\n            for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {\n              var type$1 = types[i$22];\n              if (type$1 == "1" && cur == "r") {\n                types[i$22] = "n";\n              } else if (isStrong.test(type$1)) {\n                cur = type$1;\n                if (type$1 == "r") {\n                  types[i$22] = "R";\n                }\n              }\n            }\n            for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n              var type$2 = types[i$3];\n              if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {\n                types[i$3] = "1";\n              } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {\n                types[i$3] = prev$1;\n              }\n              prev$1 = type$2;\n            }\n            for (var i$4 = 0; i$4 < len; ++i$4) {\n              var type$3 = types[i$4];\n              if (type$3 == ",") {\n                types[i$4] = "N";\n              } else if (type$3 == "%") {\n                var end = void 0;\n                for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {\n                }\n                var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";\n                for (var j2 = i$4; j2 < end; ++j2) {\n                  types[j2] = replace;\n                }\n                i$4 = end - 1;\n              }\n            }\n            for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n              var type$4 = types[i$5];\n              if (cur$1 == "L" && type$4 == "1") {\n                types[i$5] = "L";\n              } else if (isStrong.test(type$4)) {\n                cur$1 = type$4;\n              }\n            }\n            for (var i$6 = 0; i$6 < len; ++i$6) {\n              if (isNeutral.test(types[i$6])) {\n                var end$1 = void 0;\n                for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {\n                }\n                var before = (i$6 ? types[i$6 - 1] : outerType) == "L";\n                var after = (end$1 < len ? types[end$1] : outerType) == "L";\n                var replace$1 = before == after ? before ? "L" : "R" : outerType;\n                for (var j$1 = i$6; j$1 < end$1; ++j$1) {\n                  types[j$1] = replace$1;\n                }\n                i$6 = end$1 - 1;\n              }\n            }\n            var order = [], m2;\n            for (var i$7 = 0; i$7 < len; ) {\n              if (countsAsLeft.test(types[i$7])) {\n                var start = i$7;\n                for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {\n                }\n                order.push(new BidiSpan(0, start, i$7));\n              } else {\n                var pos = i$7, at2 = order.length, isRTL = direction == "rtl" ? 1 : 0;\n                for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {\n                }\n                for (var j$2 = pos; j$2 < i$7; ) {\n                  if (countsAsNum.test(types[j$2])) {\n                    if (pos < j$2) {\n                      order.splice(at2, 0, new BidiSpan(1, pos, j$2));\n                      at2 += isRTL;\n                    }\n                    var nstart = j$2;\n                    for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {\n                    }\n                    order.splice(at2, 0, new BidiSpan(2, nstart, j$2));\n                    at2 += isRTL;\n                    pos = j$2;\n                  } else {\n                    ++j$2;\n                  }\n                }\n                if (pos < i$7) {\n                  order.splice(at2, 0, new BidiSpan(1, pos, i$7));\n                }\n              }\n            }\n            if (direction == "ltr") {\n              if (order[0].level == 1 && (m2 = str.match(/^\\s+/))) {\n                order[0].from = m2[0].length;\n                order.unshift(new BidiSpan(0, 0, m2[0].length));\n              }\n              if (lst(order).level == 1 && (m2 = str.match(/\\s+$/))) {\n                lst(order).to -= m2[0].length;\n                order.push(new BidiSpan(0, len - m2[0].length, len));\n              }\n            }\n            return direction == "rtl" ? order.reverse() : order;\n          };\n        }();\n        function getOrder2(line, direction) {\n          var order = line.order;\n          if (order == null) {\n            order = line.order = bidiOrdering(line.text, direction);\n          }\n          return order;\n        }\n        var noHandlers = [];\n        var on = function(emitter, type, f) {\n          if (emitter.addEventListener) {\n            emitter.addEventListener(type, f, false);\n          } else if (emitter.attachEvent) {\n            emitter.attachEvent("on" + type, f);\n          } else {\n            var map3 = emitter._handlers || (emitter._handlers = {});\n            map3[type] = (map3[type] || noHandlers).concat(f);\n          }\n        };\n        function getHandlers(emitter, type) {\n          return emitter._handlers && emitter._handlers[type] || noHandlers;\n        }\n        function off(emitter, type, f) {\n          if (emitter.removeEventListener) {\n            emitter.removeEventListener(type, f, false);\n          } else if (emitter.detachEvent) {\n            emitter.detachEvent("on" + type, f);\n          } else {\n            var map3 = emitter._handlers, arr = map3 && map3[type];\n            if (arr) {\n              var index = indexOf2(arr, f);\n              if (index > -1) {\n                map3[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n              }\n            }\n          }\n        }\n        function signal(emitter, type) {\n          var handlers = getHandlers(emitter, type);\n          if (!handlers.length) {\n            return;\n          }\n          var args = Array.prototype.slice.call(arguments, 2);\n          for (var i2 = 0; i2 < handlers.length; ++i2) {\n            handlers[i2].apply(null, args);\n          }\n        }\n        function signalDOMEvent(cm, e, override) {\n          if (typeof e == "string") {\n            e = { type: e, preventDefault: function() {\n              this.defaultPrevented = true;\n            } };\n          }\n          signal(cm, override || e.type, cm, e);\n          return e_defaultPrevented(e) || e.codemirrorIgnore;\n        }\n        function signalCursorActivity(cm) {\n          var arr = cm._handlers && cm._handlers.cursorActivity;\n          if (!arr) {\n            return;\n          }\n          var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n          for (var i2 = 0; i2 < arr.length; ++i2) {\n            if (indexOf2(set, arr[i2]) == -1) {\n              set.push(arr[i2]);\n            }\n          }\n        }\n        function hasHandler(emitter, type) {\n          return getHandlers(emitter, type).length > 0;\n        }\n        function eventMixin(ctor) {\n          ctor.prototype.on = function(type, f) {\n            on(this, type, f);\n          };\n          ctor.prototype.off = function(type, f) {\n            off(this, type, f);\n          };\n        }\n        function e_preventDefault(e) {\n          if (e.preventDefault) {\n            e.preventDefault();\n          } else {\n            e.returnValue = false;\n          }\n        }\n        function e_stopPropagation(e) {\n          if (e.stopPropagation) {\n            e.stopPropagation();\n          } else {\n            e.cancelBubble = true;\n          }\n        }\n        function e_defaultPrevented(e) {\n          return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n        }\n        function e_stop(e) {\n          e_preventDefault(e);\n          e_stopPropagation(e);\n        }\n        function e_target(e) {\n          return e.target || e.srcElement;\n        }\n        function e_button(e) {\n          var b2 = e.which;\n          if (b2 == null) {\n            if (e.button & 1) {\n              b2 = 1;\n            } else if (e.button & 2) {\n              b2 = 3;\n            } else if (e.button & 4) {\n              b2 = 2;\n            }\n          }\n          if (mac && e.ctrlKey && b2 == 1) {\n            b2 = 3;\n          }\n          return b2;\n        }\n        var dragAndDrop = function() {\n          if (ie && ie_version < 9) {\n            return false;\n          }\n          var div2 = elt("div");\n          return "draggable" in div2 || "dragDrop" in div2;\n        }();\n        var zwspSupported;\n        function zeroWidthElement(measure) {\n          if (zwspSupported == null) {\n            var test2 = elt("span", "\\u200B");\n            removeChildrenAndAdd(measure, elt("span", [test2, document.createTextNode("x")]));\n            if (measure.firstChild.offsetHeight != 0) {\n              zwspSupported = test2.offsetWidth <= 1 && test2.offsetHeight > 2 && !(ie && ie_version < 8);\n            }\n          }\n          var node = zwspSupported ? elt("span", "\\u200B") : elt("span", "\\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");\n          node.setAttribute("cm-text", "");\n          return node;\n        }\n        var badBidiRects;\n        function hasBadBidiRects(measure) {\n          if (badBidiRects != null) {\n            return badBidiRects;\n          }\n          var txt = removeChildrenAndAdd(measure, document.createTextNode("A\\u062EA"));\n          var r0 = range(txt, 0, 1).getBoundingClientRect();\n          var r1 = range(txt, 1, 2).getBoundingClientRect();\n          removeChildren(measure);\n          if (!r0 || r0.left == r0.right) {\n            return false;\n          }\n          return badBidiRects = r1.right - r0.right < 3;\n        }\n        var splitLinesAuto = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {\n          var pos = 0, result = [], l = string.length;\n          while (pos <= l) {\n            var nl = string.indexOf("\\n", pos);\n            if (nl == -1) {\n              nl = string.length;\n            }\n            var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\n            var rt2 = line.indexOf("\\r");\n            if (rt2 != -1) {\n              result.push(line.slice(0, rt2));\n              pos += rt2 + 1;\n            } else {\n              result.push(line);\n              pos = nl + 1;\n            }\n          }\n          return result;\n        } : function(string) {\n          return string.split(/\\r\\n?|\\n/);\n        };\n        var hasSelection = window.getSelection ? function(te) {\n          try {\n            return te.selectionStart != te.selectionEnd;\n          } catch (e) {\n            return false;\n          }\n        } : function(te) {\n          var range2;\n          try {\n            range2 = te.ownerDocument.selection.createRange();\n          } catch (e) {\n          }\n          if (!range2 || range2.parentElement() != te) {\n            return false;\n          }\n          return range2.compareEndPoints("StartToEnd", range2) != 0;\n        };\n        var hasCopyEvent = function() {\n          var e = elt("div");\n          if ("oncopy" in e) {\n            return true;\n          }\n          e.setAttribute("oncopy", "return;");\n          return typeof e.oncopy == "function";\n        }();\n        var badZoomedRects = null;\n        function hasBadZoomedRects(measure) {\n          if (badZoomedRects != null) {\n            return badZoomedRects;\n          }\n          var node = removeChildrenAndAdd(measure, elt("span", "x"));\n          var normal = node.getBoundingClientRect();\n          var fromRange = range(node, 0, 1).getBoundingClientRect();\n          return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n        }\n        var modes = {}, mimeModes = {};\n        function defineMode(name, mode) {\n          if (arguments.length > 2) {\n            mode.dependencies = Array.prototype.slice.call(arguments, 2);\n          }\n          modes[name] = mode;\n        }\n        function defineMIME(mime, spec) {\n          mimeModes[mime] = spec;\n        }\n        function resolveMode(spec) {\n          if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n            spec = mimeModes[spec];\n          } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n            var found = mimeModes[spec.name];\n            if (typeof found == "string") {\n              found = { name: found };\n            }\n            spec = createObj(found, spec);\n            spec.name = found.name;\n          } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n            return resolveMode("application/xml");\n          } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n            return resolveMode("application/json");\n          }\n          if (typeof spec == "string") {\n            return { name: spec };\n          } else {\n            return spec || { name: "null" };\n          }\n        }\n        function getMode(options2, spec) {\n          spec = resolveMode(spec);\n          var mfactory = modes[spec.name];\n          if (!mfactory) {\n            return getMode(options2, "text/plain");\n          }\n          var modeObj = mfactory(options2, spec);\n          if (modeExtensions.hasOwnProperty(spec.name)) {\n            var exts = modeExtensions[spec.name];\n            for (var prop2 in exts) {\n              if (!exts.hasOwnProperty(prop2)) {\n                continue;\n              }\n              if (modeObj.hasOwnProperty(prop2)) {\n                modeObj["_" + prop2] = modeObj[prop2];\n              }\n              modeObj[prop2] = exts[prop2];\n            }\n          }\n          modeObj.name = spec.name;\n          if (spec.helperType) {\n            modeObj.helperType = spec.helperType;\n          }\n          if (spec.modeProps) {\n            for (var prop$1 in spec.modeProps) {\n              modeObj[prop$1] = spec.modeProps[prop$1];\n            }\n          }\n          return modeObj;\n        }\n        var modeExtensions = {};\n        function extendMode(mode, properties) {\n          var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n          copyObj(properties, exts);\n        }\n        function copyState(mode, state) {\n          if (state === true) {\n            return state;\n          }\n          if (mode.copyState) {\n            return mode.copyState(state);\n          }\n          var nstate = {};\n          for (var n in state) {\n            var val = state[n];\n            if (val instanceof Array) {\n              val = val.concat([]);\n            }\n            nstate[n] = val;\n          }\n          return nstate;\n        }\n        function innerMode(mode, state) {\n          var info;\n          while (mode.innerMode) {\n            info = mode.innerMode(state);\n            if (!info || info.mode == mode) {\n              break;\n            }\n            state = info.state;\n            mode = info.mode;\n          }\n          return info || { mode, state };\n        }\n        function startState(mode, a1, a2) {\n          return mode.startState ? mode.startState(a1, a2) : true;\n        }\n        var StringStream = function(string, tabSize, lineOracle) {\n          this.pos = this.start = 0;\n          this.string = string;\n          this.tabSize = tabSize || 8;\n          this.lastColumnPos = this.lastColumnValue = 0;\n          this.lineStart = 0;\n          this.lineOracle = lineOracle;\n        };\n        StringStream.prototype.eol = function() {\n          return this.pos >= this.string.length;\n        };\n        StringStream.prototype.sol = function() {\n          return this.pos == this.lineStart;\n        };\n        StringStream.prototype.peek = function() {\n          return this.string.charAt(this.pos) || void 0;\n        };\n        StringStream.prototype.next = function() {\n          if (this.pos < this.string.length) {\n            return this.string.charAt(this.pos++);\n          }\n        };\n        StringStream.prototype.eat = function(match2) {\n          var ch = this.string.charAt(this.pos);\n          var ok;\n          if (typeof match2 == "string") {\n            ok = ch == match2;\n          } else {\n            ok = ch && (match2.test ? match2.test(ch) : match2(ch));\n          }\n          if (ok) {\n            ++this.pos;\n            return ch;\n          }\n        };\n        StringStream.prototype.eatWhile = function(match2) {\n          var start = this.pos;\n          while (this.eat(match2)) {\n          }\n          return this.pos > start;\n        };\n        StringStream.prototype.eatSpace = function() {\n          var start = this.pos;\n          while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n            ++this.pos;\n          }\n          return this.pos > start;\n        };\n        StringStream.prototype.skipToEnd = function() {\n          this.pos = this.string.length;\n        };\n        StringStream.prototype.skipTo = function(ch) {\n          var found = this.string.indexOf(ch, this.pos);\n          if (found > -1) {\n            this.pos = found;\n            return true;\n          }\n        };\n        StringStream.prototype.backUp = function(n) {\n          this.pos -= n;\n        };\n        StringStream.prototype.column = function() {\n          if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n          }\n          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n        };\n        StringStream.prototype.indentation = function() {\n          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n        };\n        StringStream.prototype.match = function(pattern, consume, caseInsensitive) {\n          if (typeof pattern == "string") {\n            var cased = function(str) {\n              return caseInsensitive ? str.toLowerCase() : str;\n            };\n            var substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n              if (consume !== false) {\n                this.pos += pattern.length;\n              }\n              return true;\n            }\n          } else {\n            var match2 = this.string.slice(this.pos).match(pattern);\n            if (match2 && match2.index > 0) {\n              return null;\n            }\n            if (match2 && consume !== false) {\n              this.pos += match2[0].length;\n            }\n            return match2;\n          }\n        };\n        StringStream.prototype.current = function() {\n          return this.string.slice(this.start, this.pos);\n        };\n        StringStream.prototype.hideFirstChars = function(n, inner) {\n          this.lineStart += n;\n          try {\n            return inner();\n          } finally {\n            this.lineStart -= n;\n          }\n        };\n        StringStream.prototype.lookAhead = function(n) {\n          var oracle = this.lineOracle;\n          return oracle && oracle.lookAhead(n);\n        };\n        StringStream.prototype.baseToken = function() {\n          var oracle = this.lineOracle;\n          return oracle && oracle.baseToken(this.pos);\n        };\n        function getLine(doc2, n) {\n          n -= doc2.first;\n          if (n < 0 || n >= doc2.size) {\n            throw new Error("There is no line " + (n + doc2.first) + " in the document.");\n          }\n          var chunk = doc2;\n          while (!chunk.lines) {\n            for (var i2 = 0; ; ++i2) {\n              var child = chunk.children[i2], sz = child.chunkSize();\n              if (n < sz) {\n                chunk = child;\n                break;\n              }\n              n -= sz;\n            }\n          }\n          return chunk.lines[n];\n        }\n        function getBetween(doc2, start, end) {\n          var out = [], n = start.line;\n          doc2.iter(start.line, end.line + 1, function(line) {\n            var text = line.text;\n            if (n == end.line) {\n              text = text.slice(0, end.ch);\n            }\n            if (n == start.line) {\n              text = text.slice(start.ch);\n            }\n            out.push(text);\n            ++n;\n          });\n          return out;\n        }\n        function getLines(doc2, from, to) {\n          var out = [];\n          doc2.iter(from, to, function(line) {\n            out.push(line.text);\n          });\n          return out;\n        }\n        function updateLineHeight(line, height) {\n          var diff = height - line.height;\n          if (diff) {\n            for (var n = line; n; n = n.parent) {\n              n.height += diff;\n            }\n          }\n        }\n        function lineNo(line) {\n          if (line.parent == null) {\n            return null;\n          }\n          var cur = line.parent, no = indexOf2(cur.lines, line);\n          for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n            for (var i2 = 0; ; ++i2) {\n              if (chunk.children[i2] == cur) {\n                break;\n              }\n              no += chunk.children[i2].chunkSize();\n            }\n          }\n          return no + cur.first;\n        }\n        function lineAtHeight(chunk, h2) {\n          var n = chunk.first;\n          outer:\n            do {\n              for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {\n                var child = chunk.children[i$12], ch = child.height;\n                if (h2 < ch) {\n                  chunk = child;\n                  continue outer;\n                }\n                h2 -= ch;\n                n += child.chunkSize();\n              }\n              return n;\n            } while (!chunk.lines);\n          var i2 = 0;\n          for (; i2 < chunk.lines.length; ++i2) {\n            var line = chunk.lines[i2], lh = line.height;\n            if (h2 < lh) {\n              break;\n            }\n            h2 -= lh;\n          }\n          return n + i2;\n        }\n        function isLine(doc2, l) {\n          return l >= doc2.first && l < doc2.first + doc2.size;\n        }\n        function lineNumberFor(options2, i2) {\n          return String(options2.lineNumberFormatter(i2 + options2.firstLineNumber));\n        }\n        function Pos(line, ch, sticky) {\n          if (sticky === void 0)\n            sticky = null;\n          if (!(this instanceof Pos)) {\n            return new Pos(line, ch, sticky);\n          }\n          this.line = line;\n          this.ch = ch;\n          this.sticky = sticky;\n        }\n        function cmp2(a, b2) {\n          return a.line - b2.line || a.ch - b2.ch;\n        }\n        function equalCursorPos(a, b2) {\n          return a.sticky == b2.sticky && cmp2(a, b2) == 0;\n        }\n        function copyPos(x) {\n          return Pos(x.line, x.ch);\n        }\n        function maxPos(a, b2) {\n          return cmp2(a, b2) < 0 ? b2 : a;\n        }\n        function minPos(a, b2) {\n          return cmp2(a, b2) < 0 ? a : b2;\n        }\n        function clipLine(doc2, n) {\n          return Math.max(doc2.first, Math.min(n, doc2.first + doc2.size - 1));\n        }\n        function clipPos(doc2, pos) {\n          if (pos.line < doc2.first) {\n            return Pos(doc2.first, 0);\n          }\n          var last = doc2.first + doc2.size - 1;\n          if (pos.line > last) {\n            return Pos(last, getLine(doc2, last).text.length);\n          }\n          return clipToLen(pos, getLine(doc2, pos.line).text.length);\n        }\n        function clipToLen(pos, linelen) {\n          var ch = pos.ch;\n          if (ch == null || ch > linelen) {\n            return Pos(pos.line, linelen);\n          } else if (ch < 0) {\n            return Pos(pos.line, 0);\n          } else {\n            return pos;\n          }\n        }\n        function clipPosArray(doc2, array) {\n          var out = [];\n          for (var i2 = 0; i2 < array.length; i2++) {\n            out[i2] = clipPos(doc2, array[i2]);\n          }\n          return out;\n        }\n        var SavedContext = function(state, lookAhead) {\n          this.state = state;\n          this.lookAhead = lookAhead;\n        };\n        var Context = function(doc2, state, line, lookAhead) {\n          this.state = state;\n          this.doc = doc2;\n          this.line = line;\n          this.maxLookAhead = lookAhead || 0;\n          this.baseTokens = null;\n          this.baseTokenPos = 1;\n        };\n        Context.prototype.lookAhead = function(n) {\n          var line = this.doc.getLine(this.line + n);\n          if (line != null && n > this.maxLookAhead) {\n            this.maxLookAhead = n;\n          }\n          return line;\n        };\n        Context.prototype.baseToken = function(n) {\n          if (!this.baseTokens) {\n            return null;\n          }\n          while (this.baseTokens[this.baseTokenPos] <= n) {\n            this.baseTokenPos += 2;\n          }\n          var type = this.baseTokens[this.baseTokenPos + 1];\n          return {\n            type: type && type.replace(/( |^)overlay .*/, ""),\n            size: this.baseTokens[this.baseTokenPos] - n\n          };\n        };\n        Context.prototype.nextLine = function() {\n          this.line++;\n          if (this.maxLookAhead > 0) {\n            this.maxLookAhead--;\n          }\n        };\n        Context.fromSaved = function(doc2, saved, line) {\n          if (saved instanceof SavedContext) {\n            return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);\n          } else {\n            return new Context(doc2, copyState(doc2.mode, saved), line);\n          }\n        };\n        Context.prototype.save = function(copy) {\n          var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n          return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n        };\n        function highlightLine(cm, line, context, forceToEnd) {\n          var st2 = [cm.state.modeGen], lineClasses = {};\n          runMode(\n            cm,\n            line.text,\n            cm.doc.mode,\n            context,\n            function(end, style) {\n              return st2.push(end, style);\n            },\n            lineClasses,\n            forceToEnd\n          );\n          var state = context.state;\n          var loop = function(o2) {\n            context.baseTokens = st2;\n            var overlay = cm.state.overlays[o2], i2 = 1, at2 = 0;\n            context.state = true;\n            runMode(cm, line.text, overlay.mode, context, function(end, style) {\n              var start = i2;\n              while (at2 < end) {\n                var i_end = st2[i2];\n                if (i_end > end) {\n                  st2.splice(i2, 1, end, st2[i2 + 1], i_end);\n                }\n                i2 += 2;\n                at2 = Math.min(end, i_end);\n              }\n              if (!style) {\n                return;\n              }\n              if (overlay.opaque) {\n                st2.splice(start, i2 - start, end, "overlay " + style);\n                i2 = start + 2;\n              } else {\n                for (; start < i2; start += 2) {\n                  var cur = st2[start + 1];\n                  st2[start + 1] = (cur ? cur + " " : "") + "overlay " + style;\n                }\n              }\n            }, lineClasses);\n            context.state = state;\n            context.baseTokens = null;\n            context.baseTokenPos = 1;\n          };\n          for (var o = 0; o < cm.state.overlays.length; ++o)\n            loop(o);\n          return { styles: st2, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };\n        }\n        function getLineStyles(cm, line, updateFrontier) {\n          if (!line.styles || line.styles[0] != cm.state.modeGen) {\n            var context = getContextBefore(cm, lineNo(line));\n            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n            var result = highlightLine(cm, line, context);\n            if (resetState) {\n              context.state = resetState;\n            }\n            line.stateAfter = context.save(!resetState);\n            line.styles = result.styles;\n            if (result.classes) {\n              line.styleClasses = result.classes;\n            } else if (line.styleClasses) {\n              line.styleClasses = null;\n            }\n            if (updateFrontier === cm.doc.highlightFrontier) {\n              cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n            }\n          }\n          return line.styles;\n        }\n        function getContextBefore(cm, n, precise) {\n          var doc2 = cm.doc, display = cm.display;\n          if (!doc2.mode.startState) {\n            return new Context(doc2, true, n);\n          }\n          var start = findStartLine(cm, n, precise);\n          var saved = start > doc2.first && getLine(doc2, start - 1).stateAfter;\n          var context = saved ? Context.fromSaved(doc2, saved, start) : new Context(doc2, startState(doc2.mode), start);\n          doc2.iter(start, n, function(line) {\n            processLine(cm, line.text, context);\n            var pos = context.line;\n            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n            context.nextLine();\n          });\n          if (precise) {\n            doc2.modeFrontier = context.line;\n          }\n          return context;\n        }\n        function processLine(cm, text, context, startAt) {\n          var mode = cm.doc.mode;\n          var stream = new StringStream(text, cm.options.tabSize, context);\n          stream.start = stream.pos = startAt || 0;\n          if (text == "") {\n            callBlankLine(mode, context.state);\n          }\n          while (!stream.eol()) {\n            readToken(mode, stream, context.state);\n            stream.start = stream.pos;\n          }\n        }\n        function callBlankLine(mode, state) {\n          if (mode.blankLine) {\n            return mode.blankLine(state);\n          }\n          if (!mode.innerMode) {\n            return;\n          }\n          var inner = innerMode(mode, state);\n          if (inner.mode.blankLine) {\n            return inner.mode.blankLine(inner.state);\n          }\n        }\n        function readToken(mode, stream, state, inner) {\n          for (var i2 = 0; i2 < 10; i2++) {\n            if (inner) {\n              inner[0] = innerMode(mode, state).mode;\n            }\n            var style = mode.token(stream, state);\n            if (stream.pos > stream.start) {\n              return style;\n            }\n          }\n          throw new Error("Mode " + mode.name + " failed to advance stream.");\n        }\n        var Token = function(stream, type, state) {\n          this.start = stream.start;\n          this.end = stream.pos;\n          this.string = stream.current();\n          this.type = type || null;\n          this.state = state;\n        };\n        function takeToken(cm, pos, precise, asArray) {\n          var doc2 = cm.doc, mode = doc2.mode, style;\n          pos = clipPos(doc2, pos);\n          var line = getLine(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);\n          var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n          if (asArray) {\n            tokens = [];\n          }\n          while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n            stream.start = stream.pos;\n            style = readToken(mode, stream, context.state);\n            if (asArray) {\n              tokens.push(new Token(stream, style, copyState(doc2.mode, context.state)));\n            }\n          }\n          return asArray ? tokens : new Token(stream, style, context.state);\n        }\n        function extractLineClasses(type, output) {\n          if (type) {\n            for (; ; ) {\n              var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n              if (!lineClass) {\n                break;\n              }\n              type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n              var prop2 = lineClass[1] ? "bgClass" : "textClass";\n              if (output[prop2] == null) {\n                output[prop2] = lineClass[2];\n              } else if (!new RegExp("(?:^|\\\\s)" + lineClass[2] + "(?:$|\\\\s)").test(output[prop2])) {\n                output[prop2] += " " + lineClass[2];\n              }\n            }\n          }\n          return type;\n        }\n        function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n          var flattenSpans = mode.flattenSpans;\n          if (flattenSpans == null) {\n            flattenSpans = cm.options.flattenSpans;\n          }\n          var curStart = 0, curStyle = null;\n          var stream = new StringStream(text, cm.options.tabSize, context), style;\n          var inner = cm.options.addModeClass && [null];\n          if (text == "") {\n            extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n          }\n          while (!stream.eol()) {\n            if (stream.pos > cm.options.maxHighlightLength) {\n              flattenSpans = false;\n              if (forceToEnd) {\n                processLine(cm, text, context, stream.pos);\n              }\n              stream.pos = text.length;\n              style = null;\n            } else {\n              style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n            }\n            if (inner) {\n              var mName = inner[0].name;\n              if (mName) {\n                style = "m-" + (style ? mName + " " + style : mName);\n              }\n            }\n            if (!flattenSpans || curStyle != style) {\n              while (curStart < stream.start) {\n                curStart = Math.min(stream.start, curStart + 5e3);\n                f(curStart, curStyle);\n              }\n              curStyle = style;\n            }\n            stream.start = stream.pos;\n          }\n          while (curStart < stream.pos) {\n            var pos = Math.min(stream.pos, curStart + 5e3);\n            f(pos, curStyle);\n            curStart = pos;\n          }\n        }\n        function findStartLine(cm, n, precise) {\n          var minindent, minline, doc2 = cm.doc;\n          var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);\n          for (var search = n; search > lim; --search) {\n            if (search <= doc2.first) {\n              return doc2.first;\n            }\n            var line = getLine(doc2, search - 1), after = line.stateAfter;\n            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {\n              return search;\n            }\n            var indented = countColumn(line.text, null, cm.options.tabSize);\n            if (minline == null || minindent > indented) {\n              minline = search - 1;\n              minindent = indented;\n            }\n          }\n          return minline;\n        }\n        function retreatFrontier(doc2, n) {\n          doc2.modeFrontier = Math.min(doc2.modeFrontier, n);\n          if (doc2.highlightFrontier < n - 10) {\n            return;\n          }\n          var start = doc2.first;\n          for (var line = n - 1; line > start; line--) {\n            var saved = getLine(doc2, line).stateAfter;\n            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n              start = line + 1;\n              break;\n            }\n          }\n          doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start);\n        }\n        var sawReadOnlySpans = false, sawCollapsedSpans = false;\n        function seeReadOnlySpans() {\n          sawReadOnlySpans = true;\n        }\n        function seeCollapsedSpans() {\n          sawCollapsedSpans = true;\n        }\n        function MarkedSpan(marker, from, to) {\n          this.marker = marker;\n          this.from = from;\n          this.to = to;\n        }\n        function getMarkedSpanFor(spans, marker) {\n          if (spans) {\n            for (var i2 = 0; i2 < spans.length; ++i2) {\n              var span = spans[i2];\n              if (span.marker == marker) {\n                return span;\n              }\n            }\n          }\n        }\n        function removeMarkedSpan(spans, span) {\n          var r;\n          for (var i2 = 0; i2 < spans.length; ++i2) {\n            if (spans[i2] != span) {\n              (r || (r = [])).push(spans[i2]);\n            }\n          }\n          return r;\n        }\n        function addMarkedSpan(line, span, op) {\n          var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));\n          if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {\n            line.markedSpans.push(span);\n          } else {\n            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n            if (inThisOp) {\n              inThisOp.add(line.markedSpans);\n            }\n          }\n          span.marker.attachLine(line);\n        }\n        function markedSpansBefore(old, startCh, isInsert) {\n          var nw;\n          if (old) {\n            for (var i2 = 0; i2 < old.length; ++i2) {\n              var span = old[i2], marker = span.marker;\n              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n              if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\n                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n              }\n            }\n          }\n          return nw;\n        }\n        function markedSpansAfter(old, endCh, isInsert) {\n          var nw;\n          if (old) {\n            for (var i2 = 0; i2 < old.length; ++i2) {\n              var span = old[i2], marker = span.marker;\n              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n              if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\n                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n                (nw || (nw = [])).push(new MarkedSpan(\n                  marker,\n                  startsBefore ? null : span.from - endCh,\n                  span.to == null ? null : span.to - endCh\n                ));\n              }\n            }\n          }\n          return nw;\n        }\n        function stretchSpansOverChange(doc2, change) {\n          if (change.full) {\n            return null;\n          }\n          var oldFirst = isLine(doc2, change.from.line) && getLine(doc2, change.from.line).markedSpans;\n          var oldLast = isLine(doc2, change.to.line) && getLine(doc2, change.to.line).markedSpans;\n          if (!oldFirst && !oldLast) {\n            return null;\n          }\n          var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp2(change.from, change.to) == 0;\n          var first = markedSpansBefore(oldFirst, startCh, isInsert);\n          var last = markedSpansAfter(oldLast, endCh, isInsert);\n          var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n          if (first) {\n            for (var i2 = 0; i2 < first.length; ++i2) {\n              var span = first[i2];\n              if (span.to == null) {\n                var found = getMarkedSpanFor(last, span.marker);\n                if (!found) {\n                  span.to = startCh;\n                } else if (sameLine) {\n                  span.to = found.to == null ? null : found.to + offset;\n                }\n              }\n            }\n          }\n          if (last) {\n            for (var i$12 = 0; i$12 < last.length; ++i$12) {\n              var span$1 = last[i$12];\n              if (span$1.to != null) {\n                span$1.to += offset;\n              }\n              if (span$1.from == null) {\n                var found$1 = getMarkedSpanFor(first, span$1.marker);\n                if (!found$1) {\n                  span$1.from = offset;\n                  if (sameLine) {\n                    (first || (first = [])).push(span$1);\n                  }\n                }\n              } else {\n                span$1.from += offset;\n                if (sameLine) {\n                  (first || (first = [])).push(span$1);\n                }\n              }\n            }\n          }\n          if (first) {\n            first = clearEmptySpans(first);\n          }\n          if (last && last != first) {\n            last = clearEmptySpans(last);\n          }\n          var newMarkers = [first];\n          if (!sameLine) {\n            var gap = change.text.length - 2, gapMarkers;\n            if (gap > 0 && first) {\n              for (var i$22 = 0; i$22 < first.length; ++i$22) {\n                if (first[i$22].to == null) {\n                  (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));\n                }\n              }\n            }\n            for (var i$3 = 0; i$3 < gap; ++i$3) {\n              newMarkers.push(gapMarkers);\n            }\n            newMarkers.push(last);\n          }\n          return newMarkers;\n        }\n        function clearEmptySpans(spans) {\n          for (var i2 = 0; i2 < spans.length; ++i2) {\n            var span = spans[i2];\n            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n              spans.splice(i2--, 1);\n            }\n          }\n          if (!spans.length) {\n            return null;\n          }\n          return spans;\n        }\n        function removeReadOnlyRanges(doc2, from, to) {\n          var markers = null;\n          doc2.iter(from.line, to.line + 1, function(line) {\n            if (line.markedSpans) {\n              for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {\n                var mark = line.markedSpans[i3].marker;\n                if (mark.readOnly && (!markers || indexOf2(markers, mark) == -1)) {\n                  (markers || (markers = [])).push(mark);\n                }\n              }\n            }\n          });\n          if (!markers) {\n            return null;\n          }\n          var parts = [{ from, to }];\n          for (var i2 = 0; i2 < markers.length; ++i2) {\n            var mk = markers[i2], m2 = mk.find(0);\n            for (var j2 = 0; j2 < parts.length; ++j2) {\n              var p = parts[j2];\n              if (cmp2(p.to, m2.from) < 0 || cmp2(p.from, m2.to) > 0) {\n                continue;\n              }\n              var newParts = [j2, 1], dfrom = cmp2(p.from, m2.from), dto = cmp2(p.to, m2.to);\n              if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {\n                newParts.push({ from: p.from, to: m2.from });\n              }\n              if (dto > 0 || !mk.inclusiveRight && !dto) {\n                newParts.push({ from: m2.to, to: p.to });\n              }\n              parts.splice.apply(parts, newParts);\n              j2 += newParts.length - 3;\n            }\n          }\n          return parts;\n        }\n        function detachMarkedSpans(line) {\n          var spans = line.markedSpans;\n          if (!spans) {\n            return;\n          }\n          for (var i2 = 0; i2 < spans.length; ++i2) {\n            spans[i2].marker.detachLine(line);\n          }\n          line.markedSpans = null;\n        }\n        function attachMarkedSpans(line, spans) {\n          if (!spans) {\n            return;\n          }\n          for (var i2 = 0; i2 < spans.length; ++i2) {\n            spans[i2].marker.attachLine(line);\n          }\n          line.markedSpans = spans;\n        }\n        function extraLeft(marker) {\n          return marker.inclusiveLeft ? -1 : 0;\n        }\n        function extraRight(marker) {\n          return marker.inclusiveRight ? 1 : 0;\n        }\n        function compareCollapsedMarkers(a, b2) {\n          var lenDiff = a.lines.length - b2.lines.length;\n          if (lenDiff != 0) {\n            return lenDiff;\n          }\n          var aPos = a.find(), bPos = b2.find();\n          var fromCmp = cmp2(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b2);\n          if (fromCmp) {\n            return -fromCmp;\n          }\n          var toCmp = cmp2(aPos.to, bPos.to) || extraRight(a) - extraRight(b2);\n          if (toCmp) {\n            return toCmp;\n          }\n          return b2.id - a.id;\n        }\n        function collapsedSpanAtSide(line, start) {\n          var sps = sawCollapsedSpans && line.markedSpans, found;\n          if (sps) {\n            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {\n              sp = sps[i2];\n              if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n                found = sp.marker;\n              }\n            }\n          }\n          return found;\n        }\n        function collapsedSpanAtStart(line) {\n          return collapsedSpanAtSide(line, true);\n        }\n        function collapsedSpanAtEnd(line) {\n          return collapsedSpanAtSide(line, false);\n        }\n        function collapsedSpanAround(line, ch) {\n          var sps = sawCollapsedSpans && line.markedSpans, found;\n          if (sps) {\n            for (var i2 = 0; i2 < sps.length; ++i2) {\n              var sp = sps[i2];\n              if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n                found = sp.marker;\n              }\n            }\n          }\n          return found;\n        }\n        function conflictingCollapsedRange(doc2, lineNo2, from, to, marker) {\n          var line = getLine(doc2, lineNo2);\n          var sps = sawCollapsedSpans && line.markedSpans;\n          if (sps) {\n            for (var i2 = 0; i2 < sps.length; ++i2) {\n              var sp = sps[i2];\n              if (!sp.marker.collapsed) {\n                continue;\n              }\n              var found = sp.marker.find(0);\n              var fromCmp = cmp2(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n              var toCmp = cmp2(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n              if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n                continue;\n              }\n              if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp2(found.to, from) >= 0 : cmp2(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp2(found.from, to) <= 0 : cmp2(found.from, to) < 0)) {\n                return true;\n              }\n            }\n          }\n        }\n        function visualLine(line) {\n          var merged;\n          while (merged = collapsedSpanAtStart(line)) {\n            line = merged.find(-1, true).line;\n          }\n          return line;\n        }\n        function visualLineEnd(line) {\n          var merged;\n          while (merged = collapsedSpanAtEnd(line)) {\n            line = merged.find(1, true).line;\n          }\n          return line;\n        }\n        function visualLineContinued(line) {\n          var merged, lines;\n          while (merged = collapsedSpanAtEnd(line)) {\n            line = merged.find(1, true).line;\n            (lines || (lines = [])).push(line);\n          }\n          return lines;\n        }\n        function visualLineNo(doc2, lineN) {\n          var line = getLine(doc2, lineN), vis = visualLine(line);\n          if (line == vis) {\n            return lineN;\n          }\n          return lineNo(vis);\n        }\n        function visualLineEndNo(doc2, lineN) {\n          if (lineN > doc2.lastLine()) {\n            return lineN;\n          }\n          var line = getLine(doc2, lineN), merged;\n          if (!lineIsHidden(doc2, line)) {\n            return lineN;\n          }\n          while (merged = collapsedSpanAtEnd(line)) {\n            line = merged.find(1, true).line;\n          }\n          return lineNo(line) + 1;\n        }\n        function lineIsHidden(doc2, line) {\n          var sps = sawCollapsedSpans && line.markedSpans;\n          if (sps) {\n            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {\n              sp = sps[i2];\n              if (!sp.marker.collapsed) {\n                continue;\n              }\n              if (sp.from == null) {\n                return true;\n              }\n              if (sp.marker.widgetNode) {\n                continue;\n              }\n              if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {\n                return true;\n              }\n            }\n          }\n        }\n        function lineIsHiddenInner(doc2, line, span) {\n          if (span.to == null) {\n            var end = span.marker.find(1, true);\n            return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n          }\n          if (span.marker.inclusiveRight && span.to == line.text.length) {\n            return true;\n          }\n          for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {\n            sp = line.markedSpans[i2];\n            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {\n              return true;\n            }\n          }\n        }\n        function heightAtLine(lineObj) {\n          lineObj = visualLine(lineObj);\n          var h2 = 0, chunk = lineObj.parent;\n          for (var i2 = 0; i2 < chunk.lines.length; ++i2) {\n            var line = chunk.lines[i2];\n            if (line == lineObj) {\n              break;\n            } else {\n              h2 += line.height;\n            }\n          }\n          for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n            for (var i$12 = 0; i$12 < p.children.length; ++i$12) {\n              var cur = p.children[i$12];\n              if (cur == chunk) {\n                break;\n              } else {\n                h2 += cur.height;\n              }\n            }\n          }\n          return h2;\n        }\n        function lineLength(line) {\n          if (line.height == 0) {\n            return 0;\n          }\n          var len = line.text.length, merged, cur = line;\n          while (merged = collapsedSpanAtStart(cur)) {\n            var found = merged.find(0, true);\n            cur = found.from.line;\n            len += found.from.ch - found.to.ch;\n          }\n          cur = line;\n          while (merged = collapsedSpanAtEnd(cur)) {\n            var found$1 = merged.find(0, true);\n            len -= cur.text.length - found$1.from.ch;\n            cur = found$1.to.line;\n            len += cur.text.length - found$1.to.ch;\n          }\n          return len;\n        }\n        function findMaxLine(cm) {\n          var d = cm.display, doc2 = cm.doc;\n          d.maxLine = getLine(doc2, doc2.first);\n          d.maxLineLength = lineLength(d.maxLine);\n          d.maxLineChanged = true;\n          doc2.iter(function(line) {\n            var len = lineLength(line);\n            if (len > d.maxLineLength) {\n              d.maxLineLength = len;\n              d.maxLine = line;\n            }\n          });\n        }\n        var Line = function(text, markedSpans, estimateHeight2) {\n          this.text = text;\n          attachMarkedSpans(this, markedSpans);\n          this.height = estimateHeight2 ? estimateHeight2(this) : 1;\n        };\n        Line.prototype.lineNo = function() {\n          return lineNo(this);\n        };\n        eventMixin(Line);\n        function updateLine(line, text, markedSpans, estimateHeight2) {\n          line.text = text;\n          if (line.stateAfter) {\n            line.stateAfter = null;\n          }\n          if (line.styles) {\n            line.styles = null;\n          }\n          if (line.order != null) {\n            line.order = null;\n          }\n          detachMarkedSpans(line);\n          attachMarkedSpans(line, markedSpans);\n          var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;\n          if (estHeight != line.height) {\n            updateLineHeight(line, estHeight);\n          }\n        }\n        function cleanUpLine(line) {\n          line.parent = null;\n          detachMarkedSpans(line);\n        }\n        var styleToClassCache = {}, styleToClassCacheWithMode = {};\n        function interpretTokenStyle(style, options2) {\n          if (!style || /^\\s*$/.test(style)) {\n            return null;\n          }\n          var cache = options2.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n          return cache[style] || (cache[style] = style.replace(/\\S+/g, "cm-$&"));\n        }\n        function buildLineContent(cm, lineView) {\n          var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);\n          var builder = {\n            pre: eltP("pre", [content], "CodeMirror-line"),\n            content,\n            col: 0,\n            pos: 0,\n            cm,\n            trailingSpace: false,\n            splitSpaces: cm.getOption("lineWrapping")\n          };\n          lineView.measure = {};\n          for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {\n            var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;\n            builder.pos = 0;\n            builder.addToken = buildToken;\n            if (hasBadBidiRects(cm.display.measure) && (order = getOrder2(line, cm.doc.direction))) {\n              builder.addToken = buildTokenBadBidi(builder.addToken, order);\n            }\n            builder.map = [];\n            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n            if (line.styleClasses) {\n              if (line.styleClasses.bgClass) {\n                builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");\n              }\n              if (line.styleClasses.textClass) {\n                builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");\n              }\n            }\n            if (builder.map.length == 0) {\n              builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n            }\n            if (i2 == 0) {\n              lineView.measure.map = builder.map;\n              lineView.measure.cache = {};\n            } else {\n              (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n              (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n            }\n          }\n          if (webkit) {\n            var last = builder.content.lastChild;\n            if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {\n              builder.content.className = "cm-tab-wrap-hack";\n            }\n          }\n          signal(cm, "renderLine", cm, lineView.line, builder.pre);\n          if (builder.pre.className) {\n            builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");\n          }\n          return builder;\n        }\n        function defaultSpecialCharPlaceholder(ch) {\n          var token2 = elt("span", "\\u2022", "cm-invalidchar");\n          token2.title = "\\\\u" + ch.charCodeAt(0).toString(16);\n          token2.setAttribute("aria-label", token2.title);\n          return token2;\n        }\n        function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n          if (!text) {\n            return;\n          }\n          var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n          var special = builder.cm.state.specialChars, mustWrap = false;\n          var content;\n          if (!special.test(text)) {\n            builder.col += text.length;\n            content = document.createTextNode(displayText);\n            builder.map.push(builder.pos, builder.pos + text.length, content);\n            if (ie && ie_version < 9) {\n              mustWrap = true;\n            }\n            builder.pos += text.length;\n          } else {\n            content = document.createDocumentFragment();\n            var pos = 0;\n            while (true) {\n              special.lastIndex = pos;\n              var m2 = special.exec(text);\n              var skipped = m2 ? m2.index - pos : text.length - pos;\n              if (skipped) {\n                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n                if (ie && ie_version < 9) {\n                  content.appendChild(elt("span", [txt]));\n                } else {\n                  content.appendChild(txt);\n                }\n                builder.map.push(builder.pos, builder.pos + skipped, txt);\n                builder.col += skipped;\n                builder.pos += skipped;\n              }\n              if (!m2) {\n                break;\n              }\n              pos += skipped + 1;\n              var txt$1 = void 0;\n              if (m2[0] == "\t") {\n                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\n                txt$1.setAttribute("role", "presentation");\n                txt$1.setAttribute("cm-text", "\t");\n                builder.col += tabWidth;\n              } else if (m2[0] == "\\r" || m2[0] == "\\n") {\n                txt$1 = content.appendChild(elt("span", m2[0] == "\\r" ? "\\u240D" : "\\u2424", "cm-invalidchar"));\n                txt$1.setAttribute("cm-text", m2[0]);\n                builder.col += 1;\n              } else {\n                txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);\n                txt$1.setAttribute("cm-text", m2[0]);\n                if (ie && ie_version < 9) {\n                  content.appendChild(elt("span", [txt$1]));\n                } else {\n                  content.appendChild(txt$1);\n                }\n                builder.col += 1;\n              }\n              builder.map.push(builder.pos, builder.pos + 1, txt$1);\n              builder.pos++;\n            }\n          }\n          builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n          if (style || startStyle || endStyle || mustWrap || css || attributes) {\n            var fullStyle = style || "";\n            if (startStyle) {\n              fullStyle += startStyle;\n            }\n            if (endStyle) {\n              fullStyle += endStyle;\n            }\n            var token2 = elt("span", [content], fullStyle, css);\n            if (attributes) {\n              for (var attr in attributes) {\n                if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {\n                  token2.setAttribute(attr, attributes[attr]);\n                }\n              }\n            }\n            return builder.content.appendChild(token2);\n          }\n          builder.content.appendChild(content);\n        }\n        function splitSpaces(text, trailingBefore) {\n          if (text.length > 1 && !/  /.test(text)) {\n            return text;\n          }\n          var spaceBefore = trailingBefore, result = "";\n          for (var i2 = 0; i2 < text.length; i2++) {\n            var ch = text.charAt(i2);\n            if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {\n              ch = "\\xA0";\n            }\n            result += ch;\n            spaceBefore = ch == " ";\n          }\n          return result;\n        }\n        function buildTokenBadBidi(inner, order) {\n          return function(builder, text, style, startStyle, endStyle, css, attributes) {\n            style = style ? style + " cm-force-border" : "cm-force-border";\n            var start = builder.pos, end = start + text.length;\n            for (; ; ) {\n              var part = void 0;\n              for (var i2 = 0; i2 < order.length; i2++) {\n                part = order[i2];\n                if (part.to > start && part.from <= start) {\n                  break;\n                }\n              }\n              if (part.to >= end) {\n                return inner(builder, text, style, startStyle, endStyle, css, attributes);\n              }\n              inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n              startStyle = null;\n              text = text.slice(part.to - start);\n              start = part.to;\n            }\n          };\n        }\n        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n          var widget = !ignoreWidget && marker.widgetNode;\n          if (widget) {\n            builder.map.push(builder.pos, builder.pos + size, widget);\n          }\n          if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n            if (!widget) {\n              widget = builder.content.appendChild(document.createElement("span"));\n            }\n            widget.setAttribute("cm-marker", marker.id);\n          }\n          if (widget) {\n            builder.cm.display.input.setUneditable(widget);\n            builder.content.appendChild(widget);\n          }\n          builder.pos += size;\n          builder.trailingSpace = false;\n        }\n        function insertLineContent(line, builder, styles3) {\n          var spans = line.markedSpans, allText = line.text, at2 = 0;\n          if (!spans) {\n            for (var i$12 = 1; i$12 < styles3.length; i$12 += 2) {\n              builder.addToken(builder, allText.slice(at2, at2 = styles3[i$12]), interpretTokenStyle(styles3[i$12 + 1], builder.cm.options));\n            }\n            return;\n          }\n          var len = allText.length, pos = 0, i2 = 1, text = "", style, css;\n          var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n          for (; ; ) {\n            if (nextChange == pos) {\n              spanStyle = spanEndStyle = spanStartStyle = css = "";\n              attributes = null;\n              collapsed = null;\n              nextChange = Infinity;\n              var foundBookmarks = [], endStyles = void 0;\n              for (var j2 = 0; j2 < spans.length; ++j2) {\n                var sp = spans[j2], m2 = sp.marker;\n                if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {\n                  foundBookmarks.push(m2);\n                } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {\n                  if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n                    nextChange = sp.to;\n                    spanEndStyle = "";\n                  }\n                  if (m2.className) {\n                    spanStyle += " " + m2.className;\n                  }\n                  if (m2.css) {\n                    css = (css ? css + ";" : "") + m2.css;\n                  }\n                  if (m2.startStyle && sp.from == pos) {\n                    spanStartStyle += " " + m2.startStyle;\n                  }\n                  if (m2.endStyle && sp.to == nextChange) {\n                    (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);\n                  }\n                  if (m2.title) {\n                    (attributes || (attributes = {})).title = m2.title;\n                  }\n                  if (m2.attributes) {\n                    for (var attr in m2.attributes) {\n                      (attributes || (attributes = {}))[attr] = m2.attributes[attr];\n                    }\n                  }\n                  if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {\n                    collapsed = sp;\n                  }\n                } else if (sp.from > pos && nextChange > sp.from) {\n                  nextChange = sp.from;\n                }\n              }\n              if (endStyles) {\n                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {\n                  if (endStyles[j$1 + 1] == nextChange) {\n                    spanEndStyle += " " + endStyles[j$1];\n                  }\n                }\n              }\n              if (!collapsed || collapsed.from == pos) {\n                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {\n                  buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n                }\n              }\n              if (collapsed && (collapsed.from || 0) == pos) {\n                buildCollapsedSpan(\n                  builder,\n                  (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                  collapsed.marker,\n                  collapsed.from == null\n                );\n                if (collapsed.to == null) {\n                  return;\n                }\n                if (collapsed.to == pos) {\n                  collapsed = false;\n                }\n              }\n            }\n            if (pos >= len) {\n              break;\n            }\n            var upto = Math.min(len, nextChange);\n            while (true) {\n              if (text) {\n                var end = pos + text.length;\n                if (!collapsed) {\n                  var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n                  builder.addToken(\n                    builder,\n                    tokenText,\n                    style ? style + spanStyle : spanStyle,\n                    spanStartStyle,\n                    pos + tokenText.length == nextChange ? spanEndStyle : "",\n                    css,\n                    attributes\n                  );\n                }\n                if (end >= upto) {\n                  text = text.slice(upto - pos);\n                  pos = upto;\n                  break;\n                }\n                pos = end;\n                spanStartStyle = "";\n              }\n              text = allText.slice(at2, at2 = styles3[i2++]);\n              style = interpretTokenStyle(styles3[i2++], builder.cm.options);\n            }\n          }\n        }\n        function LineView(doc2, line, lineN) {\n          this.line = line;\n          this.rest = visualLineContinued(line);\n          this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n          this.node = this.text = null;\n          this.hidden = lineIsHidden(doc2, line);\n        }\n        function buildViewArray(cm, from, to) {\n          var array = [], nextPos;\n          for (var pos = from; pos < to; pos = nextPos) {\n            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n            nextPos = pos + view.size;\n            array.push(view);\n          }\n          return array;\n        }\n        var operationGroup = null;\n        function pushOperation(op) {\n          if (operationGroup) {\n            operationGroup.ops.push(op);\n          } else {\n            op.ownsGroup = operationGroup = {\n              ops: [op],\n              delayedCallbacks: []\n            };\n          }\n        }\n        function fireCallbacksForOps(group) {\n          var callbacks = group.delayedCallbacks, i2 = 0;\n          do {\n            for (; i2 < callbacks.length; i2++) {\n              callbacks[i2].call(null);\n            }\n            for (var j2 = 0; j2 < group.ops.length; j2++) {\n              var op = group.ops[j2];\n              if (op.cursorActivityHandlers) {\n                while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {\n                  op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n                }\n              }\n            }\n          } while (i2 < callbacks.length);\n        }\n        function finishOperation(op, endCb) {\n          var group = op.ownsGroup;\n          if (!group) {\n            return;\n          }\n          try {\n            fireCallbacksForOps(group);\n          } finally {\n            operationGroup = null;\n            endCb(group);\n          }\n        }\n        var orphanDelayedCallbacks = null;\n        function signalLater(emitter, type) {\n          var arr = getHandlers(emitter, type);\n          if (!arr.length) {\n            return;\n          }\n          var args = Array.prototype.slice.call(arguments, 2), list;\n          if (operationGroup) {\n            list = operationGroup.delayedCallbacks;\n          } else if (orphanDelayedCallbacks) {\n            list = orphanDelayedCallbacks;\n          } else {\n            list = orphanDelayedCallbacks = [];\n            setTimeout(fireOrphanDelayed, 0);\n          }\n          var loop = function(i3) {\n            list.push(function() {\n              return arr[i3].apply(null, args);\n            });\n          };\n          for (var i2 = 0; i2 < arr.length; ++i2)\n            loop(i2);\n        }\n        function fireOrphanDelayed() {\n          var delayed = orphanDelayedCallbacks;\n          orphanDelayedCallbacks = null;\n          for (var i2 = 0; i2 < delayed.length; ++i2) {\n            delayed[i2]();\n          }\n        }\n        function updateLineForChanges(cm, lineView, lineN, dims) {\n          for (var j2 = 0; j2 < lineView.changes.length; j2++) {\n            var type = lineView.changes[j2];\n            if (type == "text") {\n              updateLineText(cm, lineView);\n            } else if (type == "gutter") {\n              updateLineGutter(cm, lineView, lineN, dims);\n            } else if (type == "class") {\n              updateLineClasses(cm, lineView);\n            } else if (type == "widget") {\n              updateLineWidgets(cm, lineView, dims);\n            }\n          }\n          lineView.changes = null;\n        }\n        function ensureLineWrapped(lineView) {\n          if (lineView.node == lineView.text) {\n            lineView.node = elt("div", null, null, "position: relative");\n            if (lineView.text.parentNode) {\n              lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n            }\n            lineView.node.appendChild(lineView.text);\n            if (ie && ie_version < 8) {\n              lineView.node.style.zIndex = 2;\n            }\n          }\n          return lineView.node;\n        }\n        function updateLineBackground(cm, lineView) {\n          var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;\n          if (cls) {\n            cls += " CodeMirror-linebackground";\n          }\n          if (lineView.background) {\n            if (cls) {\n              lineView.background.className = cls;\n            } else {\n              lineView.background.parentNode.removeChild(lineView.background);\n              lineView.background = null;\n            }\n          } else if (cls) {\n            var wrap = ensureLineWrapped(lineView);\n            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);\n            cm.display.input.setUneditable(lineView.background);\n          }\n        }\n        function getLineContent(cm, lineView) {\n          var ext = cm.display.externalMeasured;\n          if (ext && ext.line == lineView.line) {\n            cm.display.externalMeasured = null;\n            lineView.measure = ext.measure;\n            return ext.built;\n          }\n          return buildLineContent(cm, lineView);\n        }\n        function updateLineText(cm, lineView) {\n          var cls = lineView.text.className;\n          var built = getLineContent(cm, lineView);\n          if (lineView.text == lineView.node) {\n            lineView.node = built.pre;\n          }\n          lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n          lineView.text = built.pre;\n          if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n            lineView.bgClass = built.bgClass;\n            lineView.textClass = built.textClass;\n            updateLineClasses(cm, lineView);\n          } else if (cls) {\n            lineView.text.className = cls;\n          }\n        }\n        function updateLineClasses(cm, lineView) {\n          updateLineBackground(cm, lineView);\n          if (lineView.line.wrapClass) {\n            ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n          } else if (lineView.node != lineView.text) {\n            lineView.node.className = "";\n          }\n          var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;\n          lineView.text.className = textClass || "";\n        }\n        function updateLineGutter(cm, lineView, lineN, dims) {\n          if (lineView.gutter) {\n            lineView.node.removeChild(lineView.gutter);\n            lineView.gutter = null;\n          }\n          if (lineView.gutterBackground) {\n            lineView.node.removeChild(lineView.gutterBackground);\n            lineView.gutterBackground = null;\n          }\n          if (lineView.line.gutterClass) {\n            var wrap = ensureLineWrapped(lineView);\n            lineView.gutterBackground = elt(\n              "div",\n              null,\n              "CodeMirror-gutter-background " + lineView.line.gutterClass,\n              "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"\n            );\n            cm.display.input.setUneditable(lineView.gutterBackground);\n            wrap.insertBefore(lineView.gutterBackground, lineView.text);\n          }\n          var markers = lineView.line.gutterMarkers;\n          if (cm.options.lineNumbers || markers) {\n            var wrap$1 = ensureLineWrapped(lineView);\n            var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");\n            gutterWrap.setAttribute("aria-hidden", "true");\n            cm.display.input.setUneditable(gutterWrap);\n            wrap$1.insertBefore(gutterWrap, lineView.text);\n            if (lineView.line.gutterClass) {\n              gutterWrap.className += " " + lineView.line.gutterClass;\n            }\n            if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {\n              lineView.lineNumber = gutterWrap.appendChild(\n                elt(\n                  "div",\n                  lineNumberFor(cm.options, lineN),\n                  "CodeMirror-linenumber CodeMirror-gutter-elt",\n                  "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"\n                )\n              );\n            }\n            if (markers) {\n              for (var k2 = 0; k2 < cm.display.gutterSpecs.length; ++k2) {\n                var id = cm.display.gutterSpecs[k2].className, found = markers.hasOwnProperty(id) && markers[id];\n                if (found) {\n                  gutterWrap.appendChild(elt(\n                    "div",\n                    [found],\n                    "CodeMirror-gutter-elt",\n                    "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"\n                  ));\n                }\n              }\n            }\n          }\n        }\n        function updateLineWidgets(cm, lineView, dims) {\n          if (lineView.alignable) {\n            lineView.alignable = null;\n          }\n          var isWidget = classTest("CodeMirror-linewidget");\n          for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\n            next = node.nextSibling;\n            if (isWidget.test(node.className)) {\n              lineView.node.removeChild(node);\n            }\n          }\n          insertLineWidgets(cm, lineView, dims);\n        }\n        function buildLineElement(cm, lineView, lineN, dims) {\n          var built = getLineContent(cm, lineView);\n          lineView.text = lineView.node = built.pre;\n          if (built.bgClass) {\n            lineView.bgClass = built.bgClass;\n          }\n          if (built.textClass) {\n            lineView.textClass = built.textClass;\n          }\n          updateLineClasses(cm, lineView);\n          updateLineGutter(cm, lineView, lineN, dims);\n          insertLineWidgets(cm, lineView, dims);\n          return lineView.node;\n        }\n        function insertLineWidgets(cm, lineView, dims) {\n          insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n          if (lineView.rest) {\n            for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n              insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);\n            }\n          }\n        }\n        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n          if (!line.widgets) {\n            return;\n          }\n          var wrap = ensureLineWrapped(lineView);\n          for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {\n            var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));\n            if (!widget.handleMouseEvents) {\n              node.setAttribute("cm-ignore-events", "true");\n            }\n            positionLineWidget(widget, node, lineView, dims);\n            cm.display.input.setUneditable(node);\n            if (allowAbove && widget.above) {\n              wrap.insertBefore(node, lineView.gutter || lineView.text);\n            } else {\n              wrap.appendChild(node);\n            }\n            signalLater(widget, "redraw");\n          }\n        }\n        function positionLineWidget(widget, node, lineView, dims) {\n          if (widget.noHScroll) {\n            (lineView.alignable || (lineView.alignable = [])).push(node);\n            var width = dims.wrapperWidth;\n            node.style.left = dims.fixedPos + "px";\n            if (!widget.coverGutter) {\n              width -= dims.gutterTotalWidth;\n              node.style.paddingLeft = dims.gutterTotalWidth + "px";\n            }\n            node.style.width = width + "px";\n          }\n          if (widget.coverGutter) {\n            node.style.zIndex = 5;\n            node.style.position = "relative";\n            if (!widget.noHScroll) {\n              node.style.marginLeft = -dims.gutterTotalWidth + "px";\n            }\n          }\n        }\n        function widgetHeight(widget) {\n          if (widget.height != null) {\n            return widget.height;\n          }\n          var cm = widget.doc.cm;\n          if (!cm) {\n            return 0;\n          }\n          if (!contains(document.body, widget.node)) {\n            var parentStyle = "position: relative;";\n            if (widget.coverGutter) {\n              parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";\n            }\n            if (widget.noHScroll) {\n              parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";\n            }\n            removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));\n          }\n          return widget.height = widget.node.parentNode.offsetHeight;\n        }\n        function eventInWidget(display, e) {\n          for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n            if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {\n              return true;\n            }\n          }\n        }\n        function paddingTop(display) {\n          return display.lineSpace.offsetTop;\n        }\n        function paddingVert(display) {\n          return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n        }\n        function paddingH(display) {\n          if (display.cachedPaddingH) {\n            return display.cachedPaddingH;\n          }\n          var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));\n          var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n          var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };\n          if (!isNaN(data.left) && !isNaN(data.right)) {\n            display.cachedPaddingH = data;\n          }\n          return data;\n        }\n        function scrollGap(cm) {\n          return scrollerGap - cm.display.nativeBarWidth;\n        }\n        function displayWidth(cm) {\n          return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n        }\n        function displayHeight(cm) {\n          return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n        }\n        function ensureLineHeights(cm, lineView, rect) {\n          var wrapping = cm.options.lineWrapping;\n          var curWidth = wrapping && displayWidth(cm);\n          if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n            var heights = lineView.measure.heights = [];\n            if (wrapping) {\n              lineView.measure.width = curWidth;\n              var rects = lineView.text.firstChild.getClientRects();\n              for (var i2 = 0; i2 < rects.length - 1; i2++) {\n                var cur = rects[i2], next = rects[i2 + 1];\n                if (Math.abs(cur.bottom - next.bottom) > 2) {\n                  heights.push((cur.bottom + next.top) / 2 - rect.top);\n                }\n              }\n            }\n            heights.push(rect.bottom - rect.top);\n          }\n        }\n        function mapFromLineView(lineView, line, lineN) {\n          if (lineView.line == line) {\n            return { map: lineView.measure.map, cache: lineView.measure.cache };\n          }\n          if (lineView.rest) {\n            for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n              if (lineView.rest[i2] == line) {\n                return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };\n              }\n            }\n            for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {\n              if (lineNo(lineView.rest[i$12]) > lineN) {\n                return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };\n              }\n            }\n          }\n        }\n        function updateExternalMeasurement(cm, line) {\n          line = visualLine(line);\n          var lineN = lineNo(line);\n          var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n          view.lineN = lineN;\n          var built = view.built = buildLineContent(cm, view);\n          view.text = built.pre;\n          removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n          return view;\n        }\n        function measureChar(cm, line, ch, bias) {\n          return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n        }\n        function findViewForLine(cm, lineN) {\n          if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n            return cm.display.view[findViewIndex(cm, lineN)];\n          }\n          var ext = cm.display.externalMeasured;\n          if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n            return ext;\n          }\n        }\n        function prepareMeasureForLine(cm, line) {\n          var lineN = lineNo(line);\n          var view = findViewForLine(cm, lineN);\n          if (view && !view.text) {\n            view = null;\n          } else if (view && view.changes) {\n            updateLineForChanges(cm, view, lineN, getDimensions(cm));\n            cm.curOp.forceUpdate = true;\n          }\n          if (!view) {\n            view = updateExternalMeasurement(cm, line);\n          }\n          var info = mapFromLineView(view, line, lineN);\n          return {\n            line,\n            view,\n            rect: null,\n            map: info.map,\n            cache: info.cache,\n            before: info.before,\n            hasHeights: false\n          };\n        }\n        function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n          if (prepared.before) {\n            ch = -1;\n          }\n          var key2 = ch + (bias || ""), found;\n          if (prepared.cache.hasOwnProperty(key2)) {\n            found = prepared.cache[key2];\n          } else {\n            if (!prepared.rect) {\n              prepared.rect = prepared.view.text.getBoundingClientRect();\n            }\n            if (!prepared.hasHeights) {\n              ensureLineHeights(cm, prepared.view, prepared.rect);\n              prepared.hasHeights = true;\n            }\n            found = measureCharInner(cm, prepared, ch, bias);\n            if (!found.bogus) {\n              prepared.cache[key2] = found;\n            }\n          }\n          return {\n            left: found.left,\n            right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom\n          };\n        }\n        var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };\n        function nodeAndOffsetInLineMap(map3, ch, bias) {\n          var node, start, end, collapse, mStart, mEnd;\n          for (var i2 = 0; i2 < map3.length; i2 += 3) {\n            mStart = map3[i2];\n            mEnd = map3[i2 + 1];\n            if (ch < mStart) {\n              start = 0;\n              end = 1;\n              collapse = "left";\n            } else if (ch < mEnd) {\n              start = ch - mStart;\n              end = start + 1;\n            } else if (i2 == map3.length - 3 || ch == mEnd && map3[i2 + 3] > ch) {\n              end = mEnd - mStart;\n              start = end - 1;\n              if (ch >= mEnd) {\n                collapse = "right";\n              }\n            }\n            if (start != null) {\n              node = map3[i2 + 2];\n              if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {\n                collapse = bias;\n              }\n              if (bias == "left" && start == 0) {\n                while (i2 && map3[i2 - 2] == map3[i2 - 3] && map3[i2 - 1].insertLeft) {\n                  node = map3[(i2 -= 3) + 2];\n                  collapse = "left";\n                }\n              }\n              if (bias == "right" && start == mEnd - mStart) {\n                while (i2 < map3.length - 3 && map3[i2 + 3] == map3[i2 + 4] && !map3[i2 + 5].insertLeft) {\n                  node = map3[(i2 += 3) + 2];\n                  collapse = "right";\n                }\n              }\n              break;\n            }\n          }\n          return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };\n        }\n        function getUsefulRect(rects, bias) {\n          var rect = nullRect;\n          if (bias == "left") {\n            for (var i2 = 0; i2 < rects.length; i2++) {\n              if ((rect = rects[i2]).left != rect.right) {\n                break;\n              }\n            }\n          } else {\n            for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {\n              if ((rect = rects[i$12]).left != rect.right) {\n                break;\n              }\n            }\n          }\n          return rect;\n        }\n        function measureCharInner(cm, prepared, ch, bias) {\n          var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n          var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n          var rect;\n          if (node.nodeType == 3) {\n            for (var i$12 = 0; i$12 < 4; i$12++) {\n              while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {\n                --start;\n              }\n              while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {\n                ++end;\n              }\n              if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n                rect = node.parentNode.getBoundingClientRect();\n              } else {\n                rect = getUsefulRect(range(node, start, end).getClientRects(), bias);\n              }\n              if (rect.left || rect.right || start == 0) {\n                break;\n              }\n              end = start;\n              start = start - 1;\n              collapse = "right";\n            }\n            if (ie && ie_version < 11) {\n              rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n            }\n          } else {\n            if (start > 0) {\n              collapse = bias = "right";\n            }\n            var rects;\n            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n              rect = rects[bias == "right" ? rects.length - 1 : 0];\n            } else {\n              rect = node.getBoundingClientRect();\n            }\n          }\n          if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n            var rSpan = node.parentNode.getClientRects()[0];\n            if (rSpan) {\n              rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };\n            } else {\n              rect = nullRect;\n            }\n          }\n          var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n          var mid = (rtop + rbot) / 2;\n          var heights = prepared.view.measure.heights;\n          var i2 = 0;\n          for (; i2 < heights.length - 1; i2++) {\n            if (mid < heights[i2]) {\n              break;\n            }\n          }\n          var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];\n          var result = {\n            left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,\n            right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,\n            top,\n            bottom: bot\n          };\n          if (!rect.left && !rect.right) {\n            result.bogus = true;\n          }\n          if (!cm.options.singleCursorHeightPerLine) {\n            result.rtop = rtop;\n            result.rbottom = rbot;\n          }\n          return result;\n        }\n        function maybeUpdateRectForZooming(measure, rect) {\n          if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n            return rect;\n          }\n          var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n          var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n          return {\n            left: rect.left * scaleX,\n            right: rect.right * scaleX,\n            top: rect.top * scaleY,\n            bottom: rect.bottom * scaleY\n          };\n        }\n        function clearLineMeasurementCacheFor(lineView) {\n          if (lineView.measure) {\n            lineView.measure.cache = {};\n            lineView.measure.heights = null;\n            if (lineView.rest) {\n              for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n                lineView.measure.caches[i2] = {};\n              }\n            }\n          }\n        }\n        function clearLineMeasurementCache(cm) {\n          cm.display.externalMeasure = null;\n          removeChildren(cm.display.lineMeasure);\n          for (var i2 = 0; i2 < cm.display.view.length; i2++) {\n            clearLineMeasurementCacheFor(cm.display.view[i2]);\n          }\n        }\n        function clearCaches(cm) {\n          clearLineMeasurementCache(cm);\n          cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n          if (!cm.options.lineWrapping) {\n            cm.display.maxLineChanged = true;\n          }\n          cm.display.lineNumChars = null;\n        }\n        function pageScrollX(doc2) {\n          if (chrome && android) {\n            return -(doc2.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc2.body).marginLeft));\n          }\n          return doc2.defaultView.pageXOffset || (doc2.documentElement || doc2.body).scrollLeft;\n        }\n        function pageScrollY(doc2) {\n          if (chrome && android) {\n            return -(doc2.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc2.body).marginTop));\n          }\n          return doc2.defaultView.pageYOffset || (doc2.documentElement || doc2.body).scrollTop;\n        }\n        function widgetTopHeight(lineObj) {\n          var ref = visualLine(lineObj);\n          var widgets = ref.widgets;\n          var height = 0;\n          if (widgets) {\n            for (var i2 = 0; i2 < widgets.length; ++i2) {\n              if (widgets[i2].above) {\n                height += widgetHeight(widgets[i2]);\n              }\n            }\n          }\n          return height;\n        }\n        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n          if (!includeWidgets) {\n            var height = widgetTopHeight(lineObj);\n            rect.top += height;\n            rect.bottom += height;\n          }\n          if (context == "line") {\n            return rect;\n          }\n          if (!context) {\n            context = "local";\n          }\n          var yOff = heightAtLine(lineObj);\n          if (context == "local") {\n            yOff += paddingTop(cm.display);\n          } else {\n            yOff -= cm.display.viewOffset;\n          }\n          if (context == "page" || context == "window") {\n            var lOff = cm.display.lineSpace.getBoundingClientRect();\n            yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));\n            var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));\n            rect.left += xOff;\n            rect.right += xOff;\n          }\n          rect.top += yOff;\n          rect.bottom += yOff;\n          return rect;\n        }\n        function fromCoordSystem(cm, coords, context) {\n          if (context == "div") {\n            return coords;\n          }\n          var left = coords.left, top = coords.top;\n          if (context == "page") {\n            left -= pageScrollX(doc(cm));\n            top -= pageScrollY(doc(cm));\n          } else if (context == "local" || !context) {\n            var localBox = cm.display.sizer.getBoundingClientRect();\n            left += localBox.left;\n            top += localBox.top;\n          }\n          var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n          return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };\n        }\n        function charCoords(cm, pos, context, lineObj, bias) {\n          if (!lineObj) {\n            lineObj = getLine(cm.doc, pos.line);\n          }\n          return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n        }\n        function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n          lineObj = lineObj || getLine(cm.doc, pos.line);\n          if (!preparedMeasure) {\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n          }\n          function get(ch2, right) {\n            var m2 = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);\n            if (right) {\n              m2.left = m2.right;\n            } else {\n              m2.right = m2.left;\n            }\n            return intoCoordSystem(cm, lineObj, m2, context);\n          }\n          var order = getOrder2(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n          if (ch >= lineObj.text.length) {\n            ch = lineObj.text.length;\n            sticky = "before";\n          } else if (ch <= 0) {\n            ch = 0;\n            sticky = "after";\n          }\n          if (!order) {\n            return get(sticky == "before" ? ch - 1 : ch, sticky == "before");\n          }\n          function getBidi(ch2, partPos2, invert) {\n            var part = order[partPos2], right = part.level == 1;\n            return get(invert ? ch2 - 1 : ch2, right != invert);\n          }\n          var partPos = getBidiPartAt(order, ch, sticky);\n          var other = bidiOther;\n          var val = getBidi(ch, partPos, sticky == "before");\n          if (other != null) {\n            val.other = getBidi(ch, other, sticky != "before");\n          }\n          return val;\n        }\n        function estimateCoords(cm, pos) {\n          var left = 0;\n          pos = clipPos(cm.doc, pos);\n          if (!cm.options.lineWrapping) {\n            left = charWidth(cm.display) * pos.ch;\n          }\n          var lineObj = getLine(cm.doc, pos.line);\n          var top = heightAtLine(lineObj) + paddingTop(cm.display);\n          return { left, right: left, top, bottom: top + lineObj.height };\n        }\n        function PosWithInfo(line, ch, sticky, outside, xRel) {\n          var pos = Pos(line, ch, sticky);\n          pos.xRel = xRel;\n          if (outside) {\n            pos.outside = outside;\n          }\n          return pos;\n        }\n        function coordsChar(cm, x, y2) {\n          var doc2 = cm.doc;\n          y2 += cm.display.viewOffset;\n          if (y2 < 0) {\n            return PosWithInfo(doc2.first, 0, null, -1, -1);\n          }\n          var lineN = lineAtHeight(doc2, y2), last = doc2.first + doc2.size - 1;\n          if (lineN > last) {\n            return PosWithInfo(doc2.first + doc2.size - 1, getLine(doc2, last).text.length, null, 1, 1);\n          }\n          if (x < 0) {\n            x = 0;\n          }\n          var lineObj = getLine(doc2, lineN);\n          for (; ; ) {\n            var found = coordsCharInner(cm, lineObj, lineN, x, y2);\n            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n            if (!collapsed) {\n              return found;\n            }\n            var rangeEnd = collapsed.find(1);\n            if (rangeEnd.line == lineN) {\n              return rangeEnd;\n            }\n            lineObj = getLine(doc2, lineN = rangeEnd.line);\n          }\n        }\n        function wrappedLineExtent(cm, lineObj, preparedMeasure, y2) {\n          y2 -= widgetTopHeight(lineObj);\n          var end = lineObj.text.length;\n          var begin = findFirst(function(ch) {\n            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y2;\n          }, end, 0);\n          end = findFirst(function(ch) {\n            return measureCharPrepared(cm, preparedMeasure, ch).top > y2;\n          }, begin, end);\n          return { begin, end };\n        }\n        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n          if (!preparedMeasure) {\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n          }\n          var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;\n          return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n        }\n        function boxIsAfter(box, x, y2, left) {\n          return box.bottom <= y2 ? false : box.top > y2 ? true : (left ? box.left : box.right) > x;\n        }\n        function coordsCharInner(cm, lineObj, lineNo2, x, y2) {\n          y2 -= heightAtLine(lineObj);\n          var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n          var widgetHeight2 = widgetTopHeight(lineObj);\n          var begin = 0, end = lineObj.text.length, ltr = true;\n          var order = getOrder2(lineObj, cm.doc.direction);\n          if (order) {\n            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y2);\n            ltr = part.level != 1;\n            begin = ltr ? part.from : part.to - 1;\n            end = ltr ? part.to : part.from - 1;\n          }\n          var chAround = null, boxAround = null;\n          var ch = findFirst(function(ch2) {\n            var box = measureCharPrepared(cm, preparedMeasure, ch2);\n            box.top += widgetHeight2;\n            box.bottom += widgetHeight2;\n            if (!boxIsAfter(box, x, y2, false)) {\n              return false;\n            }\n            if (box.top <= y2 && box.left <= x) {\n              chAround = ch2;\n              boxAround = box;\n            }\n            return true;\n          }, begin, end);\n          var baseX, sticky, outside = false;\n          if (boxAround) {\n            var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n            ch = chAround + (atStart ? 0 : 1);\n            sticky = atStart ? "after" : "before";\n            baseX = atLeft ? boxAround.left : boxAround.right;\n          } else {\n            if (!ltr && (ch == end || ch == begin)) {\n              ch++;\n            }\n            sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y2 == ltr ? "after" : "before";\n            var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);\n            baseX = coords.left;\n            outside = y2 < coords.top ? -1 : y2 >= coords.bottom ? 1 : 0;\n          }\n          ch = skipExtendingChars(lineObj.text, ch, 1);\n          return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);\n        }\n        function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y2) {\n          var index = findFirst(function(i2) {\n            var part2 = order[i2], ltr2 = part2.level != 1;\n            return boxIsAfter(cursorCoords(\n              cm,\n              Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"),\n              "line",\n              lineObj,\n              preparedMeasure\n            ), x, y2, true);\n          }, 0, order.length - 1);\n          var part = order[index];\n          if (index > 0) {\n            var ltr = part.level != 1;\n            var start = cursorCoords(\n              cm,\n              Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"),\n              "line",\n              lineObj,\n              preparedMeasure\n            );\n            if (boxIsAfter(start, x, y2, true) && start.top > y2) {\n              part = order[index - 1];\n            }\n          }\n          return part;\n        }\n        function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y2) {\n          var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y2);\n          var begin = ref.begin;\n          var end = ref.end;\n          if (/\\s/.test(lineObj.text.charAt(end - 1))) {\n            end--;\n          }\n          var part = null, closestDist = null;\n          for (var i2 = 0; i2 < order.length; i2++) {\n            var p = order[i2];\n            if (p.from >= end || p.to <= begin) {\n              continue;\n            }\n            var ltr = p.level != 1;\n            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n            var dist = endX < x ? x - endX + 1e9 : endX - x;\n            if (!part || closestDist > dist) {\n              part = p;\n              closestDist = dist;\n            }\n          }\n          if (!part) {\n            part = order[order.length - 1];\n          }\n          if (part.from < begin) {\n            part = { from: begin, to: part.to, level: part.level };\n          }\n          if (part.to > end) {\n            part = { from: part.from, to: end, level: part.level };\n          }\n          return part;\n        }\n        var measureText;\n        function textHeight(display) {\n          if (display.cachedTextHeight != null) {\n            return display.cachedTextHeight;\n          }\n          if (measureText == null) {\n            measureText = elt("pre", null, "CodeMirror-line-like");\n            for (var i2 = 0; i2 < 49; ++i2) {\n              measureText.appendChild(document.createTextNode("x"));\n              measureText.appendChild(elt("br"));\n            }\n            measureText.appendChild(document.createTextNode("x"));\n          }\n          removeChildrenAndAdd(display.measure, measureText);\n          var height = measureText.offsetHeight / 50;\n          if (height > 3) {\n            display.cachedTextHeight = height;\n          }\n          removeChildren(display.measure);\n          return height || 1;\n        }\n        function charWidth(display) {\n          if (display.cachedCharWidth != null) {\n            return display.cachedCharWidth;\n          }\n          var anchor = elt("span", "xxxxxxxxxx");\n          var pre = elt("pre", [anchor], "CodeMirror-line-like");\n          removeChildrenAndAdd(display.measure, pre);\n          var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n          if (width > 2) {\n            display.cachedCharWidth = width;\n          }\n          return width || 10;\n        }\n        function getDimensions(cm) {\n          var d = cm.display, left = {}, width = {};\n          var gutterLeft = d.gutters.clientLeft;\n          for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {\n            var id = cm.display.gutterSpecs[i2].className;\n            left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n            width[id] = n.clientWidth;\n          }\n          return {\n            fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth\n          };\n        }\n        function compensateForHScroll(display) {\n          return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n        }\n        function estimateHeight(cm) {\n          var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n          var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n          return function(line) {\n            if (lineIsHidden(cm.doc, line)) {\n              return 0;\n            }\n            var widgetsHeight = 0;\n            if (line.widgets) {\n              for (var i2 = 0; i2 < line.widgets.length; i2++) {\n                if (line.widgets[i2].height) {\n                  widgetsHeight += line.widgets[i2].height;\n                }\n              }\n            }\n            if (wrapping) {\n              return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n            } else {\n              return widgetsHeight + th;\n            }\n          };\n        }\n        function estimateLineHeights(cm) {\n          var doc2 = cm.doc, est = estimateHeight(cm);\n          doc2.iter(function(line) {\n            var estHeight = est(line);\n            if (estHeight != line.height) {\n              updateLineHeight(line, estHeight);\n            }\n          });\n        }\n        function posFromMouse(cm, e, liberal, forRect) {\n          var display = cm.display;\n          if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {\n            return null;\n          }\n          var x, y2, space = display.lineSpace.getBoundingClientRect();\n          try {\n            x = e.clientX - space.left;\n            y2 = e.clientY - space.top;\n          } catch (e$1) {\n            return null;\n          }\n          var coords = coordsChar(cm, x, y2), line;\n          if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n          }\n          return coords;\n        }\n        function findViewIndex(cm, n) {\n          if (n >= cm.display.viewTo) {\n            return null;\n          }\n          n -= cm.display.viewFrom;\n          if (n < 0) {\n            return null;\n          }\n          var view = cm.display.view;\n          for (var i2 = 0; i2 < view.length; i2++) {\n            n -= view[i2].size;\n            if (n < 0) {\n              return i2;\n            }\n          }\n        }\n        function regChange(cm, from, to, lendiff) {\n          if (from == null) {\n            from = cm.doc.first;\n          }\n          if (to == null) {\n            to = cm.doc.first + cm.doc.size;\n          }\n          if (!lendiff) {\n            lendiff = 0;\n          }\n          var display = cm.display;\n          if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n            display.updateLineNumbers = from;\n          }\n          cm.curOp.viewChanged = true;\n          if (from >= display.viewTo) {\n            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n              resetView(cm);\n            }\n          } else if (to <= display.viewFrom) {\n            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n              resetView(cm);\n            } else {\n              display.viewFrom += lendiff;\n              display.viewTo += lendiff;\n            }\n          } else if (from <= display.viewFrom && to >= display.viewTo) {\n            resetView(cm);\n          } else if (from <= display.viewFrom) {\n            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n            if (cut) {\n              display.view = display.view.slice(cut.index);\n              display.viewFrom = cut.lineN;\n              display.viewTo += lendiff;\n            } else {\n              resetView(cm);\n            }\n          } else if (to >= display.viewTo) {\n            var cut$1 = viewCuttingPoint(cm, from, from, -1);\n            if (cut$1) {\n              display.view = display.view.slice(0, cut$1.index);\n              display.viewTo = cut$1.lineN;\n            } else {\n              resetView(cm);\n            }\n          } else {\n            var cutTop = viewCuttingPoint(cm, from, from, -1);\n            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n            if (cutTop && cutBot) {\n              display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n              display.viewTo += lendiff;\n            } else {\n              resetView(cm);\n            }\n          }\n          var ext = display.externalMeasured;\n          if (ext) {\n            if (to < ext.lineN) {\n              ext.lineN += lendiff;\n            } else if (from < ext.lineN + ext.size) {\n              display.externalMeasured = null;\n            }\n          }\n        }\n        function regLineChange(cm, line, type) {\n          cm.curOp.viewChanged = true;\n          var display = cm.display, ext = cm.display.externalMeasured;\n          if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n            display.externalMeasured = null;\n          }\n          if (line < display.viewFrom || line >= display.viewTo) {\n            return;\n          }\n          var lineView = display.view[findViewIndex(cm, line)];\n          if (lineView.node == null) {\n            return;\n          }\n          var arr = lineView.changes || (lineView.changes = []);\n          if (indexOf2(arr, type) == -1) {\n            arr.push(type);\n          }\n        }\n        function resetView(cm) {\n          cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n          cm.display.view = [];\n          cm.display.viewOffset = 0;\n        }\n        function viewCuttingPoint(cm, oldN, newN, dir) {\n          var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n          if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n            return { index, lineN: newN };\n          }\n          var n = cm.display.viewFrom;\n          for (var i2 = 0; i2 < index; i2++) {\n            n += view[i2].size;\n          }\n          if (n != oldN) {\n            if (dir > 0) {\n              if (index == view.length - 1) {\n                return null;\n              }\n              diff = n + view[index].size - oldN;\n              index++;\n            } else {\n              diff = n - oldN;\n            }\n            oldN += diff;\n            newN += diff;\n          }\n          while (visualLineNo(cm.doc, newN) != newN) {\n            if (index == (dir < 0 ? 0 : view.length - 1)) {\n              return null;\n            }\n            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n            index += dir;\n          }\n          return { index, lineN: newN };\n        }\n        function adjustView(cm, from, to) {\n          var display = cm.display, view = display.view;\n          if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n            display.view = buildViewArray(cm, from, to);\n            display.viewFrom = from;\n          } else {\n            if (display.viewFrom > from) {\n              display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n            } else if (display.viewFrom < from) {\n              display.view = display.view.slice(findViewIndex(cm, from));\n            }\n            display.viewFrom = from;\n            if (display.viewTo < to) {\n              display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n            } else if (display.viewTo > to) {\n              display.view = display.view.slice(0, findViewIndex(cm, to));\n            }\n          }\n          display.viewTo = to;\n        }\n        function countDirtyView(cm) {\n          var view = cm.display.view, dirty = 0;\n          for (var i2 = 0; i2 < view.length; i2++) {\n            var lineView = view[i2];\n            if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n              ++dirty;\n            }\n          }\n          return dirty;\n        }\n        function updateSelection(cm) {\n          cm.display.input.showSelection(cm.display.input.prepareSelection());\n        }\n        function prepareSelection(cm, primary) {\n          if (primary === void 0)\n            primary = true;\n          var doc2 = cm.doc, result = {};\n          var curFragment = result.cursors = document.createDocumentFragment();\n          var selFragment = result.selection = document.createDocumentFragment();\n          var customCursor = cm.options.$customCursor;\n          if (customCursor) {\n            primary = true;\n          }\n          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {\n            if (!primary && i2 == doc2.sel.primIndex) {\n              continue;\n            }\n            var range2 = doc2.sel.ranges[i2];\n            if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {\n              continue;\n            }\n            var collapsed = range2.empty();\n            if (customCursor) {\n              var head = customCursor(cm, range2);\n              if (head) {\n                drawSelectionCursor(cm, head, curFragment);\n              }\n            } else if (collapsed || cm.options.showCursorWhenSelecting) {\n              drawSelectionCursor(cm, range2.head, curFragment);\n            }\n            if (!collapsed) {\n              drawSelectionRange(cm, range2, selFragment);\n            }\n          }\n          return result;\n        }\n        function drawSelectionCursor(cm, head, output) {\n          var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);\n          var cursor = output.appendChild(elt("div", "\\xA0", "CodeMirror-cursor"));\n          cursor.style.left = pos.left + "px";\n          cursor.style.top = pos.top + "px";\n          cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\n          if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n            var charPos = charCoords(cm, head, "div", null, null);\n            var width = charPos.right - charPos.left;\n            cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";\n          }\n          if (pos.other) {\n            var otherCursor = output.appendChild(elt("div", "\\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));\n            otherCursor.style.display = "";\n            otherCursor.style.left = pos.other.left + "px";\n            otherCursor.style.top = pos.other.top + "px";\n            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";\n          }\n        }\n        function cmpCoords(a, b2) {\n          return a.top - b2.top || a.left - b2.left;\n        }\n        function drawSelectionRange(cm, range2, output) {\n          var display = cm.display, doc2 = cm.doc;\n          var fragment = document.createDocumentFragment();\n          var padding = paddingH(cm.display), leftSide = padding.left;\n          var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n          var docLTR = doc2.direction == "ltr";\n          function add2(left, top, width, bottom) {\n            if (top < 0) {\n              top = 0;\n            }\n            top = Math.round(top);\n            bottom = Math.round(bottom);\n            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\\n                             height: " + (bottom - top) + "px"));\n          }\n          function drawForLine(line, fromArg, toArg) {\n            var lineObj = getLine(doc2, line);\n            var lineLen = lineObj.text.length;\n            var start, end;\n            function coords(ch, bias) {\n              return charCoords(cm, Pos(line, ch), "div", lineObj, bias);\n            }\n            function wrapX(pos, dir, side) {\n              var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n              var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";\n              var ch = side == "after" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n              return coords(ch, prop2)[prop2];\n            }\n            var order = getOrder2(lineObj, doc2.direction);\n            iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {\n              var ltr = dir == "ltr";\n              var fromPos = coords(from, ltr ? "left" : "right");\n              var toPos = coords(to - 1, ltr ? "right" : "left");\n              var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n              var first = i2 == 0, last = !order || i2 == order.length - 1;\n              if (toPos.top - fromPos.top <= 3) {\n                var openLeft = (docLTR ? openStart : openEnd) && first;\n                var openRight = (docLTR ? openEnd : openStart) && last;\n                var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n                var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n                add2(left, fromPos.top, right - left, fromPos.bottom);\n              } else {\n                var topLeft, topRight, botLeft, botRight;\n                if (ltr) {\n                  topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n                  topRight = docLTR ? rightSide : wrapX(from, dir, "before");\n                  botLeft = docLTR ? leftSide : wrapX(to, dir, "after");\n                  botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n                } else {\n                  topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");\n                  topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n                  botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n                  botRight = !docLTR ? rightSide : wrapX(to, dir, "after");\n                }\n                add2(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n                if (fromPos.bottom < toPos.top) {\n                  add2(leftSide, fromPos.bottom, null, toPos.top);\n                }\n                add2(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n              }\n              if (!start || cmpCoords(fromPos, start) < 0) {\n                start = fromPos;\n              }\n              if (cmpCoords(toPos, start) < 0) {\n                start = toPos;\n              }\n              if (!end || cmpCoords(fromPos, end) < 0) {\n                end = fromPos;\n              }\n              if (cmpCoords(toPos, end) < 0) {\n                end = toPos;\n              }\n            });\n            return { start, end };\n          }\n          var sFrom = range2.from(), sTo = range2.to();\n          if (sFrom.line == sTo.line) {\n            drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n          } else {\n            var fromLine = getLine(doc2, sFrom.line), toLine = getLine(doc2, sTo.line);\n            var singleVLine = visualLine(fromLine) == visualLine(toLine);\n            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n            if (singleVLine) {\n              if (leftEnd.top < rightStart.top - 2) {\n                add2(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n                add2(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n              } else {\n                add2(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n              }\n            }\n            if (leftEnd.bottom < rightStart.top) {\n              add2(leftSide, leftEnd.bottom, null, rightStart.top);\n            }\n          }\n          output.appendChild(fragment);\n        }\n        function restartBlink(cm) {\n          if (!cm.state.focused) {\n            return;\n          }\n          var display = cm.display;\n          clearInterval(display.blinker);\n          var on2 = true;\n          display.cursorDiv.style.visibility = "";\n          if (cm.options.cursorBlinkRate > 0) {\n            display.blinker = setInterval(function() {\n              if (!cm.hasFocus()) {\n                onBlur(cm);\n              }\n              display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";\n            }, cm.options.cursorBlinkRate);\n          } else if (cm.options.cursorBlinkRate < 0) {\n            display.cursorDiv.style.visibility = "hidden";\n          }\n        }\n        function ensureFocus(cm) {\n          if (!cm.hasFocus()) {\n            cm.display.input.focus();\n            if (!cm.state.focused) {\n              onFocus(cm);\n            }\n          }\n        }\n        function delayBlurEvent(cm) {\n          cm.state.delayingBlurEvent = true;\n          setTimeout(function() {\n            if (cm.state.delayingBlurEvent) {\n              cm.state.delayingBlurEvent = false;\n              if (cm.state.focused) {\n                onBlur(cm);\n              }\n            }\n          }, 100);\n        }\n        function onFocus(cm, e) {\n          if (cm.state.delayingBlurEvent && !cm.state.draggingText) {\n            cm.state.delayingBlurEvent = false;\n          }\n          if (cm.options.readOnly == "nocursor") {\n            return;\n          }\n          if (!cm.state.focused) {\n            signal(cm, "focus", cm, e);\n            cm.state.focused = true;\n            addClass(cm.display.wrapper, "CodeMirror-focused");\n            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n              cm.display.input.reset();\n              if (webkit) {\n                setTimeout(function() {\n                  return cm.display.input.reset(true);\n                }, 20);\n              }\n            }\n            cm.display.input.receivedFocus();\n          }\n          restartBlink(cm);\n        }\n        function onBlur(cm, e) {\n          if (cm.state.delayingBlurEvent) {\n            return;\n          }\n          if (cm.state.focused) {\n            signal(cm, "blur", cm, e);\n            cm.state.focused = false;\n            rmClass(cm.display.wrapper, "CodeMirror-focused");\n          }\n          clearInterval(cm.display.blinker);\n          setTimeout(function() {\n            if (!cm.state.focused) {\n              cm.display.shift = false;\n            }\n          }, 150);\n        }\n        function updateHeightsInViewport(cm) {\n          var display = cm.display;\n          var prevBottom = display.lineDiv.offsetTop;\n          var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n          var oldHeight = display.lineDiv.getBoundingClientRect().top;\n          var mustScroll = 0;\n          for (var i2 = 0; i2 < display.view.length; i2++) {\n            var cur = display.view[i2], wrapping = cm.options.lineWrapping;\n            var height = void 0, width = 0;\n            if (cur.hidden) {\n              continue;\n            }\n            oldHeight += cur.line.height;\n            if (ie && ie_version < 8) {\n              var bot = cur.node.offsetTop + cur.node.offsetHeight;\n              height = bot - prevBottom;\n              prevBottom = bot;\n            } else {\n              var box = cur.node.getBoundingClientRect();\n              height = box.bottom - box.top;\n              if (!wrapping && cur.text.firstChild) {\n                width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n              }\n            }\n            var diff = cur.line.height - height;\n            if (diff > 5e-3 || diff < -5e-3) {\n              if (oldHeight < viewTop) {\n                mustScroll -= diff;\n              }\n              updateLineHeight(cur.line, height);\n              updateWidgetHeight(cur.line);\n              if (cur.rest) {\n                for (var j2 = 0; j2 < cur.rest.length; j2++) {\n                  updateWidgetHeight(cur.rest[j2]);\n                }\n              }\n            }\n            if (width > cm.display.sizerWidth) {\n              var chWidth = Math.ceil(width / charWidth(cm.display));\n              if (chWidth > cm.display.maxLineLength) {\n                cm.display.maxLineLength = chWidth;\n                cm.display.maxLine = cur.line;\n                cm.display.maxLineChanged = true;\n              }\n            }\n          }\n          if (Math.abs(mustScroll) > 2) {\n            display.scroller.scrollTop += mustScroll;\n          }\n        }\n        function updateWidgetHeight(line) {\n          if (line.widgets) {\n            for (var i2 = 0; i2 < line.widgets.length; ++i2) {\n              var w = line.widgets[i2], parent = w.node.parentNode;\n              if (parent) {\n                w.height = parent.offsetHeight;\n              }\n            }\n          }\n        }\n        function visibleLines(display, doc2, viewport) {\n          var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n          top = Math.floor(top - paddingTop(display));\n          var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n          var from = lineAtHeight(doc2, top), to = lineAtHeight(doc2, bottom);\n          if (viewport && viewport.ensure) {\n            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n            if (ensureFrom < from) {\n              from = ensureFrom;\n              to = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureFrom)) + display.wrapper.clientHeight);\n            } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {\n              from = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureTo)) - display.wrapper.clientHeight);\n              to = ensureTo;\n            }\n          }\n          return { from, to: Math.max(to, from + 1) };\n        }\n        function maybeScrollWindow(cm, rect) {\n          if (signalDOMEvent(cm, "scrollCursorIntoView")) {\n            return;\n          }\n          var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n          var doc2 = display.wrapper.ownerDocument;\n          if (rect.top + box.top < 0) {\n            doScroll = true;\n          } else if (rect.bottom + box.top > (doc2.defaultView.innerHeight || doc2.documentElement.clientHeight)) {\n            doScroll = false;\n          }\n          if (doScroll != null && !phantom) {\n            var scrollNode = elt("div", "\\u200B", null, "position: absolute;\\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");\n            cm.display.lineSpace.appendChild(scrollNode);\n            scrollNode.scrollIntoView(doScroll);\n            cm.display.lineSpace.removeChild(scrollNode);\n          }\n        }\n        function scrollPosIntoView(cm, pos, end, margin) {\n          if (margin == null) {\n            margin = 0;\n          }\n          var rect;\n          if (!cm.options.lineWrapping && pos == end) {\n            end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;\n            pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;\n          }\n          for (var limit = 0; limit < 5; limit++) {\n            var changed = false;\n            var coords = cursorCoords(cm, pos);\n            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n            rect = {\n              left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n            };\n            var scrollPos = calculateScrollPos(cm, rect);\n            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n            if (scrollPos.scrollTop != null) {\n              updateScrollTop(cm, scrollPos.scrollTop);\n              if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n                changed = true;\n              }\n            }\n            if (scrollPos.scrollLeft != null) {\n              setScrollLeft(cm, scrollPos.scrollLeft);\n              if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n                changed = true;\n              }\n            }\n            if (!changed) {\n              break;\n            }\n          }\n          return rect;\n        }\n        function scrollIntoView(cm, rect) {\n          var scrollPos = calculateScrollPos(cm, rect);\n          if (scrollPos.scrollTop != null) {\n            updateScrollTop(cm, scrollPos.scrollTop);\n          }\n          if (scrollPos.scrollLeft != null) {\n            setScrollLeft(cm, scrollPos.scrollLeft);\n          }\n        }\n        function calculateScrollPos(cm, rect) {\n          var display = cm.display, snapMargin = textHeight(cm.display);\n          if (rect.top < 0) {\n            rect.top = 0;\n          }\n          var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n          var screen2 = displayHeight(cm), result = {};\n          if (rect.bottom - rect.top > screen2) {\n            rect.bottom = rect.top + screen2;\n          }\n          var docBottom = cm.doc.height + paddingVert(display);\n          var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n          if (rect.top < screentop) {\n            result.scrollTop = atTop ? 0 : rect.top;\n          } else if (rect.bottom > screentop + screen2) {\n            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);\n            if (newTop != screentop) {\n              result.scrollTop = newTop;\n            }\n          }\n          var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n          var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n          var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n          var tooWide = rect.right - rect.left > screenw;\n          if (tooWide) {\n            rect.right = rect.left + screenw;\n          }\n          if (rect.left < 10) {\n            result.scrollLeft = 0;\n          } else if (rect.left < screenleft) {\n            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));\n          } else if (rect.right > screenw + screenleft - 3) {\n            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;\n          }\n          return result;\n        }\n        function addToScrollTop(cm, top) {\n          if (top == null) {\n            return;\n          }\n          resolveScrollToPos(cm);\n          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n        }\n        function ensureCursorVisible(cm) {\n          resolveScrollToPos(cm);\n          var cur = cm.getCursor();\n          cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };\n        }\n        function scrollToCoords(cm, x, y2) {\n          if (x != null || y2 != null) {\n            resolveScrollToPos(cm);\n          }\n          if (x != null) {\n            cm.curOp.scrollLeft = x;\n          }\n          if (y2 != null) {\n            cm.curOp.scrollTop = y2;\n          }\n        }\n        function scrollToRange(cm, range2) {\n          resolveScrollToPos(cm);\n          cm.curOp.scrollToPos = range2;\n        }\n        function resolveScrollToPos(cm) {\n          var range2 = cm.curOp.scrollToPos;\n          if (range2) {\n            cm.curOp.scrollToPos = null;\n            var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);\n            scrollToCoordsRange(cm, from, to, range2.margin);\n          }\n        }\n        function scrollToCoordsRange(cm, from, to, margin) {\n          var sPos = calculateScrollPos(cm, {\n            left: Math.min(from.left, to.left),\n            top: Math.min(from.top, to.top) - margin,\n            right: Math.max(from.right, to.right),\n            bottom: Math.max(from.bottom, to.bottom) + margin\n          });\n          scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n        }\n        function updateScrollTop(cm, val) {\n          if (Math.abs(cm.doc.scrollTop - val) < 2) {\n            return;\n          }\n          if (!gecko) {\n            updateDisplaySimple(cm, { top: val });\n          }\n          setScrollTop(cm, val, true);\n          if (gecko) {\n            updateDisplaySimple(cm);\n          }\n          startWorker(cm, 100);\n        }\n        function setScrollTop(cm, val, forceScroll) {\n          val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n          if (cm.display.scroller.scrollTop == val && !forceScroll) {\n            return;\n          }\n          cm.doc.scrollTop = val;\n          cm.display.scrollbars.setScrollTop(val);\n          if (cm.display.scroller.scrollTop != val) {\n            cm.display.scroller.scrollTop = val;\n          }\n        }\n        function setScrollLeft(cm, val, isScroller, forceScroll) {\n          val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n          if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n            return;\n          }\n          cm.doc.scrollLeft = val;\n          alignHorizontally(cm);\n          if (cm.display.scroller.scrollLeft != val) {\n            cm.display.scroller.scrollLeft = val;\n          }\n          cm.display.scrollbars.setScrollLeft(val);\n        }\n        function measureForScrollbars(cm) {\n          var d = cm.display, gutterW = d.gutters.offsetWidth;\n          var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n          return {\n            clientHeight: d.scroller.clientHeight,\n            viewHeight: d.wrapper.clientHeight,\n            scrollWidth: d.scroller.scrollWidth,\n            clientWidth: d.scroller.clientWidth,\n            viewWidth: d.wrapper.clientWidth,\n            barLeft: cm.options.fixedGutter ? gutterW : 0,\n            docHeight: docH,\n            scrollHeight: docH + scrollGap(cm) + d.barHeight,\n            nativeBarWidth: d.nativeBarWidth,\n            gutterWidth: gutterW\n          };\n        }\n        var NativeScrollbars = function(place, scroll, cm) {\n          this.cm = cm;\n          var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");\n          var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");\n          vert.tabIndex = horiz.tabIndex = -1;\n          place(vert);\n          place(horiz);\n          on(vert, "scroll", function() {\n            if (vert.clientHeight) {\n              scroll(vert.scrollTop, "vertical");\n            }\n          });\n          on(horiz, "scroll", function() {\n            if (horiz.clientWidth) {\n              scroll(horiz.scrollLeft, "horizontal");\n            }\n          });\n          this.checkedZeroWidth = false;\n          if (ie && ie_version < 8) {\n            this.horiz.style.minHeight = this.vert.style.minWidth = "18px";\n          }\n        };\n        NativeScrollbars.prototype.update = function(measure) {\n          var needsH = measure.scrollWidth > measure.clientWidth + 1;\n          var needsV = measure.scrollHeight > measure.clientHeight + 1;\n          var sWidth = measure.nativeBarWidth;\n          if (needsV) {\n            this.vert.style.display = "block";\n            this.vert.style.bottom = needsH ? sWidth + "px" : "0";\n            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";\n          } else {\n            this.vert.scrollTop = 0;\n            this.vert.style.display = "";\n            this.vert.firstChild.style.height = "0";\n          }\n          if (needsH) {\n            this.horiz.style.display = "block";\n            this.horiz.style.right = needsV ? sWidth + "px" : "0";\n            this.horiz.style.left = measure.barLeft + "px";\n            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";\n          } else {\n            this.horiz.style.display = "";\n            this.horiz.firstChild.style.width = "0";\n          }\n          if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n            if (sWidth == 0) {\n              this.zeroWidthHack();\n            }\n            this.checkedZeroWidth = true;\n          }\n          return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };\n        };\n        NativeScrollbars.prototype.setScrollLeft = function(pos) {\n          if (this.horiz.scrollLeft != pos) {\n            this.horiz.scrollLeft = pos;\n          }\n          if (this.disableHoriz) {\n            this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");\n          }\n        };\n        NativeScrollbars.prototype.setScrollTop = function(pos) {\n          if (this.vert.scrollTop != pos) {\n            this.vert.scrollTop = pos;\n          }\n          if (this.disableVert) {\n            this.enableZeroWidthBar(this.vert, this.disableVert, "vert");\n          }\n        };\n        NativeScrollbars.prototype.zeroWidthHack = function() {\n          var w = mac && !mac_geMountainLion ? "12px" : "18px";\n          this.horiz.style.height = this.vert.style.width = w;\n          this.horiz.style.visibility = this.vert.style.visibility = "hidden";\n          this.disableHoriz = new Delayed();\n          this.disableVert = new Delayed();\n        };\n        NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {\n          bar.style.visibility = "";\n          function maybeDisable() {\n            var box = bar.getBoundingClientRect();\n            var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n            if (elt2 != bar) {\n              bar.style.visibility = "hidden";\n            } else {\n              delay.set(1e3, maybeDisable);\n            }\n          }\n          delay.set(1e3, maybeDisable);\n        };\n        NativeScrollbars.prototype.clear = function() {\n          var parent = this.horiz.parentNode;\n          parent.removeChild(this.horiz);\n          parent.removeChild(this.vert);\n        };\n        var NullScrollbars = function() {\n        };\n        NullScrollbars.prototype.update = function() {\n          return { bottom: 0, right: 0 };\n        };\n        NullScrollbars.prototype.setScrollLeft = function() {\n        };\n        NullScrollbars.prototype.setScrollTop = function() {\n        };\n        NullScrollbars.prototype.clear = function() {\n        };\n        function updateScrollbars(cm, measure) {\n          if (!measure) {\n            measure = measureForScrollbars(cm);\n          }\n          var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n          updateScrollbarsInner(cm, measure);\n          for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {\n            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n              updateHeightsInViewport(cm);\n            }\n            updateScrollbarsInner(cm, measureForScrollbars(cm));\n            startWidth = cm.display.barWidth;\n            startHeight = cm.display.barHeight;\n          }\n        }\n        function updateScrollbarsInner(cm, measure) {\n          var d = cm.display;\n          var sizes = d.scrollbars.update(measure);\n          d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";\n          d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";\n          d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";\n          if (sizes.right && sizes.bottom) {\n            d.scrollbarFiller.style.display = "block";\n            d.scrollbarFiller.style.height = sizes.bottom + "px";\n            d.scrollbarFiller.style.width = sizes.right + "px";\n          } else {\n            d.scrollbarFiller.style.display = "";\n          }\n          if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n            d.gutterFiller.style.display = "block";\n            d.gutterFiller.style.height = sizes.bottom + "px";\n            d.gutterFiller.style.width = measure.gutterWidth + "px";\n          } else {\n            d.gutterFiller.style.display = "";\n          }\n        }\n        var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };\n        function initScrollbars(cm) {\n          if (cm.display.scrollbars) {\n            cm.display.scrollbars.clear();\n            if (cm.display.scrollbars.addClass) {\n              rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n            }\n          }\n          cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {\n            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n            on(node, "mousedown", function() {\n              if (cm.state.focused) {\n                setTimeout(function() {\n                  return cm.display.input.focus();\n                }, 0);\n              }\n            });\n            node.setAttribute("cm-not-content", "true");\n          }, function(pos, axis) {\n            if (axis == "horizontal") {\n              setScrollLeft(cm, pos);\n            } else {\n              updateScrollTop(cm, pos);\n            }\n          }, cm);\n          if (cm.display.scrollbars.addClass) {\n            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n          }\n        }\n        var nextOpId = 0;\n        function startOperation(cm) {\n          cm.curOp = {\n            cm,\n            viewChanged: false,\n            // Flag that indicates that lines might need to be redrawn\n            startHeight: cm.doc.height,\n            // Used to detect need to update scrollbar\n            forceUpdate: false,\n            // Used to force a redraw\n            updateInput: 0,\n            // Whether to reset the input textarea\n            typing: false,\n            // Whether this reset should be careful to leave existing text (for compositing)\n            changeObjs: null,\n            // Accumulated changes, for firing change events\n            cursorActivityHandlers: null,\n            // Set of handlers to fire cursorActivity on\n            cursorActivityCalled: 0,\n            // Tracks which cursorActivity handlers have been called already\n            selectionChanged: false,\n            // Whether the selection needs to be redrawn\n            updateMaxLine: false,\n            // Set when the widest line needs to be determined anew\n            scrollLeft: null,\n            scrollTop: null,\n            // Intermediate scroll position, not pushed to DOM yet\n            scrollToPos: null,\n            // Used to scroll to a specific position\n            focus: false,\n            id: ++nextOpId,\n            // Unique ID\n            markArrays: null\n            // Used by addMarkedSpan\n          };\n          pushOperation(cm.curOp);\n        }\n        function endOperation(cm) {\n          var op = cm.curOp;\n          if (op) {\n            finishOperation(op, function(group) {\n              for (var i2 = 0; i2 < group.ops.length; i2++) {\n                group.ops[i2].cm.curOp = null;\n              }\n              endOperations(group);\n            });\n          }\n        }\n        function endOperations(group) {\n          var ops = group.ops;\n          for (var i2 = 0; i2 < ops.length; i2++) {\n            endOperation_R1(ops[i2]);\n          }\n          for (var i$12 = 0; i$12 < ops.length; i$12++) {\n            endOperation_W1(ops[i$12]);\n          }\n          for (var i$22 = 0; i$22 < ops.length; i$22++) {\n            endOperation_R2(ops[i$22]);\n          }\n          for (var i$3 = 0; i$3 < ops.length; i$3++) {\n            endOperation_W2(ops[i$3]);\n          }\n          for (var i$4 = 0; i$4 < ops.length; i$4++) {\n            endOperation_finish(ops[i$4]);\n          }\n        }\n        function endOperation_R1(op) {\n          var cm = op.cm, display = cm.display;\n          maybeClipScrollbars(cm);\n          if (op.updateMaxLine) {\n            findMaxLine(cm);\n          }\n          op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n          op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);\n        }\n        function endOperation_W1(op) {\n          op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n        }\n        function endOperation_R2(op) {\n          var cm = op.cm, display = cm.display;\n          if (op.updatedDisplay) {\n            updateHeightsInViewport(cm);\n          }\n          op.barMeasure = measureForScrollbars(cm);\n          if (display.maxLineChanged && !cm.options.lineWrapping) {\n            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n            cm.display.sizerWidth = op.adjustWidthTo;\n            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n          }\n          if (op.updatedDisplay || op.selectionChanged) {\n            op.preparedSelection = display.input.prepareSelection();\n          }\n        }\n        function endOperation_W2(op) {\n          var cm = op.cm;\n          if (op.adjustWidthTo != null) {\n            cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";\n            if (op.maxScrollLeft < cm.doc.scrollLeft) {\n              setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n            }\n            cm.display.maxLineChanged = false;\n          }\n          var takeFocus = op.focus && op.focus == activeElt(root(cm));\n          if (op.preparedSelection) {\n            cm.display.input.showSelection(op.preparedSelection, takeFocus);\n          }\n          if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n            updateScrollbars(cm, op.barMeasure);\n          }\n          if (op.updatedDisplay) {\n            setDocumentHeight(cm, op.barMeasure);\n          }\n          if (op.selectionChanged) {\n            restartBlink(cm);\n          }\n          if (cm.state.focused && op.updateInput) {\n            cm.display.input.reset(op.typing);\n          }\n          if (takeFocus) {\n            ensureFocus(op.cm);\n          }\n        }\n        function endOperation_finish(op) {\n          var cm = op.cm, display = cm.display, doc2 = cm.doc;\n          if (op.updatedDisplay) {\n            postUpdateDisplay(cm, op.update);\n          }\n          if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n            display.wheelStartX = display.wheelStartY = null;\n          }\n          if (op.scrollTop != null) {\n            setScrollTop(cm, op.scrollTop, op.forceScroll);\n          }\n          if (op.scrollLeft != null) {\n            setScrollLeft(cm, op.scrollLeft, true, true);\n          }\n          if (op.scrollToPos) {\n            var rect = scrollPosIntoView(\n              cm,\n              clipPos(doc2, op.scrollToPos.from),\n              clipPos(doc2, op.scrollToPos.to),\n              op.scrollToPos.margin\n            );\n            maybeScrollWindow(cm, rect);\n          }\n          var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n          if (hidden) {\n            for (var i2 = 0; i2 < hidden.length; ++i2) {\n              if (!hidden[i2].lines.length) {\n                signal(hidden[i2], "hide");\n              }\n            }\n          }\n          if (unhidden) {\n            for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {\n              if (unhidden[i$12].lines.length) {\n                signal(unhidden[i$12], "unhide");\n              }\n            }\n          }\n          if (display.wrapper.offsetHeight) {\n            doc2.scrollTop = cm.display.scroller.scrollTop;\n          }\n          if (op.changeObjs) {\n            signal(cm, "changes", cm, op.changeObjs);\n          }\n          if (op.update) {\n            op.update.finish();\n          }\n        }\n        function runInOp(cm, f) {\n          if (cm.curOp) {\n            return f();\n          }\n          startOperation(cm);\n          try {\n            return f();\n          } finally {\n            endOperation(cm);\n          }\n        }\n        function operation(cm, f) {\n          return function() {\n            if (cm.curOp) {\n              return f.apply(cm, arguments);\n            }\n            startOperation(cm);\n            try {\n              return f.apply(cm, arguments);\n            } finally {\n              endOperation(cm);\n            }\n          };\n        }\n        function methodOp(f) {\n          return function() {\n            if (this.curOp) {\n              return f.apply(this, arguments);\n            }\n            startOperation(this);\n            try {\n              return f.apply(this, arguments);\n            } finally {\n              endOperation(this);\n            }\n          };\n        }\n        function docMethodOp(f) {\n          return function() {\n            var cm = this.cm;\n            if (!cm || cm.curOp) {\n              return f.apply(this, arguments);\n            }\n            startOperation(cm);\n            try {\n              return f.apply(this, arguments);\n            } finally {\n              endOperation(cm);\n            }\n          };\n        }\n        function startWorker(cm, time) {\n          if (cm.doc.highlightFrontier < cm.display.viewTo) {\n            cm.state.highlight.set(time, bind(highlightWorker, cm));\n          }\n        }\n        function highlightWorker(cm) {\n          var doc2 = cm.doc;\n          if (doc2.highlightFrontier >= cm.display.viewTo) {\n            return;\n          }\n          var end = +/* @__PURE__ */ new Date() + cm.options.workTime;\n          var context = getContextBefore(cm, doc2.highlightFrontier);\n          var changedLines = [];\n          doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {\n            if (context.line >= cm.display.viewFrom) {\n              var oldStyles = line.styles;\n              var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;\n              var highlighted = highlightLine(cm, line, context, true);\n              if (resetState) {\n                context.state = resetState;\n              }\n              line.styles = highlighted.styles;\n              var oldCls = line.styleClasses, newCls = highlighted.classes;\n              if (newCls) {\n                line.styleClasses = newCls;\n              } else if (oldCls) {\n                line.styleClasses = null;\n              }\n              var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n              for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {\n                ischange = oldStyles[i2] != line.styles[i2];\n              }\n              if (ischange) {\n                changedLines.push(context.line);\n              }\n              line.stateAfter = context.save();\n              context.nextLine();\n            } else {\n              if (line.text.length <= cm.options.maxHighlightLength) {\n                processLine(cm, line.text, context);\n              }\n              line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n              context.nextLine();\n            }\n            if (+/* @__PURE__ */ new Date() > end) {\n              startWorker(cm, cm.options.workDelay);\n              return true;\n            }\n          });\n          doc2.highlightFrontier = context.line;\n          doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);\n          if (changedLines.length) {\n            runInOp(cm, function() {\n              for (var i2 = 0; i2 < changedLines.length; i2++) {\n                regLineChange(cm, changedLines[i2], "text");\n              }\n            });\n          }\n        }\n        var DisplayUpdate = function(cm, viewport, force) {\n          var display = cm.display;\n          this.viewport = viewport;\n          this.visible = visibleLines(display, cm.doc, viewport);\n          this.editorIsHidden = !display.wrapper.offsetWidth;\n          this.wrapperHeight = display.wrapper.clientHeight;\n          this.wrapperWidth = display.wrapper.clientWidth;\n          this.oldDisplayWidth = displayWidth(cm);\n          this.force = force;\n          this.dims = getDimensions(cm);\n          this.events = [];\n        };\n        DisplayUpdate.prototype.signal = function(emitter, type) {\n          if (hasHandler(emitter, type)) {\n            this.events.push(arguments);\n          }\n        };\n        DisplayUpdate.prototype.finish = function() {\n          for (var i2 = 0; i2 < this.events.length; i2++) {\n            signal.apply(null, this.events[i2]);\n          }\n        };\n        function maybeClipScrollbars(cm) {\n          var display = cm.display;\n          if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n            display.heightForcer.style.height = scrollGap(cm) + "px";\n            display.sizer.style.marginBottom = -display.nativeBarWidth + "px";\n            display.sizer.style.borderRightWidth = scrollGap(cm) + "px";\n            display.scrollbarsClipped = true;\n          }\n        }\n        function selectionSnapshot(cm) {\n          if (cm.hasFocus()) {\n            return null;\n          }\n          var active = activeElt(root(cm));\n          if (!active || !contains(cm.display.lineDiv, active)) {\n            return null;\n          }\n          var result = { activeElt: active };\n          if (window.getSelection) {\n            var sel = win(cm).getSelection();\n            if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n              result.anchorNode = sel.anchorNode;\n              result.anchorOffset = sel.anchorOffset;\n              result.focusNode = sel.focusNode;\n              result.focusOffset = sel.focusOffset;\n            }\n          }\n          return result;\n        }\n        function restoreSelection(snapshot) {\n          if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) {\n            return;\n          }\n          snapshot.activeElt.focus();\n          if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n            var doc2 = snapshot.activeElt.ownerDocument;\n            var sel = doc2.defaultView.getSelection(), range2 = doc2.createRange();\n            range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n            range2.collapse(false);\n            sel.removeAllRanges();\n            sel.addRange(range2);\n            sel.extend(snapshot.focusNode, snapshot.focusOffset);\n          }\n        }\n        function updateDisplayIfNeeded(cm, update) {\n          var display = cm.display, doc2 = cm.doc;\n          if (update.editorIsHidden) {\n            resetView(cm);\n            return false;\n          }\n          if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n            return false;\n          }\n          if (maybeUpdateLineNumberWidth(cm)) {\n            resetView(cm);\n            update.dims = getDimensions(cm);\n          }\n          var end = doc2.first + doc2.size;\n          var from = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);\n          var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n          if (display.viewFrom < from && from - display.viewFrom < 20) {\n            from = Math.max(doc2.first, display.viewFrom);\n          }\n          if (display.viewTo > to && display.viewTo - to < 20) {\n            to = Math.min(end, display.viewTo);\n          }\n          if (sawCollapsedSpans) {\n            from = visualLineNo(cm.doc, from);\n            to = visualLineEndNo(cm.doc, to);\n          }\n          var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n          adjustView(cm, from, to);\n          display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n          cm.display.mover.style.top = display.viewOffset + "px";\n          var toUpdate = countDirtyView(cm);\n          if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n            return false;\n          }\n          var selSnapshot = selectionSnapshot(cm);\n          if (toUpdate > 4) {\n            display.lineDiv.style.display = "none";\n          }\n          patchDisplay(cm, display.updateLineNumbers, update.dims);\n          if (toUpdate > 4) {\n            display.lineDiv.style.display = "";\n          }\n          display.renderedView = display.view;\n          restoreSelection(selSnapshot);\n          removeChildren(display.cursorDiv);\n          removeChildren(display.selectionDiv);\n          display.gutters.style.height = display.sizer.style.minHeight = 0;\n          if (different) {\n            display.lastWrapHeight = update.wrapperHeight;\n            display.lastWrapWidth = update.wrapperWidth;\n            startWorker(cm, 400);\n          }\n          display.updateLineNumbers = null;\n          return true;\n        }\n        function postUpdateDisplay(cm, update) {\n          var viewport = update.viewport;\n          for (var first = true; ; first = false) {\n            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n              if (viewport && viewport.top != null) {\n                viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };\n              }\n              update.visible = visibleLines(cm.display, cm.doc, viewport);\n              if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n                break;\n              }\n            } else if (first) {\n              update.visible = visibleLines(cm.display, cm.doc, viewport);\n            }\n            if (!updateDisplayIfNeeded(cm, update)) {\n              break;\n            }\n            updateHeightsInViewport(cm);\n            var barMeasure = measureForScrollbars(cm);\n            updateSelection(cm);\n            updateScrollbars(cm, barMeasure);\n            setDocumentHeight(cm, barMeasure);\n            update.force = false;\n          }\n          update.signal(cm, "update", cm);\n          if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n            update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);\n            cm.display.reportedViewFrom = cm.display.viewFrom;\n            cm.display.reportedViewTo = cm.display.viewTo;\n          }\n        }\n        function updateDisplaySimple(cm, viewport) {\n          var update = new DisplayUpdate(cm, viewport);\n          if (updateDisplayIfNeeded(cm, update)) {\n            updateHeightsInViewport(cm);\n            postUpdateDisplay(cm, update);\n            var barMeasure = measureForScrollbars(cm);\n            updateSelection(cm);\n            updateScrollbars(cm, barMeasure);\n            setDocumentHeight(cm, barMeasure);\n            update.finish();\n          }\n        }\n        function patchDisplay(cm, updateNumbersFrom, dims) {\n          var display = cm.display, lineNumbers = cm.options.lineNumbers;\n          var container = display.lineDiv, cur = container.firstChild;\n          function rm(node2) {\n            var next = node2.nextSibling;\n            if (webkit && mac && cm.display.currentWheelTarget == node2) {\n              node2.style.display = "none";\n            } else {\n              node2.parentNode.removeChild(node2);\n            }\n            return next;\n          }\n          var view = display.view, lineN = display.viewFrom;\n          for (var i2 = 0; i2 < view.length; i2++) {\n            var lineView = view[i2];\n            if (lineView.hidden)\n              ;\n            else if (!lineView.node || lineView.node.parentNode != container) {\n              var node = buildLineElement(cm, lineView, lineN, dims);\n              container.insertBefore(node, cur);\n            } else {\n              while (cur != lineView.node) {\n                cur = rm(cur);\n              }\n              var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n              if (lineView.changes) {\n                if (indexOf2(lineView.changes, "gutter") > -1) {\n                  updateNumber = false;\n                }\n                updateLineForChanges(cm, lineView, lineN, dims);\n              }\n              if (updateNumber) {\n                removeChildren(lineView.lineNumber);\n                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n              }\n              cur = lineView.node.nextSibling;\n            }\n            lineN += lineView.size;\n          }\n          while (cur) {\n            cur = rm(cur);\n          }\n        }\n        function updateGutterSpace(display) {\n          var width = display.gutters.offsetWidth;\n          display.sizer.style.marginLeft = width + "px";\n          signalLater(display, "gutterChanged", display);\n        }\n        function setDocumentHeight(cm, measure) {\n          cm.display.sizer.style.minHeight = measure.docHeight + "px";\n          cm.display.heightForcer.style.top = measure.docHeight + "px";\n          cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";\n        }\n        function alignHorizontally(cm) {\n          var display = cm.display, view = display.view;\n          if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n            return;\n          }\n          var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n          var gutterW = display.gutters.offsetWidth, left = comp + "px";\n          for (var i2 = 0; i2 < view.length; i2++) {\n            if (!view[i2].hidden) {\n              if (cm.options.fixedGutter) {\n                if (view[i2].gutter) {\n                  view[i2].gutter.style.left = left;\n                }\n                if (view[i2].gutterBackground) {\n                  view[i2].gutterBackground.style.left = left;\n                }\n              }\n              var align = view[i2].alignable;\n              if (align) {\n                for (var j2 = 0; j2 < align.length; j2++) {\n                  align[j2].style.left = left;\n                }\n              }\n            }\n          }\n          if (cm.options.fixedGutter) {\n            display.gutters.style.left = comp + gutterW + "px";\n          }\n        }\n        function maybeUpdateLineNumberWidth(cm) {\n          if (!cm.options.lineNumbers) {\n            return false;\n          }\n          var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;\n          if (last.length != display.lineNumChars) {\n            var test2 = display.measure.appendChild(elt(\n              "div",\n              [elt("div", last)],\n              "CodeMirror-linenumber CodeMirror-gutter-elt"\n            ));\n            var innerW = test2.firstChild.offsetWidth, padding = test2.offsetWidth - innerW;\n            display.lineGutter.style.width = "";\n            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n            display.lineNumWidth = display.lineNumInnerWidth + padding;\n            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n            display.lineGutter.style.width = display.lineNumWidth + "px";\n            updateGutterSpace(cm.display);\n            return true;\n          }\n          return false;\n        }\n        function getGutters(gutters, lineNumbers) {\n          var result = [], sawLineNumbers = false;\n          for (var i2 = 0; i2 < gutters.length; i2++) {\n            var name = gutters[i2], style = null;\n            if (typeof name != "string") {\n              style = name.style;\n              name = name.className;\n            }\n            if (name == "CodeMirror-linenumbers") {\n              if (!lineNumbers) {\n                continue;\n              } else {\n                sawLineNumbers = true;\n              }\n            }\n            result.push({ className: name, style });\n          }\n          if (lineNumbers && !sawLineNumbers) {\n            result.push({ className: "CodeMirror-linenumbers", style: null });\n          }\n          return result;\n        }\n        function renderGutters(display) {\n          var gutters = display.gutters, specs = display.gutterSpecs;\n          removeChildren(gutters);\n          display.lineGutter = null;\n          for (var i2 = 0; i2 < specs.length; ++i2) {\n            var ref = specs[i2];\n            var className = ref.className;\n            var style = ref.style;\n            var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));\n            if (style) {\n              gElt.style.cssText = style;\n            }\n            if (className == "CodeMirror-linenumbers") {\n              display.lineGutter = gElt;\n              gElt.style.width = (display.lineNumWidth || 1) + "px";\n            }\n          }\n          gutters.style.display = specs.length ? "" : "none";\n          updateGutterSpace(display);\n        }\n        function updateGutters(cm) {\n          renderGutters(cm.display);\n          regChange(cm);\n          alignHorizontally(cm);\n        }\n        function Display(place, doc2, input, options2) {\n          var d = this;\n          this.input = input;\n          d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\n          d.scrollbarFiller.setAttribute("cm-not-content", "true");\n          d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\n          d.gutterFiller.setAttribute("cm-not-content", "true");\n          d.lineDiv = eltP("div", null, "CodeMirror-code");\n          d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\n          d.cursorDiv = elt("div", null, "CodeMirror-cursors");\n          d.measure = elt("div", null, "CodeMirror-measure");\n          d.lineMeasure = elt("div", null, "CodeMirror-measure");\n          d.lineSpace = eltP(\n            "div",\n            [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n            null,\n            "position: relative; outline: none"\n          );\n          var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");\n          d.mover = elt("div", [lines], null, "position: relative");\n          d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\n          d.sizerWidth = null;\n          d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");\n          d.gutters = elt("div", null, "CodeMirror-gutters");\n          d.lineGutter = null;\n          d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\n          d.scroller.setAttribute("tabIndex", "-1");\n          d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\n          if (chrome && chrome_version >= 105) {\n            d.wrapper.style.clipPath = "inset(0px)";\n          }\n          d.wrapper.setAttribute("translate", "no");\n          if (ie && ie_version < 8) {\n            d.gutters.style.zIndex = -1;\n            d.scroller.style.paddingRight = 0;\n          }\n          if (!webkit && !(gecko && mobile)) {\n            d.scroller.draggable = true;\n          }\n          if (place) {\n            if (place.appendChild) {\n              place.appendChild(d.wrapper);\n            } else {\n              place(d.wrapper);\n            }\n          }\n          d.viewFrom = d.viewTo = doc2.first;\n          d.reportedViewFrom = d.reportedViewTo = doc2.first;\n          d.view = [];\n          d.renderedView = null;\n          d.externalMeasured = null;\n          d.viewOffset = 0;\n          d.lastWrapHeight = d.lastWrapWidth = 0;\n          d.updateLineNumbers = null;\n          d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n          d.scrollbarsClipped = false;\n          d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n          d.alignWidgets = false;\n          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n          d.maxLine = null;\n          d.maxLineLength = 0;\n          d.maxLineChanged = false;\n          d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n          d.shift = false;\n          d.selForContextMenu = null;\n          d.activeTouch = null;\n          d.gutterSpecs = getGutters(options2.gutters, options2.lineNumbers);\n          renderGutters(d);\n          input.init(d);\n        }\n        var wheelSamples = 0, wheelPixelsPerUnit = null;\n        if (ie) {\n          wheelPixelsPerUnit = -0.53;\n        } else if (gecko) {\n          wheelPixelsPerUnit = 15;\n        } else if (chrome) {\n          wheelPixelsPerUnit = -0.7;\n        } else if (safari) {\n          wheelPixelsPerUnit = -1 / 3;\n        }\n        function wheelEventDelta(e) {\n          var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n          if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n            dx = e.detail;\n          }\n          if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n            dy = e.detail;\n          } else if (dy == null) {\n            dy = e.wheelDelta;\n          }\n          return { x: dx, y: dy };\n        }\n        function wheelEventPixels(e) {\n          var delta = wheelEventDelta(e);\n          delta.x *= wheelPixelsPerUnit;\n          delta.y *= wheelPixelsPerUnit;\n          return delta;\n        }\n        function onScrollWheel(cm, e) {\n          if (chrome && chrome_version == 102) {\n            if (cm.display.chromeScrollHack == null) {\n              cm.display.sizer.style.pointerEvents = "none";\n            } else {\n              clearTimeout(cm.display.chromeScrollHack);\n            }\n            cm.display.chromeScrollHack = setTimeout(function() {\n              cm.display.chromeScrollHack = null;\n              cm.display.sizer.style.pointerEvents = "";\n            }, 100);\n          }\n          var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n          var pixelsPerUnit = wheelPixelsPerUnit;\n          if (e.deltaMode === 0) {\n            dx = e.deltaX;\n            dy = e.deltaY;\n            pixelsPerUnit = 1;\n          }\n          var display = cm.display, scroll = display.scroller;\n          var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n          var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n          if (!(dx && canScrollX || dy && canScrollY)) {\n            return;\n          }\n          if (dy && mac && webkit) {\n            outer:\n              for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n                for (var i2 = 0; i2 < view.length; i2++) {\n                  if (view[i2].node == cur) {\n                    cm.display.currentWheelTarget = cur;\n                    break outer;\n                  }\n                }\n              }\n          }\n          if (dx && !gecko && !presto && pixelsPerUnit != null) {\n            if (dy && canScrollY) {\n              updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));\n            }\n            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));\n            if (!dy || dy && canScrollY) {\n              e_preventDefault(e);\n            }\n            display.wheelStartX = null;\n            return;\n          }\n          if (dy && pixelsPerUnit != null) {\n            var pixels = dy * pixelsPerUnit;\n            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n            if (pixels < 0) {\n              top = Math.max(0, top + pixels - 50);\n            } else {\n              bot = Math.min(cm.doc.height, bot + pixels + 50);\n            }\n            updateDisplaySimple(cm, { top, bottom: bot });\n          }\n          if (wheelSamples < 20 && e.deltaMode !== 0) {\n            if (display.wheelStartX == null) {\n              display.wheelStartX = scroll.scrollLeft;\n              display.wheelStartY = scroll.scrollTop;\n              display.wheelDX = dx;\n              display.wheelDY = dy;\n              setTimeout(function() {\n                if (display.wheelStartX == null) {\n                  return;\n                }\n                var movedX = scroll.scrollLeft - display.wheelStartX;\n                var movedY = scroll.scrollTop - display.wheelStartY;\n                var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n                display.wheelStartX = display.wheelStartY = null;\n                if (!sample) {\n                  return;\n                }\n                wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n                ++wheelSamples;\n              }, 200);\n            } else {\n              display.wheelDX += dx;\n              display.wheelDY += dy;\n            }\n          }\n        }\n        var Selection = function(ranges, primIndex) {\n          this.ranges = ranges;\n          this.primIndex = primIndex;\n        };\n        Selection.prototype.primary = function() {\n          return this.ranges[this.primIndex];\n        };\n        Selection.prototype.equals = function(other) {\n          if (other == this) {\n            return true;\n          }\n          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n            return false;\n          }\n          for (var i2 = 0; i2 < this.ranges.length; i2++) {\n            var here = this.ranges[i2], there = other.ranges[i2];\n            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        Selection.prototype.deepCopy = function() {\n          var out = [];\n          for (var i2 = 0; i2 < this.ranges.length; i2++) {\n            out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));\n          }\n          return new Selection(out, this.primIndex);\n        };\n        Selection.prototype.somethingSelected = function() {\n          for (var i2 = 0; i2 < this.ranges.length; i2++) {\n            if (!this.ranges[i2].empty()) {\n              return true;\n            }\n          }\n          return false;\n        };\n        Selection.prototype.contains = function(pos, end) {\n          if (!end) {\n            end = pos;\n          }\n          for (var i2 = 0; i2 < this.ranges.length; i2++) {\n            var range2 = this.ranges[i2];\n            if (cmp2(end, range2.from()) >= 0 && cmp2(pos, range2.to()) <= 0) {\n              return i2;\n            }\n          }\n          return -1;\n        };\n        var Range = function(anchor, head) {\n          this.anchor = anchor;\n          this.head = head;\n        };\n        Range.prototype.from = function() {\n          return minPos(this.anchor, this.head);\n        };\n        Range.prototype.to = function() {\n          return maxPos(this.anchor, this.head);\n        };\n        Range.prototype.empty = function() {\n          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n        };\n        function normalizeSelection(cm, ranges, primIndex) {\n          var mayTouch = cm && cm.options.selectionsMayTouch;\n          var prim = ranges[primIndex];\n          ranges.sort(function(a, b2) {\n            return cmp2(a.from(), b2.from());\n          });\n          primIndex = indexOf2(ranges, prim);\n          for (var i2 = 1; i2 < ranges.length; i2++) {\n            var cur = ranges[i2], prev = ranges[i2 - 1];\n            var diff = cmp2(prev.to(), cur.from());\n            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n              var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n              var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n              if (i2 <= primIndex) {\n                --primIndex;\n              }\n              ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));\n            }\n          }\n          return new Selection(ranges, primIndex);\n        }\n        function simpleSelection(anchor, head) {\n          return new Selection([new Range(anchor, head || anchor)], 0);\n        }\n        function changeEnd(change) {\n          if (!change.text) {\n            return change.to;\n          }\n          return Pos(\n            change.from.line + change.text.length - 1,\n            lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0)\n          );\n        }\n        function adjustForChange(pos, change) {\n          if (cmp2(pos, change.from) < 0) {\n            return pos;\n          }\n          if (cmp2(pos, change.to) <= 0) {\n            return changeEnd(change);\n          }\n          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n          if (pos.line == change.to.line) {\n            ch += changeEnd(change).ch - change.to.ch;\n          }\n          return Pos(line, ch);\n        }\n        function computeSelAfterChange(doc2, change) {\n          var out = [];\n          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {\n            var range2 = doc2.sel.ranges[i2];\n            out.push(new Range(\n              adjustForChange(range2.anchor, change),\n              adjustForChange(range2.head, change)\n            ));\n          }\n          return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);\n        }\n        function offsetPos(pos, old, nw) {\n          if (pos.line == old.line) {\n            return Pos(nw.line, pos.ch - old.ch + nw.ch);\n          } else {\n            return Pos(nw.line + (pos.line - old.line), pos.ch);\n          }\n        }\n        function computeReplacedSel(doc2, changes, hint) {\n          var out = [];\n          var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;\n          for (var i2 = 0; i2 < changes.length; i2++) {\n            var change = changes[i2];\n            var from = offsetPos(change.from, oldPrev, newPrev);\n            var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n            oldPrev = change.to;\n            newPrev = to;\n            if (hint == "around") {\n              var range2 = doc2.sel.ranges[i2], inv = cmp2(range2.head, range2.anchor) < 0;\n              out[i2] = new Range(inv ? to : from, inv ? from : to);\n            } else {\n              out[i2] = new Range(from, from);\n            }\n          }\n          return new Selection(out, doc2.sel.primIndex);\n        }\n        function loadMode(cm) {\n          cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n          resetModeState(cm);\n        }\n        function resetModeState(cm) {\n          cm.doc.iter(function(line) {\n            if (line.stateAfter) {\n              line.stateAfter = null;\n            }\n            if (line.styles) {\n              line.styles = null;\n            }\n          });\n          cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n          startWorker(cm, 100);\n          cm.state.modeGen++;\n          if (cm.curOp) {\n            regChange(cm);\n          }\n        }\n        function isWholeLineUpdate(doc2, change) {\n          return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);\n        }\n        function updateDoc(doc2, change, markedSpans, estimateHeight2) {\n          function spansFor(n) {\n            return markedSpans ? markedSpans[n] : null;\n          }\n          function update(line, text2, spans) {\n            updateLine(line, text2, spans, estimateHeight2);\n            signalLater(line, "change", line, change);\n          }\n          function linesFor(start, end) {\n            var result = [];\n            for (var i2 = start; i2 < end; ++i2) {\n              result.push(new Line(text[i2], spansFor(i2), estimateHeight2));\n            }\n            return result;\n          }\n          var from = change.from, to = change.to, text = change.text;\n          var firstLine = getLine(doc2, from.line), lastLine = getLine(doc2, to.line);\n          var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n          if (change.full) {\n            doc2.insert(0, linesFor(0, text.length));\n            doc2.remove(text.length, doc2.size - text.length);\n          } else if (isWholeLineUpdate(doc2, change)) {\n            var added = linesFor(0, text.length - 1);\n            update(lastLine, lastLine.text, lastSpans);\n            if (nlines) {\n              doc2.remove(from.line, nlines);\n            }\n            if (added.length) {\n              doc2.insert(from.line, added);\n            }\n          } else if (firstLine == lastLine) {\n            if (text.length == 1) {\n              update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n            } else {\n              var added$1 = linesFor(1, text.length - 1);\n              added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));\n              update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n              doc2.insert(from.line + 1, added$1);\n            }\n          } else if (text.length == 1) {\n            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n            doc2.remove(from.line + 1, nlines);\n          } else {\n            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n            var added$2 = linesFor(1, text.length - 1);\n            if (nlines > 1) {\n              doc2.remove(from.line + 1, nlines - 1);\n            }\n            doc2.insert(from.line + 1, added$2);\n          }\n          signalLater(doc2, "change", doc2, change);\n        }\n        function linkedDocs(doc2, f, sharedHistOnly) {\n          function propagate(doc3, skip, sharedHist) {\n            if (doc3.linked) {\n              for (var i2 = 0; i2 < doc3.linked.length; ++i2) {\n                var rel = doc3.linked[i2];\n                if (rel.doc == skip) {\n                  continue;\n                }\n                var shared = sharedHist && rel.sharedHist;\n                if (sharedHistOnly && !shared) {\n                  continue;\n                }\n                f(rel.doc, shared);\n                propagate(rel.doc, doc3, shared);\n              }\n            }\n          }\n          propagate(doc2, null, true);\n        }\n        function attachDoc(cm, doc2) {\n          if (doc2.cm) {\n            throw new Error("This document is already in use.");\n          }\n          cm.doc = doc2;\n          doc2.cm = cm;\n          estimateLineHeights(cm);\n          loadMode(cm);\n          setDirectionClass(cm);\n          cm.options.direction = doc2.direction;\n          if (!cm.options.lineWrapping) {\n            findMaxLine(cm);\n          }\n          cm.options.mode = doc2.modeOption;\n          regChange(cm);\n        }\n        function setDirectionClass(cm) {\n          (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");\n        }\n        function directionChanged(cm) {\n          runInOp(cm, function() {\n            setDirectionClass(cm);\n            regChange(cm);\n          });\n        }\n        function History(prev) {\n          this.done = [];\n          this.undone = [];\n          this.undoDepth = prev ? prev.undoDepth : Infinity;\n          this.lastModTime = this.lastSelTime = 0;\n          this.lastOp = this.lastSelOp = null;\n          this.lastOrigin = this.lastSelOrigin = null;\n          this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n        }\n        function historyChangeFromChange(doc2, change) {\n          var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };\n          attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);\n          linkedDocs(doc2, function(doc3) {\n            return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);\n          }, true);\n          return histChange;\n        }\n        function clearSelectionEvents(array) {\n          while (array.length) {\n            var last = lst(array);\n            if (last.ranges) {\n              array.pop();\n            } else {\n              break;\n            }\n          }\n        }\n        function lastChangeEvent(hist, force) {\n          if (force) {\n            clearSelectionEvents(hist.done);\n            return lst(hist.done);\n          } else if (hist.done.length && !lst(hist.done).ranges) {\n            return lst(hist.done);\n          } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n            hist.done.pop();\n            return lst(hist.done);\n          }\n        }\n        function addChangeToHistory(doc2, change, selAfter, opId) {\n          var hist = doc2.history;\n          hist.undone.length = 0;\n          var time = +/* @__PURE__ */ new Date(), cur;\n          var last;\n          if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n            last = lst(cur.changes);\n            if (cmp2(change.from, change.to) == 0 && cmp2(change.from, last.to) == 0) {\n              last.to = changeEnd(change);\n            } else {\n              cur.changes.push(historyChangeFromChange(doc2, change));\n            }\n          } else {\n            var before = lst(hist.done);\n            if (!before || !before.ranges) {\n              pushSelectionToHistory(doc2.sel, hist.done);\n            }\n            cur = {\n              changes: [historyChangeFromChange(doc2, change)],\n              generation: hist.generation\n            };\n            hist.done.push(cur);\n            while (hist.done.length > hist.undoDepth) {\n              hist.done.shift();\n              if (!hist.done[0].ranges) {\n                hist.done.shift();\n              }\n            }\n          }\n          hist.done.push(selAfter);\n          hist.generation = ++hist.maxGeneration;\n          hist.lastModTime = hist.lastSelTime = time;\n          hist.lastOp = hist.lastSelOp = opId;\n          hist.lastOrigin = hist.lastSelOrigin = change.origin;\n          if (!last) {\n            signal(doc2, "historyAdded");\n          }\n        }\n        function selectionEventCanBeMerged(doc2, origin, prev, sel) {\n          var ch = origin.charAt(0);\n          return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && /* @__PURE__ */ new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);\n        }\n        function addSelectionToHistory(doc2, sel, opId, options2) {\n          var hist = doc2.history, origin = options2 && options2.origin;\n          if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {\n            hist.done[hist.done.length - 1] = sel;\n          } else {\n            pushSelectionToHistory(sel, hist.done);\n          }\n          hist.lastSelTime = +/* @__PURE__ */ new Date();\n          hist.lastSelOrigin = origin;\n          hist.lastSelOp = opId;\n          if (options2 && options2.clearRedo !== false) {\n            clearSelectionEvents(hist.undone);\n          }\n        }\n        function pushSelectionToHistory(sel, dest) {\n          var top = lst(dest);\n          if (!(top && top.ranges && top.equals(sel))) {\n            dest.push(sel);\n          }\n        }\n        function attachLocalSpans(doc2, change, from, to) {\n          var existing = change["spans_" + doc2.id], n = 0;\n          doc2.iter(Math.max(doc2.first, from), Math.min(doc2.first + doc2.size, to), function(line) {\n            if (line.markedSpans) {\n              (existing || (existing = change["spans_" + doc2.id] = {}))[n] = line.markedSpans;\n            }\n            ++n;\n          });\n        }\n        function removeClearedSpans(spans) {\n          if (!spans) {\n            return null;\n          }\n          var out;\n          for (var i2 = 0; i2 < spans.length; ++i2) {\n            if (spans[i2].marker.explicitlyCleared) {\n              if (!out) {\n                out = spans.slice(0, i2);\n              }\n            } else if (out) {\n              out.push(spans[i2]);\n            }\n          }\n          return !out ? spans : out.length ? out : null;\n        }\n        function getOldSpans(doc2, change) {\n          var found = change["spans_" + doc2.id];\n          if (!found) {\n            return null;\n          }\n          var nw = [];\n          for (var i2 = 0; i2 < change.text.length; ++i2) {\n            nw.push(removeClearedSpans(found[i2]));\n          }\n          return nw;\n        }\n        function mergeOldSpans(doc2, change) {\n          var old = getOldSpans(doc2, change);\n          var stretched = stretchSpansOverChange(doc2, change);\n          if (!old) {\n            return stretched;\n          }\n          if (!stretched) {\n            return old;\n          }\n          for (var i2 = 0; i2 < old.length; ++i2) {\n            var oldCur = old[i2], stretchCur = stretched[i2];\n            if (oldCur && stretchCur) {\n              spans:\n                for (var j2 = 0; j2 < stretchCur.length; ++j2) {\n                  var span = stretchCur[j2];\n                  for (var k2 = 0; k2 < oldCur.length; ++k2) {\n                    if (oldCur[k2].marker == span.marker) {\n                      continue spans;\n                    }\n                  }\n                  oldCur.push(span);\n                }\n            } else if (stretchCur) {\n              old[i2] = stretchCur;\n            }\n          }\n          return old;\n        }\n        function copyHistoryArray(events, newGroup, instantiateSel) {\n          var copy = [];\n          for (var i2 = 0; i2 < events.length; ++i2) {\n            var event = events[i2];\n            if (event.ranges) {\n              copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n              continue;\n            }\n            var changes = event.changes, newChanges = [];\n            copy.push({ changes: newChanges });\n            for (var j2 = 0; j2 < changes.length; ++j2) {\n              var change = changes[j2], m2 = void 0;\n              newChanges.push({ from: change.from, to: change.to, text: change.text });\n              if (newGroup) {\n                for (var prop2 in change) {\n                  if (m2 = prop2.match(/^spans_(\\d+)$/)) {\n                    if (indexOf2(newGroup, Number(m2[1])) > -1) {\n                      lst(newChanges)[prop2] = change[prop2];\n                      delete change[prop2];\n                    }\n                  }\n                }\n              }\n            }\n          }\n          return copy;\n        }\n        function extendRange(range2, head, other, extend) {\n          if (extend) {\n            var anchor = range2.anchor;\n            if (other) {\n              var posBefore = cmp2(head, anchor) < 0;\n              if (posBefore != cmp2(other, anchor) < 0) {\n                anchor = head;\n                head = other;\n              } else if (posBefore != cmp2(head, other) < 0) {\n                head = other;\n              }\n            }\n            return new Range(anchor, head);\n          } else {\n            return new Range(other || head, head);\n          }\n        }\n        function extendSelection(doc2, head, other, options2, extend) {\n          if (extend == null) {\n            extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);\n          }\n          setSelection(doc2, new Selection([extendRange(doc2.sel.primary(), head, other, extend)], 0), options2);\n        }\n        function extendSelections(doc2, heads, options2) {\n          var out = [];\n          var extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);\n          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {\n            out[i2] = extendRange(doc2.sel.ranges[i2], heads[i2], null, extend);\n          }\n          var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);\n          setSelection(doc2, newSel, options2);\n        }\n        function replaceOneSelection(doc2, i2, range2, options2) {\n          var ranges = doc2.sel.ranges.slice(0);\n          ranges[i2] = range2;\n          setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options2);\n        }\n        function setSimpleSelection(doc2, anchor, head, options2) {\n          setSelection(doc2, simpleSelection(anchor, head), options2);\n        }\n        function filterSelectionChange(doc2, sel, options2) {\n          var obj = {\n            ranges: sel.ranges,\n            update: function(ranges) {\n              this.ranges = [];\n              for (var i2 = 0; i2 < ranges.length; i2++) {\n                this.ranges[i2] = new Range(\n                  clipPos(doc2, ranges[i2].anchor),\n                  clipPos(doc2, ranges[i2].head)\n                );\n              }\n            },\n            origin: options2 && options2.origin\n          };\n          signal(doc2, "beforeSelectionChange", doc2, obj);\n          if (doc2.cm) {\n            signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);\n          }\n          if (obj.ranges != sel.ranges) {\n            return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);\n          } else {\n            return sel;\n          }\n        }\n        function setSelectionReplaceHistory(doc2, sel, options2) {\n          var done = doc2.history.done, last = lst(done);\n          if (last && last.ranges) {\n            done[done.length - 1] = sel;\n            setSelectionNoUndo(doc2, sel, options2);\n          } else {\n            setSelection(doc2, sel, options2);\n          }\n        }\n        function setSelection(doc2, sel, options2) {\n          setSelectionNoUndo(doc2, sel, options2);\n          addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options2);\n        }\n        function setSelectionNoUndo(doc2, sel, options2) {\n          if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {\n            sel = filterSelectionChange(doc2, sel, options2);\n          }\n          var bias = options2 && options2.bias || (cmp2(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);\n          setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));\n          if (!(options2 && options2.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {\n            ensureCursorVisible(doc2.cm);\n          }\n        }\n        function setSelectionInner(doc2, sel) {\n          if (sel.equals(doc2.sel)) {\n            return;\n          }\n          doc2.sel = sel;\n          if (doc2.cm) {\n            doc2.cm.curOp.updateInput = 1;\n            doc2.cm.curOp.selectionChanged = true;\n            signalCursorActivity(doc2.cm);\n          }\n          signalLater(doc2, "cursorActivity", doc2);\n        }\n        function reCheckSelection(doc2) {\n          setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));\n        }\n        function skipAtomicInSelection(doc2, sel, bias, mayClear) {\n          var out;\n          for (var i2 = 0; i2 < sel.ranges.length; i2++) {\n            var range2 = sel.ranges[i2];\n            var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i2];\n            var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);\n            var newHead = range2.head == range2.anchor ? newAnchor : skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);\n            if (out || newAnchor != range2.anchor || newHead != range2.head) {\n              if (!out) {\n                out = sel.ranges.slice(0, i2);\n              }\n              out[i2] = new Range(newAnchor, newHead);\n            }\n          }\n          return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;\n        }\n        function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {\n          var line = getLine(doc2, pos.line);\n          if (line.markedSpans) {\n            for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {\n              var sp = line.markedSpans[i2], m2 = sp.marker;\n              var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;\n              var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;\n              if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n                if (mayClear) {\n                  signal(m2, "beforeCursorEnter");\n                  if (m2.explicitlyCleared) {\n                    if (!line.markedSpans) {\n                      break;\n                    } else {\n                      --i2;\n                      continue;\n                    }\n                  }\n                }\n                if (!m2.atomic) {\n                  continue;\n                }\n                if (oldPos) {\n                  var near = m2.find(dir < 0 ? 1 : -1), diff = void 0;\n                  if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n                    near = movePos(doc2, near, -dir, near && near.line == pos.line ? line : null);\n                  }\n                  if (near && near.line == pos.line && (diff = cmp2(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {\n                    return skipAtomicInner(doc2, near, pos, dir, mayClear);\n                  }\n                }\n                var far = m2.find(dir < 0 ? -1 : 1);\n                if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n                  far = movePos(doc2, far, dir, far.line == pos.line ? line : null);\n                }\n                return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;\n              }\n            }\n          }\n          return pos;\n        }\n        function skipAtomic(doc2, pos, oldPos, bias, mayClear) {\n          var dir = bias || 1;\n          var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);\n          if (!found) {\n            doc2.cantEdit = true;\n            return Pos(doc2.first, 0);\n          }\n          return found;\n        }\n        function movePos(doc2, pos, dir, line) {\n          if (dir < 0 && pos.ch == 0) {\n            if (pos.line > doc2.first) {\n              return clipPos(doc2, Pos(pos.line - 1));\n            } else {\n              return null;\n            }\n          } else if (dir > 0 && pos.ch == (line || getLine(doc2, pos.line)).text.length) {\n            if (pos.line < doc2.first + doc2.size - 1) {\n              return Pos(pos.line + 1, 0);\n            } else {\n              return null;\n            }\n          } else {\n            return new Pos(pos.line, pos.ch + dir);\n          }\n        }\n        function selectAll(cm) {\n          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n        }\n        function filterChange(doc2, change, update) {\n          var obj = {\n            canceled: false,\n            from: change.from,\n            to: change.to,\n            text: change.text,\n            origin: change.origin,\n            cancel: function() {\n              return obj.canceled = true;\n            }\n          };\n          if (update) {\n            obj.update = function(from, to, text, origin) {\n              if (from) {\n                obj.from = clipPos(doc2, from);\n              }\n              if (to) {\n                obj.to = clipPos(doc2, to);\n              }\n              if (text) {\n                obj.text = text;\n              }\n              if (origin !== void 0) {\n                obj.origin = origin;\n              }\n            };\n          }\n          signal(doc2, "beforeChange", doc2, obj);\n          if (doc2.cm) {\n            signal(doc2.cm, "beforeChange", doc2.cm, obj);\n          }\n          if (obj.canceled) {\n            if (doc2.cm) {\n              doc2.cm.curOp.updateInput = 2;\n            }\n            return null;\n          }\n          return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };\n        }\n        function makeChange(doc2, change, ignoreReadOnly) {\n          if (doc2.cm) {\n            if (!doc2.cm.curOp) {\n              return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);\n            }\n            if (doc2.cm.state.suppressEdits) {\n              return;\n            }\n          }\n          if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {\n            change = filterChange(doc2, change, true);\n            if (!change) {\n              return;\n            }\n          }\n          var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);\n          if (split) {\n            for (var i2 = split.length - 1; i2 >= 0; --i2) {\n              makeChangeInner(doc2, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });\n            }\n          } else {\n            makeChangeInner(doc2, change);\n          }\n        }\n        function makeChangeInner(doc2, change) {\n          if (change.text.length == 1 && change.text[0] == "" && cmp2(change.from, change.to) == 0) {\n            return;\n          }\n          var selAfter = computeSelAfterChange(doc2, change);\n          addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);\n          makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));\n          var rebased = [];\n          linkedDocs(doc2, function(doc3, sharedHist) {\n            if (!sharedHist && indexOf2(rebased, doc3.history) == -1) {\n              rebaseHist(doc3.history, change);\n              rebased.push(doc3.history);\n            }\n            makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));\n          });\n        }\n        function makeChangeFromHistory(doc2, type, allowSelectionOnly) {\n          var suppress = doc2.cm && doc2.cm.state.suppressEdits;\n          if (suppress && !allowSelectionOnly) {\n            return;\n          }\n          var hist = doc2.history, event, selAfter = doc2.sel;\n          var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;\n          var i2 = 0;\n          for (; i2 < source.length; i2++) {\n            event = source[i2];\n            if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {\n              break;\n            }\n          }\n          if (i2 == source.length) {\n            return;\n          }\n          hist.lastOrigin = hist.lastSelOrigin = null;\n          for (; ; ) {\n            event = source.pop();\n            if (event.ranges) {\n              pushSelectionToHistory(event, dest);\n              if (allowSelectionOnly && !event.equals(doc2.sel)) {\n                setSelection(doc2, event, { clearRedo: false });\n                return;\n              }\n              selAfter = event;\n            } else if (suppress) {\n              source.push(event);\n              return;\n            } else {\n              break;\n            }\n          }\n          var antiChanges = [];\n          pushSelectionToHistory(selAfter, dest);\n          dest.push({ changes: antiChanges, generation: hist.generation });\n          hist.generation = event.generation || ++hist.maxGeneration;\n          var filter2 = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");\n          var loop = function(i3) {\n            var change = event.changes[i3];\n            change.origin = type;\n            if (filter2 && !filterChange(doc2, change, false)) {\n              source.length = 0;\n              return {};\n            }\n            antiChanges.push(historyChangeFromChange(doc2, change));\n            var after = i3 ? computeSelAfterChange(doc2, change) : lst(source);\n            makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));\n            if (!i3 && doc2.cm) {\n              doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });\n            }\n            var rebased = [];\n            linkedDocs(doc2, function(doc3, sharedHist) {\n              if (!sharedHist && indexOf2(rebased, doc3.history) == -1) {\n                rebaseHist(doc3.history, change);\n                rebased.push(doc3.history);\n              }\n              makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));\n            });\n          };\n          for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {\n            var returned = loop(i$12);\n            if (returned)\n              return returned.v;\n          }\n        }\n        function shiftDoc(doc2, distance) {\n          if (distance == 0) {\n            return;\n          }\n          doc2.first += distance;\n          doc2.sel = new Selection(map2(doc2.sel.ranges, function(range2) {\n            return new Range(\n              Pos(range2.anchor.line + distance, range2.anchor.ch),\n              Pos(range2.head.line + distance, range2.head.ch)\n            );\n          }), doc2.sel.primIndex);\n          if (doc2.cm) {\n            regChange(doc2.cm, doc2.first, doc2.first - distance, distance);\n            for (var d = doc2.cm.display, l = d.viewFrom; l < d.viewTo; l++) {\n              regLineChange(doc2.cm, l, "gutter");\n            }\n          }\n        }\n        function makeChangeSingleDoc(doc2, change, selAfter, spans) {\n          if (doc2.cm && !doc2.cm.curOp) {\n            return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);\n          }\n          if (change.to.line < doc2.first) {\n            shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));\n            return;\n          }\n          if (change.from.line > doc2.lastLine()) {\n            return;\n          }\n          if (change.from.line < doc2.first) {\n            var shift = change.text.length - 1 - (doc2.first - change.from.line);\n            shiftDoc(doc2, shift);\n            change = {\n              from: Pos(doc2.first, 0),\n              to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)],\n              origin: change.origin\n            };\n          }\n          var last = doc2.lastLine();\n          if (change.to.line > last) {\n            change = {\n              from: change.from,\n              to: Pos(last, getLine(doc2, last).text.length),\n              text: [change.text[0]],\n              origin: change.origin\n            };\n          }\n          change.removed = getBetween(doc2, change.from, change.to);\n          if (!selAfter) {\n            selAfter = computeSelAfterChange(doc2, change);\n          }\n          if (doc2.cm) {\n            makeChangeSingleDocInEditor(doc2.cm, change, spans);\n          } else {\n            updateDoc(doc2, change, spans);\n          }\n          setSelectionNoUndo(doc2, selAfter, sel_dontScroll);\n          if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {\n            doc2.cantEdit = false;\n          }\n        }\n        function makeChangeSingleDocInEditor(cm, change, spans) {\n          var doc2 = cm.doc, display = cm.display, from = change.from, to = change.to;\n          var recomputeMaxLength = false, checkWidthStart = from.line;\n          if (!cm.options.lineWrapping) {\n            checkWidthStart = lineNo(visualLine(getLine(doc2, from.line)));\n            doc2.iter(checkWidthStart, to.line + 1, function(line) {\n              if (line == display.maxLine) {\n                recomputeMaxLength = true;\n                return true;\n              }\n            });\n          }\n          if (doc2.sel.contains(change.from, change.to) > -1) {\n            signalCursorActivity(cm);\n          }\n          updateDoc(doc2, change, spans, estimateHeight(cm));\n          if (!cm.options.lineWrapping) {\n            doc2.iter(checkWidthStart, from.line + change.text.length, function(line) {\n              var len = lineLength(line);\n              if (len > display.maxLineLength) {\n                display.maxLine = line;\n                display.maxLineLength = len;\n                display.maxLineChanged = true;\n                recomputeMaxLength = false;\n              }\n            });\n            if (recomputeMaxLength) {\n              cm.curOp.updateMaxLine = true;\n            }\n          }\n          retreatFrontier(doc2, from.line);\n          startWorker(cm, 400);\n          var lendiff = change.text.length - (to.line - from.line) - 1;\n          if (change.full) {\n            regChange(cm);\n          } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n            regLineChange(cm, from.line, "text");\n          } else {\n            regChange(cm, from.line, to.line + 1, lendiff);\n          }\n          var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");\n          if (changeHandler || changesHandler) {\n            var obj = {\n              from,\n              to,\n              text: change.text,\n              removed: change.removed,\n              origin: change.origin\n            };\n            if (changeHandler) {\n              signalLater(cm, "change", cm, obj);\n            }\n            if (changesHandler) {\n              (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n            }\n          }\n          cm.display.selForContextMenu = null;\n        }\n        function replaceRange(doc2, code, from, to, origin) {\n          var assign;\n          if (!to) {\n            to = from;\n          }\n          if (cmp2(to, from) < 0) {\n            assign = [to, from], from = assign[0], to = assign[1];\n          }\n          if (typeof code == "string") {\n            code = doc2.splitLines(code);\n          }\n          makeChange(doc2, { from, to, text: code, origin });\n        }\n        function rebaseHistSelSingle(pos, from, to, diff) {\n          if (to < pos.line) {\n            pos.line += diff;\n          } else if (from < pos.line) {\n            pos.line = from;\n            pos.ch = 0;\n          }\n        }\n        function rebaseHistArray(array, from, to, diff) {\n          for (var i2 = 0; i2 < array.length; ++i2) {\n            var sub2 = array[i2], ok = true;\n            if (sub2.ranges) {\n              if (!sub2.copied) {\n                sub2 = array[i2] = sub2.deepCopy();\n                sub2.copied = true;\n              }\n              for (var j2 = 0; j2 < sub2.ranges.length; j2++) {\n                rebaseHistSelSingle(sub2.ranges[j2].anchor, from, to, diff);\n                rebaseHistSelSingle(sub2.ranges[j2].head, from, to, diff);\n              }\n              continue;\n            }\n            for (var j$1 = 0; j$1 < sub2.changes.length; ++j$1) {\n              var cur = sub2.changes[j$1];\n              if (to < cur.from.line) {\n                cur.from = Pos(cur.from.line + diff, cur.from.ch);\n                cur.to = Pos(cur.to.line + diff, cur.to.ch);\n              } else if (from <= cur.to.line) {\n                ok = false;\n                break;\n              }\n            }\n            if (!ok) {\n              array.splice(0, i2 + 1);\n              i2 = 0;\n            }\n          }\n        }\n        function rebaseHist(hist, change) {\n          var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n          rebaseHistArray(hist.done, from, to, diff);\n          rebaseHistArray(hist.undone, from, to, diff);\n        }\n        function changeLine(doc2, handle, changeType, op) {\n          var no = handle, line = handle;\n          if (typeof handle == "number") {\n            line = getLine(doc2, clipLine(doc2, handle));\n          } else {\n            no = lineNo(handle);\n          }\n          if (no == null) {\n            return null;\n          }\n          if (op(line, no) && doc2.cm) {\n            regLineChange(doc2.cm, no, changeType);\n          }\n          return line;\n        }\n        function LeafChunk(lines) {\n          this.lines = lines;\n          this.parent = null;\n          var height = 0;\n          for (var i2 = 0; i2 < lines.length; ++i2) {\n            lines[i2].parent = this;\n            height += lines[i2].height;\n          }\n          this.height = height;\n        }\n        LeafChunk.prototype = {\n          chunkSize: function() {\n            return this.lines.length;\n          },\n          // Remove the n lines at offset \'at\'.\n          removeInner: function(at2, n) {\n            for (var i2 = at2, e = at2 + n; i2 < e; ++i2) {\n              var line = this.lines[i2];\n              this.height -= line.height;\n              cleanUpLine(line);\n              signalLater(line, "delete");\n            }\n            this.lines.splice(at2, n);\n          },\n          // Helper used to collapse a small branch into a single leaf.\n          collapse: function(lines) {\n            lines.push.apply(lines, this.lines);\n          },\n          // Insert the given array of lines at offset \'at\', count them as\n          // having the given height.\n          insertInner: function(at2, lines, height) {\n            this.height += height;\n            this.lines = this.lines.slice(0, at2).concat(lines).concat(this.lines.slice(at2));\n            for (var i2 = 0; i2 < lines.length; ++i2) {\n              lines[i2].parent = this;\n            }\n          },\n          // Used to iterate over a part of the tree.\n          iterN: function(at2, n, op) {\n            for (var e = at2 + n; at2 < e; ++at2) {\n              if (op(this.lines[at2])) {\n                return true;\n              }\n            }\n          }\n        };\n        function BranchChunk(children) {\n          this.children = children;\n          var size = 0, height = 0;\n          for (var i2 = 0; i2 < children.length; ++i2) {\n            var ch = children[i2];\n            size += ch.chunkSize();\n            height += ch.height;\n            ch.parent = this;\n          }\n          this.size = size;\n          this.height = height;\n          this.parent = null;\n        }\n        BranchChunk.prototype = {\n          chunkSize: function() {\n            return this.size;\n          },\n          removeInner: function(at2, n) {\n            this.size -= n;\n            for (var i2 = 0; i2 < this.children.length; ++i2) {\n              var child = this.children[i2], sz = child.chunkSize();\n              if (at2 < sz) {\n                var rm = Math.min(n, sz - at2), oldHeight = child.height;\n                child.removeInner(at2, rm);\n                this.height -= oldHeight - child.height;\n                if (sz == rm) {\n                  this.children.splice(i2--, 1);\n                  child.parent = null;\n                }\n                if ((n -= rm) == 0) {\n                  break;\n                }\n                at2 = 0;\n              } else {\n                at2 -= sz;\n              }\n            }\n            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n              var lines = [];\n              this.collapse(lines);\n              this.children = [new LeafChunk(lines)];\n              this.children[0].parent = this;\n            }\n          },\n          collapse: function(lines) {\n            for (var i2 = 0; i2 < this.children.length; ++i2) {\n              this.children[i2].collapse(lines);\n            }\n          },\n          insertInner: function(at2, lines, height) {\n            this.size += lines.length;\n            this.height += height;\n            for (var i2 = 0; i2 < this.children.length; ++i2) {\n              var child = this.children[i2], sz = child.chunkSize();\n              if (at2 <= sz) {\n                child.insertInner(at2, lines, height);\n                if (child.lines && child.lines.length > 50) {\n                  var remaining = child.lines.length % 25 + 25;\n                  for (var pos = remaining; pos < child.lines.length; ) {\n                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n                    child.height -= leaf.height;\n                    this.children.splice(++i2, 0, leaf);\n                    leaf.parent = this;\n                  }\n                  child.lines = child.lines.slice(0, remaining);\n                  this.maybeSpill();\n                }\n                break;\n              }\n              at2 -= sz;\n            }\n          },\n          // When a node has grown, check whether it should be split.\n          maybeSpill: function() {\n            if (this.children.length <= 10) {\n              return;\n            }\n            var me = this;\n            do {\n              var spilled = me.children.splice(me.children.length - 5, 5);\n              var sibling = new BranchChunk(spilled);\n              if (!me.parent) {\n                var copy = new BranchChunk(me.children);\n                copy.parent = me;\n                me.children = [copy, sibling];\n                me = copy;\n              } else {\n                me.size -= sibling.size;\n                me.height -= sibling.height;\n                var myIndex = indexOf2(me.parent.children, me);\n                me.parent.children.splice(myIndex + 1, 0, sibling);\n              }\n              sibling.parent = me.parent;\n            } while (me.children.length > 10);\n            me.parent.maybeSpill();\n          },\n          iterN: function(at2, n, op) {\n            for (var i2 = 0; i2 < this.children.length; ++i2) {\n              var child = this.children[i2], sz = child.chunkSize();\n              if (at2 < sz) {\n                var used = Math.min(n, sz - at2);\n                if (child.iterN(at2, used, op)) {\n                  return true;\n                }\n                if ((n -= used) == 0) {\n                  break;\n                }\n                at2 = 0;\n              } else {\n                at2 -= sz;\n              }\n            }\n          }\n        };\n        var LineWidget = function(doc2, node, options2) {\n          if (options2) {\n            for (var opt in options2) {\n              if (options2.hasOwnProperty(opt)) {\n                this[opt] = options2[opt];\n              }\n            }\n          }\n          this.doc = doc2;\n          this.node = node;\n        };\n        LineWidget.prototype.clear = function() {\n          var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n          if (no == null || !ws) {\n            return;\n          }\n          for (var i2 = 0; i2 < ws.length; ++i2) {\n            if (ws[i2] == this) {\n              ws.splice(i2--, 1);\n            }\n          }\n          if (!ws.length) {\n            line.widgets = null;\n          }\n          var height = widgetHeight(this);\n          updateLineHeight(line, Math.max(0, line.height - height));\n          if (cm) {\n            runInOp(cm, function() {\n              adjustScrollWhenAboveVisible(cm, line, -height);\n              regLineChange(cm, no, "widget");\n            });\n            signalLater(cm, "lineWidgetCleared", cm, this, no);\n          }\n        };\n        LineWidget.prototype.changed = function() {\n          var this$1 = this;\n          var oldH = this.height, cm = this.doc.cm, line = this.line;\n          this.height = null;\n          var diff = widgetHeight(this) - oldH;\n          if (!diff) {\n            return;\n          }\n          if (!lineIsHidden(this.doc, line)) {\n            updateLineHeight(line, line.height + diff);\n          }\n          if (cm) {\n            runInOp(cm, function() {\n              cm.curOp.forceUpdate = true;\n              adjustScrollWhenAboveVisible(cm, line, diff);\n              signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));\n            });\n          }\n        };\n        eventMixin(LineWidget);\n        function adjustScrollWhenAboveVisible(cm, line, diff) {\n          if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n            addToScrollTop(cm, diff);\n          }\n        }\n        function addLineWidget(doc2, handle, node, options2) {\n          var widget = new LineWidget(doc2, node, options2);\n          var cm = doc2.cm;\n          if (cm && widget.noHScroll) {\n            cm.display.alignWidgets = true;\n          }\n          changeLine(doc2, handle, "widget", function(line) {\n            var widgets = line.widgets || (line.widgets = []);\n            if (widget.insertAt == null) {\n              widgets.push(widget);\n            } else {\n              widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);\n            }\n            widget.line = line;\n            if (cm && !lineIsHidden(doc2, line)) {\n              var aboveVisible = heightAtLine(line) < doc2.scrollTop;\n              updateLineHeight(line, line.height + widgetHeight(widget));\n              if (aboveVisible) {\n                addToScrollTop(cm, widget.height);\n              }\n              cm.curOp.forceUpdate = true;\n            }\n            return true;\n          });\n          if (cm) {\n            signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));\n          }\n          return widget;\n        }\n        var nextMarkerId = 0;\n        var TextMarker = function(doc2, type) {\n          this.lines = [];\n          this.type = type;\n          this.doc = doc2;\n          this.id = ++nextMarkerId;\n        };\n        TextMarker.prototype.clear = function() {\n          if (this.explicitlyCleared) {\n            return;\n          }\n          var cm = this.doc.cm, withOp = cm && !cm.curOp;\n          if (withOp) {\n            startOperation(cm);\n          }\n          if (hasHandler(this, "clear")) {\n            var found = this.find();\n            if (found) {\n              signalLater(this, "clear", found.from, found.to);\n            }\n          }\n          var min2 = null, max2 = null;\n          for (var i2 = 0; i2 < this.lines.length; ++i2) {\n            var line = this.lines[i2];\n            var span = getMarkedSpanFor(line.markedSpans, this);\n            if (cm && !this.collapsed) {\n              regLineChange(cm, lineNo(line), "text");\n            } else if (cm) {\n              if (span.to != null) {\n                max2 = lineNo(line);\n              }\n              if (span.from != null) {\n                min2 = lineNo(line);\n              }\n            }\n            line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {\n              updateLineHeight(line, textHeight(cm.display));\n            }\n          }\n          if (cm && this.collapsed && !cm.options.lineWrapping) {\n            for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {\n              var visual = visualLine(this.lines[i$12]), len = lineLength(visual);\n              if (len > cm.display.maxLineLength) {\n                cm.display.maxLine = visual;\n                cm.display.maxLineLength = len;\n                cm.display.maxLineChanged = true;\n              }\n            }\n          }\n          if (min2 != null && cm && this.collapsed) {\n            regChange(cm, min2, max2 + 1);\n          }\n          this.lines.length = 0;\n          this.explicitlyCleared = true;\n          if (this.atomic && this.doc.cantEdit) {\n            this.doc.cantEdit = false;\n            if (cm) {\n              reCheckSelection(cm.doc);\n            }\n          }\n          if (cm) {\n            signalLater(cm, "markerCleared", cm, this, min2, max2);\n          }\n          if (withOp) {\n            endOperation(cm);\n          }\n          if (this.parent) {\n            this.parent.clear();\n          }\n        };\n        TextMarker.prototype.find = function(side, lineObj) {\n          if (side == null && this.type == "bookmark") {\n            side = 1;\n          }\n          var from, to;\n          for (var i2 = 0; i2 < this.lines.length; ++i2) {\n            var line = this.lines[i2];\n            var span = getMarkedSpanFor(line.markedSpans, this);\n            if (span.from != null) {\n              from = Pos(lineObj ? line : lineNo(line), span.from);\n              if (side == -1) {\n                return from;\n              }\n            }\n            if (span.to != null) {\n              to = Pos(lineObj ? line : lineNo(line), span.to);\n              if (side == 1) {\n                return to;\n              }\n            }\n          }\n          return from && { from, to };\n        };\n        TextMarker.prototype.changed = function() {\n          var this$1 = this;\n          var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n          if (!pos || !cm) {\n            return;\n          }\n          runInOp(cm, function() {\n            var line = pos.line, lineN = lineNo(pos.line);\n            var view = findViewForLine(cm, lineN);\n            if (view) {\n              clearLineMeasurementCacheFor(view);\n              cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n            }\n            cm.curOp.updateMaxLine = true;\n            if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n              var oldHeight = widget.height;\n              widget.height = null;\n              var dHeight = widgetHeight(widget) - oldHeight;\n              if (dHeight) {\n                updateLineHeight(line, line.height + dHeight);\n              }\n            }\n            signalLater(cm, "markerChanged", cm, this$1);\n          });\n        };\n        TextMarker.prototype.attachLine = function(line) {\n          if (!this.lines.length && this.doc.cm) {\n            var op = this.doc.cm.curOp;\n            if (!op.maybeHiddenMarkers || indexOf2(op.maybeHiddenMarkers, this) == -1) {\n              (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n            }\n          }\n          this.lines.push(line);\n        };\n        TextMarker.prototype.detachLine = function(line) {\n          this.lines.splice(indexOf2(this.lines, line), 1);\n          if (!this.lines.length && this.doc.cm) {\n            var op = this.doc.cm.curOp;\n            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n          }\n        };\n        eventMixin(TextMarker);\n        function markText(doc2, from, to, options2, type) {\n          if (options2 && options2.shared) {\n            return markTextShared(doc2, from, to, options2, type);\n          }\n          if (doc2.cm && !doc2.cm.curOp) {\n            return operation(doc2.cm, markText)(doc2, from, to, options2, type);\n          }\n          var marker = new TextMarker(doc2, type), diff = cmp2(from, to);\n          if (options2) {\n            copyObj(options2, marker, false);\n          }\n          if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {\n            return marker;\n          }\n          if (marker.replacedWith) {\n            marker.collapsed = true;\n            marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");\n            if (!options2.handleMouseEvents) {\n              marker.widgetNode.setAttribute("cm-ignore-events", "true");\n            }\n            if (options2.insertLeft) {\n              marker.widgetNode.insertLeft = true;\n            }\n          }\n          if (marker.collapsed) {\n            if (conflictingCollapsedRange(doc2, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc2, to.line, from, to, marker)) {\n              throw new Error("Inserting collapsed marker partially overlapping an existing one");\n            }\n            seeCollapsedSpans();\n          }\n          if (marker.addToHistory) {\n            addChangeToHistory(doc2, { from, to, origin: "markText" }, doc2.sel, NaN);\n          }\n          var curLine = from.line, cm = doc2.cm, updateMaxLine;\n          doc2.iter(curLine, to.line + 1, function(line) {\n            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n              updateMaxLine = true;\n            }\n            if (marker.collapsed && curLine != from.line) {\n              updateLineHeight(line, 0);\n            }\n            addMarkedSpan(line, new MarkedSpan(\n              marker,\n              curLine == from.line ? from.ch : null,\n              curLine == to.line ? to.ch : null\n            ), doc2.cm && doc2.cm.curOp);\n            ++curLine;\n          });\n          if (marker.collapsed) {\n            doc2.iter(from.line, to.line + 1, function(line) {\n              if (lineIsHidden(doc2, line)) {\n                updateLineHeight(line, 0);\n              }\n            });\n          }\n          if (marker.clearOnEnter) {\n            on(marker, "beforeCursorEnter", function() {\n              return marker.clear();\n            });\n          }\n          if (marker.readOnly) {\n            seeReadOnlySpans();\n            if (doc2.history.done.length || doc2.history.undone.length) {\n              doc2.clearHistory();\n            }\n          }\n          if (marker.collapsed) {\n            marker.id = ++nextMarkerId;\n            marker.atomic = true;\n          }\n          if (cm) {\n            if (updateMaxLine) {\n              cm.curOp.updateMaxLine = true;\n            }\n            if (marker.collapsed) {\n              regChange(cm, from.line, to.line + 1);\n            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {\n              for (var i2 = from.line; i2 <= to.line; i2++) {\n                regLineChange(cm, i2, "text");\n              }\n            }\n            if (marker.atomic) {\n              reCheckSelection(cm.doc);\n            }\n            signalLater(cm, "markerAdded", cm, marker);\n          }\n          return marker;\n        }\n        var SharedTextMarker = function(markers, primary) {\n          this.markers = markers;\n          this.primary = primary;\n          for (var i2 = 0; i2 < markers.length; ++i2) {\n            markers[i2].parent = this;\n          }\n        };\n        SharedTextMarker.prototype.clear = function() {\n          if (this.explicitlyCleared) {\n            return;\n          }\n          this.explicitlyCleared = true;\n          for (var i2 = 0; i2 < this.markers.length; ++i2) {\n            this.markers[i2].clear();\n          }\n          signalLater(this, "clear");\n        };\n        SharedTextMarker.prototype.find = function(side, lineObj) {\n          return this.primary.find(side, lineObj);\n        };\n        eventMixin(SharedTextMarker);\n        function markTextShared(doc2, from, to, options2, type) {\n          options2 = copyObj(options2);\n          options2.shared = false;\n          var markers = [markText(doc2, from, to, options2, type)], primary = markers[0];\n          var widget = options2.widgetNode;\n          linkedDocs(doc2, function(doc3) {\n            if (widget) {\n              options2.widgetNode = widget.cloneNode(true);\n            }\n            markers.push(markText(doc3, clipPos(doc3, from), clipPos(doc3, to), options2, type));\n            for (var i2 = 0; i2 < doc3.linked.length; ++i2) {\n              if (doc3.linked[i2].isParent) {\n                return;\n              }\n            }\n            primary = lst(markers);\n          });\n          return new SharedTextMarker(markers, primary);\n        }\n        function findSharedMarkers(doc2) {\n          return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m2) {\n            return m2.parent;\n          });\n        }\n        function copySharedMarkers(doc2, markers) {\n          for (var i2 = 0; i2 < markers.length; i2++) {\n            var marker = markers[i2], pos = marker.find();\n            var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);\n            if (cmp2(mFrom, mTo)) {\n              var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);\n              marker.markers.push(subMark);\n              subMark.parent = marker;\n            }\n          }\n        }\n        function detachSharedMarkers(markers) {\n          var loop = function(i3) {\n            var marker = markers[i3], linked = [marker.primary.doc];\n            linkedDocs(marker.primary.doc, function(d) {\n              return linked.push(d);\n            });\n            for (var j2 = 0; j2 < marker.markers.length; j2++) {\n              var subMarker = marker.markers[j2];\n              if (indexOf2(linked, subMarker.doc) == -1) {\n                subMarker.parent = null;\n                marker.markers.splice(j2--, 1);\n              }\n            }\n          };\n          for (var i2 = 0; i2 < markers.length; i2++)\n            loop(i2);\n        }\n        var nextDocId = 0;\n        var Doc = function(text, mode, firstLine, lineSep, direction) {\n          if (!(this instanceof Doc)) {\n            return new Doc(text, mode, firstLine, lineSep, direction);\n          }\n          if (firstLine == null) {\n            firstLine = 0;\n          }\n          BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\n          this.first = firstLine;\n          this.scrollTop = this.scrollLeft = 0;\n          this.cantEdit = false;\n          this.cleanGeneration = 1;\n          this.modeFrontier = this.highlightFrontier = firstLine;\n          var start = Pos(firstLine, 0);\n          this.sel = simpleSelection(start);\n          this.history = new History(null);\n          this.id = ++nextDocId;\n          this.modeOption = mode;\n          this.lineSep = lineSep;\n          this.direction = direction == "rtl" ? "rtl" : "ltr";\n          this.extend = false;\n          if (typeof text == "string") {\n            text = this.splitLines(text);\n          }\n          updateDoc(this, { from: start, to: start, text });\n          setSelection(this, simpleSelection(start), sel_dontScroll);\n        };\n        Doc.prototype = createObj(BranchChunk.prototype, {\n          constructor: Doc,\n          // Iterate over the document. Supports two forms -- with only one\n          // argument, it calls that for each line in the document. With\n          // three, it iterates over the range given by the first two (with\n          // the second being non-inclusive).\n          iter: function(from, to, op) {\n            if (op) {\n              this.iterN(from - this.first, to - from, op);\n            } else {\n              this.iterN(this.first, this.first + this.size, from);\n            }\n          },\n          // Non-public interface for adding and removing lines.\n          insert: function(at2, lines) {\n            var height = 0;\n            for (var i2 = 0; i2 < lines.length; ++i2) {\n              height += lines[i2].height;\n            }\n            this.insertInner(at2 - this.first, lines, height);\n          },\n          remove: function(at2, n) {\n            this.removeInner(at2 - this.first, n);\n          },\n          // From here, the methods are part of the public interface. Most\n          // are also available from CodeMirror (editor) instances.\n          getValue: function(lineSep) {\n            var lines = getLines(this, this.first, this.first + this.size);\n            if (lineSep === false) {\n              return lines;\n            }\n            return lines.join(lineSep || this.lineSeparator());\n          },\n          setValue: docMethodOp(function(code) {\n            var top = Pos(this.first, 0), last = this.first + this.size - 1;\n            makeChange(this, {\n              from: top,\n              to: Pos(last, getLine(this, last).text.length),\n              text: this.splitLines(code),\n              origin: "setValue",\n              full: true\n            }, true);\n            if (this.cm) {\n              scrollToCoords(this.cm, 0, 0);\n            }\n            setSelection(this, simpleSelection(top), sel_dontScroll);\n          }),\n          replaceRange: function(code, from, to, origin) {\n            from = clipPos(this, from);\n            to = to ? clipPos(this, to) : from;\n            replaceRange(this, code, from, to, origin);\n          },\n          getRange: function(from, to, lineSep) {\n            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n            if (lineSep === false) {\n              return lines;\n            }\n            if (lineSep === "") {\n              return lines.join("");\n            }\n            return lines.join(lineSep || this.lineSeparator());\n          },\n          getLine: function(line) {\n            var l = this.getLineHandle(line);\n            return l && l.text;\n          },\n          getLineHandle: function(line) {\n            if (isLine(this, line)) {\n              return getLine(this, line);\n            }\n          },\n          getLineNumber: function(line) {\n            return lineNo(line);\n          },\n          getLineHandleVisualStart: function(line) {\n            if (typeof line == "number") {\n              line = getLine(this, line);\n            }\n            return visualLine(line);\n          },\n          lineCount: function() {\n            return this.size;\n          },\n          firstLine: function() {\n            return this.first;\n          },\n          lastLine: function() {\n            return this.first + this.size - 1;\n          },\n          clipPos: function(pos) {\n            return clipPos(this, pos);\n          },\n          getCursor: function(start) {\n            var range2 = this.sel.primary(), pos;\n            if (start == null || start == "head") {\n              pos = range2.head;\n            } else if (start == "anchor") {\n              pos = range2.anchor;\n            } else if (start == "end" || start == "to" || start === false) {\n              pos = range2.to();\n            } else {\n              pos = range2.from();\n            }\n            return pos;\n          },\n          listSelections: function() {\n            return this.sel.ranges;\n          },\n          somethingSelected: function() {\n            return this.sel.somethingSelected();\n          },\n          setCursor: docMethodOp(function(line, ch, options2) {\n            setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options2);\n          }),\n          setSelection: docMethodOp(function(anchor, head, options2) {\n            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options2);\n          }),\n          extendSelection: docMethodOp(function(head, other, options2) {\n            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options2);\n          }),\n          extendSelections: docMethodOp(function(heads, options2) {\n            extendSelections(this, clipPosArray(this, heads), options2);\n          }),\n          extendSelectionsBy: docMethodOp(function(f, options2) {\n            var heads = map2(this.sel.ranges, f);\n            extendSelections(this, clipPosArray(this, heads), options2);\n          }),\n          setSelections: docMethodOp(function(ranges, primary, options2) {\n            if (!ranges.length) {\n              return;\n            }\n            var out = [];\n            for (var i2 = 0; i2 < ranges.length; i2++) {\n              out[i2] = new Range(\n                clipPos(this, ranges[i2].anchor),\n                clipPos(this, ranges[i2].head || ranges[i2].anchor)\n              );\n            }\n            if (primary == null) {\n              primary = Math.min(ranges.length - 1, this.sel.primIndex);\n            }\n            setSelection(this, normalizeSelection(this.cm, out, primary), options2);\n          }),\n          addSelection: docMethodOp(function(anchor, head, options2) {\n            var ranges = this.sel.ranges.slice(0);\n            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options2);\n          }),\n          getSelection: function(lineSep) {\n            var ranges = this.sel.ranges, lines;\n            for (var i2 = 0; i2 < ranges.length; i2++) {\n              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());\n              lines = lines ? lines.concat(sel) : sel;\n            }\n            if (lineSep === false) {\n              return lines;\n            } else {\n              return lines.join(lineSep || this.lineSeparator());\n            }\n          },\n          getSelections: function(lineSep) {\n            var parts = [], ranges = this.sel.ranges;\n            for (var i2 = 0; i2 < ranges.length; i2++) {\n              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());\n              if (lineSep !== false) {\n                sel = sel.join(lineSep || this.lineSeparator());\n              }\n              parts[i2] = sel;\n            }\n            return parts;\n          },\n          replaceSelection: function(code, collapse, origin) {\n            var dup = [];\n            for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {\n              dup[i2] = code;\n            }\n            this.replaceSelections(dup, collapse, origin || "+input");\n          },\n          replaceSelections: docMethodOp(function(code, collapse, origin) {\n            var changes = [], sel = this.sel;\n            for (var i2 = 0; i2 < sel.ranges.length; i2++) {\n              var range2 = sel.ranges[i2];\n              changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };\n            }\n            var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);\n            for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {\n              makeChange(this, changes[i$12]);\n            }\n            if (newSel) {\n              setSelectionReplaceHistory(this, newSel);\n            } else if (this.cm) {\n              ensureCursorVisible(this.cm);\n            }\n          }),\n          undo: docMethodOp(function() {\n            makeChangeFromHistory(this, "undo");\n          }),\n          redo: docMethodOp(function() {\n            makeChangeFromHistory(this, "redo");\n          }),\n          undoSelection: docMethodOp(function() {\n            makeChangeFromHistory(this, "undo", true);\n          }),\n          redoSelection: docMethodOp(function() {\n            makeChangeFromHistory(this, "redo", true);\n          }),\n          setExtending: function(val) {\n            this.extend = val;\n          },\n          getExtending: function() {\n            return this.extend;\n          },\n          historySize: function() {\n            var hist = this.history, done = 0, undone = 0;\n            for (var i2 = 0; i2 < hist.done.length; i2++) {\n              if (!hist.done[i2].ranges) {\n                ++done;\n              }\n            }\n            for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {\n              if (!hist.undone[i$12].ranges) {\n                ++undone;\n              }\n            }\n            return { undo: done, redo: undone };\n          },\n          clearHistory: function() {\n            var this$1 = this;\n            this.history = new History(this.history);\n            linkedDocs(this, function(doc2) {\n              return doc2.history = this$1.history;\n            }, true);\n          },\n          markClean: function() {\n            this.cleanGeneration = this.changeGeneration(true);\n          },\n          changeGeneration: function(forceSplit) {\n            if (forceSplit) {\n              this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n            }\n            return this.history.generation;\n          },\n          isClean: function(gen) {\n            return this.history.generation == (gen || this.cleanGeneration);\n          },\n          getHistory: function() {\n            return {\n              done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)\n            };\n          },\n          setHistory: function(histData) {\n            var hist = this.history = new History(this.history);\n            hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n          },\n          setGutterMarker: docMethodOp(function(line, gutterID, value) {\n            return changeLine(this, line, "gutter", function(line2) {\n              var markers = line2.gutterMarkers || (line2.gutterMarkers = {});\n              markers[gutterID] = value;\n              if (!value && isEmpty(markers)) {\n                line2.gutterMarkers = null;\n              }\n              return true;\n            });\n          }),\n          clearGutter: docMethodOp(function(gutterID) {\n            var this$1 = this;\n            this.iter(function(line) {\n              if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n                changeLine(this$1, line, "gutter", function() {\n                  line.gutterMarkers[gutterID] = null;\n                  if (isEmpty(line.gutterMarkers)) {\n                    line.gutterMarkers = null;\n                  }\n                  return true;\n                });\n              }\n            });\n          }),\n          lineInfo: function(line) {\n            var n;\n            if (typeof line == "number") {\n              if (!isLine(this, line)) {\n                return null;\n              }\n              n = line;\n              line = getLine(this, line);\n              if (!line) {\n                return null;\n              }\n            } else {\n              n = lineNo(line);\n              if (n == null) {\n                return null;\n              }\n            }\n            return {\n              line: n,\n              handle: line,\n              text: line.text,\n              gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass,\n              bgClass: line.bgClass,\n              wrapClass: line.wrapClass,\n              widgets: line.widgets\n            };\n          },\n          addLineClass: docMethodOp(function(handle, where, cls) {\n            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {\n              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";\n              if (!line[prop2]) {\n                line[prop2] = cls;\n              } else if (classTest(cls).test(line[prop2])) {\n                return false;\n              } else {\n                line[prop2] += " " + cls;\n              }\n              return true;\n            });\n          }),\n          removeLineClass: docMethodOp(function(handle, where, cls) {\n            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {\n              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";\n              var cur = line[prop2];\n              if (!cur) {\n                return false;\n              } else if (cls == null) {\n                line[prop2] = null;\n              } else {\n                var found = cur.match(classTest(cls));\n                if (!found) {\n                  return false;\n                }\n                var end = found.index + found[0].length;\n                line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\n              }\n              return true;\n            });\n          }),\n          addLineWidget: docMethodOp(function(handle, node, options2) {\n            return addLineWidget(this, handle, node, options2);\n          }),\n          removeLineWidget: function(widget) {\n            widget.clear();\n          },\n          markText: function(from, to, options2) {\n            return markText(this, clipPos(this, from), clipPos(this, to), options2, options2 && options2.type || "range");\n          },\n          setBookmark: function(pos, options2) {\n            var realOpts = {\n              replacedWith: options2 && (options2.nodeType == null ? options2.widget : options2),\n              insertLeft: options2 && options2.insertLeft,\n              clearWhenEmpty: false,\n              shared: options2 && options2.shared,\n              handleMouseEvents: options2 && options2.handleMouseEvents\n            };\n            pos = clipPos(this, pos);\n            return markText(this, pos, pos, realOpts, "bookmark");\n          },\n          findMarksAt: function(pos) {\n            pos = clipPos(this, pos);\n            var markers = [], spans = getLine(this, pos.line).markedSpans;\n            if (spans) {\n              for (var i2 = 0; i2 < spans.length; ++i2) {\n                var span = spans[i2];\n                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n                  markers.push(span.marker.parent || span.marker);\n                }\n              }\n            }\n            return markers;\n          },\n          findMarks: function(from, to, filter2) {\n            from = clipPos(this, from);\n            to = clipPos(this, to);\n            var found = [], lineNo2 = from.line;\n            this.iter(from.line, to.line + 1, function(line) {\n              var spans = line.markedSpans;\n              if (spans) {\n                for (var i2 = 0; i2 < spans.length; i2++) {\n                  var span = spans[i2];\n                  if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter2 || filter2(span.marker))) {\n                    found.push(span.marker.parent || span.marker);\n                  }\n                }\n              }\n              ++lineNo2;\n            });\n            return found;\n          },\n          getAllMarks: function() {\n            var markers = [];\n            this.iter(function(line) {\n              var sps = line.markedSpans;\n              if (sps) {\n                for (var i2 = 0; i2 < sps.length; ++i2) {\n                  if (sps[i2].from != null) {\n                    markers.push(sps[i2].marker);\n                  }\n                }\n              }\n            });\n            return markers;\n          },\n          posFromIndex: function(off2) {\n            var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;\n            this.iter(function(line) {\n              var sz = line.text.length + sepSize;\n              if (sz > off2) {\n                ch = off2;\n                return true;\n              }\n              off2 -= sz;\n              ++lineNo2;\n            });\n            return clipPos(this, Pos(lineNo2, ch));\n          },\n          indexFromPos: function(coords) {\n            coords = clipPos(this, coords);\n            var index = coords.ch;\n            if (coords.line < this.first || coords.ch < 0) {\n              return 0;\n            }\n            var sepSize = this.lineSeparator().length;\n            this.iter(this.first, coords.line, function(line) {\n              index += line.text.length + sepSize;\n            });\n            return index;\n          },\n          copy: function(copyHistory) {\n            var doc2 = new Doc(\n              getLines(this, this.first, this.first + this.size),\n              this.modeOption,\n              this.first,\n              this.lineSep,\n              this.direction\n            );\n            doc2.scrollTop = this.scrollTop;\n            doc2.scrollLeft = this.scrollLeft;\n            doc2.sel = this.sel;\n            doc2.extend = false;\n            if (copyHistory) {\n              doc2.history.undoDepth = this.history.undoDepth;\n              doc2.setHistory(this.getHistory());\n            }\n            return doc2;\n          },\n          linkedDoc: function(options2) {\n            if (!options2) {\n              options2 = {};\n            }\n            var from = this.first, to = this.first + this.size;\n            if (options2.from != null && options2.from > from) {\n              from = options2.from;\n            }\n            if (options2.to != null && options2.to < to) {\n              to = options2.to;\n            }\n            var copy = new Doc(getLines(this, from, to), options2.mode || this.modeOption, from, this.lineSep, this.direction);\n            if (options2.sharedHist) {\n              copy.history = this.history;\n            }\n            (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options2.sharedHist });\n            copy.linked = [{ doc: this, isParent: true, sharedHist: options2.sharedHist }];\n            copySharedMarkers(copy, findSharedMarkers(this));\n            return copy;\n          },\n          unlinkDoc: function(other) {\n            if (other instanceof CodeMirror8) {\n              other = other.doc;\n            }\n            if (this.linked) {\n              for (var i2 = 0; i2 < this.linked.length; ++i2) {\n                var link = this.linked[i2];\n                if (link.doc != other) {\n                  continue;\n                }\n                this.linked.splice(i2, 1);\n                other.unlinkDoc(this);\n                detachSharedMarkers(findSharedMarkers(this));\n                break;\n              }\n            }\n            if (other.history == this.history) {\n              var splitIds = [other.id];\n              linkedDocs(other, function(doc2) {\n                return splitIds.push(doc2.id);\n              }, true);\n              other.history = new History(null);\n              other.history.done = copyHistoryArray(this.history.done, splitIds);\n              other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n            }\n          },\n          iterLinkedDocs: function(f) {\n            linkedDocs(this, f);\n          },\n          getMode: function() {\n            return this.mode;\n          },\n          getEditor: function() {\n            return this.cm;\n          },\n          splitLines: function(str) {\n            if (this.lineSep) {\n              return str.split(this.lineSep);\n            }\n            return splitLinesAuto(str);\n          },\n          lineSeparator: function() {\n            return this.lineSep || "\\n";\n          },\n          setDirection: docMethodOp(function(dir) {\n            if (dir != "rtl") {\n              dir = "ltr";\n            }\n            if (dir == this.direction) {\n              return;\n            }\n            this.direction = dir;\n            this.iter(function(line) {\n              return line.order = null;\n            });\n            if (this.cm) {\n              directionChanged(this.cm);\n            }\n          })\n        });\n        Doc.prototype.eachLine = Doc.prototype.iter;\n        var lastDrop = 0;\n        function onDrop(e) {\n          var cm = this;\n          clearDragCursor(cm);\n          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n            return;\n          }\n          e_preventDefault(e);\n          if (ie) {\n            lastDrop = +/* @__PURE__ */ new Date();\n          }\n          var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n          if (!pos || cm.isReadOnly()) {\n            return;\n          }\n          if (files && files.length && window.FileReader && window.File) {\n            var n = files.length, text = Array(n), read = 0;\n            var markAsReadAndPasteIfAllFilesAreRead = function() {\n              if (++read == n) {\n                operation(cm, function() {\n                  pos = clipPos(cm.doc, pos);\n                  var change = {\n                    from: pos,\n                    to: pos,\n                    text: cm.doc.splitLines(\n                      text.filter(function(t) {\n                        return t != null;\n                      }).join(cm.doc.lineSeparator())\n                    ),\n                    origin: "paste"\n                  };\n                  makeChange(cm.doc, change);\n                  setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n                })();\n              }\n            };\n            var readTextFromFile = function(file, i3) {\n              if (cm.options.allowDropFileTypes && indexOf2(cm.options.allowDropFileTypes, file.type) == -1) {\n                markAsReadAndPasteIfAllFilesAreRead();\n                return;\n              }\n              var reader = new FileReader();\n              reader.onerror = function() {\n                return markAsReadAndPasteIfAllFilesAreRead();\n              };\n              reader.onload = function() {\n                var content = reader.result;\n                if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n                  markAsReadAndPasteIfAllFilesAreRead();\n                  return;\n                }\n                text[i3] = content;\n                markAsReadAndPasteIfAllFilesAreRead();\n              };\n              reader.readAsText(file);\n            };\n            for (var i2 = 0; i2 < files.length; i2++) {\n              readTextFromFile(files[i2], i2);\n            }\n          } else {\n            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n              cm.state.draggingText(e);\n              setTimeout(function() {\n                return cm.display.input.focus();\n              }, 20);\n              return;\n            }\n            try {\n              var text$1 = e.dataTransfer.getData("Text");\n              if (text$1) {\n                var selected;\n                if (cm.state.draggingText && !cm.state.draggingText.copy) {\n                  selected = cm.listSelections();\n                }\n                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n                if (selected) {\n                  for (var i$12 = 0; i$12 < selected.length; ++i$12) {\n                    replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");\n                  }\n                }\n                cm.replaceSelection(text$1, "around", "paste");\n                cm.display.input.focus();\n              }\n            } catch (e$1) {\n            }\n          }\n        }\n        function onDragStart(cm, e) {\n          if (ie && (!cm.state.draggingText || +/* @__PURE__ */ new Date() - lastDrop < 100)) {\n            e_stop(e);\n            return;\n          }\n          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n            return;\n          }\n          e.dataTransfer.setData("Text", cm.getSelection());\n          e.dataTransfer.effectAllowed = "copyMove";\n          if (e.dataTransfer.setDragImage && !safari) {\n            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\n            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n            if (presto) {\n              img.width = img.height = 1;\n              cm.display.wrapper.appendChild(img);\n              img._top = img.offsetTop;\n            }\n            e.dataTransfer.setDragImage(img, 0, 0);\n            if (presto) {\n              img.parentNode.removeChild(img);\n            }\n          }\n        }\n        function onDragOver(cm, e) {\n          var pos = posFromMouse(cm, e);\n          if (!pos) {\n            return;\n          }\n          var frag = document.createDocumentFragment();\n          drawSelectionCursor(cm, pos, frag);\n          if (!cm.display.dragCursor) {\n            cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");\n            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n          }\n          removeChildrenAndAdd(cm.display.dragCursor, frag);\n        }\n        function clearDragCursor(cm) {\n          if (cm.display.dragCursor) {\n            cm.display.lineSpace.removeChild(cm.display.dragCursor);\n            cm.display.dragCursor = null;\n          }\n        }\n        function forEachCodeMirror(f) {\n          if (!document.getElementsByClassName) {\n            return;\n          }\n          var byClass = document.getElementsByClassName("CodeMirror"), editors = [];\n          for (var i2 = 0; i2 < byClass.length; i2++) {\n            var cm = byClass[i2].CodeMirror;\n            if (cm) {\n              editors.push(cm);\n            }\n          }\n          if (editors.length) {\n            editors[0].operation(function() {\n              for (var i3 = 0; i3 < editors.length; i3++) {\n                f(editors[i3]);\n              }\n            });\n          }\n        }\n        var globalsRegistered = false;\n        function ensureGlobalHandlers() {\n          if (globalsRegistered) {\n            return;\n          }\n          registerGlobalHandlers();\n          globalsRegistered = true;\n        }\n        function registerGlobalHandlers() {\n          var resizeTimer;\n          on(window, "resize", function() {\n            if (resizeTimer == null) {\n              resizeTimer = setTimeout(function() {\n                resizeTimer = null;\n                forEachCodeMirror(onResize);\n              }, 100);\n            }\n          });\n          on(window, "blur", function() {\n            return forEachCodeMirror(onBlur);\n          });\n        }\n        function onResize(cm) {\n          var d = cm.display;\n          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n          d.scrollbarsClipped = false;\n          cm.setSize();\n        }\n        var keyNames = {\n          3: "Pause",\n          8: "Backspace",\n          9: "Tab",\n          13: "Enter",\n          16: "Shift",\n          17: "Ctrl",\n          18: "Alt",\n          19: "Pause",\n          20: "CapsLock",\n          27: "Esc",\n          32: "Space",\n          33: "PageUp",\n          34: "PageDown",\n          35: "End",\n          36: "Home",\n          37: "Left",\n          38: "Up",\n          39: "Right",\n          40: "Down",\n          44: "PrintScrn",\n          45: "Insert",\n          46: "Delete",\n          59: ";",\n          61: "=",\n          91: "Mod",\n          92: "Mod",\n          93: "Mod",\n          106: "*",\n          107: "=",\n          109: "-",\n          110: ".",\n          111: "/",\n          145: "ScrollLock",\n          173: "-",\n          186: ";",\n          187: "=",\n          188: ",",\n          189: "-",\n          190: ".",\n          191: "/",\n          192: "`",\n          219: "[",\n          220: "\\\\",\n          221: "]",\n          222: "\'",\n          224: "Mod",\n          63232: "Up",\n          63233: "Down",\n          63234: "Left",\n          63235: "Right",\n          63272: "Delete",\n          63273: "Home",\n          63275: "End",\n          63276: "PageUp",\n          63277: "PageDown",\n          63302: "Insert"\n        };\n        for (var i = 0; i < 10; i++) {\n          keyNames[i + 48] = keyNames[i + 96] = String(i);\n        }\n        for (var i$1 = 65; i$1 <= 90; i$1++) {\n          keyNames[i$1] = String.fromCharCode(i$1);\n        }\n        for (var i$2 = 1; i$2 <= 12; i$2++) {\n          keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;\n        }\n        var keyMap = {};\n        keyMap.basic = {\n          "Left": "goCharLeft",\n          "Right": "goCharRight",\n          "Up": "goLineUp",\n          "Down": "goLineDown",\n          "End": "goLineEnd",\n          "Home": "goLineStartSmart",\n          "PageUp": "goPageUp",\n          "PageDown": "goPageDown",\n          "Delete": "delCharAfter",\n          "Backspace": "delCharBefore",\n          "Shift-Backspace": "delCharBefore",\n          "Tab": "defaultTab",\n          "Shift-Tab": "indentAuto",\n          "Enter": "newlineAndIndent",\n          "Insert": "toggleOverwrite",\n          "Esc": "singleSelection"\n        };\n        keyMap.pcDefault = {\n          "Ctrl-A": "selectAll",\n          "Ctrl-D": "deleteLine",\n          "Ctrl-Z": "undo",\n          "Shift-Ctrl-Z": "redo",\n          "Ctrl-Y": "redo",\n          "Ctrl-Home": "goDocStart",\n          "Ctrl-End": "goDocEnd",\n          "Ctrl-Up": "goLineUp",\n          "Ctrl-Down": "goLineDown",\n          "Ctrl-Left": "goGroupLeft",\n          "Ctrl-Right": "goGroupRight",\n          "Alt-Left": "goLineStart",\n          "Alt-Right": "goLineEnd",\n          "Ctrl-Backspace": "delGroupBefore",\n          "Ctrl-Delete": "delGroupAfter",\n          "Ctrl-S": "save",\n          "Ctrl-F": "find",\n          "Ctrl-G": "findNext",\n          "Shift-Ctrl-G": "findPrev",\n          "Shift-Ctrl-F": "replace",\n          "Shift-Ctrl-R": "replaceAll",\n          "Ctrl-[": "indentLess",\n          "Ctrl-]": "indentMore",\n          "Ctrl-U": "undoSelection",\n          "Shift-Ctrl-U": "redoSelection",\n          "Alt-U": "redoSelection",\n          "fallthrough": "basic"\n        };\n        keyMap.emacsy = {\n          "Ctrl-F": "goCharRight",\n          "Ctrl-B": "goCharLeft",\n          "Ctrl-P": "goLineUp",\n          "Ctrl-N": "goLineDown",\n          "Ctrl-A": "goLineStart",\n          "Ctrl-E": "goLineEnd",\n          "Ctrl-V": "goPageDown",\n          "Shift-Ctrl-V": "goPageUp",\n          "Ctrl-D": "delCharAfter",\n          "Ctrl-H": "delCharBefore",\n          "Alt-Backspace": "delWordBefore",\n          "Ctrl-K": "killLine",\n          "Ctrl-T": "transposeChars",\n          "Ctrl-O": "openLine"\n        };\n        keyMap.macDefault = {\n          "Cmd-A": "selectAll",\n          "Cmd-D": "deleteLine",\n          "Cmd-Z": "undo",\n          "Shift-Cmd-Z": "redo",\n          "Cmd-Y": "redo",\n          "Cmd-Home": "goDocStart",\n          "Cmd-Up": "goDocStart",\n          "Cmd-End": "goDocEnd",\n          "Cmd-Down": "goDocEnd",\n          "Alt-Left": "goGroupLeft",\n          "Alt-Right": "goGroupRight",\n          "Cmd-Left": "goLineLeft",\n          "Cmd-Right": "goLineRight",\n          "Alt-Backspace": "delGroupBefore",\n          "Ctrl-Alt-Backspace": "delGroupAfter",\n          "Alt-Delete": "delGroupAfter",\n          "Cmd-S": "save",\n          "Cmd-F": "find",\n          "Cmd-G": "findNext",\n          "Shift-Cmd-G": "findPrev",\n          "Cmd-Alt-F": "replace",\n          "Shift-Cmd-Alt-F": "replaceAll",\n          "Cmd-[": "indentLess",\n          "Cmd-]": "indentMore",\n          "Cmd-Backspace": "delWrappedLineLeft",\n          "Cmd-Delete": "delWrappedLineRight",\n          "Cmd-U": "undoSelection",\n          "Shift-Cmd-U": "redoSelection",\n          "Ctrl-Up": "goDocStart",\n          "Ctrl-Down": "goDocEnd",\n          "fallthrough": ["basic", "emacsy"]\n        };\n        keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n        function normalizeKeyName(name) {\n          var parts = name.split(/-(?!$)/);\n          name = parts[parts.length - 1];\n          var alt, ctrl, shift, cmd;\n          for (var i2 = 0; i2 < parts.length - 1; i2++) {\n            var mod2 = parts[i2];\n            if (/^(cmd|meta|m)$/i.test(mod2)) {\n              cmd = true;\n            } else if (/^a(lt)?$/i.test(mod2)) {\n              alt = true;\n            } else if (/^(c|ctrl|control)$/i.test(mod2)) {\n              ctrl = true;\n            } else if (/^s(hift)?$/i.test(mod2)) {\n              shift = true;\n            } else {\n              throw new Error("Unrecognized modifier name: " + mod2);\n            }\n          }\n          if (alt) {\n            name = "Alt-" + name;\n          }\n          if (ctrl) {\n            name = "Ctrl-" + name;\n          }\n          if (cmd) {\n            name = "Cmd-" + name;\n          }\n          if (shift) {\n            name = "Shift-" + name;\n          }\n          return name;\n        }\n        function normalizeKeyMap(keymap) {\n          var copy = {};\n          for (var keyname in keymap) {\n            if (keymap.hasOwnProperty(keyname)) {\n              var value = keymap[keyname];\n              if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n                continue;\n              }\n              if (value == "...") {\n                delete keymap[keyname];\n                continue;\n              }\n              var keys = map2(keyname.split(" "), normalizeKeyName);\n              for (var i2 = 0; i2 < keys.length; i2++) {\n                var val = void 0, name = void 0;\n                if (i2 == keys.length - 1) {\n                  name = keys.join(" ");\n                  val = value;\n                } else {\n                  name = keys.slice(0, i2 + 1).join(" ");\n                  val = "...";\n                }\n                var prev = copy[name];\n                if (!prev) {\n                  copy[name] = val;\n                } else if (prev != val) {\n                  throw new Error("Inconsistent bindings for " + name);\n                }\n              }\n              delete keymap[keyname];\n            }\n          }\n          for (var prop2 in copy) {\n            keymap[prop2] = copy[prop2];\n          }\n          return keymap;\n        }\n        function lookupKey(key2, map3, handle, context) {\n          map3 = getKeyMap(map3);\n          var found = map3.call ? map3.call(key2, context) : map3[key2];\n          if (found === false) {\n            return "nothing";\n          }\n          if (found === "...") {\n            return "multi";\n          }\n          if (found != null && handle(found)) {\n            return "handled";\n          }\n          if (map3.fallthrough) {\n            if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {\n              return lookupKey(key2, map3.fallthrough, handle, context);\n            }\n            for (var i2 = 0; i2 < map3.fallthrough.length; i2++) {\n              var result = lookupKey(key2, map3.fallthrough[i2], handle, context);\n              if (result) {\n                return result;\n              }\n            }\n          }\n        }\n        function isModifierKey(value) {\n          var name = typeof value == "string" ? value : keyNames[value.keyCode];\n          return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";\n        }\n        function addModifierNames(name, event, noShift) {\n          var base = name;\n          if (event.altKey && base != "Alt") {\n            name = "Alt-" + name;\n          }\n          if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {\n            name = "Ctrl-" + name;\n          }\n          if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {\n            name = "Cmd-" + name;\n          }\n          if (!noShift && event.shiftKey && base != "Shift") {\n            name = "Shift-" + name;\n          }\n          return name;\n        }\n        function keyName(event, noShift) {\n          if (presto && event.keyCode == 34 && event["char"]) {\n            return false;\n          }\n          var name = keyNames[event.keyCode];\n          if (name == null || event.altGraphKey) {\n            return false;\n          }\n          if (event.keyCode == 3 && event.code) {\n            name = event.code;\n          }\n          return addModifierNames(name, event, noShift);\n        }\n        function getKeyMap(val) {\n          return typeof val == "string" ? keyMap[val] : val;\n        }\n        function deleteNearSelection(cm, compute) {\n          var ranges = cm.doc.sel.ranges, kill = [];\n          for (var i2 = 0; i2 < ranges.length; i2++) {\n            var toKill = compute(ranges[i2]);\n            while (kill.length && cmp2(toKill.from, lst(kill).to) <= 0) {\n              var replaced = kill.pop();\n              if (cmp2(replaced.from, toKill.from) < 0) {\n                toKill.from = replaced.from;\n                break;\n              }\n            }\n            kill.push(toKill);\n          }\n          runInOp(cm, function() {\n            for (var i3 = kill.length - 1; i3 >= 0; i3--) {\n              replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");\n            }\n            ensureCursorVisible(cm);\n          });\n        }\n        function moveCharLogically(line, ch, dir) {\n          var target = skipExtendingChars(line.text, ch + dir, dir);\n          return target < 0 || target > line.text.length ? null : target;\n        }\n        function moveLogically(line, start, dir) {\n          var ch = moveCharLogically(line, start.ch, dir);\n          return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");\n        }\n        function endOfLine(visually, cm, lineObj, lineNo2, dir) {\n          if (visually) {\n            if (cm.doc.direction == "rtl") {\n              dir = -dir;\n            }\n            var order = getOrder2(lineObj, cm.doc.direction);\n            if (order) {\n              var part = dir < 0 ? lst(order) : order[0];\n              var moveInStorageOrder = dir < 0 == (part.level == 1);\n              var sticky = moveInStorageOrder ? "after" : "before";\n              var ch;\n              if (part.level > 0 || cm.doc.direction == "rtl") {\n                var prep = prepareMeasureForLine(cm, lineObj);\n                ch = dir < 0 ? lineObj.text.length - 1 : 0;\n                var targetTop = measureCharPrepared(cm, prep, ch).top;\n                ch = findFirst(function(ch2) {\n                  return measureCharPrepared(cm, prep, ch2).top == targetTop;\n                }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n                if (sticky == "before") {\n                  ch = moveCharLogically(lineObj, ch, 1);\n                }\n              } else {\n                ch = dir < 0 ? part.to : part.from;\n              }\n              return new Pos(lineNo2, ch, sticky);\n            }\n          }\n          return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");\n        }\n        function moveVisually(cm, line, start, dir) {\n          var bidi = getOrder2(line, cm.doc.direction);\n          if (!bidi) {\n            return moveLogically(line, start, dir);\n          }\n          if (start.ch >= line.text.length) {\n            start.ch = line.text.length;\n            start.sticky = "before";\n          } else if (start.ch <= 0) {\n            start.ch = 0;\n            start.sticky = "after";\n          }\n          var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n          if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n            return moveLogically(line, start, dir);\n          }\n          var mv = function(pos, dir2) {\n            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);\n          };\n          var prep;\n          var getWrappedLineExtent = function(ch2) {\n            if (!cm.options.lineWrapping) {\n              return { begin: 0, end: line.text.length };\n            }\n            prep = prep || prepareMeasureForLine(cm, line);\n            return wrappedLineExtentChar(cm, line, prep, ch2);\n          };\n          var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);\n          if (cm.doc.direction == "rtl" || part.level == 1) {\n            var moveInStorageOrder = part.level == 1 == dir < 0;\n            var ch = mv(start, moveInStorageOrder ? 1 : -1);\n            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {\n              var sticky = moveInStorageOrder ? "before" : "after";\n              return new Pos(start.line, ch, sticky);\n            }\n          }\n          var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {\n            var getRes = function(ch3, moveInStorageOrder3) {\n              return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");\n            };\n            for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {\n              var part2 = bidi[partPos2];\n              var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);\n              var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);\n              if (part2.from <= ch2 && ch2 < part2.to) {\n                return getRes(ch2, moveInStorageOrder2);\n              }\n              ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);\n              if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {\n                return getRes(ch2, moveInStorageOrder2);\n              }\n            }\n          };\n          var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);\n          if (res) {\n            return res;\n          }\n          var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);\n          if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n            if (res) {\n              return res;\n            }\n          }\n          return null;\n        }\n        var commands = {\n          selectAll,\n          singleSelection: function(cm) {\n            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);\n          },\n          killLine: function(cm) {\n            return deleteNearSelection(cm, function(range2) {\n              if (range2.empty()) {\n                var len = getLine(cm.doc, range2.head.line).text.length;\n                if (range2.head.ch == len && range2.head.line < cm.lastLine()) {\n                  return { from: range2.head, to: Pos(range2.head.line + 1, 0) };\n                } else {\n                  return { from: range2.head, to: Pos(range2.head.line, len) };\n                }\n              } else {\n                return { from: range2.from(), to: range2.to() };\n              }\n            });\n          },\n          deleteLine: function(cm) {\n            return deleteNearSelection(cm, function(range2) {\n              return {\n                from: Pos(range2.from().line, 0),\n                to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))\n              };\n            });\n          },\n          delLineLeft: function(cm) {\n            return deleteNearSelection(cm, function(range2) {\n              return {\n                from: Pos(range2.from().line, 0),\n                to: range2.from()\n              };\n            });\n          },\n          delWrappedLineLeft: function(cm) {\n            return deleteNearSelection(cm, function(range2) {\n              var top = cm.charCoords(range2.head, "div").top + 5;\n              var leftPos = cm.coordsChar({ left: 0, top }, "div");\n              return { from: leftPos, to: range2.from() };\n            });\n          },\n          delWrappedLineRight: function(cm) {\n            return deleteNearSelection(cm, function(range2) {\n              var top = cm.charCoords(range2.head, "div").top + 5;\n              var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");\n              return { from: range2.from(), to: rightPos };\n            });\n          },\n          undo: function(cm) {\n            return cm.undo();\n          },\n          redo: function(cm) {\n            return cm.redo();\n          },\n          undoSelection: function(cm) {\n            return cm.undoSelection();\n          },\n          redoSelection: function(cm) {\n            return cm.redoSelection();\n          },\n          goDocStart: function(cm) {\n            return cm.extendSelection(Pos(cm.firstLine(), 0));\n          },\n          goDocEnd: function(cm) {\n            return cm.extendSelection(Pos(cm.lastLine()));\n          },\n          goLineStart: function(cm) {\n            return cm.extendSelectionsBy(\n              function(range2) {\n                return lineStart(cm, range2.head.line);\n              },\n              { origin: "+move", bias: 1 }\n            );\n          },\n          goLineStartSmart: function(cm) {\n            return cm.extendSelectionsBy(\n              function(range2) {\n                return lineStartSmart(cm, range2.head);\n              },\n              { origin: "+move", bias: 1 }\n            );\n          },\n          goLineEnd: function(cm) {\n            return cm.extendSelectionsBy(\n              function(range2) {\n                return lineEnd(cm, range2.head.line);\n              },\n              { origin: "+move", bias: -1 }\n            );\n          },\n          goLineRight: function(cm) {\n            return cm.extendSelectionsBy(function(range2) {\n              var top = cm.cursorCoords(range2.head, "div").top + 5;\n              return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");\n            }, sel_move);\n          },\n          goLineLeft: function(cm) {\n            return cm.extendSelectionsBy(function(range2) {\n              var top = cm.cursorCoords(range2.head, "div").top + 5;\n              return cm.coordsChar({ left: 0, top }, "div");\n            }, sel_move);\n          },\n          goLineLeftSmart: function(cm) {\n            return cm.extendSelectionsBy(function(range2) {\n              var top = cm.cursorCoords(range2.head, "div").top + 5;\n              var pos = cm.coordsChar({ left: 0, top }, "div");\n              if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n                return lineStartSmart(cm, range2.head);\n              }\n              return pos;\n            }, sel_move);\n          },\n          goLineUp: function(cm) {\n            return cm.moveV(-1, "line");\n          },\n          goLineDown: function(cm) {\n            return cm.moveV(1, "line");\n          },\n          goPageUp: function(cm) {\n            return cm.moveV(-1, "page");\n          },\n          goPageDown: function(cm) {\n            return cm.moveV(1, "page");\n          },\n          goCharLeft: function(cm) {\n            return cm.moveH(-1, "char");\n          },\n          goCharRight: function(cm) {\n            return cm.moveH(1, "char");\n          },\n          goColumnLeft: function(cm) {\n            return cm.moveH(-1, "column");\n          },\n          goColumnRight: function(cm) {\n            return cm.moveH(1, "column");\n          },\n          goWordLeft: function(cm) {\n            return cm.moveH(-1, "word");\n          },\n          goGroupRight: function(cm) {\n            return cm.moveH(1, "group");\n          },\n          goGroupLeft: function(cm) {\n            return cm.moveH(-1, "group");\n          },\n          goWordRight: function(cm) {\n            return cm.moveH(1, "word");\n          },\n          delCharBefore: function(cm) {\n            return cm.deleteH(-1, "codepoint");\n          },\n          delCharAfter: function(cm) {\n            return cm.deleteH(1, "char");\n          },\n          delWordBefore: function(cm) {\n            return cm.deleteH(-1, "word");\n          },\n          delWordAfter: function(cm) {\n            return cm.deleteH(1, "word");\n          },\n          delGroupBefore: function(cm) {\n            return cm.deleteH(-1, "group");\n          },\n          delGroupAfter: function(cm) {\n            return cm.deleteH(1, "group");\n          },\n          indentAuto: function(cm) {\n            return cm.indentSelection("smart");\n          },\n          indentMore: function(cm) {\n            return cm.indentSelection("add");\n          },\n          indentLess: function(cm) {\n            return cm.indentSelection("subtract");\n          },\n          insertTab: function(cm) {\n            return cm.replaceSelection("\t");\n          },\n          insertSoftTab: function(cm) {\n            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n            for (var i2 = 0; i2 < ranges.length; i2++) {\n              var pos = ranges[i2].from();\n              var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n              spaces.push(spaceStr(tabSize - col % tabSize));\n            }\n            cm.replaceSelections(spaces);\n          },\n          defaultTab: function(cm) {\n            if (cm.somethingSelected()) {\n              cm.indentSelection("add");\n            } else {\n              cm.execCommand("insertTab");\n            }\n          },\n          // Swap the two chars left and right of each selection\'s head.\n          // Move cursor behind the two swapped characters afterwards.\n          //\n          // Doesn\'t consider line feeds a character.\n          // Doesn\'t scan more than one line above to find a character.\n          // Doesn\'t do anything on an empty line.\n          // Doesn\'t do anything with non-empty selections.\n          transposeChars: function(cm) {\n            return runInOp(cm, function() {\n              var ranges = cm.listSelections(), newSel = [];\n              for (var i2 = 0; i2 < ranges.length; i2++) {\n                if (!ranges[i2].empty()) {\n                  continue;\n                }\n                var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;\n                if (line) {\n                  if (cur.ch == line.length) {\n                    cur = new Pos(cur.line, cur.ch - 1);\n                  }\n                  if (cur.ch > 0) {\n                    cur = new Pos(cur.line, cur.ch + 1);\n                    cm.replaceRange(\n                      line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                      Pos(cur.line, cur.ch - 2),\n                      cur,\n                      "+transpose"\n                    );\n                  } else if (cur.line > cm.doc.first) {\n                    var prev = getLine(cm.doc, cur.line - 1).text;\n                    if (prev) {\n                      cur = new Pos(cur.line, 1);\n                      cm.replaceRange(\n                        line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1),\n                        Pos(cur.line - 1, prev.length - 1),\n                        cur,\n                        "+transpose"\n                      );\n                    }\n                  }\n                }\n                newSel.push(new Range(cur, cur));\n              }\n              cm.setSelections(newSel);\n            });\n          },\n          newlineAndIndent: function(cm) {\n            return runInOp(cm, function() {\n              var sels = cm.listSelections();\n              for (var i2 = sels.length - 1; i2 >= 0; i2--) {\n                cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");\n              }\n              sels = cm.listSelections();\n              for (var i$12 = 0; i$12 < sels.length; i$12++) {\n                cm.indentLine(sels[i$12].from().line, null, true);\n              }\n              ensureCursorVisible(cm);\n            });\n          },\n          openLine: function(cm) {\n            return cm.replaceSelection("\\n", "start");\n          },\n          toggleOverwrite: function(cm) {\n            return cm.toggleOverwrite();\n          }\n        };\n        function lineStart(cm, lineN) {\n          var line = getLine(cm.doc, lineN);\n          var visual = visualLine(line);\n          if (visual != line) {\n            lineN = lineNo(visual);\n          }\n          return endOfLine(true, cm, visual, lineN, 1);\n        }\n        function lineEnd(cm, lineN) {\n          var line = getLine(cm.doc, lineN);\n          var visual = visualLineEnd(line);\n          if (visual != line) {\n            lineN = lineNo(visual);\n          }\n          return endOfLine(true, cm, line, lineN, -1);\n        }\n        function lineStartSmart(cm, pos) {\n          var start = lineStart(cm, pos.line);\n          var line = getLine(cm.doc, start.line);\n          var order = getOrder2(line, cm.doc.direction);\n          if (!order || order[0].level == 0) {\n            var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n            return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);\n          }\n          return start;\n        }\n        function doHandleBinding(cm, bound, dropShift) {\n          if (typeof bound == "string") {\n            bound = commands[bound];\n            if (!bound) {\n              return false;\n            }\n          }\n          cm.display.input.ensurePolled();\n          var prevShift = cm.display.shift, done = false;\n          try {\n            if (cm.isReadOnly()) {\n              cm.state.suppressEdits = true;\n            }\n            if (dropShift) {\n              cm.display.shift = false;\n            }\n            done = bound(cm) != Pass;\n          } finally {\n            cm.display.shift = prevShift;\n            cm.state.suppressEdits = false;\n          }\n          return done;\n        }\n        function lookupKeyForEditor(cm, name, handle) {\n          for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {\n            var result = lookupKey(name, cm.state.keyMaps[i2], handle, cm);\n            if (result) {\n              return result;\n            }\n          }\n          return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);\n        }\n        var stopSeq = new Delayed();\n        function dispatchKey(cm, name, e, handle) {\n          var seq = cm.state.keySeq;\n          if (seq) {\n            if (isModifierKey(name)) {\n              return "handled";\n            }\n            if (/\\\'$/.test(name)) {\n              cm.state.keySeq = null;\n            } else {\n              stopSeq.set(50, function() {\n                if (cm.state.keySeq == seq) {\n                  cm.state.keySeq = null;\n                  cm.display.input.reset();\n                }\n              });\n            }\n            if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {\n              return true;\n            }\n          }\n          return dispatchKeyInner(cm, name, e, handle);\n        }\n        function dispatchKeyInner(cm, name, e, handle) {\n          var result = lookupKeyForEditor(cm, name, handle);\n          if (result == "multi") {\n            cm.state.keySeq = name;\n          }\n          if (result == "handled") {\n            signalLater(cm, "keyHandled", cm, name, e);\n          }\n          if (result == "handled" || result == "multi") {\n            e_preventDefault(e);\n            restartBlink(cm);\n          }\n          return !!result;\n        }\n        function handleKeyBinding(cm, e) {\n          var name = keyName(e, true);\n          if (!name) {\n            return false;\n          }\n          if (e.shiftKey && !cm.state.keySeq) {\n            return dispatchKey(cm, "Shift-" + name, e, function(b2) {\n              return doHandleBinding(cm, b2, true);\n            }) || dispatchKey(cm, name, e, function(b2) {\n              if (typeof b2 == "string" ? /^go[A-Z]/.test(b2) : b2.motion) {\n                return doHandleBinding(cm, b2);\n              }\n            });\n          } else {\n            return dispatchKey(cm, name, e, function(b2) {\n              return doHandleBinding(cm, b2);\n            });\n          }\n        }\n        function handleCharBinding(cm, e, ch) {\n          return dispatchKey(cm, "\'" + ch + "\'", e, function(b2) {\n            return doHandleBinding(cm, b2, true);\n          });\n        }\n        var lastStoppedKey = null;\n        function onKeyDown(e) {\n          var cm = this;\n          if (e.target && e.target != cm.display.input.getField()) {\n            return;\n          }\n          cm.curOp.focus = activeElt(root(cm));\n          if (signalDOMEvent(cm, e)) {\n            return;\n          }\n          if (ie && ie_version < 11 && e.keyCode == 27) {\n            e.returnValue = false;\n          }\n          var code = e.keyCode;\n          cm.display.shift = code == 16 || e.shiftKey;\n          var handled = handleKeyBinding(cm, e);\n          if (presto) {\n            lastStoppedKey = handled ? code : null;\n            if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n              cm.replaceSelection("", null, "cut");\n            }\n          }\n          if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {\n            document.execCommand("cut");\n          }\n          if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n            showCrossHair(cm);\n          }\n        }\n        function showCrossHair(cm) {\n          var lineDiv = cm.display.lineDiv;\n          addClass(lineDiv, "CodeMirror-crosshair");\n          function up(e) {\n            if (e.keyCode == 18 || !e.altKey) {\n              rmClass(lineDiv, "CodeMirror-crosshair");\n              off(document, "keyup", up);\n              off(document, "mouseover", up);\n            }\n          }\n          on(document, "keyup", up);\n          on(document, "mouseover", up);\n        }\n        function onKeyUp(e) {\n          if (e.keyCode == 16) {\n            this.doc.sel.shift = false;\n          }\n          signalDOMEvent(this, e);\n        }\n        function onKeyPress(e) {\n          var cm = this;\n          if (e.target && e.target != cm.display.input.getField()) {\n            return;\n          }\n          if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n            return;\n          }\n          var keyCode = e.keyCode, charCode = e.charCode;\n          if (presto && keyCode == lastStoppedKey) {\n            lastStoppedKey = null;\n            e_preventDefault(e);\n            return;\n          }\n          if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n            return;\n          }\n          var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n          if (ch == "\\b") {\n            return;\n          }\n          if (handleCharBinding(cm, e, ch)) {\n            return;\n          }\n          cm.display.input.onKeyPress(e);\n        }\n        var DOUBLECLICK_DELAY = 400;\n        var PastClick = function(time, pos, button) {\n          this.time = time;\n          this.pos = pos;\n          this.button = button;\n        };\n        PastClick.prototype.compare = function(time, pos, button) {\n          return this.time + DOUBLECLICK_DELAY > time && cmp2(pos, this.pos) == 0 && button == this.button;\n        };\n        var lastClick, lastDoubleClick;\n        function clickRepeat(pos, button) {\n          var now = +/* @__PURE__ */ new Date();\n          if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n            lastClick = lastDoubleClick = null;\n            return "triple";\n          } else if (lastClick && lastClick.compare(now, pos, button)) {\n            lastDoubleClick = new PastClick(now, pos, button);\n            lastClick = null;\n            return "double";\n          } else {\n            lastClick = new PastClick(now, pos, button);\n            lastDoubleClick = null;\n            return "single";\n          }\n        }\n        function onMouseDown(e) {\n          var cm = this, display = cm.display;\n          if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n            return;\n          }\n          display.input.ensurePolled();\n          display.shift = e.shiftKey;\n          if (eventInWidget(display, e)) {\n            if (!webkit) {\n              display.scroller.draggable = false;\n              setTimeout(function() {\n                return display.scroller.draggable = true;\n              }, 100);\n            }\n            return;\n          }\n          if (clickInGutter(cm, e)) {\n            return;\n          }\n          var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";\n          win(cm).focus();\n          if (button == 1 && cm.state.selectingText) {\n            cm.state.selectingText(e);\n          }\n          if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n            return;\n          }\n          if (button == 1) {\n            if (pos) {\n              leftButtonDown(cm, pos, repeat, e);\n            } else if (e_target(e) == display.scroller) {\n              e_preventDefault(e);\n            }\n          } else if (button == 2) {\n            if (pos) {\n              extendSelection(cm.doc, pos);\n            }\n            setTimeout(function() {\n              return display.input.focus();\n            }, 20);\n          } else if (button == 3) {\n            if (captureRightClick) {\n              cm.display.input.onContextMenu(e);\n            } else {\n              delayBlurEvent(cm);\n            }\n          }\n        }\n        function handleMappedButton(cm, button, pos, repeat, event) {\n          var name = "Click";\n          if (repeat == "double") {\n            name = "Double" + name;\n          } else if (repeat == "triple") {\n            name = "Triple" + name;\n          }\n          name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;\n          return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {\n            if (typeof bound == "string") {\n              bound = commands[bound];\n            }\n            if (!bound) {\n              return false;\n            }\n            var done = false;\n            try {\n              if (cm.isReadOnly()) {\n                cm.state.suppressEdits = true;\n              }\n              done = bound(cm, pos) != Pass;\n            } finally {\n              cm.state.suppressEdits = false;\n            }\n            return done;\n          });\n        }\n        function configureMouse(cm, repeat, event) {\n          var option = cm.getOption("configureMouse");\n          var value = option ? option(cm, repeat, event) : {};\n          if (value.unit == null) {\n            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n            value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";\n          }\n          if (value.extend == null || cm.doc.extend) {\n            value.extend = cm.doc.extend || event.shiftKey;\n          }\n          if (value.addNew == null) {\n            value.addNew = mac ? event.metaKey : event.ctrlKey;\n          }\n          if (value.moveOnDrag == null) {\n            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n          }\n          return value;\n        }\n        function leftButtonDown(cm, pos, repeat, event) {\n          if (ie) {\n            setTimeout(bind(ensureFocus, cm), 0);\n          } else {\n            cm.curOp.focus = activeElt(root(cm));\n          }\n          var behavior = configureMouse(cm, repeat, event);\n          var sel = cm.doc.sel, contained;\n          if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp2((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp2(contained.to(), pos) > 0 || pos.xRel < 0)) {\n            leftButtonStartDrag(cm, event, pos, behavior);\n          } else {\n            leftButtonSelect(cm, event, pos, behavior);\n          }\n        }\n        function leftButtonStartDrag(cm, event, pos, behavior) {\n          var display = cm.display, moved = false;\n          var dragEnd = operation(cm, function(e) {\n            if (webkit) {\n              display.scroller.draggable = false;\n            }\n            cm.state.draggingText = false;\n            if (cm.state.delayingBlurEvent) {\n              if (cm.hasFocus()) {\n                cm.state.delayingBlurEvent = false;\n              } else {\n                delayBlurEvent(cm);\n              }\n            }\n            off(display.wrapper.ownerDocument, "mouseup", dragEnd);\n            off(display.wrapper.ownerDocument, "mousemove", mouseMove);\n            off(display.scroller, "dragstart", dragStart);\n            off(display.scroller, "drop", dragEnd);\n            if (!moved) {\n              e_preventDefault(e);\n              if (!behavior.addNew) {\n                extendSelection(cm.doc, pos, null, null, behavior.extend);\n              }\n              if (webkit && !safari || ie && ie_version == 9) {\n                setTimeout(function() {\n                  display.wrapper.ownerDocument.body.focus({ preventScroll: true });\n                  display.input.focus();\n                }, 20);\n              } else {\n                display.input.focus();\n              }\n            }\n          });\n          var mouseMove = function(e2) {\n            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n          };\n          var dragStart = function() {\n            return moved = true;\n          };\n          if (webkit) {\n            display.scroller.draggable = true;\n          }\n          cm.state.draggingText = dragEnd;\n          dragEnd.copy = !behavior.moveOnDrag;\n          on(display.wrapper.ownerDocument, "mouseup", dragEnd);\n          on(display.wrapper.ownerDocument, "mousemove", mouseMove);\n          on(display.scroller, "dragstart", dragStart);\n          on(display.scroller, "drop", dragEnd);\n          cm.state.delayingBlurEvent = true;\n          setTimeout(function() {\n            return display.input.focus();\n          }, 20);\n          if (display.scroller.dragDrop) {\n            display.scroller.dragDrop();\n          }\n        }\n        function rangeForUnit(cm, pos, unit) {\n          if (unit == "char") {\n            return new Range(pos, pos);\n          }\n          if (unit == "word") {\n            return cm.findWordAt(pos);\n          }\n          if (unit == "line") {\n            return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n          }\n          var result = unit(cm, pos);\n          return new Range(result.from, result.to);\n        }\n        function leftButtonSelect(cm, event, start, behavior) {\n          if (ie) {\n            delayBlurEvent(cm);\n          }\n          var display = cm.display, doc2 = cm.doc;\n          e_preventDefault(event);\n          var ourRange, ourIndex, startSel = doc2.sel, ranges = startSel.ranges;\n          if (behavior.addNew && !behavior.extend) {\n            ourIndex = doc2.sel.contains(start);\n            if (ourIndex > -1) {\n              ourRange = ranges[ourIndex];\n            } else {\n              ourRange = new Range(start, start);\n            }\n          } else {\n            ourRange = doc2.sel.primary();\n            ourIndex = doc2.sel.primIndex;\n          }\n          if (behavior.unit == "rectangle") {\n            if (!behavior.addNew) {\n              ourRange = new Range(start, start);\n            }\n            start = posFromMouse(cm, event, true, true);\n            ourIndex = -1;\n          } else {\n            var range2 = rangeForUnit(cm, start, behavior.unit);\n            if (behavior.extend) {\n              ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);\n            } else {\n              ourRange = range2;\n            }\n          }\n          if (!behavior.addNew) {\n            ourIndex = 0;\n            setSelection(doc2, new Selection([ourRange], 0), sel_mouse);\n            startSel = doc2.sel;\n          } else if (ourIndex == -1) {\n            ourIndex = ranges.length;\n            setSelection(\n              doc2,\n              normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n              { scroll: false, origin: "*mouse" }\n            );\n          } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {\n            setSelection(\n              doc2,\n              normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n              { scroll: false, origin: "*mouse" }\n            );\n            startSel = doc2.sel;\n          } else {\n            replaceOneSelection(doc2, ourIndex, ourRange, sel_mouse);\n          }\n          var lastPos = start;\n          function extendTo(pos) {\n            if (cmp2(lastPos, pos) == 0) {\n              return;\n            }\n            lastPos = pos;\n            if (behavior.unit == "rectangle") {\n              var ranges2 = [], tabSize = cm.options.tabSize;\n              var startCol = countColumn(getLine(doc2, start.line).text, start.ch, tabSize);\n              var posCol = countColumn(getLine(doc2, pos.line).text, pos.ch, tabSize);\n              var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n              for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {\n                var text = getLine(doc2, line).text, leftPos = findColumn(text, left, tabSize);\n                if (left == right) {\n                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n                } else if (text.length > leftPos) {\n                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n                }\n              }\n              if (!ranges2.length) {\n                ranges2.push(new Range(start, start));\n              }\n              setSelection(\n                doc2,\n                normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex),\n                { origin: "*mouse", scroll: false }\n              );\n              cm.scrollIntoView(pos);\n            } else {\n              var oldRange = ourRange;\n              var range3 = rangeForUnit(cm, pos, behavior.unit);\n              var anchor = oldRange.anchor, head;\n              if (cmp2(range3.anchor, anchor) > 0) {\n                head = range3.head;\n                anchor = minPos(oldRange.from(), range3.anchor);\n              } else {\n                head = range3.anchor;\n                anchor = maxPos(oldRange.to(), range3.head);\n              }\n              var ranges$1 = startSel.ranges.slice(0);\n              ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc2, anchor), head));\n              setSelection(doc2, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n            }\n          }\n          var editorSize = display.wrapper.getBoundingClientRect();\n          var counter = 0;\n          function extend(e) {\n            var curCount = ++counter;\n            var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");\n            if (!cur) {\n              return;\n            }\n            if (cmp2(cur, lastPos) != 0) {\n              cm.curOp.focus = activeElt(root(cm));\n              extendTo(cur);\n              var visible = visibleLines(display, doc2);\n              if (cur.line >= visible.to || cur.line < visible.from) {\n                setTimeout(operation(cm, function() {\n                  if (counter == curCount) {\n                    extend(e);\n                  }\n                }), 150);\n              }\n            } else {\n              var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n              if (outside) {\n                setTimeout(operation(cm, function() {\n                  if (counter != curCount) {\n                    return;\n                  }\n                  display.scroller.scrollTop += outside;\n                  extend(e);\n                }), 50);\n              }\n            }\n          }\n          function done(e) {\n            cm.state.selectingText = false;\n            counter = Infinity;\n            if (e) {\n              e_preventDefault(e);\n              display.input.focus();\n            }\n            off(display.wrapper.ownerDocument, "mousemove", move);\n            off(display.wrapper.ownerDocument, "mouseup", up);\n            doc2.history.lastSelOrigin = null;\n          }\n          var move = operation(cm, function(e) {\n            if (e.buttons === 0 || !e_button(e)) {\n              done(e);\n            } else {\n              extend(e);\n            }\n          });\n          var up = operation(cm, done);\n          cm.state.selectingText = up;\n          on(display.wrapper.ownerDocument, "mousemove", move);\n          on(display.wrapper.ownerDocument, "mouseup", up);\n        }\n        function bidiSimplify(cm, range2) {\n          var anchor = range2.anchor;\n          var head = range2.head;\n          var anchorLine = getLine(cm.doc, anchor.line);\n          if (cmp2(anchor, head) == 0 && anchor.sticky == head.sticky) {\n            return range2;\n          }\n          var order = getOrder2(anchorLine);\n          if (!order) {\n            return range2;\n          }\n          var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n          if (part.from != anchor.ch && part.to != anchor.ch) {\n            return range2;\n          }\n          var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);\n          if (boundary == 0 || boundary == order.length) {\n            return range2;\n          }\n          var leftSide;\n          if (head.line != anchor.line) {\n            leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;\n          } else {\n            var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n            if (headIndex == boundary - 1 || headIndex == boundary) {\n              leftSide = dir < 0;\n            } else {\n              leftSide = dir > 0;\n            }\n          }\n          var usePart = order[boundary + (leftSide ? -1 : 0)];\n          var from = leftSide == (usePart.level == 1);\n          var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";\n          return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);\n        }\n        function gutterEvent(cm, e, type, prevent) {\n          var mX, mY;\n          if (e.touches) {\n            mX = e.touches[0].clientX;\n            mY = e.touches[0].clientY;\n          } else {\n            try {\n              mX = e.clientX;\n              mY = e.clientY;\n            } catch (e$1) {\n              return false;\n            }\n          }\n          if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n            return false;\n          }\n          if (prevent) {\n            e_preventDefault(e);\n          }\n          var display = cm.display;\n          var lineBox = display.lineDiv.getBoundingClientRect();\n          if (mY > lineBox.bottom || !hasHandler(cm, type)) {\n            return e_defaultPrevented(e);\n          }\n          mY -= lineBox.top - display.viewOffset;\n          for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {\n            var g2 = display.gutters.childNodes[i2];\n            if (g2 && g2.getBoundingClientRect().right >= mX) {\n              var line = lineAtHeight(cm.doc, mY);\n              var gutter = cm.display.gutterSpecs[i2];\n              signal(cm, type, cm, line, gutter.className, e);\n              return e_defaultPrevented(e);\n            }\n          }\n        }\n        function clickInGutter(cm, e) {\n          return gutterEvent(cm, e, "gutterClick", true);\n        }\n        function onContextMenu(cm, e) {\n          if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n            return;\n          }\n          if (signalDOMEvent(cm, e, "contextmenu")) {\n            return;\n          }\n          if (!captureRightClick) {\n            cm.display.input.onContextMenu(e);\n          }\n        }\n        function contextMenuInGutter(cm, e) {\n          if (!hasHandler(cm, "gutterContextMenu")) {\n            return false;\n          }\n          return gutterEvent(cm, e, "gutterContextMenu", false);\n        }\n        function themeChanged(cm) {\n          cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") + cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\n          clearCaches(cm);\n        }\n        var Init = { toString: function() {\n          return "CodeMirror.Init";\n        } };\n        var defaults2 = {};\n        var optionHandlers = {};\n        function defineOptions(CodeMirror9) {\n          var optionHandlers2 = CodeMirror9.optionHandlers;\n          function option(name, deflt, handle, notOnInit) {\n            CodeMirror9.defaults[name] = deflt;\n            if (handle) {\n              optionHandlers2[name] = notOnInit ? function(cm, val, old) {\n                if (old != Init) {\n                  handle(cm, val, old);\n                }\n              } : handle;\n            }\n          }\n          CodeMirror9.defineOption = option;\n          CodeMirror9.Init = Init;\n          option("value", "", function(cm, val) {\n            return cm.setValue(val);\n          }, true);\n          option("mode", null, function(cm, val) {\n            cm.doc.modeOption = val;\n            loadMode(cm);\n          }, true);\n          option("indentUnit", 2, loadMode, true);\n          option("indentWithTabs", false);\n          option("smartIndent", true);\n          option("tabSize", 4, function(cm) {\n            resetModeState(cm);\n            clearCaches(cm);\n            regChange(cm);\n          }, true);\n          option("lineSeparator", null, function(cm, val) {\n            cm.doc.lineSep = val;\n            if (!val) {\n              return;\n            }\n            var newBreaks = [], lineNo2 = cm.doc.first;\n            cm.doc.iter(function(line) {\n              for (var pos = 0; ; ) {\n                var found = line.text.indexOf(val, pos);\n                if (found == -1) {\n                  break;\n                }\n                pos = found + val.length;\n                newBreaks.push(Pos(lineNo2, found));\n              }\n              lineNo2++;\n            });\n            for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {\n              replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));\n            }\n          });\n          option("specialChars", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]/g, function(cm, val, old) {\n            cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");\n            if (old != Init) {\n              cm.refresh();\n            }\n          });\n          option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {\n            return cm.refresh();\n          }, true);\n          option("electricChars", true);\n          option("inputStyle", mobile ? "contenteditable" : "textarea", function() {\n            throw new Error("inputStyle can not (yet) be changed in a running editor");\n          }, true);\n          option("spellcheck", false, function(cm, val) {\n            return cm.getInputField().spellcheck = val;\n          }, true);\n          option("autocorrect", false, function(cm, val) {\n            return cm.getInputField().autocorrect = val;\n          }, true);\n          option("autocapitalize", false, function(cm, val) {\n            return cm.getInputField().autocapitalize = val;\n          }, true);\n          option("rtlMoveVisually", !windows);\n          option("wholeLineUpdateBefore", true);\n          option("theme", "default", function(cm) {\n            themeChanged(cm);\n            updateGutters(cm);\n          }, true);\n          option("keyMap", "default", function(cm, val, old) {\n            var next = getKeyMap(val);\n            var prev = old != Init && getKeyMap(old);\n            if (prev && prev.detach) {\n              prev.detach(cm, next);\n            }\n            if (next.attach) {\n              next.attach(cm, prev || null);\n            }\n          });\n          option("extraKeys", null);\n          option("configureMouse", null);\n          option("lineWrapping", false, wrappingChanged, true);\n          option("gutters", [], function(cm, val) {\n            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n            updateGutters(cm);\n          }, true);\n          option("fixedGutter", true, function(cm, val) {\n            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\n            cm.refresh();\n          }, true);\n          option("coverGutterNextToScrollbar", false, function(cm) {\n            return updateScrollbars(cm);\n          }, true);\n          option("scrollbarStyle", "native", function(cm) {\n            initScrollbars(cm);\n            updateScrollbars(cm);\n            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n          }, true);\n          option("lineNumbers", false, function(cm, val) {\n            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n            updateGutters(cm);\n          }, true);\n          option("firstLineNumber", 1, updateGutters, true);\n          option("lineNumberFormatter", function(integer) {\n            return integer;\n          }, updateGutters, true);\n          option("showCursorWhenSelecting", false, updateSelection, true);\n          option("resetSelectionOnContextMenu", true);\n          option("lineWiseCopyCut", true);\n          option("pasteLinesPerSelection", true);\n          option("selectionsMayTouch", false);\n          option("readOnly", false, function(cm, val) {\n            if (val == "nocursor") {\n              onBlur(cm);\n              cm.display.input.blur();\n            }\n            cm.display.input.readOnlyChanged(val);\n          });\n          option("screenReaderLabel", null, function(cm, val) {\n            val = val === "" ? null : val;\n            cm.display.input.screenReaderLabelChanged(val);\n          });\n          option("disableInput", false, function(cm, val) {\n            if (!val) {\n              cm.display.input.reset();\n            }\n          }, true);\n          option("dragDrop", true, dragDropChanged);\n          option("allowDropFileTypes", null);\n          option("cursorBlinkRate", 530);\n          option("cursorScrollMargin", 0);\n          option("cursorHeight", 1, updateSelection, true);\n          option("singleCursorHeightPerLine", true, updateSelection, true);\n          option("workTime", 100);\n          option("workDelay", 100);\n          option("flattenSpans", true, resetModeState, true);\n          option("addModeClass", false, resetModeState, true);\n          option("pollInterval", 100);\n          option("undoDepth", 200, function(cm, val) {\n            return cm.doc.history.undoDepth = val;\n          });\n          option("historyEventDelay", 1250);\n          option("viewportMargin", 10, function(cm) {\n            return cm.refresh();\n          }, true);\n          option("maxHighlightLength", 1e4, resetModeState, true);\n          option("moveInputWithCursor", true, function(cm, val) {\n            if (!val) {\n              cm.display.input.resetPosition();\n            }\n          });\n          option("tabindex", null, function(cm, val) {\n            return cm.display.input.getField().tabIndex = val || "";\n          });\n          option("autofocus", null);\n          option("direction", "ltr", function(cm, val) {\n            return cm.doc.setDirection(val);\n          }, true);\n          option("phrases", null);\n        }\n        function dragDropChanged(cm, value, old) {\n          var wasOn = old && old != Init;\n          if (!value != !wasOn) {\n            var funcs = cm.display.dragFunctions;\n            var toggle = value ? on : off;\n            toggle(cm.display.scroller, "dragstart", funcs.start);\n            toggle(cm.display.scroller, "dragenter", funcs.enter);\n            toggle(cm.display.scroller, "dragover", funcs.over);\n            toggle(cm.display.scroller, "dragleave", funcs.leave);\n            toggle(cm.display.scroller, "drop", funcs.drop);\n          }\n        }\n        function wrappingChanged(cm) {\n          if (cm.options.lineWrapping) {\n            addClass(cm.display.wrapper, "CodeMirror-wrap");\n            cm.display.sizer.style.minWidth = "";\n            cm.display.sizerWidth = null;\n          } else {\n            rmClass(cm.display.wrapper, "CodeMirror-wrap");\n            findMaxLine(cm);\n          }\n          estimateLineHeights(cm);\n          regChange(cm);\n          clearCaches(cm);\n          setTimeout(function() {\n            return updateScrollbars(cm);\n          }, 100);\n        }\n        function CodeMirror8(place, options2) {\n          var this$1 = this;\n          if (!(this instanceof CodeMirror8)) {\n            return new CodeMirror8(place, options2);\n          }\n          this.options = options2 = options2 ? copyObj(options2) : {};\n          copyObj(defaults2, options2, false);\n          var doc2 = options2.value;\n          if (typeof doc2 == "string") {\n            doc2 = new Doc(doc2, options2.mode, null, options2.lineSeparator, options2.direction);\n          } else if (options2.mode) {\n            doc2.modeOption = options2.mode;\n          }\n          this.doc = doc2;\n          var input = new CodeMirror8.inputStyles[options2.inputStyle](this);\n          var display = this.display = new Display(place, doc2, input, options2);\n          display.wrapper.CodeMirror = this;\n          themeChanged(this);\n          if (options2.lineWrapping) {\n            this.display.wrapper.className += " CodeMirror-wrap";\n          }\n          initScrollbars(this);\n          this.state = {\n            keyMaps: [],\n            // stores maps added by addKeyMap\n            overlays: [],\n            // highlighting overlays, as added by addOverlay\n            modeGen: 0,\n            // bumped when mode/overlay changes, used to invalidate highlighting info\n            overwrite: false,\n            delayingBlurEvent: false,\n            focused: false,\n            suppressEdits: false,\n            // used to disable editing during key handlers when in readOnly mode\n            pasteIncoming: -1,\n            cutIncoming: -1,\n            // help recognize paste/cut edits in input.poll\n            selectingText: false,\n            draggingText: false,\n            highlight: new Delayed(),\n            // stores highlight worker timeout\n            keySeq: null,\n            // Unfinished key sequence\n            specialChars: null\n          };\n          if (options2.autofocus && !mobile) {\n            display.input.focus();\n          }\n          if (ie && ie_version < 11) {\n            setTimeout(function() {\n              return this$1.display.input.reset(true);\n            }, 20);\n          }\n          registerEventHandlers(this);\n          ensureGlobalHandlers();\n          startOperation(this);\n          this.curOp.forceUpdate = true;\n          attachDoc(this, doc2);\n          if (options2.autofocus && !mobile || this.hasFocus()) {\n            setTimeout(function() {\n              if (this$1.hasFocus() && !this$1.state.focused) {\n                onFocus(this$1);\n              }\n            }, 20);\n          } else {\n            onBlur(this);\n          }\n          for (var opt in optionHandlers) {\n            if (optionHandlers.hasOwnProperty(opt)) {\n              optionHandlers[opt](this, options2[opt], Init);\n            }\n          }\n          maybeUpdateLineNumberWidth(this);\n          if (options2.finishInit) {\n            options2.finishInit(this);\n          }\n          for (var i2 = 0; i2 < initHooks.length; ++i2) {\n            initHooks[i2](this);\n          }\n          endOperation(this);\n          if (webkit && options2.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {\n            display.lineDiv.style.textRendering = "auto";\n          }\n        }\n        CodeMirror8.defaults = defaults2;\n        CodeMirror8.optionHandlers = optionHandlers;\n        function registerEventHandlers(cm) {\n          var d = cm.display;\n          on(d.scroller, "mousedown", operation(cm, onMouseDown));\n          if (ie && ie_version < 11) {\n            on(d.scroller, "dblclick", operation(cm, function(e) {\n              if (signalDOMEvent(cm, e)) {\n                return;\n              }\n              var pos = posFromMouse(cm, e);\n              if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n                return;\n              }\n              e_preventDefault(e);\n              var word = cm.findWordAt(pos);\n              extendSelection(cm.doc, word.anchor, word.head);\n            }));\n          } else {\n            on(d.scroller, "dblclick", function(e) {\n              return signalDOMEvent(cm, e) || e_preventDefault(e);\n            });\n          }\n          on(d.scroller, "contextmenu", function(e) {\n            return onContextMenu(cm, e);\n          });\n          on(d.input.getField(), "contextmenu", function(e) {\n            if (!d.scroller.contains(e.target)) {\n              onContextMenu(cm, e);\n            }\n          });\n          var touchFinished, prevTouch = { end: 0 };\n          function finishTouch() {\n            if (d.activeTouch) {\n              touchFinished = setTimeout(function() {\n                return d.activeTouch = null;\n              }, 1e3);\n              prevTouch = d.activeTouch;\n              prevTouch.end = +/* @__PURE__ */ new Date();\n            }\n          }\n          function isMouseLikeTouchEvent(e) {\n            if (e.touches.length != 1) {\n              return false;\n            }\n            var touch = e.touches[0];\n            return touch.radiusX <= 1 && touch.radiusY <= 1;\n          }\n          function farAway(touch, other) {\n            if (other.left == null) {\n              return true;\n            }\n            var dx = other.left - touch.left, dy = other.top - touch.top;\n            return dx * dx + dy * dy > 20 * 20;\n          }\n          on(d.scroller, "touchstart", function(e) {\n            if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n              d.input.ensurePolled();\n              clearTimeout(touchFinished);\n              var now = +/* @__PURE__ */ new Date();\n              d.activeTouch = {\n                start: now,\n                moved: false,\n                prev: now - prevTouch.end <= 300 ? prevTouch : null\n              };\n              if (e.touches.length == 1) {\n                d.activeTouch.left = e.touches[0].pageX;\n                d.activeTouch.top = e.touches[0].pageY;\n              }\n            }\n          });\n          on(d.scroller, "touchmove", function() {\n            if (d.activeTouch) {\n              d.activeTouch.moved = true;\n            }\n          });\n          on(d.scroller, "touchend", function(e) {\n            var touch = d.activeTouch;\n            if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && /* @__PURE__ */ new Date() - touch.start < 300) {\n              var pos = cm.coordsChar(d.activeTouch, "page"), range2;\n              if (!touch.prev || farAway(touch, touch.prev)) {\n                range2 = new Range(pos, pos);\n              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {\n                range2 = cm.findWordAt(pos);\n              } else {\n                range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n              }\n              cm.setSelection(range2.anchor, range2.head);\n              cm.focus();\n              e_preventDefault(e);\n            }\n            finishTouch();\n          });\n          on(d.scroller, "touchcancel", finishTouch);\n          on(d.scroller, "scroll", function() {\n            if (d.scroller.clientHeight) {\n              updateScrollTop(cm, d.scroller.scrollTop);\n              setScrollLeft(cm, d.scroller.scrollLeft, true);\n              signal(cm, "scroll", cm);\n            }\n          });\n          on(d.scroller, "mousewheel", function(e) {\n            return onScrollWheel(cm, e);\n          });\n          on(d.scroller, "DOMMouseScroll", function(e) {\n            return onScrollWheel(cm, e);\n          });\n          on(d.wrapper, "scroll", function() {\n            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n          });\n          d.dragFunctions = {\n            enter: function(e) {\n              if (!signalDOMEvent(cm, e)) {\n                e_stop(e);\n              }\n            },\n            over: function(e) {\n              if (!signalDOMEvent(cm, e)) {\n                onDragOver(cm, e);\n                e_stop(e);\n              }\n            },\n            start: function(e) {\n              return onDragStart(cm, e);\n            },\n            drop: operation(cm, onDrop),\n            leave: function(e) {\n              if (!signalDOMEvent(cm, e)) {\n                clearDragCursor(cm);\n              }\n            }\n          };\n          var inp = d.input.getField();\n          on(inp, "keyup", function(e) {\n            return onKeyUp.call(cm, e);\n          });\n          on(inp, "keydown", operation(cm, onKeyDown));\n          on(inp, "keypress", operation(cm, onKeyPress));\n          on(inp, "focus", function(e) {\n            return onFocus(cm, e);\n          });\n          on(inp, "blur", function(e) {\n            return onBlur(cm, e);\n          });\n        }\n        var initHooks = [];\n        CodeMirror8.defineInitHook = function(f) {\n          return initHooks.push(f);\n        };\n        function indentLine(cm, n, how, aggressive) {\n          var doc2 = cm.doc, state;\n          if (how == null) {\n            how = "add";\n          }\n          if (how == "smart") {\n            if (!doc2.mode.indent) {\n              how = "prev";\n            } else {\n              state = getContextBefore(cm, n).state;\n            }\n          }\n          var tabSize = cm.options.tabSize;\n          var line = getLine(doc2, n), curSpace = countColumn(line.text, null, tabSize);\n          if (line.stateAfter) {\n            line.stateAfter = null;\n          }\n          var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n          if (!aggressive && !/\\S/.test(line.text)) {\n            indentation = 0;\n            how = "not";\n          } else if (how == "smart") {\n            indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n            if (indentation == Pass || indentation > 150) {\n              if (!aggressive) {\n                return;\n              }\n              how = "prev";\n            }\n          }\n          if (how == "prev") {\n            if (n > doc2.first) {\n              indentation = countColumn(getLine(doc2, n - 1).text, null, tabSize);\n            } else {\n              indentation = 0;\n            }\n          } else if (how == "add") {\n            indentation = curSpace + cm.options.indentUnit;\n          } else if (how == "subtract") {\n            indentation = curSpace - cm.options.indentUnit;\n          } else if (typeof how == "number") {\n            indentation = curSpace + how;\n          }\n          indentation = Math.max(0, indentation);\n          var indentString = "", pos = 0;\n          if (cm.options.indentWithTabs) {\n            for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {\n              pos += tabSize;\n              indentString += "\t";\n            }\n          }\n          if (pos < indentation) {\n            indentString += spaceStr(indentation - pos);\n          }\n          if (indentString != curSpaceString) {\n            replaceRange(doc2, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\n            line.stateAfter = null;\n            return true;\n          } else {\n            for (var i$12 = 0; i$12 < doc2.sel.ranges.length; i$12++) {\n              var range2 = doc2.sel.ranges[i$12];\n              if (range2.head.line == n && range2.head.ch < curSpaceString.length) {\n                var pos$1 = Pos(n, curSpaceString.length);\n                replaceOneSelection(doc2, i$12, new Range(pos$1, pos$1));\n                break;\n              }\n            }\n          }\n        }\n        var lastCopied = null;\n        function setLastCopied(newLastCopied) {\n          lastCopied = newLastCopied;\n        }\n        function applyTextInput(cm, inserted, deleted, sel, origin) {\n          var doc2 = cm.doc;\n          cm.display.shift = false;\n          if (!sel) {\n            sel = doc2.sel;\n          }\n          var recent = +/* @__PURE__ */ new Date() - 200;\n          var paste = origin == "paste" || cm.state.pasteIncoming > recent;\n          var textLines = splitLinesAuto(inserted), multiPaste = null;\n          if (paste && sel.ranges.length > 1) {\n            if (lastCopied && lastCopied.text.join("\\n") == inserted) {\n              if (sel.ranges.length % lastCopied.text.length == 0) {\n                multiPaste = [];\n                for (var i2 = 0; i2 < lastCopied.text.length; i2++) {\n                  multiPaste.push(doc2.splitLines(lastCopied.text[i2]));\n                }\n              }\n            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n              multiPaste = map2(textLines, function(l) {\n                return [l];\n              });\n            }\n          }\n          var updateInput = cm.curOp.updateInput;\n          for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {\n            var range2 = sel.ranges[i$12];\n            var from = range2.from(), to = range2.to();\n            if (range2.empty()) {\n              if (deleted && deleted > 0) {\n                from = Pos(from.line, from.ch - deleted);\n              } else if (cm.state.overwrite && !paste) {\n                to = Pos(to.line, Math.min(getLine(doc2, to.line).text.length, to.ch + lst(textLines).length));\n              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\\n") == textLines.join("\\n")) {\n                from = to = Pos(from.line, 0);\n              }\n            }\n            var changeEvent = {\n              from,\n              to,\n              text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,\n              origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")\n            };\n            makeChange(cm.doc, changeEvent);\n            signalLater(cm, "inputRead", cm, changeEvent);\n          }\n          if (inserted && !paste) {\n            triggerElectric(cm, inserted);\n          }\n          ensureCursorVisible(cm);\n          if (cm.curOp.updateInput < 2) {\n            cm.curOp.updateInput = updateInput;\n          }\n          cm.curOp.typing = true;\n          cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n        }\n        function handlePaste(e, cm) {\n          var pasted = e.clipboardData && e.clipboardData.getData("Text");\n          if (pasted) {\n            e.preventDefault();\n            if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {\n              runInOp(cm, function() {\n                return applyTextInput(cm, pasted, 0, null, "paste");\n              });\n            }\n            return true;\n          }\n        }\n        function triggerElectric(cm, inserted) {\n          if (!cm.options.electricChars || !cm.options.smartIndent) {\n            return;\n          }\n          var sel = cm.doc.sel;\n          for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {\n            var range2 = sel.ranges[i2];\n            if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {\n              continue;\n            }\n            var mode = cm.getModeAt(range2.head);\n            var indented = false;\n            if (mode.electricChars) {\n              for (var j2 = 0; j2 < mode.electricChars.length; j2++) {\n                if (inserted.indexOf(mode.electricChars.charAt(j2)) > -1) {\n                  indented = indentLine(cm, range2.head.line, "smart");\n                  break;\n                }\n              }\n            } else if (mode.electricInput) {\n              if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {\n                indented = indentLine(cm, range2.head.line, "smart");\n              }\n            }\n            if (indented) {\n              signalLater(cm, "electricInput", cm, range2.head.line);\n            }\n          }\n        }\n        function copyableRanges(cm) {\n          var text = [], ranges = [];\n          for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {\n            var line = cm.doc.sel.ranges[i2].head.line;\n            var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };\n            ranges.push(lineRange);\n            text.push(cm.getRange(lineRange.anchor, lineRange.head));\n          }\n          return { text, ranges };\n        }\n        function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n          field.setAttribute("autocorrect", autocorrect ? "on" : "off");\n          field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");\n          field.setAttribute("spellcheck", !!spellcheck);\n        }\n        function hiddenTextarea() {\n          var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");\n          var div2 = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\n          if (webkit) {\n            te.style.width = "1000px";\n          } else {\n            te.setAttribute("wrap", "off");\n          }\n          if (ios) {\n            te.style.border = "1px solid black";\n          }\n          return div2;\n        }\n        function addEditorMethods(CodeMirror9) {\n          var optionHandlers2 = CodeMirror9.optionHandlers;\n          var helpers = CodeMirror9.helpers = {};\n          CodeMirror9.prototype = {\n            constructor: CodeMirror9,\n            focus: function() {\n              win(this).focus();\n              this.display.input.focus();\n            },\n            setOption: function(option, value) {\n              var options2 = this.options, old = options2[option];\n              if (options2[option] == value && option != "mode") {\n                return;\n              }\n              options2[option] = value;\n              if (optionHandlers2.hasOwnProperty(option)) {\n                operation(this, optionHandlers2[option])(this, value, old);\n              }\n              signal(this, "optionChange", this, option);\n            },\n            getOption: function(option) {\n              return this.options[option];\n            },\n            getDoc: function() {\n              return this.doc;\n            },\n            addKeyMap: function(map3, bottom) {\n              this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map3));\n            },\n            removeKeyMap: function(map3) {\n              var maps = this.state.keyMaps;\n              for (var i2 = 0; i2 < maps.length; ++i2) {\n                if (maps[i2] == map3 || maps[i2].name == map3) {\n                  maps.splice(i2, 1);\n                  return true;\n                }\n              }\n            },\n            addOverlay: methodOp(function(spec, options2) {\n              var mode = spec.token ? spec : CodeMirror9.getMode(this.options, spec);\n              if (mode.startState) {\n                throw new Error("Overlays may not be stateful.");\n              }\n              insertSorted(\n                this.state.overlays,\n                {\n                  mode,\n                  modeSpec: spec,\n                  opaque: options2 && options2.opaque,\n                  priority: options2 && options2.priority || 0\n                },\n                function(overlay) {\n                  return overlay.priority;\n                }\n              );\n              this.state.modeGen++;\n              regChange(this);\n            }),\n            removeOverlay: methodOp(function(spec) {\n              var overlays = this.state.overlays;\n              for (var i2 = 0; i2 < overlays.length; ++i2) {\n                var cur = overlays[i2].modeSpec;\n                if (cur == spec || typeof spec == "string" && cur.name == spec) {\n                  overlays.splice(i2, 1);\n                  this.state.modeGen++;\n                  regChange(this);\n                  return;\n                }\n              }\n            }),\n            indentLine: methodOp(function(n, dir, aggressive) {\n              if (typeof dir != "string" && typeof dir != "number") {\n                if (dir == null) {\n                  dir = this.options.smartIndent ? "smart" : "prev";\n                } else {\n                  dir = dir ? "add" : "subtract";\n                }\n              }\n              if (isLine(this.doc, n)) {\n                indentLine(this, n, dir, aggressive);\n              }\n            }),\n            indentSelection: methodOp(function(how) {\n              var ranges = this.doc.sel.ranges, end = -1;\n              for (var i2 = 0; i2 < ranges.length; i2++) {\n                var range2 = ranges[i2];\n                if (!range2.empty()) {\n                  var from = range2.from(), to = range2.to();\n                  var start = Math.max(end, from.line);\n                  end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n                  for (var j2 = start; j2 < end; ++j2) {\n                    indentLine(this, j2, how);\n                  }\n                  var newRanges = this.doc.sel.ranges;\n                  if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {\n                    replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);\n                  }\n                } else if (range2.head.line > end) {\n                  indentLine(this, range2.head.line, how, true);\n                  end = range2.head.line;\n                  if (i2 == this.doc.sel.primIndex) {\n                    ensureCursorVisible(this);\n                  }\n                }\n              }\n            }),\n            // Fetch the parser token for a given character. Useful for hacks\n            // that want to inspect the mode state (say, for completion).\n            getTokenAt: function(pos, precise) {\n              return takeToken(this, pos, precise);\n            },\n            getLineTokens: function(line, precise) {\n              return takeToken(this, Pos(line), precise, true);\n            },\n            getTokenTypeAt: function(pos) {\n              pos = clipPos(this.doc, pos);\n              var styles3 = getLineStyles(this, getLine(this.doc, pos.line));\n              var before = 0, after = (styles3.length - 1) / 2, ch = pos.ch;\n              var type;\n              if (ch == 0) {\n                type = styles3[2];\n              } else {\n                for (; ; ) {\n                  var mid = before + after >> 1;\n                  if ((mid ? styles3[mid * 2 - 1] : 0) >= ch) {\n                    after = mid;\n                  } else if (styles3[mid * 2 + 1] < ch) {\n                    before = mid + 1;\n                  } else {\n                    type = styles3[mid * 2 + 2];\n                    break;\n                  }\n                }\n              }\n              var cut = type ? type.indexOf("overlay ") : -1;\n              return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n            },\n            getModeAt: function(pos) {\n              var mode = this.doc.mode;\n              if (!mode.innerMode) {\n                return mode;\n              }\n              return CodeMirror9.innerMode(mode, this.getTokenAt(pos).state).mode;\n            },\n            getHelper: function(pos, type) {\n              return this.getHelpers(pos, type)[0];\n            },\n            getHelpers: function(pos, type) {\n              var found = [];\n              if (!helpers.hasOwnProperty(type)) {\n                return found;\n              }\n              var help = helpers[type], mode = this.getModeAt(pos);\n              if (typeof mode[type] == "string") {\n                if (help[mode[type]]) {\n                  found.push(help[mode[type]]);\n                }\n              } else if (mode[type]) {\n                for (var i2 = 0; i2 < mode[type].length; i2++) {\n                  var val = help[mode[type][i2]];\n                  if (val) {\n                    found.push(val);\n                  }\n                }\n              } else if (mode.helperType && help[mode.helperType]) {\n                found.push(help[mode.helperType]);\n              } else if (help[mode.name]) {\n                found.push(help[mode.name]);\n              }\n              for (var i$12 = 0; i$12 < help._global.length; i$12++) {\n                var cur = help._global[i$12];\n                if (cur.pred(mode, this) && indexOf2(found, cur.val) == -1) {\n                  found.push(cur.val);\n                }\n              }\n              return found;\n            },\n            getStateAfter: function(line, precise) {\n              var doc2 = this.doc;\n              line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);\n              return getContextBefore(this, line + 1, precise).state;\n            },\n            cursorCoords: function(start, mode) {\n              var pos, range2 = this.doc.sel.primary();\n              if (start == null) {\n                pos = range2.head;\n              } else if (typeof start == "object") {\n                pos = clipPos(this.doc, start);\n              } else {\n                pos = start ? range2.from() : range2.to();\n              }\n              return cursorCoords(this, pos, mode || "page");\n            },\n            charCoords: function(pos, mode) {\n              return charCoords(this, clipPos(this.doc, pos), mode || "page");\n            },\n            coordsChar: function(coords, mode) {\n              coords = fromCoordSystem(this, coords, mode || "page");\n              return coordsChar(this, coords.left, coords.top);\n            },\n            lineAtHeight: function(height, mode) {\n              height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;\n              return lineAtHeight(this.doc, height + this.display.viewOffset);\n            },\n            heightAtLine: function(line, mode, includeWidgets) {\n              var end = false, lineObj;\n              if (typeof line == "number") {\n                var last = this.doc.first + this.doc.size - 1;\n                if (line < this.doc.first) {\n                  line = this.doc.first;\n                } else if (line > last) {\n                  line = last;\n                  end = true;\n                }\n                lineObj = getLine(this.doc, line);\n              } else {\n                lineObj = line;\n              }\n              return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);\n            },\n            defaultTextHeight: function() {\n              return textHeight(this.display);\n            },\n            defaultCharWidth: function() {\n              return charWidth(this.display);\n            },\n            getViewport: function() {\n              return { from: this.display.viewFrom, to: this.display.viewTo };\n            },\n            addWidget: function(pos, node, scroll, vert, horiz) {\n              var display = this.display;\n              pos = cursorCoords(this, clipPos(this.doc, pos));\n              var top = pos.bottom, left = pos.left;\n              node.style.position = "absolute";\n              node.setAttribute("cm-ignore-events", "true");\n              this.display.input.setUneditable(node);\n              display.sizer.appendChild(node);\n              if (vert == "over") {\n                top = pos.top;\n              } else if (vert == "above" || vert == "near") {\n                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n                if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n                  top = pos.top - node.offsetHeight;\n                } else if (pos.bottom + node.offsetHeight <= vspace) {\n                  top = pos.bottom;\n                }\n                if (left + node.offsetWidth > hspace) {\n                  left = hspace - node.offsetWidth;\n                }\n              }\n              node.style.top = top + "px";\n              node.style.left = node.style.right = "";\n              if (horiz == "right") {\n                left = display.sizer.clientWidth - node.offsetWidth;\n                node.style.right = "0px";\n              } else {\n                if (horiz == "left") {\n                  left = 0;\n                } else if (horiz == "middle") {\n                  left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n                }\n                node.style.left = left + "px";\n              }\n              if (scroll) {\n                scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });\n              }\n            },\n            triggerOnKeyDown: methodOp(onKeyDown),\n            triggerOnKeyPress: methodOp(onKeyPress),\n            triggerOnKeyUp: onKeyUp,\n            triggerOnMouseDown: methodOp(onMouseDown),\n            execCommand: function(cmd) {\n              if (commands.hasOwnProperty(cmd)) {\n                return commands[cmd].call(null, this);\n              }\n            },\n            triggerElectric: methodOp(function(text) {\n              triggerElectric(this, text);\n            }),\n            findPosH: function(from, amount, unit, visually) {\n              var dir = 1;\n              if (amount < 0) {\n                dir = -1;\n                amount = -amount;\n              }\n              var cur = clipPos(this.doc, from);\n              for (var i2 = 0; i2 < amount; ++i2) {\n                cur = findPosH(this.doc, cur, dir, unit, visually);\n                if (cur.hitSide) {\n                  break;\n                }\n              }\n              return cur;\n            },\n            moveH: methodOp(function(dir, unit) {\n              var this$1 = this;\n              this.extendSelectionsBy(function(range2) {\n                if (this$1.display.shift || this$1.doc.extend || range2.empty()) {\n                  return findPosH(this$1.doc, range2.head, dir, unit, this$1.options.rtlMoveVisually);\n                } else {\n                  return dir < 0 ? range2.from() : range2.to();\n                }\n              }, sel_move);\n            }),\n            deleteH: methodOp(function(dir, unit) {\n              var sel = this.doc.sel, doc2 = this.doc;\n              if (sel.somethingSelected()) {\n                doc2.replaceSelection("", null, "+delete");\n              } else {\n                deleteNearSelection(this, function(range2) {\n                  var other = findPosH(doc2, range2.head, dir, unit, false);\n                  return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };\n                });\n              }\n            }),\n            findPosV: function(from, amount, unit, goalColumn) {\n              var dir = 1, x = goalColumn;\n              if (amount < 0) {\n                dir = -1;\n                amount = -amount;\n              }\n              var cur = clipPos(this.doc, from);\n              for (var i2 = 0; i2 < amount; ++i2) {\n                var coords = cursorCoords(this, cur, "div");\n                if (x == null) {\n                  x = coords.left;\n                } else {\n                  coords.left = x;\n                }\n                cur = findPosV(this, coords, dir, unit);\n                if (cur.hitSide) {\n                  break;\n                }\n              }\n              return cur;\n            },\n            moveV: methodOp(function(dir, unit) {\n              var this$1 = this;\n              var doc2 = this.doc, goals = [];\n              var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();\n              doc2.extendSelectionsBy(function(range2) {\n                if (collapse) {\n                  return dir < 0 ? range2.from() : range2.to();\n                }\n                var headPos = cursorCoords(this$1, range2.head, "div");\n                if (range2.goalColumn != null) {\n                  headPos.left = range2.goalColumn;\n                }\n                goals.push(headPos.left);\n                var pos = findPosV(this$1, headPos, dir, unit);\n                if (unit == "page" && range2 == doc2.sel.primary()) {\n                  addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);\n                }\n                return pos;\n              }, sel_move);\n              if (goals.length) {\n                for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {\n                  doc2.sel.ranges[i2].goalColumn = goals[i2];\n                }\n              }\n            }),\n            // Find the word at the given position (as returned by coordsChar).\n            findWordAt: function(pos) {\n              var doc2 = this.doc, line = getLine(doc2, pos.line).text;\n              var start = pos.ch, end = pos.ch;\n              if (line) {\n                var helper = this.getHelper(pos, "wordChars");\n                if ((pos.sticky == "before" || end == line.length) && start) {\n                  --start;\n                } else {\n                  ++end;\n                }\n                var startChar = line.charAt(start);\n                var check = isWordChar(startChar, helper) ? function(ch) {\n                  return isWordChar(ch, helper);\n                } : /\\s/.test(startChar) ? function(ch) {\n                  return /\\s/.test(ch);\n                } : function(ch) {\n                  return !/\\s/.test(ch) && !isWordChar(ch);\n                };\n                while (start > 0 && check(line.charAt(start - 1))) {\n                  --start;\n                }\n                while (end < line.length && check(line.charAt(end))) {\n                  ++end;\n                }\n              }\n              return new Range(Pos(pos.line, start), Pos(pos.line, end));\n            },\n            toggleOverwrite: function(value) {\n              if (value != null && value == this.state.overwrite) {\n                return;\n              }\n              if (this.state.overwrite = !this.state.overwrite) {\n                addClass(this.display.cursorDiv, "CodeMirror-overwrite");\n              } else {\n                rmClass(this.display.cursorDiv, "CodeMirror-overwrite");\n              }\n              signal(this, "overwriteToggle", this, this.state.overwrite);\n            },\n            hasFocus: function() {\n              return this.display.input.getField() == activeElt(root(this));\n            },\n            isReadOnly: function() {\n              return !!(this.options.readOnly || this.doc.cantEdit);\n            },\n            scrollTo: methodOp(function(x, y2) {\n              scrollToCoords(this, x, y2);\n            }),\n            getScrollInfo: function() {\n              var scroller = this.display.scroller;\n              return {\n                left: scroller.scrollLeft,\n                top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this),\n                clientWidth: displayWidth(this)\n              };\n            },\n            scrollIntoView: methodOp(function(range2, margin) {\n              if (range2 == null) {\n                range2 = { from: this.doc.sel.primary().head, to: null };\n                if (margin == null) {\n                  margin = this.options.cursorScrollMargin;\n                }\n              } else if (typeof range2 == "number") {\n                range2 = { from: Pos(range2, 0), to: null };\n              } else if (range2.from == null) {\n                range2 = { from: range2, to: null };\n              }\n              if (!range2.to) {\n                range2.to = range2.from;\n              }\n              range2.margin = margin || 0;\n              if (range2.from.line != null) {\n                scrollToRange(this, range2);\n              } else {\n                scrollToCoordsRange(this, range2.from, range2.to, range2.margin);\n              }\n            }),\n            setSize: methodOp(function(width, height) {\n              var this$1 = this;\n              var interpret = function(val) {\n                return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val;\n              };\n              if (width != null) {\n                this.display.wrapper.style.width = interpret(width);\n              }\n              if (height != null) {\n                this.display.wrapper.style.height = interpret(height);\n              }\n              if (this.options.lineWrapping) {\n                clearLineMeasurementCache(this);\n              }\n              var lineNo2 = this.display.viewFrom;\n              this.doc.iter(lineNo2, this.display.viewTo, function(line) {\n                if (line.widgets) {\n                  for (var i2 = 0; i2 < line.widgets.length; i2++) {\n                    if (line.widgets[i2].noHScroll) {\n                      regLineChange(this$1, lineNo2, "widget");\n                      break;\n                    }\n                  }\n                }\n                ++lineNo2;\n              });\n              this.curOp.forceUpdate = true;\n              signal(this, "refresh", this);\n            }),\n            operation: function(f) {\n              return runInOp(this, f);\n            },\n            startOperation: function() {\n              return startOperation(this);\n            },\n            endOperation: function() {\n              return endOperation(this);\n            },\n            refresh: methodOp(function() {\n              var oldHeight = this.display.cachedTextHeight;\n              regChange(this);\n              this.curOp.forceUpdate = true;\n              clearCaches(this);\n              scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n              updateGutterSpace(this.display);\n              if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {\n                estimateLineHeights(this);\n              }\n              signal(this, "refresh", this);\n            }),\n            swapDoc: methodOp(function(doc2) {\n              var old = this.doc;\n              old.cm = null;\n              if (this.state.selectingText) {\n                this.state.selectingText();\n              }\n              attachDoc(this, doc2);\n              clearCaches(this);\n              this.display.input.reset();\n              scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);\n              this.curOp.forceScroll = true;\n              signalLater(this, "swapDoc", this, old);\n              return old;\n            }),\n            phrase: function(phraseText) {\n              var phrases = this.options.phrases;\n              return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n            },\n            getInputField: function() {\n              return this.display.input.getField();\n            },\n            getWrapperElement: function() {\n              return this.display.wrapper;\n            },\n            getScrollerElement: function() {\n              return this.display.scroller;\n            },\n            getGutterElement: function() {\n              return this.display.gutters;\n            }\n          };\n          eventMixin(CodeMirror9);\n          CodeMirror9.registerHelper = function(type, name, value) {\n            if (!helpers.hasOwnProperty(type)) {\n              helpers[type] = CodeMirror9[type] = { _global: [] };\n            }\n            helpers[type][name] = value;\n          };\n          CodeMirror9.registerGlobalHelper = function(type, name, predicate, value) {\n            CodeMirror9.registerHelper(type, name, value);\n            helpers[type]._global.push({ pred: predicate, val: value });\n          };\n        }\n        function findPosH(doc2, pos, dir, unit, visually) {\n          var oldPos = pos;\n          var origDir = dir;\n          var lineObj = getLine(doc2, pos.line);\n          var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;\n          function findNextLine() {\n            var l = pos.line + lineDir;\n            if (l < doc2.first || l >= doc2.first + doc2.size) {\n              return false;\n            }\n            pos = new Pos(l, pos.ch, pos.sticky);\n            return lineObj = getLine(doc2, l);\n          }\n          function moveOnce(boundToLine) {\n            var next;\n            if (unit == "codepoint") {\n              var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n              if (isNaN(ch)) {\n                next = null;\n              } else {\n                var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;\n                next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n              }\n            } else if (visually) {\n              next = moveVisually(doc2.cm, lineObj, pos, dir);\n            } else {\n              next = moveLogically(lineObj, pos, dir);\n            }\n            if (next == null) {\n              if (!boundToLine && findNextLine()) {\n                pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);\n              } else {\n                return false;\n              }\n            } else {\n              pos = next;\n            }\n            return true;\n          }\n          if (unit == "char" || unit == "codepoint") {\n            moveOnce();\n          } else if (unit == "column") {\n            moveOnce(true);\n          } else if (unit == "word" || unit == "group") {\n            var sawType = null, group = unit == "group";\n            var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");\n            for (var first = true; ; first = false) {\n              if (dir < 0 && !moveOnce(!first)) {\n                break;\n              }\n              var cur = lineObj.text.charAt(pos.ch) || "\\n";\n              var type = isWordChar(cur, helper) ? "w" : group && cur == "\\n" ? "n" : !group || /\\s/.test(cur) ? null : "p";\n              if (group && !first && !type) {\n                type = "s";\n              }\n              if (sawType && sawType != type) {\n                if (dir < 0) {\n                  dir = 1;\n                  moveOnce();\n                  pos.sticky = "after";\n                }\n                break;\n              }\n              if (type) {\n                sawType = type;\n              }\n              if (dir > 0 && !moveOnce(!first)) {\n                break;\n              }\n            }\n          }\n          var result = skipAtomic(doc2, pos, oldPos, origDir, true);\n          if (equalCursorPos(oldPos, result)) {\n            result.hitSide = true;\n          }\n          return result;\n        }\n        function findPosV(cm, pos, dir, unit) {\n          var doc2 = cm.doc, x = pos.left, y2;\n          if (unit == "page") {\n            var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc2(cm).documentElement.clientHeight);\n            var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);\n            y2 = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n          } else if (unit == "line") {\n            y2 = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n          }\n          var target;\n          for (; ; ) {\n            target = coordsChar(cm, x, y2);\n            if (!target.outside) {\n              break;\n            }\n            if (dir < 0 ? y2 <= 0 : y2 >= doc2.height) {\n              target.hitSide = true;\n              break;\n            }\n            y2 += dir * 5;\n          }\n          return target;\n        }\n        var ContentEditableInput = function(cm) {\n          this.cm = cm;\n          this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n          this.polling = new Delayed();\n          this.composing = null;\n          this.gracePeriod = false;\n          this.readDOMTimeout = null;\n        };\n        ContentEditableInput.prototype.init = function(display) {\n          var this$1 = this;\n          var input = this, cm = input.cm;\n          var div2 = input.div = display.lineDiv;\n          div2.contentEditable = true;\n          disableBrowserMagic(div2, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n          function belongsToInput(e) {\n            for (var t = e.target; t; t = t.parentNode) {\n              if (t == div2) {\n                return true;\n              }\n              if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {\n                break;\n              }\n            }\n            return false;\n          }\n          on(div2, "paste", function(e) {\n            if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n              return;\n            }\n            if (ie_version <= 11) {\n              setTimeout(operation(cm, function() {\n                return this$1.updateFromDOM();\n              }), 20);\n            }\n          });\n          on(div2, "compositionstart", function(e) {\n            this$1.composing = { data: e.data, done: false };\n          });\n          on(div2, "compositionupdate", function(e) {\n            if (!this$1.composing) {\n              this$1.composing = { data: e.data, done: false };\n            }\n          });\n          on(div2, "compositionend", function(e) {\n            if (this$1.composing) {\n              if (e.data != this$1.composing.data) {\n                this$1.readFromDOMSoon();\n              }\n              this$1.composing.done = true;\n            }\n          });\n          on(div2, "touchstart", function() {\n            return input.forceCompositionEnd();\n          });\n          on(div2, "input", function() {\n            if (!this$1.composing) {\n              this$1.readFromDOMSoon();\n            }\n          });\n          function onCopyCut(e) {\n            if (!belongsToInput(e) || signalDOMEvent(cm, e)) {\n              return;\n            }\n            if (cm.somethingSelected()) {\n              setLastCopied({ lineWise: false, text: cm.getSelections() });\n              if (e.type == "cut") {\n                cm.replaceSelection("", null, "cut");\n              }\n            } else if (!cm.options.lineWiseCopyCut) {\n              return;\n            } else {\n              var ranges = copyableRanges(cm);\n              setLastCopied({ lineWise: true, text: ranges.text });\n              if (e.type == "cut") {\n                cm.operation(function() {\n                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n                  cm.replaceSelection("", null, "cut");\n                });\n              }\n            }\n            if (e.clipboardData) {\n              e.clipboardData.clearData();\n              var content = lastCopied.text.join("\\n");\n              e.clipboardData.setData("Text", content);\n              if (e.clipboardData.getData("Text") == content) {\n                e.preventDefault();\n                return;\n              }\n            }\n            var kludge = hiddenTextarea(), te = kludge.firstChild;\n            disableBrowserMagic(te);\n            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n            te.value = lastCopied.text.join("\\n");\n            var hadFocus = activeElt(rootNode(div2));\n            selectInput(te);\n            setTimeout(function() {\n              cm.display.lineSpace.removeChild(kludge);\n              hadFocus.focus();\n              if (hadFocus == div2) {\n                input.showPrimarySelection();\n              }\n            }, 50);\n          }\n          on(div2, "copy", onCopyCut);\n          on(div2, "cut", onCopyCut);\n        };\n        ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {\n          if (label) {\n            this.div.setAttribute("aria-label", label);\n          } else {\n            this.div.removeAttribute("aria-label");\n          }\n        };\n        ContentEditableInput.prototype.prepareSelection = function() {\n          var result = prepareSelection(this.cm, false);\n          result.focus = activeElt(rootNode(this.div)) == this.div;\n          return result;\n        };\n        ContentEditableInput.prototype.showSelection = function(info, takeFocus) {\n          if (!info || !this.cm.display.view.length) {\n            return;\n          }\n          if (info.focus || takeFocus) {\n            this.showPrimarySelection();\n          }\n          this.showMultipleSelections(info);\n        };\n        ContentEditableInput.prototype.getSelection = function() {\n          return this.cm.display.wrapper.ownerDocument.getSelection();\n        };\n        ContentEditableInput.prototype.showPrimarySelection = function() {\n          var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n          var from = prim.from(), to = prim.to();\n          if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n            sel.removeAllRanges();\n            return;\n          }\n          var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n          var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp2(minPos(curAnchor, curFocus), from) == 0 && cmp2(maxPos(curAnchor, curFocus), to) == 0) {\n            return;\n          }\n          var view = cm.display.view;\n          var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };\n          var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n          if (!end) {\n            var measure = view[view.length - 1].measure;\n            var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n            end = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };\n          }\n          if (!start || !end) {\n            sel.removeAllRanges();\n            return;\n          }\n          var old = sel.rangeCount && sel.getRangeAt(0), rng;\n          try {\n            rng = range(start.node, start.offset, end.offset, end.node);\n          } catch (e) {\n          }\n          if (rng) {\n            if (!gecko && cm.state.focused) {\n              sel.collapse(start.node, start.offset);\n              if (!rng.collapsed) {\n                sel.removeAllRanges();\n                sel.addRange(rng);\n              }\n            } else {\n              sel.removeAllRanges();\n              sel.addRange(rng);\n            }\n            if (old && sel.anchorNode == null) {\n              sel.addRange(old);\n            } else if (gecko) {\n              this.startGracePeriod();\n            }\n          }\n          this.rememberSelection();\n        };\n        ContentEditableInput.prototype.startGracePeriod = function() {\n          var this$1 = this;\n          clearTimeout(this.gracePeriod);\n          this.gracePeriod = setTimeout(function() {\n            this$1.gracePeriod = false;\n            if (this$1.selectionChanged()) {\n              this$1.cm.operation(function() {\n                return this$1.cm.curOp.selectionChanged = true;\n              });\n            }\n          }, 20);\n        };\n        ContentEditableInput.prototype.showMultipleSelections = function(info) {\n          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n        };\n        ContentEditableInput.prototype.rememberSelection = function() {\n          var sel = this.getSelection();\n          this.lastAnchorNode = sel.anchorNode;\n          this.lastAnchorOffset = sel.anchorOffset;\n          this.lastFocusNode = sel.focusNode;\n          this.lastFocusOffset = sel.focusOffset;\n        };\n        ContentEditableInput.prototype.selectionInEditor = function() {\n          var sel = this.getSelection();\n          if (!sel.rangeCount) {\n            return false;\n          }\n          var node = sel.getRangeAt(0).commonAncestorContainer;\n          return contains(this.div, node);\n        };\n        ContentEditableInput.prototype.focus = function() {\n          if (this.cm.options.readOnly != "nocursor") {\n            if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div) {\n              this.showSelection(this.prepareSelection(), true);\n            }\n            this.div.focus();\n          }\n        };\n        ContentEditableInput.prototype.blur = function() {\n          this.div.blur();\n        };\n        ContentEditableInput.prototype.getField = function() {\n          return this.div;\n        };\n        ContentEditableInput.prototype.supportsTouch = function() {\n          return true;\n        };\n        ContentEditableInput.prototype.receivedFocus = function() {\n          var this$1 = this;\n          var input = this;\n          if (this.selectionInEditor()) {\n            setTimeout(function() {\n              return this$1.pollSelection();\n            }, 20);\n          } else {\n            runInOp(this.cm, function() {\n              return input.cm.curOp.selectionChanged = true;\n            });\n          }\n          function poll() {\n            if (input.cm.state.focused) {\n              input.pollSelection();\n              input.polling.set(input.cm.options.pollInterval, poll);\n            }\n          }\n          this.polling.set(this.cm.options.pollInterval, poll);\n        };\n        ContentEditableInput.prototype.selectionChanged = function() {\n          var sel = this.getSelection();\n          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n        };\n        ContentEditableInput.prototype.pollSelection = function() {\n          if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n            return;\n          }\n          var sel = this.getSelection(), cm = this.cm;\n          if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });\n            this.blur();\n            this.focus();\n            return;\n          }\n          if (this.composing) {\n            return;\n          }\n          this.rememberSelection();\n          var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n          var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n          if (anchor && head) {\n            runInOp(cm, function() {\n              setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n              if (anchor.bad || head.bad) {\n                cm.curOp.selectionChanged = true;\n              }\n            });\n          }\n        };\n        ContentEditableInput.prototype.pollContent = function() {\n          if (this.readDOMTimeout != null) {\n            clearTimeout(this.readDOMTimeout);\n            this.readDOMTimeout = null;\n          }\n          var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n          var from = sel.from(), to = sel.to();\n          if (from.ch == 0 && from.line > cm.firstLine()) {\n            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);\n          }\n          if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n            to = Pos(to.line + 1, 0);\n          }\n          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n            return false;\n          }\n          var fromIndex, fromLine, fromNode;\n          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n            fromLine = lineNo(display.view[0].line);\n            fromNode = display.view[0].node;\n          } else {\n            fromLine = lineNo(display.view[fromIndex].line);\n            fromNode = display.view[fromIndex - 1].node.nextSibling;\n          }\n          var toIndex = findViewIndex(cm, to.line);\n          var toLine, toNode;\n          if (toIndex == display.view.length - 1) {\n            toLine = display.viewTo - 1;\n            toNode = display.lineDiv.lastChild;\n          } else {\n            toLine = lineNo(display.view[toIndex + 1].line) - 1;\n            toNode = display.view[toIndex + 1].node.previousSibling;\n          }\n          if (!fromNode) {\n            return false;\n          }\n          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n          while (newText.length > 1 && oldText.length > 1) {\n            if (lst(newText) == lst(oldText)) {\n              newText.pop();\n              oldText.pop();\n              toLine--;\n            } else if (newText[0] == oldText[0]) {\n              newText.shift();\n              oldText.shift();\n              fromLine++;\n            } else {\n              break;\n            }\n          }\n          var cutFront = 0, cutEnd = 0;\n          var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {\n            ++cutFront;\n          }\n          var newBot = lst(newText), oldBot = lst(oldText);\n          var maxCutEnd = Math.min(\n            newBot.length - (newText.length == 1 ? cutFront : 0),\n            oldBot.length - (oldText.length == 1 ? cutFront : 0)\n          );\n          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n            ++cutEnd;\n          }\n          if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n            while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n              cutFront--;\n              cutEnd++;\n            }\n          }\n          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, "");\n          newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, "");\n          var chFrom = Pos(fromLine, cutFront);\n          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n          if (newText.length > 1 || newText[0] || cmp2(chFrom, chTo)) {\n            replaceRange(cm.doc, newText, chFrom, chTo, "+input");\n            return true;\n          }\n        };\n        ContentEditableInput.prototype.ensurePolled = function() {\n          this.forceCompositionEnd();\n        };\n        ContentEditableInput.prototype.reset = function() {\n          this.forceCompositionEnd();\n        };\n        ContentEditableInput.prototype.forceCompositionEnd = function() {\n          if (!this.composing) {\n            return;\n          }\n          clearTimeout(this.readDOMTimeout);\n          this.composing = null;\n          this.updateFromDOM();\n          this.div.blur();\n          this.div.focus();\n        };\n        ContentEditableInput.prototype.readFromDOMSoon = function() {\n          var this$1 = this;\n          if (this.readDOMTimeout != null) {\n            return;\n          }\n          this.readDOMTimeout = setTimeout(function() {\n            this$1.readDOMTimeout = null;\n            if (this$1.composing) {\n              if (this$1.composing.done) {\n                this$1.composing = null;\n              } else {\n                return;\n              }\n            }\n            this$1.updateFromDOM();\n          }, 80);\n        };\n        ContentEditableInput.prototype.updateFromDOM = function() {\n          var this$1 = this;\n          if (this.cm.isReadOnly() || !this.pollContent()) {\n            runInOp(this.cm, function() {\n              return regChange(this$1.cm);\n            });\n          }\n        };\n        ContentEditableInput.prototype.setUneditable = function(node) {\n          node.contentEditable = "false";\n        };\n        ContentEditableInput.prototype.onKeyPress = function(e) {\n          if (e.charCode == 0 || this.composing) {\n            return;\n          }\n          e.preventDefault();\n          if (!this.cm.isReadOnly()) {\n            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n          }\n        };\n        ContentEditableInput.prototype.readOnlyChanged = function(val) {\n          this.div.contentEditable = String(val != "nocursor");\n        };\n        ContentEditableInput.prototype.onContextMenu = function() {\n        };\n        ContentEditableInput.prototype.resetPosition = function() {\n        };\n        ContentEditableInput.prototype.needsContentAttribute = true;\n        function posToDOM(cm, pos) {\n          var view = findViewForLine(cm, pos.line);\n          if (!view || view.hidden) {\n            return null;\n          }\n          var line = getLine(cm.doc, pos.line);\n          var info = mapFromLineView(view, line, pos.line);\n          var order = getOrder2(line, cm.doc.direction), side = "left";\n          if (order) {\n            var partPos = getBidiPartAt(order, pos.ch);\n            side = partPos % 2 ? "right" : "left";\n          }\n          var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n          result.offset = result.collapse == "right" ? result.end : result.start;\n          return result;\n        }\n        function isInGutter(node) {\n          for (var scan = node; scan; scan = scan.parentNode) {\n            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function badPos(pos, bad) {\n          if (bad) {\n            pos.bad = true;\n          }\n          return pos;\n        }\n        function domTextBetween(cm, from, to, fromLine, toLine) {\n          var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n          function recognizeMarker(id) {\n            return function(marker) {\n              return marker.id == id;\n            };\n          }\n          function close() {\n            if (closing) {\n              text += lineSep;\n              if (extraLinebreak) {\n                text += lineSep;\n              }\n              closing = extraLinebreak = false;\n            }\n          }\n          function addText(str) {\n            if (str) {\n              close();\n              text += str;\n            }\n          }\n          function walk37(node) {\n            if (node.nodeType == 1) {\n              var cmText = node.getAttribute("cm-text");\n              if (cmText) {\n                addText(cmText);\n                return;\n              }\n              var markerID = node.getAttribute("cm-marker"), range2;\n              if (markerID) {\n                var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n                if (found.length && (range2 = found[0].find(0))) {\n                  addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));\n                }\n                return;\n              }\n              if (node.getAttribute("contenteditable") == "false") {\n                return;\n              }\n              var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n              if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n                return;\n              }\n              if (isBlock) {\n                close();\n              }\n              for (var i2 = 0; i2 < node.childNodes.length; i2++) {\n                walk37(node.childNodes[i2]);\n              }\n              if (/^(pre|p)$/i.test(node.nodeName)) {\n                extraLinebreak = true;\n              }\n              if (isBlock) {\n                closing = true;\n              }\n            } else if (node.nodeType == 3) {\n              addText(node.nodeValue.replace(/\\u200b/g, "").replace(/\\u00a0/g, " "));\n            }\n          }\n          for (; ; ) {\n            walk37(from);\n            if (from == to) {\n              break;\n            }\n            from = from.nextSibling;\n            extraLinebreak = false;\n          }\n          return text;\n        }\n        function domToPos(cm, node, offset) {\n          var lineNode;\n          if (node == cm.display.lineDiv) {\n            lineNode = cm.display.lineDiv.childNodes[offset];\n            if (!lineNode) {\n              return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n            }\n            node = null;\n            offset = 0;\n          } else {\n            for (lineNode = node; ; lineNode = lineNode.parentNode) {\n              if (!lineNode || lineNode == cm.display.lineDiv) {\n                return null;\n              }\n              if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n                break;\n              }\n            }\n          }\n          for (var i2 = 0; i2 < cm.display.view.length; i2++) {\n            var lineView = cm.display.view[i2];\n            if (lineView.node == lineNode) {\n              return locateNodeInLineView(lineView, node, offset);\n            }\n          }\n        }\n        function locateNodeInLineView(lineView, node, offset) {\n          var wrapper = lineView.text.firstChild, bad = false;\n          if (!node || !contains(wrapper, node)) {\n            return badPos(Pos(lineNo(lineView.line), 0), true);\n          }\n          if (node == wrapper) {\n            bad = true;\n            node = wrapper.childNodes[offset];\n            offset = 0;\n            if (!node) {\n              var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n              return badPos(Pos(lineNo(line), line.text.length), bad);\n            }\n          }\n          var textNode = node.nodeType == 3 ? node : null, topNode = node;\n          if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n            textNode = node.firstChild;\n            if (offset) {\n              offset = textNode.nodeValue.length;\n            }\n          }\n          while (topNode.parentNode != wrapper) {\n            topNode = topNode.parentNode;\n          }\n          var measure = lineView.measure, maps = measure.maps;\n          function find(textNode2, topNode2, offset2) {\n            for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {\n              var map3 = i2 < 0 ? measure.map : maps[i2];\n              for (var j2 = 0; j2 < map3.length; j2 += 3) {\n                var curNode = map3[j2 + 2];\n                if (curNode == textNode2 || curNode == topNode2) {\n                  var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);\n                  var ch = map3[j2] + offset2;\n                  if (offset2 < 0 || curNode != textNode2) {\n                    ch = map3[j2 + (offset2 ? 1 : 0)];\n                  }\n                  return Pos(line2, ch);\n                }\n              }\n            }\n          }\n          var found = find(textNode, topNode, offset);\n          if (found) {\n            return badPos(found, bad);\n          }\n          for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n            found = find(after, after.firstChild, 0);\n            if (found) {\n              return badPos(Pos(found.line, found.ch - dist), bad);\n            } else {\n              dist += after.textContent.length;\n            }\n          }\n          for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n            found = find(before, before.firstChild, -1);\n            if (found) {\n              return badPos(Pos(found.line, found.ch + dist$1), bad);\n            } else {\n              dist$1 += before.textContent.length;\n            }\n          }\n        }\n        var TextareaInput = function(cm) {\n          this.cm = cm;\n          this.prevInput = "";\n          this.pollingFast = false;\n          this.polling = new Delayed();\n          this.hasSelection = false;\n          this.composing = null;\n          this.resetting = false;\n        };\n        TextareaInput.prototype.init = function(display) {\n          var this$1 = this;\n          var input = this, cm = this.cm;\n          this.createField(display);\n          var te = this.textarea;\n          display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n          if (ios) {\n            te.style.width = "0px";\n          }\n          on(te, "input", function() {\n            if (ie && ie_version >= 9 && this$1.hasSelection) {\n              this$1.hasSelection = null;\n            }\n            input.poll();\n          });\n          on(te, "paste", function(e) {\n            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n              return;\n            }\n            cm.state.pasteIncoming = +/* @__PURE__ */ new Date();\n            input.fastPoll();\n          });\n          function prepareCopyCut(e) {\n            if (signalDOMEvent(cm, e)) {\n              return;\n            }\n            if (cm.somethingSelected()) {\n              setLastCopied({ lineWise: false, text: cm.getSelections() });\n            } else if (!cm.options.lineWiseCopyCut) {\n              return;\n            } else {\n              var ranges = copyableRanges(cm);\n              setLastCopied({ lineWise: true, text: ranges.text });\n              if (e.type == "cut") {\n                cm.setSelections(ranges.ranges, null, sel_dontScroll);\n              } else {\n                input.prevInput = "";\n                te.value = ranges.text.join("\\n");\n                selectInput(te);\n              }\n            }\n            if (e.type == "cut") {\n              cm.state.cutIncoming = +/* @__PURE__ */ new Date();\n            }\n          }\n          on(te, "cut", prepareCopyCut);\n          on(te, "copy", prepareCopyCut);\n          on(display.scroller, "paste", function(e) {\n            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n              return;\n            }\n            if (!te.dispatchEvent) {\n              cm.state.pasteIncoming = +/* @__PURE__ */ new Date();\n              input.focus();\n              return;\n            }\n            var event = new Event("paste");\n            event.clipboardData = e.clipboardData;\n            te.dispatchEvent(event);\n          });\n          on(display.lineSpace, "selectstart", function(e) {\n            if (!eventInWidget(display, e)) {\n              e_preventDefault(e);\n            }\n          });\n          on(te, "compositionstart", function() {\n            var start = cm.getCursor("from");\n            if (input.composing) {\n              input.composing.range.clear();\n            }\n            input.composing = {\n              start,\n              range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })\n            };\n          });\n          on(te, "compositionend", function() {\n            if (input.composing) {\n              input.poll();\n              input.composing.range.clear();\n              input.composing = null;\n            }\n          });\n        };\n        TextareaInput.prototype.createField = function(_display) {\n          this.wrapper = hiddenTextarea();\n          this.textarea = this.wrapper.firstChild;\n          var opts = this.cm.options;\n          disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);\n        };\n        TextareaInput.prototype.screenReaderLabelChanged = function(label) {\n          if (label) {\n            this.textarea.setAttribute("aria-label", label);\n          } else {\n            this.textarea.removeAttribute("aria-label");\n          }\n        };\n        TextareaInput.prototype.prepareSelection = function() {\n          var cm = this.cm, display = cm.display, doc2 = cm.doc;\n          var result = prepareSelection(cm);\n          if (cm.options.moveInputWithCursor) {\n            var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");\n            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n            result.teTop = Math.max(0, Math.min(\n              display.wrapper.clientHeight - 10,\n              headPos.top + lineOff.top - wrapOff.top\n            ));\n            result.teLeft = Math.max(0, Math.min(\n              display.wrapper.clientWidth - 10,\n              headPos.left + lineOff.left - wrapOff.left\n            ));\n          }\n          return result;\n        };\n        TextareaInput.prototype.showSelection = function(drawn) {\n          var cm = this.cm, display = cm.display;\n          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n          removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n          if (drawn.teTop != null) {\n            this.wrapper.style.top = drawn.teTop + "px";\n            this.wrapper.style.left = drawn.teLeft + "px";\n          }\n        };\n        TextareaInput.prototype.reset = function(typing) {\n          if (this.contextMenuPending || this.composing && typing) {\n            return;\n          }\n          var cm = this.cm;\n          this.resetting = true;\n          if (cm.somethingSelected()) {\n            this.prevInput = "";\n            var content = cm.getSelection();\n            this.textarea.value = content;\n            if (cm.state.focused) {\n              selectInput(this.textarea);\n            }\n            if (ie && ie_version >= 9) {\n              this.hasSelection = content;\n            }\n          } else if (!typing) {\n            this.prevInput = this.textarea.value = "";\n            if (ie && ie_version >= 9) {\n              this.hasSelection = null;\n            }\n          }\n          this.resetting = false;\n        };\n        TextareaInput.prototype.getField = function() {\n          return this.textarea;\n        };\n        TextareaInput.prototype.supportsTouch = function() {\n          return false;\n        };\n        TextareaInput.prototype.focus = function() {\n          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {\n            try {\n              this.textarea.focus();\n            } catch (e) {\n            }\n          }\n        };\n        TextareaInput.prototype.blur = function() {\n          this.textarea.blur();\n        };\n        TextareaInput.prototype.resetPosition = function() {\n          this.wrapper.style.top = this.wrapper.style.left = 0;\n        };\n        TextareaInput.prototype.receivedFocus = function() {\n          this.slowPoll();\n        };\n        TextareaInput.prototype.slowPoll = function() {\n          var this$1 = this;\n          if (this.pollingFast) {\n            return;\n          }\n          this.polling.set(this.cm.options.pollInterval, function() {\n            this$1.poll();\n            if (this$1.cm.state.focused) {\n              this$1.slowPoll();\n            }\n          });\n        };\n        TextareaInput.prototype.fastPoll = function() {\n          var missed = false, input = this;\n          input.pollingFast = true;\n          function p() {\n            var changed = input.poll();\n            if (!changed && !missed) {\n              missed = true;\n              input.polling.set(60, p);\n            } else {\n              input.pollingFast = false;\n              input.slowPoll();\n            }\n          }\n          input.polling.set(20, p);\n        };\n        TextareaInput.prototype.poll = function() {\n          var this$1 = this;\n          var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n          if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n            return false;\n          }\n          var text = input.value;\n          if (text == prevInput && !cm.somethingSelected()) {\n            return false;\n          }\n          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {\n            cm.display.input.reset();\n            return false;\n          }\n          if (cm.doc.sel == cm.display.selForContextMenu) {\n            var first = text.charCodeAt(0);\n            if (first == 8203 && !prevInput) {\n              prevInput = "\\u200B";\n            }\n            if (first == 8666) {\n              this.reset();\n              return this.cm.execCommand("undo");\n            }\n          }\n          var same = 0, l = Math.min(prevInput.length, text.length);\n          while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {\n            ++same;\n          }\n          runInOp(cm, function() {\n            applyTextInput(\n              cm,\n              text.slice(same),\n              prevInput.length - same,\n              null,\n              this$1.composing ? "*compose" : null\n            );\n            if (text.length > 1e3 || text.indexOf("\\n") > -1) {\n              input.value = this$1.prevInput = "";\n            } else {\n              this$1.prevInput = text;\n            }\n            if (this$1.composing) {\n              this$1.composing.range.clear();\n              this$1.composing.range = cm.markText(\n                this$1.composing.start,\n                cm.getCursor("to"),\n                { className: "CodeMirror-composing" }\n              );\n            }\n          });\n          return true;\n        };\n        TextareaInput.prototype.ensurePolled = function() {\n          if (this.pollingFast && this.poll()) {\n            this.pollingFast = false;\n          }\n        };\n        TextareaInput.prototype.onKeyPress = function() {\n          if (ie && ie_version >= 9) {\n            this.hasSelection = null;\n          }\n          this.fastPoll();\n        };\n        TextareaInput.prototype.onContextMenu = function(e) {\n          var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n          if (input.contextMenuPending) {\n            input.contextMenuPending();\n          }\n          var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n          if (!pos || presto) {\n            return;\n          }\n          var reset = cm.options.resetSelectionOnContextMenu;\n          if (reset && cm.doc.sel.contains(pos) == -1) {\n            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n          }\n          var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n          var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n          input.wrapper.style.cssText = "position: static";\n          te.style.cssText = "position: absolute; width: 30px; height: 30px;\\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";\n          var oldScrollY;\n          if (webkit) {\n            oldScrollY = te.ownerDocument.defaultView.scrollY;\n          }\n          display.input.focus();\n          if (webkit) {\n            te.ownerDocument.defaultView.scrollTo(null, oldScrollY);\n          }\n          display.input.reset();\n          if (!cm.somethingSelected()) {\n            te.value = input.prevInput = " ";\n          }\n          input.contextMenuPending = rehide;\n          display.selForContextMenu = cm.doc.sel;\n          clearTimeout(display.detectingSelectAll);\n          function prepareSelectAllHack() {\n            if (te.selectionStart != null) {\n              var selected = cm.somethingSelected();\n              var extval = "\\u200B" + (selected ? te.value : "");\n              te.value = "\\u21DA";\n              te.value = extval;\n              input.prevInput = selected ? "" : "\\u200B";\n              te.selectionStart = 1;\n              te.selectionEnd = extval.length;\n              display.selForContextMenu = cm.doc.sel;\n            }\n          }\n          function rehide() {\n            if (input.contextMenuPending != rehide) {\n              return;\n            }\n            input.contextMenuPending = false;\n            input.wrapper.style.cssText = oldWrapperCSS;\n            te.style.cssText = oldCSS;\n            if (ie && ie_version < 9) {\n              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n            }\n            if (te.selectionStart != null) {\n              if (!ie || ie && ie_version < 9) {\n                prepareSelectAllHack();\n              }\n              var i2 = 0, poll = function() {\n                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\\u200B") {\n                  operation(cm, selectAll)(cm);\n                } else if (i2++ < 10) {\n                  display.detectingSelectAll = setTimeout(poll, 500);\n                } else {\n                  display.selForContextMenu = null;\n                  display.input.reset();\n                }\n              };\n              display.detectingSelectAll = setTimeout(poll, 200);\n            }\n          }\n          if (ie && ie_version >= 9) {\n            prepareSelectAllHack();\n          }\n          if (captureRightClick) {\n            e_stop(e);\n            var mouseup = function() {\n              off(window, "mouseup", mouseup);\n              setTimeout(rehide, 20);\n            };\n            on(window, "mouseup", mouseup);\n          } else {\n            setTimeout(rehide, 50);\n          }\n        };\n        TextareaInput.prototype.readOnlyChanged = function(val) {\n          if (!val) {\n            this.reset();\n          }\n          this.textarea.disabled = val == "nocursor";\n          this.textarea.readOnly = !!val;\n        };\n        TextareaInput.prototype.setUneditable = function() {\n        };\n        TextareaInput.prototype.needsContentAttribute = false;\n        function fromTextArea(textarea, options2) {\n          options2 = options2 ? copyObj(options2) : {};\n          options2.value = textarea.value;\n          if (!options2.tabindex && textarea.tabIndex) {\n            options2.tabindex = textarea.tabIndex;\n          }\n          if (!options2.placeholder && textarea.placeholder) {\n            options2.placeholder = textarea.placeholder;\n          }\n          if (options2.autofocus == null) {\n            var hasFocus = activeElt(rootNode(textarea));\n            options2.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;\n          }\n          function save() {\n            textarea.value = cm.getValue();\n          }\n          var realSubmit;\n          if (textarea.form) {\n            on(textarea.form, "submit", save);\n            if (!options2.leaveSubmitMethodAlone) {\n              var form = textarea.form;\n              realSubmit = form.submit;\n              try {\n                var wrappedSubmit = form.submit = function() {\n                  save();\n                  form.submit = realSubmit;\n                  form.submit();\n                  form.submit = wrappedSubmit;\n                };\n              } catch (e) {\n              }\n            }\n          }\n          options2.finishInit = function(cm2) {\n            cm2.save = save;\n            cm2.getTextArea = function() {\n              return textarea;\n            };\n            cm2.toTextArea = function() {\n              cm2.toTextArea = isNaN;\n              save();\n              textarea.parentNode.removeChild(cm2.getWrapperElement());\n              textarea.style.display = "";\n              if (textarea.form) {\n                off(textarea.form, "submit", save);\n                if (!options2.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {\n                  textarea.form.submit = realSubmit;\n                }\n              }\n            };\n          };\n          textarea.style.display = "none";\n          var cm = CodeMirror8(\n            function(node) {\n              return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n            },\n            options2\n          );\n          return cm;\n        }\n        function addLegacyProps(CodeMirror9) {\n          CodeMirror9.off = off;\n          CodeMirror9.on = on;\n          CodeMirror9.wheelEventPixels = wheelEventPixels;\n          CodeMirror9.Doc = Doc;\n          CodeMirror9.splitLines = splitLinesAuto;\n          CodeMirror9.countColumn = countColumn;\n          CodeMirror9.findColumn = findColumn;\n          CodeMirror9.isWordChar = isWordCharBasic;\n          CodeMirror9.Pass = Pass;\n          CodeMirror9.signal = signal;\n          CodeMirror9.Line = Line;\n          CodeMirror9.changeEnd = changeEnd;\n          CodeMirror9.scrollbarModel = scrollbarModel;\n          CodeMirror9.Pos = Pos;\n          CodeMirror9.cmpPos = cmp2;\n          CodeMirror9.modes = modes;\n          CodeMirror9.mimeModes = mimeModes;\n          CodeMirror9.resolveMode = resolveMode;\n          CodeMirror9.getMode = getMode;\n          CodeMirror9.modeExtensions = modeExtensions;\n          CodeMirror9.extendMode = extendMode;\n          CodeMirror9.copyState = copyState;\n          CodeMirror9.startState = startState;\n          CodeMirror9.innerMode = innerMode;\n          CodeMirror9.commands = commands;\n          CodeMirror9.keyMap = keyMap;\n          CodeMirror9.keyName = keyName;\n          CodeMirror9.isModifierKey = isModifierKey;\n          CodeMirror9.lookupKey = lookupKey;\n          CodeMirror9.normalizeKeyMap = normalizeKeyMap;\n          CodeMirror9.StringStream = StringStream;\n          CodeMirror9.SharedTextMarker = SharedTextMarker;\n          CodeMirror9.TextMarker = TextMarker;\n          CodeMirror9.LineWidget = LineWidget;\n          CodeMirror9.e_preventDefault = e_preventDefault;\n          CodeMirror9.e_stopPropagation = e_stopPropagation;\n          CodeMirror9.e_stop = e_stop;\n          CodeMirror9.addClass = addClass;\n          CodeMirror9.contains = contains;\n          CodeMirror9.rmClass = rmClass;\n          CodeMirror9.keyNames = keyNames;\n        }\n        defineOptions(CodeMirror8);\n        addEditorMethods(CodeMirror8);\n        var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");\n        for (var prop in Doc.prototype) {\n          if (Doc.prototype.hasOwnProperty(prop) && indexOf2(dontDelegate, prop) < 0) {\n            CodeMirror8.prototype[prop] = /* @__PURE__ */ function(method) {\n              return function() {\n                return method.apply(this.doc, arguments);\n              };\n            }(Doc.prototype[prop]);\n          }\n        }\n        eventMixin(Doc);\n        CodeMirror8.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };\n        CodeMirror8.defineMode = function(name) {\n          if (!CodeMirror8.defaults.mode && name != "null") {\n            CodeMirror8.defaults.mode = name;\n          }\n          defineMode.apply(this, arguments);\n        };\n        CodeMirror8.defineMIME = defineMIME;\n        CodeMirror8.defineMode("null", function() {\n          return { token: function(stream) {\n            return stream.skipToEnd();\n          } };\n        });\n        CodeMirror8.defineMIME("text/plain", "null");\n        CodeMirror8.defineExtension = function(name, func) {\n          CodeMirror8.prototype[name] = func;\n        };\n        CodeMirror8.defineDocExtension = function(name, func) {\n          Doc.prototype[name] = func;\n        };\n        CodeMirror8.fromTextArea = fromTextArea;\n        addLegacyProps(CodeMirror8);\n        CodeMirror8.version = "5.65.16";\n        return CodeMirror8;\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/editor/editor-mode-query.js\n  function editor_mode_query_default(config) {\n    const keywords = /* @__PURE__ */ new Set([\n      "has",\n      "in",\n      "no",\n      "not",\n      "and",\n      "or",\n      "is",\n      "asc",\n      "ascN",\n      "ascA",\n      "ascAN",\n      "ascNA",\n      "desc",\n      "descN",\n      "descA",\n      "descAN",\n      "descNA"\n    ]);\n    const jsMode = import_codemirror.default.getMode(config, {\n      name: "javascript",\n      json: true\n    });\n    return {\n      ...jsMode,\n      indent(state, textAfter) {\n        return state.indented + config.indentUnit * (state.lastType === "{" && textAfter.trim()[0] !== "}" || state.lastType === "(" && textAfter.trim()[0] !== ")" || state.lastType === "[" && textAfter.trim()[0] !== "]");\n      },\n      token(stream, state) {\n        const next = stream.peek();\n        if (next === "#" || next === "@") {\n          jsMode.token(new import_codemirror.default.StringStream("$", 4, stream.lineOracle), state);\n          stream.pos++;\n          return "variable";\n        }\n        let token2 = jsMode.token(stream, state);\n        const str = stream.string.slice(stream.start, stream.pos);\n        if (stream.string[stream.start - 1] !== ".") {\n          if (state.isAssertionContext) {\n            if ((token2 === "variable" || token2 === "atom") && (state.isAssertionParen === 0 && str !== "not")) {\n              return "type";\n            }\n            if (str === "(") {\n              state.isAssertionParen++;\n            } else if (str === ")") {\n              if (state.isAssertionParen > 0) {\n                state.isAssertionParen--;\n              }\n              if (state.isAssertionParen === 0) {\n                state.isAssertionContext = false;\n              }\n            }\n          }\n          if (keywords.has(str)) {\n            if (str === "is") {\n              state.isAssertionContext = true;\n              state.isAssertionParen = 0;\n            }\n            return "keyword";\n          }\n        }\n        if (state.isAssertionContext) {\n          if (token2 === "variable" || token2 === "atom" || token2 === "def" || str === "function") {\n            return "type";\n          }\n          if (state.isAssertionParen === 0 && (token2 || /\\S/.test(str))) {\n            state.isAssertionContext = false;\n          }\n        }\n        return token2;\n      }\n    };\n  }\n  var import_codemirror;\n  var init_editor_mode_query = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/editor/editor-mode-query.js"() {\n      import_codemirror = __toESM(require_codemirror(), 1);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/editor/editor-mode-view.js\n  function editor_mode_view_default(config, options2) {\n    const isDiscoveryViewDefined = typeof options2.isDiscoveryViewDefined === "function" ? options2.isDiscoveryViewDefined : () => {\n    };\n    const jsMode = import_codemirror2.default.getMode(config, {\n      name: "javascript",\n      json: true\n    });\n    return {\n      ...jsMode,\n      indent(state, textAfter) {\n        return state.indented + config.indentUnit * (state.lastType === "{" && textAfter.trim()[0] !== "}" || state.lastType === "(" && textAfter.trim()[0] !== ")" || state.lastType === "[" && textAfter.trim()[0] !== "]");\n      },\n      token: function(stream, state) {\n        if (state.suspendTokens) {\n          const { pos, token: token3 } = state.suspendTokens.shift();\n          stream.pos = pos;\n          if (state.suspendTokens.length === 0) {\n            state.suspendTokens = null;\n          }\n          return token3;\n        }\n        const start = stream.pos;\n        const token2 = jsMode.token(stream, state);\n        if (token2 === "string") {\n          const end = stream.pos;\n          const [, viewName] = stream.string.slice(start + 1, end - 1).match(/^(.+?)([:{]|$)/) || [];\n          if (isDiscoveryViewDefined(viewName)) {\n            stream.pos = start + 1;\n            state.suspendTokens = [\n              { pos: start + 1 + viewName.length, token: "string discovery-view-name" },\n              { pos: end, token: token2 }\n            ];\n          }\n        }\n        return token2;\n      }\n    };\n  }\n  var import_codemirror2;\n  var init_editor_mode_view = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/editor/editor-mode-view.js"() {\n      import_codemirror2 = __toESM(require_codemirror(), 1);\n    }\n  });\n\n  // node_modules/codemirror/mode/javascript/javascript.js\n  var require_javascript = __commonJS({\n    "node_modules/codemirror/mode/javascript/javascript.js"(exports, module) {\n      (function(mod2) {\n        if (typeof exports == "object" && typeof module == "object")\n          mod2(require_codemirror());\n        else if (typeof define == "function" && define.amd)\n          define(["../../lib/codemirror"], mod2);\n        else\n          mod2(CodeMirror);\n      })(function(CodeMirror8) {\n        "use strict";\n        CodeMirror8.defineMode("javascript", function(config, parserConfig) {\n          var indentUnit = config.indentUnit;\n          var statementIndent = parserConfig.statementIndent;\n          var jsonldMode = parserConfig.jsonld;\n          var jsonMode = parserConfig.json || jsonldMode;\n          var trackScope = parserConfig.trackScope !== false;\n          var isTS = parserConfig.typescript;\n          var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n          var keywords = function() {\n            function kw(type2) {\n              return { type: type2, style: "keyword" };\n            }\n            var A = kw("keyword a"), B2 = kw("keyword b"), C2 = kw("keyword c"), D2 = kw("keyword d");\n            var operator = kw("operator"), atom = { type: "atom", style: "atom" };\n            return {\n              "if": kw("if"),\n              "while": A,\n              "with": A,\n              "else": B2,\n              "do": B2,\n              "try": B2,\n              "finally": B2,\n              "return": D2,\n              "break": D2,\n              "continue": D2,\n              "new": kw("new"),\n              "delete": C2,\n              "void": C2,\n              "throw": C2,\n              "debugger": kw("debugger"),\n              "var": kw("var"),\n              "const": kw("var"),\n              "let": kw("var"),\n              "function": kw("function"),\n              "catch": kw("catch"),\n              "for": kw("for"),\n              "switch": kw("switch"),\n              "case": kw("case"),\n              "default": kw("default"),\n              "in": operator,\n              "typeof": operator,\n              "instanceof": operator,\n              "true": atom,\n              "false": atom,\n              "null": atom,\n              "undefined": atom,\n              "NaN": atom,\n              "Infinity": atom,\n              "this": kw("this"),\n              "class": kw("class"),\n              "super": kw("atom"),\n              "yield": C2,\n              "export": kw("export"),\n              "import": kw("import"),\n              "extends": C2,\n              "await": C2\n            };\n          }();\n          var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n          var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;\n          function readRegexp(stream) {\n            var escaped = false, next, inSet = false;\n            while ((next = stream.next()) != null) {\n              if (!escaped) {\n                if (next == "/" && !inSet)\n                  return;\n                if (next == "[")\n                  inSet = true;\n                else if (inSet && next == "]")\n                  inSet = false;\n              }\n              escaped = !escaped && next == "\\\\";\n            }\n          }\n          var type, content;\n          function ret(tp, style, cont2) {\n            type = tp;\n            content = cont2;\n            return style;\n          }\n          function tokenBase(stream, state) {\n            var ch = stream.next();\n            if (ch == \'"\' || ch == "\'") {\n              state.tokenize = tokenString(ch);\n              return state.tokenize(stream, state);\n            } else if (ch == "." && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n              return ret("number", "number");\n            } else if (ch == "." && stream.match("..")) {\n              return ret("spread", "meta");\n            } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n              return ret(ch);\n            } else if (ch == "=" && stream.eat(">")) {\n              return ret("=>", "operator");\n            } else if (ch == "0" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n              return ret("number", "number");\n            } else if (/\\d/.test(ch)) {\n              stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n              return ret("number", "number");\n            } else if (ch == "/") {\n              if (stream.eat("*")) {\n                state.tokenize = tokenComment;\n                return tokenComment(stream, state);\n              } else if (stream.eat("/")) {\n                stream.skipToEnd();\n                return ret("comment", "comment");\n              } else if (expressionAllowed(stream, state, 1)) {\n                readRegexp(stream);\n                stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n                return ret("regexp", "string-2");\n              } else {\n                stream.eat("=");\n                return ret("operator", "operator", stream.current());\n              }\n            } else if (ch == "`") {\n              state.tokenize = tokenQuasi;\n              return tokenQuasi(stream, state);\n            } else if (ch == "#" && stream.peek() == "!") {\n              stream.skipToEnd();\n              return ret("meta", "meta");\n            } else if (ch == "#" && stream.eatWhile(wordRE)) {\n              return ret("variable", "property");\n            } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\\S/.test(stream.string.slice(0, stream.start))) {\n              stream.skipToEnd();\n              return ret("comment", "comment");\n            } else if (isOperatorChar.test(ch)) {\n              if (ch != ">" || !state.lexical || state.lexical.type != ">") {\n                if (stream.eat("=")) {\n                  if (ch == "!" || ch == "=")\n                    stream.eat("=");\n                } else if (/[<>*+\\-|&?]/.test(ch)) {\n                  stream.eat(ch);\n                  if (ch == ">")\n                    stream.eat(ch);\n                }\n              }\n              if (ch == "?" && stream.eat("."))\n                return ret(".");\n              return ret("operator", "operator", stream.current());\n            } else if (wordRE.test(ch)) {\n              stream.eatWhile(wordRE);\n              var word = stream.current();\n              if (state.lastType != ".") {\n                if (keywords.propertyIsEnumerable(word)) {\n                  var kw = keywords[word];\n                  return ret(kw.type, kw.style, word);\n                }\n                if (word == "async" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n                  return ret("async", "keyword", word);\n              }\n              return ret("variable", "variable", word);\n            }\n          }\n          function tokenString(quote2) {\n            return function(stream, state) {\n              var escaped = false, next;\n              if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {\n                state.tokenize = tokenBase;\n                return ret("jsonld-keyword", "meta");\n              }\n              while ((next = stream.next()) != null) {\n                if (next == quote2 && !escaped)\n                  break;\n                escaped = !escaped && next == "\\\\";\n              }\n              if (!escaped)\n                state.tokenize = tokenBase;\n              return ret("string", "string");\n            };\n          }\n          function tokenComment(stream, state) {\n            var maybeEnd = false, ch;\n            while (ch = stream.next()) {\n              if (ch == "/" && maybeEnd) {\n                state.tokenize = tokenBase;\n                break;\n              }\n              maybeEnd = ch == "*";\n            }\n            return ret("comment", "comment");\n          }\n          function tokenQuasi(stream, state) {\n            var escaped = false, next;\n            while ((next = stream.next()) != null) {\n              if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n                state.tokenize = tokenBase;\n                break;\n              }\n              escaped = !escaped && next == "\\\\";\n            }\n            return ret("quasi", "string-2", stream.current());\n          }\n          var brackets = "([{}])";\n          function findFatArrow(stream, state) {\n            if (state.fatArrowAt)\n              state.fatArrowAt = null;\n            var arrow = stream.string.indexOf("=>", stream.start);\n            if (arrow < 0)\n              return;\n            if (isTS) {\n              var m2 = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n              if (m2)\n                arrow = m2.index;\n            }\n            var depth = 0, sawSomething = false;\n            for (var pos = arrow - 1; pos >= 0; --pos) {\n              var ch = stream.string.charAt(pos);\n              var bracket = brackets.indexOf(ch);\n              if (bracket >= 0 && bracket < 3) {\n                if (!depth) {\n                  ++pos;\n                  break;\n                }\n                if (--depth == 0) {\n                  if (ch == "(")\n                    sawSomething = true;\n                  break;\n                }\n              } else if (bracket >= 3 && bracket < 6) {\n                ++depth;\n              } else if (wordRE.test(ch)) {\n                sawSomething = true;\n              } else if (/["\'\\/`]/.test(ch)) {\n                for (; ; --pos) {\n                  if (pos == 0)\n                    return;\n                  var next = stream.string.charAt(pos - 1);\n                  if (next == ch && stream.string.charAt(pos - 2) != "\\\\") {\n                    pos--;\n                    break;\n                  }\n                }\n              } else if (sawSomething && !depth) {\n                ++pos;\n                break;\n              }\n            }\n            if (sawSomething && !depth)\n              state.fatArrowAt = pos;\n          }\n          var atomicTypes = {\n            "atom": true,\n            "number": true,\n            "variable": true,\n            "string": true,\n            "regexp": true,\n            "this": true,\n            "import": true,\n            "jsonld-keyword": true\n          };\n          function JSLexical(indented, column, type2, align, prev, info) {\n            this.indented = indented;\n            this.column = column;\n            this.type = type2;\n            this.prev = prev;\n            this.info = info;\n            if (align != null)\n              this.align = align;\n          }\n          function inScope(state, varname) {\n            if (!trackScope)\n              return false;\n            for (var v2 = state.localVars; v2; v2 = v2.next)\n              if (v2.name == varname)\n                return true;\n            for (var cx2 = state.context; cx2; cx2 = cx2.prev) {\n              for (var v2 = cx2.vars; v2; v2 = v2.next)\n                if (v2.name == varname)\n                  return true;\n            }\n          }\n          function parseJS(state, style, type2, content2, stream) {\n            var cc = state.cc;\n            cx.state = state;\n            cx.stream = stream;\n            cx.marked = null, cx.cc = cc;\n            cx.style = style;\n            if (!state.lexical.hasOwnProperty("align"))\n              state.lexical.align = true;\n            while (true) {\n              var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n              if (combinator(type2, content2)) {\n                while (cc.length && cc[cc.length - 1].lex)\n                  cc.pop()();\n                if (cx.marked)\n                  return cx.marked;\n                if (type2 == "variable" && inScope(state, content2))\n                  return "variable-2";\n                return style;\n              }\n            }\n          }\n          var cx = { state: null, column: null, marked: null, cc: null };\n          function pass() {\n            for (var i = arguments.length - 1; i >= 0; i--)\n              cx.cc.push(arguments[i]);\n          }\n          function cont() {\n            pass.apply(null, arguments);\n            return true;\n          }\n          function inList(name, list) {\n            for (var v2 = list; v2; v2 = v2.next)\n              if (v2.name == name)\n                return true;\n            return false;\n          }\n          function register(varname) {\n            var state = cx.state;\n            cx.marked = "def";\n            if (!trackScope)\n              return;\n            if (state.context) {\n              if (state.lexical.info == "var" && state.context && state.context.block) {\n                var newContext = registerVarScoped(varname, state.context);\n                if (newContext != null) {\n                  state.context = newContext;\n                  return;\n                }\n              } else if (!inList(varname, state.localVars)) {\n                state.localVars = new Var(varname, state.localVars);\n                return;\n              }\n            }\n            if (parserConfig.globalVars && !inList(varname, state.globalVars))\n              state.globalVars = new Var(varname, state.globalVars);\n          }\n          function registerVarScoped(varname, context) {\n            if (!context) {\n              return null;\n            } else if (context.block) {\n              var inner = registerVarScoped(varname, context.prev);\n              if (!inner)\n                return null;\n              if (inner == context.prev)\n                return context;\n              return new Context(inner, context.vars, true);\n            } else if (inList(varname, context.vars)) {\n              return context;\n            } else {\n              return new Context(context.prev, new Var(varname, context.vars), false);\n            }\n          }\n          function isModifier(name) {\n            return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";\n          }\n          function Context(prev, vars, block3) {\n            this.prev = prev;\n            this.vars = vars;\n            this.block = block3;\n          }\n          function Var(name, next) {\n            this.name = name;\n            this.next = next;\n          }\n          var defaultVars = new Var("this", new Var("arguments", null));\n          function pushcontext() {\n            cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n            cx.state.localVars = defaultVars;\n          }\n          function pushblockcontext() {\n            cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n            cx.state.localVars = null;\n          }\n          pushcontext.lex = pushblockcontext.lex = true;\n          function popcontext() {\n            cx.state.localVars = cx.state.context.vars;\n            cx.state.context = cx.state.context.prev;\n          }\n          popcontext.lex = true;\n          function pushlex(type2, info) {\n            var result = function() {\n              var state = cx.state, indent = state.indented;\n              if (state.lexical.type == "stat")\n                indent = state.lexical.indented;\n              else\n                for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)\n                  indent = outer.indented;\n              state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);\n            };\n            result.lex = true;\n            return result;\n          }\n          function poplex() {\n            var state = cx.state;\n            if (state.lexical.prev) {\n              if (state.lexical.type == ")")\n                state.indented = state.lexical.indented;\n              state.lexical = state.lexical.prev;\n            }\n          }\n          poplex.lex = true;\n          function expect(wanted) {\n            function exp(type2) {\n              if (type2 == wanted)\n                return cont();\n              else if (wanted == ";" || type2 == "}" || type2 == ")" || type2 == "]")\n                return pass();\n              else\n                return cont(exp);\n            }\n            ;\n            return exp;\n          }\n          function statement(type2, value) {\n            if (type2 == "var")\n              return cont(pushlex("vardef", value), vardef, expect(";"), poplex);\n            if (type2 == "keyword a")\n              return cont(pushlex("form"), parenExpr, statement, poplex);\n            if (type2 == "keyword b")\n              return cont(pushlex("form"), statement, poplex);\n            if (type2 == "keyword d")\n              return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);\n            if (type2 == "debugger")\n              return cont(expect(";"));\n            if (type2 == "{")\n              return cont(pushlex("}"), pushblockcontext, block2, poplex, popcontext);\n            if (type2 == ";")\n              return cont();\n            if (type2 == "if") {\n              if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n                cx.state.cc.pop()();\n              return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);\n            }\n            if (type2 == "function")\n              return cont(functiondef);\n            if (type2 == "for")\n              return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);\n            if (type2 == "class" || isTS && value == "interface") {\n              cx.marked = "keyword";\n              return cont(pushlex("form", type2 == "class" ? type2 : value), className, poplex);\n            }\n            if (type2 == "variable") {\n              if (isTS && value == "declare") {\n                cx.marked = "keyword";\n                return cont(statement);\n              } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\\s*\\w/, false)) {\n                cx.marked = "keyword";\n                if (value == "enum")\n                  return cont(enumdef);\n                else if (value == "type")\n                  return cont(typename, expect("operator"), typeexpr, expect(";"));\n                else\n                  return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block2, poplex, poplex);\n              } else if (isTS && value == "namespace") {\n                cx.marked = "keyword";\n                return cont(pushlex("form"), expression, statement, poplex);\n              } else if (isTS && value == "abstract") {\n                cx.marked = "keyword";\n                return cont(statement);\n              } else {\n                return cont(pushlex("stat"), maybelabel);\n              }\n            }\n            if (type2 == "switch")\n              return cont(\n                pushlex("form"),\n                parenExpr,\n                expect("{"),\n                pushlex("}", "switch"),\n                pushblockcontext,\n                block2,\n                poplex,\n                poplex,\n                popcontext\n              );\n            if (type2 == "case")\n              return cont(expression, expect(":"));\n            if (type2 == "default")\n              return cont(expect(":"));\n            if (type2 == "catch")\n              return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n            if (type2 == "export")\n              return cont(pushlex("stat"), afterExport, poplex);\n            if (type2 == "import")\n              return cont(pushlex("stat"), afterImport, poplex);\n            if (type2 == "async")\n              return cont(statement);\n            if (value == "@")\n              return cont(expression, statement);\n            return pass(pushlex("stat"), expression, expect(";"), poplex);\n          }\n          function maybeCatchBinding(type2) {\n            if (type2 == "(")\n              return cont(funarg, expect(")"));\n          }\n          function expression(type2, value) {\n            return expressionInner(type2, value, false);\n          }\n          function expressionNoComma(type2, value) {\n            return expressionInner(type2, value, true);\n          }\n          function parenExpr(type2) {\n            if (type2 != "(")\n              return pass();\n            return cont(pushlex(")"), maybeexpression, expect(")"), poplex);\n          }\n          function expressionInner(type2, value, noComma) {\n            if (cx.state.fatArrowAt == cx.stream.start) {\n              var body = noComma ? arrowBodyNoComma : arrowBody;\n              if (type2 == "(")\n                return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);\n              else if (type2 == "variable")\n                return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n            }\n            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n            if (atomicTypes.hasOwnProperty(type2))\n              return cont(maybeop);\n            if (type2 == "function")\n              return cont(functiondef, maybeop);\n            if (type2 == "class" || isTS && value == "interface") {\n              cx.marked = "keyword";\n              return cont(pushlex("form"), classExpression, poplex);\n            }\n            if (type2 == "keyword c" || type2 == "async")\n              return cont(noComma ? expressionNoComma : expression);\n            if (type2 == "(")\n              return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);\n            if (type2 == "operator" || type2 == "spread")\n              return cont(noComma ? expressionNoComma : expression);\n            if (type2 == "[")\n              return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n            if (type2 == "{")\n              return contCommasep(objprop, "}", null, maybeop);\n            if (type2 == "quasi")\n              return pass(quasi, maybeop);\n            if (type2 == "new")\n              return cont(maybeTarget(noComma));\n            return cont();\n          }\n          function maybeexpression(type2) {\n            if (type2.match(/[;\\}\\)\\],]/))\n              return pass();\n            return pass(expression);\n          }\n          function maybeoperatorComma(type2, value) {\n            if (type2 == ",")\n              return cont(maybeexpression);\n            return maybeoperatorNoComma(type2, value, false);\n          }\n          function maybeoperatorNoComma(type2, value, noComma) {\n            var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n            var expr = noComma == false ? expression : expressionNoComma;\n            if (type2 == "=>")\n              return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n            if (type2 == "operator") {\n              if (/\\+\\+|--/.test(value) || isTS && value == "!")\n                return cont(me);\n              if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n                return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);\n              if (value == "?")\n                return cont(expression, expect(":"), expr);\n              return cont(expr);\n            }\n            if (type2 == "quasi") {\n              return pass(quasi, me);\n            }\n            if (type2 == ";")\n              return;\n            if (type2 == "(")\n              return contCommasep(expressionNoComma, ")", "call", me);\n            if (type2 == ".")\n              return cont(property, me);\n            if (type2 == "[")\n              return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n            if (isTS && value == "as") {\n              cx.marked = "keyword";\n              return cont(typeexpr, me);\n            }\n            if (type2 == "regexp") {\n              cx.state.lastType = cx.marked = "operator";\n              cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n              return cont(expr);\n            }\n          }\n          function quasi(type2, value) {\n            if (type2 != "quasi")\n              return pass();\n            if (value.slice(value.length - 2) != "${")\n              return cont(quasi);\n            return cont(maybeexpression, continueQuasi);\n          }\n          function continueQuasi(type2) {\n            if (type2 == "}") {\n              cx.marked = "string-2";\n              cx.state.tokenize = tokenQuasi;\n              return cont(quasi);\n            }\n          }\n          function arrowBody(type2) {\n            findFatArrow(cx.stream, cx.state);\n            return pass(type2 == "{" ? statement : expression);\n          }\n          function arrowBodyNoComma(type2) {\n            findFatArrow(cx.stream, cx.state);\n            return pass(type2 == "{" ? statement : expressionNoComma);\n          }\n          function maybeTarget(noComma) {\n            return function(type2) {\n              if (type2 == ".")\n                return cont(noComma ? targetNoComma : target);\n              else if (type2 == "variable" && isTS)\n                return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);\n              else\n                return pass(noComma ? expressionNoComma : expression);\n            };\n          }\n          function target(_, value) {\n            if (value == "target") {\n              cx.marked = "keyword";\n              return cont(maybeoperatorComma);\n            }\n          }\n          function targetNoComma(_, value) {\n            if (value == "target") {\n              cx.marked = "keyword";\n              return cont(maybeoperatorNoComma);\n            }\n          }\n          function maybelabel(type2) {\n            if (type2 == ":")\n              return cont(poplex, statement);\n            return pass(maybeoperatorComma, expect(";"), poplex);\n          }\n          function property(type2) {\n            if (type2 == "variable") {\n              cx.marked = "property";\n              return cont();\n            }\n          }\n          function objprop(type2, value) {\n            if (type2 == "async") {\n              cx.marked = "property";\n              return cont(objprop);\n            } else if (type2 == "variable" || cx.style == "keyword") {\n              cx.marked = "property";\n              if (value == "get" || value == "set")\n                return cont(getterSetter);\n              var m2;\n              if (isTS && cx.state.fatArrowAt == cx.stream.start && (m2 = cx.stream.match(/^\\s*:\\s*/, false)))\n                cx.state.fatArrowAt = cx.stream.pos + m2[0].length;\n              return cont(afterprop);\n            } else if (type2 == "number" || type2 == "string") {\n              cx.marked = jsonldMode ? "property" : cx.style + " property";\n              return cont(afterprop);\n            } else if (type2 == "jsonld-keyword") {\n              return cont(afterprop);\n            } else if (isTS && isModifier(value)) {\n              cx.marked = "keyword";\n              return cont(objprop);\n            } else if (type2 == "[") {\n              return cont(expression, maybetype, expect("]"), afterprop);\n            } else if (type2 == "spread") {\n              return cont(expressionNoComma, afterprop);\n            } else if (value == "*") {\n              cx.marked = "keyword";\n              return cont(objprop);\n            } else if (type2 == ":") {\n              return pass(afterprop);\n            }\n          }\n          function getterSetter(type2) {\n            if (type2 != "variable")\n              return pass(afterprop);\n            cx.marked = "property";\n            return cont(functiondef);\n          }\n          function afterprop(type2) {\n            if (type2 == ":")\n              return cont(expressionNoComma);\n            if (type2 == "(")\n              return pass(functiondef);\n          }\n          function commasep(what, end, sep) {\n            function proceed(type2, value) {\n              if (sep ? sep.indexOf(type2) > -1 : type2 == ",") {\n                var lex = cx.state.lexical;\n                if (lex.info == "call")\n                  lex.pos = (lex.pos || 0) + 1;\n                return cont(function(type3, value2) {\n                  if (type3 == end || value2 == end)\n                    return pass();\n                  return pass(what);\n                }, proceed);\n              }\n              if (type2 == end || value == end)\n                return cont();\n              if (sep && sep.indexOf(";") > -1)\n                return pass(what);\n              return cont(expect(end));\n            }\n            return function(type2, value) {\n              if (type2 == end || value == end)\n                return cont();\n              return pass(what, proceed);\n            };\n          }\n          function contCommasep(what, end, info) {\n            for (var i = 3; i < arguments.length; i++)\n              cx.cc.push(arguments[i]);\n            return cont(pushlex(end, info), commasep(what, end), poplex);\n          }\n          function block2(type2) {\n            if (type2 == "}")\n              return cont();\n            return pass(statement, block2);\n          }\n          function maybetype(type2, value) {\n            if (isTS) {\n              if (type2 == ":")\n                return cont(typeexpr);\n              if (value == "?")\n                return cont(maybetype);\n            }\n          }\n          function maybetypeOrIn(type2, value) {\n            if (isTS && (type2 == ":" || value == "in"))\n              return cont(typeexpr);\n          }\n          function mayberettype(type2) {\n            if (isTS && type2 == ":") {\n              if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false))\n                return cont(expression, isKW, typeexpr);\n              else\n                return cont(typeexpr);\n            }\n          }\n          function isKW(_, value) {\n            if (value == "is") {\n              cx.marked = "keyword";\n              return cont();\n            }\n          }\n          function typeexpr(type2, value) {\n            if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {\n              cx.marked = "keyword";\n              return cont(value == "typeof" ? expressionNoComma : typeexpr);\n            }\n            if (type2 == "variable" || value == "void") {\n              cx.marked = "type";\n              return cont(afterType);\n            }\n            if (value == "|" || value == "&")\n              return cont(typeexpr);\n            if (type2 == "string" || type2 == "number" || type2 == "atom")\n              return cont(afterType);\n            if (type2 == "[")\n              return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);\n            if (type2 == "{")\n              return cont(pushlex("}"), typeprops, poplex, afterType);\n            if (type2 == "(")\n              return cont(commasep(typearg, ")"), maybeReturnType, afterType);\n            if (type2 == "<")\n              return cont(commasep(typeexpr, ">"), typeexpr);\n            if (type2 == "quasi") {\n              return pass(quasiType, afterType);\n            }\n          }\n          function maybeReturnType(type2) {\n            if (type2 == "=>")\n              return cont(typeexpr);\n          }\n          function typeprops(type2) {\n            if (type2.match(/[\\}\\)\\]]/))\n              return cont();\n            if (type2 == "," || type2 == ";")\n              return cont(typeprops);\n            return pass(typeprop, typeprops);\n          }\n          function typeprop(type2, value) {\n            if (type2 == "variable" || cx.style == "keyword") {\n              cx.marked = "property";\n              return cont(typeprop);\n            } else if (value == "?" || type2 == "number" || type2 == "string") {\n              return cont(typeprop);\n            } else if (type2 == ":") {\n              return cont(typeexpr);\n            } else if (type2 == "[") {\n              return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);\n            } else if (type2 == "(") {\n              return pass(functiondecl, typeprop);\n            } else if (!type2.match(/[;\\}\\)\\],]/)) {\n              return cont();\n            }\n          }\n          function quasiType(type2, value) {\n            if (type2 != "quasi")\n              return pass();\n            if (value.slice(value.length - 2) != "${")\n              return cont(quasiType);\n            return cont(typeexpr, continueQuasiType);\n          }\n          function continueQuasiType(type2) {\n            if (type2 == "}") {\n              cx.marked = "string-2";\n              cx.state.tokenize = tokenQuasi;\n              return cont(quasiType);\n            }\n          }\n          function typearg(type2, value) {\n            if (type2 == "variable" && cx.stream.match(/^\\s*[?:]/, false) || value == "?")\n              return cont(typearg);\n            if (type2 == ":")\n              return cont(typeexpr);\n            if (type2 == "spread")\n              return cont(typearg);\n            return pass(typeexpr);\n          }\n          function afterType(type2, value) {\n            if (value == "<")\n              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);\n            if (value == "|" || type2 == "." || value == "&")\n              return cont(typeexpr);\n            if (type2 == "[")\n              return cont(typeexpr, expect("]"), afterType);\n            if (value == "extends" || value == "implements") {\n              cx.marked = "keyword";\n              return cont(typeexpr);\n            }\n            if (value == "?")\n              return cont(typeexpr, expect(":"), typeexpr);\n          }\n          function maybeTypeArgs(_, value) {\n            if (value == "<")\n              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);\n          }\n          function typeparam() {\n            return pass(typeexpr, maybeTypeDefault);\n          }\n          function maybeTypeDefault(_, value) {\n            if (value == "=")\n              return cont(typeexpr);\n          }\n          function vardef(_, value) {\n            if (value == "enum") {\n              cx.marked = "keyword";\n              return cont(enumdef);\n            }\n            return pass(pattern, maybetype, maybeAssign, vardefCont);\n          }\n          function pattern(type2, value) {\n            if (isTS && isModifier(value)) {\n              cx.marked = "keyword";\n              return cont(pattern);\n            }\n            if (type2 == "variable") {\n              register(value);\n              return cont();\n            }\n            if (type2 == "spread")\n              return cont(pattern);\n            if (type2 == "[")\n              return contCommasep(eltpattern, "]");\n            if (type2 == "{")\n              return contCommasep(proppattern, "}");\n          }\n          function proppattern(type2, value) {\n            if (type2 == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n              register(value);\n              return cont(maybeAssign);\n            }\n            if (type2 == "variable")\n              cx.marked = "property";\n            if (type2 == "spread")\n              return cont(pattern);\n            if (type2 == "}")\n              return pass();\n            if (type2 == "[")\n              return cont(expression, expect("]"), expect(":"), proppattern);\n            return cont(expect(":"), pattern, maybeAssign);\n          }\n          function eltpattern() {\n            return pass(pattern, maybeAssign);\n          }\n          function maybeAssign(_type, value) {\n            if (value == "=")\n              return cont(expressionNoComma);\n          }\n          function vardefCont(type2) {\n            if (type2 == ",")\n              return cont(vardef);\n          }\n          function maybeelse(type2, value) {\n            if (type2 == "keyword b" && value == "else")\n              return cont(pushlex("form", "else"), statement, poplex);\n          }\n          function forspec(type2, value) {\n            if (value == "await")\n              return cont(forspec);\n            if (type2 == "(")\n              return cont(pushlex(")"), forspec1, poplex);\n          }\n          function forspec1(type2) {\n            if (type2 == "var")\n              return cont(vardef, forspec2);\n            if (type2 == "variable")\n              return cont(forspec2);\n            return pass(forspec2);\n          }\n          function forspec2(type2, value) {\n            if (type2 == ")")\n              return cont();\n            if (type2 == ";")\n              return cont(forspec2);\n            if (value == "in" || value == "of") {\n              cx.marked = "keyword";\n              return cont(expression, forspec2);\n            }\n            return pass(expression, forspec2);\n          }\n          function functiondef(type2, value) {\n            if (value == "*") {\n              cx.marked = "keyword";\n              return cont(functiondef);\n            }\n            if (type2 == "variable") {\n              register(value);\n              return cont(functiondef);\n            }\n            if (type2 == "(")\n              return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);\n            if (isTS && value == "<")\n              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);\n          }\n          function functiondecl(type2, value) {\n            if (value == "*") {\n              cx.marked = "keyword";\n              return cont(functiondecl);\n            }\n            if (type2 == "variable") {\n              register(value);\n              return cont(functiondecl);\n            }\n            if (type2 == "(")\n              return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);\n            if (isTS && value == "<")\n              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);\n          }\n          function typename(type2, value) {\n            if (type2 == "keyword" || type2 == "variable") {\n              cx.marked = "type";\n              return cont(typename);\n            } else if (value == "<") {\n              return cont(pushlex(">"), commasep(typeparam, ">"), poplex);\n            }\n          }\n          function funarg(type2, value) {\n            if (value == "@")\n              cont(expression, funarg);\n            if (type2 == "spread")\n              return cont(funarg);\n            if (isTS && isModifier(value)) {\n              cx.marked = "keyword";\n              return cont(funarg);\n            }\n            if (isTS && type2 == "this")\n              return cont(maybetype, maybeAssign);\n            return pass(pattern, maybetype, maybeAssign);\n          }\n          function classExpression(type2, value) {\n            if (type2 == "variable")\n              return className(type2, value);\n            return classNameAfter(type2, value);\n          }\n          function className(type2, value) {\n            if (type2 == "variable") {\n              register(value);\n              return cont(classNameAfter);\n            }\n          }\n          function classNameAfter(type2, value) {\n            if (value == "<")\n              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);\n            if (value == "extends" || value == "implements" || isTS && type2 == ",") {\n              if (value == "implements")\n                cx.marked = "keyword";\n              return cont(isTS ? typeexpr : expression, classNameAfter);\n            }\n            if (type2 == "{")\n              return cont(pushlex("}"), classBody, poplex);\n          }\n          function classBody(type2, value) {\n            if (type2 == "async" || type2 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false)) {\n              cx.marked = "keyword";\n              return cont(classBody);\n            }\n            if (type2 == "variable" || cx.style == "keyword") {\n              cx.marked = "property";\n              return cont(classfield, classBody);\n            }\n            if (type2 == "number" || type2 == "string")\n              return cont(classfield, classBody);\n            if (type2 == "[")\n              return cont(expression, maybetype, expect("]"), classfield, classBody);\n            if (value == "*") {\n              cx.marked = "keyword";\n              return cont(classBody);\n            }\n            if (isTS && type2 == "(")\n              return pass(functiondecl, classBody);\n            if (type2 == ";" || type2 == ",")\n              return cont(classBody);\n            if (type2 == "}")\n              return cont();\n            if (value == "@")\n              return cont(expression, classBody);\n          }\n          function classfield(type2, value) {\n            if (value == "!")\n              return cont(classfield);\n            if (value == "?")\n              return cont(classfield);\n            if (type2 == ":")\n              return cont(typeexpr, maybeAssign);\n            if (value == "=")\n              return cont(expressionNoComma);\n            var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";\n            return pass(isInterface ? functiondecl : functiondef);\n          }\n          function afterExport(type2, value) {\n            if (value == "*") {\n              cx.marked = "keyword";\n              return cont(maybeFrom, expect(";"));\n            }\n            if (value == "default") {\n              cx.marked = "keyword";\n              return cont(expression, expect(";"));\n            }\n            if (type2 == "{")\n              return cont(commasep(exportField, "}"), maybeFrom, expect(";"));\n            return pass(statement);\n          }\n          function exportField(type2, value) {\n            if (value == "as") {\n              cx.marked = "keyword";\n              return cont(expect("variable"));\n            }\n            if (type2 == "variable")\n              return pass(expressionNoComma, exportField);\n          }\n          function afterImport(type2) {\n            if (type2 == "string")\n              return cont();\n            if (type2 == "(")\n              return pass(expression);\n            if (type2 == ".")\n              return pass(maybeoperatorComma);\n            return pass(importSpec, maybeMoreImports, maybeFrom);\n          }\n          function importSpec(type2, value) {\n            if (type2 == "{")\n              return contCommasep(importSpec, "}");\n            if (type2 == "variable")\n              register(value);\n            if (value == "*")\n              cx.marked = "keyword";\n            return cont(maybeAs);\n          }\n          function maybeMoreImports(type2) {\n            if (type2 == ",")\n              return cont(importSpec, maybeMoreImports);\n          }\n          function maybeAs(_type, value) {\n            if (value == "as") {\n              cx.marked = "keyword";\n              return cont(importSpec);\n            }\n          }\n          function maybeFrom(_type, value) {\n            if (value == "from") {\n              cx.marked = "keyword";\n              return cont(expression);\n            }\n          }\n          function arrayLiteral(type2) {\n            if (type2 == "]")\n              return cont();\n            return pass(commasep(expressionNoComma, "]"));\n          }\n          function enumdef() {\n            return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);\n          }\n          function enummember() {\n            return pass(pattern, maybeAssign);\n          }\n          function isContinuedStatement(state, textAfter) {\n            return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n          }\n          function expressionAllowed(stream, state, backUp) {\n            return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n          }\n          return {\n            startState: function(basecolumn) {\n              var state = {\n                tokenize: tokenBase,\n                lastType: "sof",\n                cc: [],\n                lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n                localVars: parserConfig.localVars,\n                context: parserConfig.localVars && new Context(null, null, false),\n                indented: basecolumn || 0\n              };\n              if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")\n                state.globalVars = parserConfig.globalVars;\n              return state;\n            },\n            token: function(stream, state) {\n              if (stream.sol()) {\n                if (!state.lexical.hasOwnProperty("align"))\n                  state.lexical.align = false;\n                state.indented = stream.indentation();\n                findFatArrow(stream, state);\n              }\n              if (state.tokenize != tokenComment && stream.eatSpace())\n                return null;\n              var style = state.tokenize(stream, state);\n              if (type == "comment")\n                return style;\n              state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n              return parseJS(state, style, type, content, stream);\n            },\n            indent: function(state, textAfter) {\n              if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)\n                return CodeMirror8.Pass;\n              if (state.tokenize != tokenBase)\n                return 0;\n              var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;\n              if (!/^\\s*else\\b/.test(textAfter))\n                for (var i = state.cc.length - 1; i >= 0; --i) {\n                  var c = state.cc[i];\n                  if (c == poplex)\n                    lexical = lexical.prev;\n                  else if (c != maybeelse && c != popcontext)\n                    break;\n                }\n              while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))\n                lexical = lexical.prev;\n              if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")\n                lexical = lexical.prev;\n              var type2 = lexical.type, closing = firstChar == type2;\n              if (type2 == "vardef")\n                return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);\n              else if (type2 == "form" && firstChar == "{")\n                return lexical.indented;\n              else if (type2 == "form")\n                return lexical.indented + indentUnit;\n              else if (type2 == "stat")\n                return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n              else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)\n                return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n              else if (lexical.align)\n                return lexical.column + (closing ? 0 : 1);\n              else\n                return lexical.indented + (closing ? 0 : indentUnit);\n            },\n            electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n            blockCommentStart: jsonMode ? null : "/*",\n            blockCommentEnd: jsonMode ? null : "*/",\n            blockCommentContinue: jsonMode ? null : " * ",\n            lineComment: jsonMode ? null : "//",\n            fold: "brace",\n            closeBrackets: "()[]{}\'\'\\"\\"``",\n            helperType: jsonMode ? "json" : "javascript",\n            jsonldMode,\n            jsonMode,\n            expressionAllowed,\n            skipExpression: function(state) {\n              parseJS(state, "atom", "atom", "true", new CodeMirror8.StringStream("", 2, null));\n            }\n          };\n        });\n        CodeMirror8.registerHelper("wordChars", "javascript", /[\\w$]/);\n        CodeMirror8.defineMIME("text/javascript", "javascript");\n        CodeMirror8.defineMIME("text/ecmascript", "javascript");\n        CodeMirror8.defineMIME("application/javascript", "javascript");\n        CodeMirror8.defineMIME("application/x-javascript", "javascript");\n        CodeMirror8.defineMIME("application/ecmascript", "javascript");\n        CodeMirror8.defineMIME("application/json", { name: "javascript", json: true });\n        CodeMirror8.defineMIME("application/x-json", { name: "javascript", json: true });\n        CodeMirror8.defineMIME("application/manifest+json", { name: "javascript", json: true });\n        CodeMirror8.defineMIME("application/ld+json", { name: "javascript", jsonld: true });\n        CodeMirror8.defineMIME("text/typescript", { name: "javascript", typescript: true });\n        CodeMirror8.defineMIME("application/typescript", { name: "javascript", typescript: true });\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/editor/editors-hint.js\n  function getText(completion) {\n    if (typeof completion == "string") {\n      return completion;\n    }\n    return completion.text;\n  }\n  function getHintElement(hintsElement, el) {\n    while (el && el.parentNode !== hintsElement) {\n      el = el.parentNode;\n    }\n    return el;\n  }\n  var import_codemirror3, POPUP_CLASS, HINT_CLASS, ACTIVE_HINT_CLASS, requestAnimationFrame2, cancelAnimationFrame, Completion, Widget;\n  var init_editors_hint = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/editor/editors-hint.js"() {\n      import_codemirror3 = __toESM(require_codemirror(), 1);\n      init_layout();\n      init_dom();\n      POPUP_CLASS = "discovery-view-editor-hints-popup";\n      HINT_CLASS = "discovery-view-editor-hint";\n      ACTIVE_HINT_CLASS = "active";\n      requestAnimationFrame2 = window.requestAnimationFrame || ((fn) => setTimeout(fn, 1e3 / 60));\n      cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n      import_codemirror3.default.commands.autocomplete = import_codemirror3.default.showHint;\n      import_codemirror3.default.defineOption("showHintOptions", null);\n      import_codemirror3.default.defineExtension("showHint", function(options2) {\n        options2 = {\n          closeOnUnfocus: true,\n          container: null,\n          ...this.options.showHintOptions,\n          ...options2\n        };\n        if (this.state.completionActive) {\n          this.state.completionActive.close();\n        }\n        if (this.listSelections().length > 1) {\n          return;\n        }\n        if (this.somethingSelected()) {\n          return;\n        }\n        if (typeof options2.hint !== "function") {\n          return;\n        }\n        this.state.completionActive = new Completion(this, options2);\n        this.state.completionActive.update(true);\n        import_codemirror3.default.signal(this, "startCompletion", this);\n      });\n      Completion = class {\n        constructor(cm, options2) {\n          this.cm = cm;\n          this.options = options2;\n          this.widget = null;\n          this.debounce = 0;\n          this.tick = 0;\n          this.startPos = this.cm.getCursor("start");\n          this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n          cm.on("cursorActivity", this.activityFunc = () => this.cursorActivity());\n          if (options2.closeOnUnfocus) {\n            let closingOnBlur;\n            this.onFocus = () => clearTimeout(closingOnBlur);\n            this.onBlur = () => closingOnBlur = setTimeout(() => this.close(), 100);\n            cm.on("focus", this.onFocus);\n            cm.on("blur", this.onBlur);\n          }\n        }\n        close() {\n          if (!this.active()) {\n            return;\n          }\n          this.cm.state.completionActive = null;\n          this.tick = null;\n          this.cm.off("cursorActivity", this.activityFunc);\n          if (this.options.closeOnUnfocus) {\n            this.cm.off("blur", this.onBlur);\n            this.cm.off("focus", this.onFocus);\n          }\n          if (this.widget) {\n            if (this.data) {\n              import_codemirror3.default.signal(this.data, "close");\n            }\n            this.widget.close();\n          }\n          import_codemirror3.default.signal(this.cm, "endCompletion", this.cm);\n        }\n        active() {\n          return this.cm.state.completionActive === this;\n        }\n        pick(data, idx) {\n          const completion = data.list[idx];\n          this.cm.state.completionEnabled = false;\n          if (completion.hint) {\n            completion.hint(this.cm, data, completion);\n          } else {\n            this.cm.replaceRange(\n              getText(completion),\n              completion.from || data.from,\n              completion.to || data.to,\n              "complete"\n            );\n          }\n          import_codemirror3.default.signal(data, "pick", completion);\n          this.close();\n        }\n        cursorActivity() {\n          if (this.debounce) {\n            cancelAnimationFrame(this.debounce);\n            this.debounce = 0;\n          }\n          const pos = this.cm.getCursor();\n          const line = this.cm.getLine(pos.line);\n          if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < this.startPos.ch || this.cm.somethingSelected()) {\n            this.close();\n          } else {\n            this.debounce = requestAnimationFrame2(() => this.update());\n            if (this.widget) {\n              this.widget.disable();\n            }\n          }\n        }\n        update(first) {\n          if (this.tick === null) {\n            return;\n          }\n          const myTick = ++this.tick;\n          Promise.resolve(this.options.hint(this.cm, this.options)).then((data) => {\n            if (this.tick == myTick) {\n              this.finishUpdate(data, first);\n            }\n          });\n        }\n        finishUpdate(data) {\n          if (this.data) {\n            import_codemirror3.default.signal(this.data, "update");\n          }\n          const picked = this.widget && this.widget.picked;\n          if (this.widget) {\n            this.widget.close();\n          }\n          this.data = data;\n          if (data && data.list.length) {\n            if (picked && data.list.length == 1) {\n              this.pick(data, 0);\n            } else {\n              this.widget = new Widget(this, data);\n              import_codemirror3.default.signal(data, "shown");\n            }\n          }\n        }\n      };\n      Widget = class {\n        constructor(completion, data) {\n          const cm = completion.cm;\n          const hintsEl = this.hintsEl = document.createElement("ul");\n          const hintsElClassNames = [\n            POPUP_CLASS,\n            completion.cm.options.theme\n          ].filter(Boolean);\n          const containerEl = completion.options.container || document.body;\n          this.rootEls = /* @__PURE__ */ new Set([containerEl.getRootNode()]);\n          this.completion = completion;\n          this.data = data;\n          this.picked = false;\n          this.selectedHint = data.selectedHint || 0;\n          hintsEl.style.visibility = "hidden";\n          hintsEl.classList.add(...hintsElClassNames);\n          containerEl.appendChild(hintsEl);\n          this.items = data.list.map((cur, idx) => {\n            const el = hintsEl.appendChild(document.createElement("li"));\n            el.className = HINT_CLASS;\n            if (idx === this.selectedHint) {\n              el.classList.add(ACTIVE_HINT_CLASS);\n            }\n            if (cur.render) {\n              cur.render(el, data, cur);\n            } else {\n              el.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n            }\n            return el;\n          });\n          cm.addKeyMap(this.keyMap = {\n            Up: () => this.changeActive(this.selectedHint - 1),\n            Down: () => this.changeActive(this.selectedHint + 1),\n            Enter: () => this.pick(),\n            Tab: () => this.pick(),\n            Esc: () => {\n              cm.state.completionEnabled = false;\n              completion.close();\n            }\n          });\n          this.updatePosSize();\n          this.onScroll = () => this.updatePosSize();\n          for (const el of this.rootEls) {\n            el.addEventListener("scroll", this.onScroll, passiveCaptureOptions);\n          }\n          import_codemirror3.default.on(hintsEl, "mousedown", (e) => {\n            const el = getHintElement(hintsEl, e.target);\n            const idx = this.items.indexOf(el);\n            if (idx !== -1) {\n              this.close();\n              this.selectedHint = idx;\n              this.pick();\n              setTimeout(() => cm.focus(), 1);\n            }\n          });\n          import_codemirror3.default.signal(data, "select", data.list[this.selectedHint], this.items[this.selectedHint]);\n        }\n        close() {\n          if (this.completion.widget !== this) {\n            return;\n          }\n          this.completion.widget = null;\n          this.completion.cm.removeKeyMap(this.keyMap);\n          this.hintsEl.remove();\n          for (const el of this.rootEls) {\n            el.removeEventListener("scroll", this.onScroll, passiveCaptureOptions);\n          }\n        }\n        disable() {\n          this.completion.cm.removeKeyMap(this.keyMap);\n          this.keyMap = {\n            Enter: () => this.picked = true\n          };\n          this.completion.cm.addKeyMap(this.keyMap);\n        }\n        pick() {\n          this.completion.pick(this.data, this.selectedHint);\n        }\n        changeActive(idx, avoidWrap) {\n          if (idx >= this.items.length) {\n            idx = avoidWrap ? this.items.length - 1 : 0;\n          } else if (idx < 0) {\n            idx = avoidWrap ? 0 : this.items.length - 1;\n          }\n          const prev = this.items[this.selectedHint];\n          const next = this.items[this.selectedHint = idx];\n          if (next === prev) {\n            return;\n          }\n          if (prev) {\n            prev.classList.remove(ACTIVE_HINT_CLASS);\n          }\n          next.classList.add(ACTIVE_HINT_CLASS);\n          if (next.offsetTop < this.hintsEl.scrollTop) {\n            this.hintsEl.scrollTop = next.offsetTop - 3;\n          } else if (next.offsetTop + next.offsetHeight > this.hintsEl.scrollTop + this.hintsEl.clientHeight) {\n            this.hintsEl.scrollTop = next.offsetTop + next.offsetHeight - this.hintsEl.clientHeight + 3;\n          }\n          import_codemirror3.default.signal(this.data, "select", this.data.list[this.selectedHint], next);\n        }\n        getCursorCoords() {\n          const { completion, hintsEl } = this;\n          const cm = completion.cm;\n          const offsetParent = getOffsetParent(hintsEl);\n          const cursorBox = cm.cursorCoords(null, "local");\n          const editorBox = getBoundingRect(cm.display.wrapper, offsetParent);\n          return {\n            top: editorBox.top + cursorBox.top + 5,\n            left: editorBox.left + cursorBox.left + 9,\n            bottom: editorBox.top + cursorBox.bottom + 5,\n            right: editorBox.left + cursorBox.right + 9\n          };\n        }\n        updatePosSize() {\n          const CURSOR_OFFSET = 1;\n          const PAGE_OFFSET = 6;\n          const { hintsEl } = this;\n          let pos = this.getCursorCoords();\n          const { clientWidth: viewportW, clientHeight: viewportH } = getOverflowParent(hintsEl);\n          hintsEl.style.left = "0px";\n          hintsEl.style.top = "0px";\n          let { width, height } = hintsEl.getBoundingClientRect();\n          const availBottom = viewportH - pos.bottom;\n          const availTop = pos.top;\n          if (availBottom < height && availTop > availBottom) {\n            const h2 = Math.min(height, availTop - PAGE_OFFSET - CURSOR_OFFSET);\n            hintsEl.style.top = `${pos.top - 1 - h2 - PAGE_OFFSET}px`;\n            hintsEl.style.maxHeight = `${h2}px`;\n          } else {\n            hintsEl.style.top = `${pos.bottom + CURSOR_OFFSET}px`;\n            hintsEl.style.maxHeight = `${availBottom - CURSOR_OFFSET - PAGE_OFFSET}px`;\n          }\n          const availRight = viewportW - pos.right;\n          const availLeft = pos.left;\n          if (availRight < width && availLeft > availRight) {\n            hintsEl.style.left = `${pos.left + 1 - Math.min(width, availLeft - PAGE_OFFSET)}px`;\n            hintsEl.style.maxWidth = `${availLeft - PAGE_OFFSET}px`;\n          } else {\n            hintsEl.style.left = `${pos.right}px`;\n            hintsEl.style.maxWidth = `${availRight - PAGE_OFFSET}px`;\n          }\n          hintsEl.style.visibility = "visible";\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/editor/editors.js\n  function renderQueryAutocompleteItem(el, self5, { entry: { type, text, value } }) {\n    const startChar = text[0];\n    const lastChar = text[text.length - 1];\n    const start = startChar === \'"\' || startChar === "\'" ? 1 : 0;\n    const end = lastChar === \'"\' || lastChar === "\'" ? 1 : 0;\n    const pattern = text.toLowerCase().substring(start, text.length - end);\n    const offset = pattern ? value.toLowerCase().indexOf(pattern, value[0] === \'"\' || value[0] === "\'" ? 1 : 0) : -1;\n    if (offset !== -1) {\n      value = escapeHtml2(value.substring(0, offset)) + \'<span class="match">\' + escapeHtml2(value.substr(offset, pattern.length)) + "</span>" + escapeHtml2(value.substr(offset + pattern.length));\n    }\n    el.classList.add("type-" + type);\n    el.appendChild(createElement("span", "name", value));\n  }\n  function editors_default(host) {\n    Object.assign(host.view, {\n      QueryEditor: class extends QueryEditor {\n        get container() {\n          return host.dom.container;\n        }\n      },\n      ViewEditor: class extends ViewEditor {\n        isViewDefined(name) {\n          return host.view.isDefined(name);\n        }\n      }\n    });\n  }\n  var import_codemirror4, import_javascript, Editor, QueryEditor, ViewEditor;\n  var init_editors = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/editor/editors.js"() {\n      init_dom();\n      init_html();\n      init_size();\n      init_emitter();\n      import_codemirror4 = __toESM(require_codemirror(), 1);\n      init_editor_mode_query();\n      init_editor_mode_view();\n      import_javascript = __toESM(require_javascript(), 1);\n      init_editors_hint();\n      Editor = class extends Emitter {\n        static CodeMirror = import_codemirror4.default;\n        constructor({ hint, mode }) {\n          super();\n          this.el = document.createElement("div");\n          this.el.className = "discovery-view-editor";\n          const self5 = this;\n          const cm = (0, import_codemirror4.default)(this.el, {\n            extraKeys: { "Alt-Space": "autocomplete" },\n            mode: mode || "javascript",\n            theme: "neo",\n            indentUnit: 0,\n            showHintOptions: {\n              hint,\n              get container() {\n                return self5.container;\n              }\n            }\n          });\n          cm.on("change", () => this.emit("change", cm.getValue()));\n          if (typeof hint === "function") {\n            cm.on("cursorActivity", (cm2) => {\n              if (cm2.state.completionEnabled && cm2.state.focused) {\n                cm2.showHint();\n              }\n            });\n            cm.on("focus", (cm2) => {\n              if (cm2.getValue() === "") {\n                cm2.state.completionEnabled = true;\n              }\n              if (cm2.state.completionEnabled && !cm2.state.completionActive) {\n                cm2.showHint();\n              }\n            });\n            cm.on("change", (_, change) => {\n              if (change.origin !== "complete") {\n                cm.state.completionEnabled = true;\n              }\n            });\n          }\n          this.cm = cm;\n          const rect = new ContentRect();\n          rect.subscribe(() => cm.refresh());\n          rect.observe(cm.display.wrapper);\n        }\n        getValue() {\n          return this.cm.getValue();\n        }\n        setValue(value) {\n          requestAnimationFrame(() => this.cm.refresh());\n          if (typeof value === "string" && this.getValue() !== value) {\n            this.cm.setValue(value || "");\n          }\n        }\n        focus() {\n          this.cm.focus();\n        }\n      };\n      QueryEditor = class extends Editor {\n        constructor(getSuggestions) {\n          super({ mode: "discovery-query", hint: (cm) => {\n            const cursor = cm.getCursor();\n            const suggestions = getSuggestions(\n              cm.getValue(),\n              cm.doc.indexFromPos(cursor),\n              this.queryData,\n              this.queryContext\n            );\n            if (!suggestions) {\n              return;\n            }\n            return {\n              list: suggestions.slice(0, 50).map((entry) => {\n                return {\n                  entry,\n                  text: entry.value,\n                  render: renderQueryAutocompleteItem,\n                  from: cm.posFromIndex(entry.from),\n                  to: cm.posFromIndex(entry.to)\n                };\n              })\n            };\n          } });\n          this.inputPanelEl = createElement("div", "discovery-view-editor__input-panel");\n          this.outputPanelEl = createElement("div", "discovery-view-editor__output-panel");\n          this.el.append(this.inputPanelEl, this.outputPanelEl);\n        }\n        setValue(value, data, context) {\n          const valueChanged = typeof value === "string" && this.getValue() !== value;\n          const dataChanged = this.queryData !== data || this.queryContext !== context;\n          this.queryData = data;\n          this.queryContext = context;\n          super.setValue(value);\n          if (dataChanged && !valueChanged) {\n            if (this.cm.state.completionEnabled && this.cm.state.focused) {\n              this.cm.showHint();\n            }\n          }\n        }\n      };\n      ViewEditor = class extends Editor {\n        constructor() {\n          super({\n            mode: {\n              name: "discovery-view",\n              isDiscoveryViewDefined: (name) => this.isViewDefined(name)\n            }\n          });\n        }\n      };\n      import_codemirror4.default.defineMode("jora", editor_mode_query_default);\n      import_codemirror4.default.defineMode("discovery-query", editor_mode_query_default);\n      import_codemirror4.default.defineMode("discovery-view", editor_mode_view_default);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/block.usage.js\n  var block_usage_default;\n  var init_block_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/block.usage.js"() {\n      block_usage_default = {\n        beforeDemo: [\'md:"A block has no its own look. It\\\'s using for wrapping some content with a `className` (btw `className` is a common property for any view when appropriate)"\'],\n        demo: {\n          view: "block",\n          className: "foo",\n          content: [\n            \'text:"Content inside block"\'\n          ]\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/block.js\n  function block_default(host) {\n    host.view.define("block", function(el, config, data, context) {\n      const { content = [], onInit, onChange: onChange4 } = config;\n      const blockContent = typeof onInit !== "function" && typeof onChange4 !== "function" ? content : this.composeConfig(content, {\n        onInit,\n        onChange: onChange4\n      });\n      return host.view.render(el, blockContent, data, context);\n    }, { usage: block_usage_default });\n  }\n  var init_block = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/block.js"() {\n      init_block_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/columns.usage.js\n  var columns_usage_default;\n  var init_columns_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/columns.usage.js"() {\n      columns_usage_default = {\n        demo: {\n          view: "columns",\n          data: ["one", "two", "three", "four"],\n          column: "text"\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/column.js\n  function column_default(host) {\n    host.view.define("column", function(el, config, data, context) {\n      const { content = [] } = config;\n      return host.view.render(el, content, data, context);\n    }, { usage: columns_usage_default });\n  }\n  var init_column = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/column.js"() {\n      init_columns_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/columns.js\n  function columns_default(host) {\n    host.view.define("columns", function render2(el, config, data, context) {\n      const { column, columnConfig, emptyText, limit } = config;\n      if (emptyText !== false && emptyText !== "") {\n        el.setAttribute("emptyText", emptyText || "Empty");\n      }\n      if (!Array.isArray(data) && data) {\n        data = [data];\n      }\n      if (Array.isArray(data)) {\n        return host.view.renderList(el, this.composeConfig({\n          view: "column",\n          content: column\n        }, columnConfig), data, context, 0, host.view.listLimit(limit, 25));\n      }\n    }, { usage: columns_usage_default });\n  }\n  var init_columns = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/columns.js"() {\n      init_columns_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/expand.usage.js\n  var expand_usage_default;\n  var init_expand_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/expand.usage.js"() {\n      expand_usage_default = {\n        demo: {\n          view: "expand",\n          header: \'text:"Expand me!"\',\n          content: \'text:"Content"\'\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/expand.js\n  function expand_default(host) {\n    host.view.define("expand", function(el, config, data, context) {\n      function renderState() {\n        el.classList.toggle("expanded", expanded);\n        if (expanded) {\n          contentEl = createElement("div", "content");\n          return host.view.render(contentEl, content, data, context).then(() => el.appendChild(contentEl));\n        } else if (contentEl !== null) {\n          contentEl.remove();\n          contentEl = null;\n        }\n      }\n      let { expanded, header, content, onToggle: onToggle2 } = config;\n      const headerEl = el.appendChild(createElement("div", "header"));\n      const headerContentEl = headerEl.appendChild(createElement("div", "header-content"));\n      let contentEl = null;\n      expanded = host.queryBool(expanded, data, context);\n      headerEl.appendChild(createElement("div", "trigger"));\n      headerEl.addEventListener("click", () => {\n        expanded = !expanded;\n        renderState();\n        if (typeof onToggle2 === "function") {\n          onToggle2(expanded);\n        }\n      });\n      return Promise.all([\n        host.view.render(headerContentEl, header || \'text:"\\xA0"\', data, context),\n        renderState()\n      ]);\n    }, { usage: expand_usage_default });\n  }\n  var init_expand = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/expand.js"() {\n      init_dom();\n      init_expand_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/hstack.usage.js\n  var hstack_usage_default;\n  var init_hstack_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/hstack.usage.js"() {\n      hstack_usage_default = {\n        demo: {\n          view: "hstack",\n          content: [\n            \'button:{text:"First button"}\',\n            \'button-primary:{text:"Second button"}\'\n          ]\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/hstack.js\n  function hstack_default(host) {\n    host.view.define("hstack", function(el, config, data, context) {\n      const { content = [] } = config;\n      return host.view.render(el, content, data, context);\n    }, { usage: hstack_usage_default });\n  }\n  var init_hstack = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/hstack.js"() {\n      init_hstack_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/list-item.js\n  function list_item_default(host) {\n    host.view.define("list-item", function(el, config, data, context) {\n      const { content = "text" } = config;\n      return host.view.render(el, content, data, context);\n    }, {\n      tag: "li"\n    });\n  }\n  var init_list_item = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/list-item.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/lists.usage.js\n  var lists_usage_default;\n  var init_lists_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/lists.usage.js"() {\n      lists_usage_default = (view, group) => ({\n        demo: {\n          view,\n          data: ["one", "two", "three", "four"]\n        },\n        examples: [\n          {\n            title: "Variations",\n            demo: {\n              view: "context",\n              data: ["foo", "bar", "baz"],\n              content: group.map((view2) => [\n                `header{ content: \'md:${JSON.stringify(\'`view: \\\\"\' + view2 + \'\\\\"`\')}\' }`,\n                view2\n              ])\n            }\n          },\n          {\n            title: "Configure item\'s content",\n            demo: [\n              {\n                view,\n                data: ["one", "two", "three", "four"],\n                item: [\n                  \'text:"<item> "\',\n                  {\n                    view: "link",\n                    data: \'{ href: "#" + $ }\'\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            title: "Configure item\'s config",\n            demo: {\n              view,\n              data: ["one", "two", "three", "four"],\n              itemConfig: {\n                className: "special"\n              },\n              item: {\n                view: "text",\n                data: \'"prefix-" + $\'\n              }\n            }\n          }\n        ]\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/lists.js\n  function lists_default(host) {\n    function render2(el, config, data, context) {\n      const { item, itemConfig, limit, emptyText } = config;\n      if (emptyText !== false && emptyText !== "") {\n        el.setAttribute("emptyText", emptyText || "Empty list");\n      }\n      if (!Array.isArray(data) && data) {\n        data = [data];\n      }\n      if (Array.isArray(data)) {\n        return host.view.renderList(el, this.composeConfig({\n          view: "list-item",\n          content: item\n        }, itemConfig), data, context, 0, host.view.listLimit(limit, 25));\n      }\n    }\n    host.view.define("list", render2, { usage: lists_usage_default });\n    host.view.define("inline-list", render2, { usage: lists_usage_default });\n    host.view.define("comma-list", render2, { usage: lists_usage_default });\n    host.view.define("ol", render2, { tag: "ol", usage: lists_usage_default });\n    host.view.define("ul", render2, { tag: "ul", usage: lists_usage_default });\n  }\n  var init_lists = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/lists.js"() {\n      init_lists_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/page-header.usage.js\n  var page_header_usage_default;\n  var init_page_header_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/page-header.usage.js"() {\n      page_header_usage_default = (view) => ({\n        beforeDemo: [\n          \'md:"A special view to be used as the first view in the body of the page. This view stays in place as the page scrolls (although it may move slightly to the top of the page at the start of the scroll), so that the most relevant information and important action elements can remain accessible despite page scrolling."\'\n        ],\n        demoFixed: 100,\n        demo: `${view}:"That\'s a \\\\"${view}\\\\""`,\n        examples: [\n          {\n            title: "Prelude",\n            demoFixed: 150,\n            highlightProps: ["prelude"],\n            demo: {\n              view,\n              prelude: [\n                \'badge:{ text: "demo" }\',\n                \'badge:{ text: "demo", prefix: "prelude", postfix: "postfix" }\'\n              ],\n              content: \'h1:"Header"\'\n            }\n          }\n        ]\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/page-header.js\n  function page_header_default(host) {\n    host.view.define("page-header", function render2(el, config, data, context) {\n      const { prelude, content, onInit, onChange: onChange4 } = config;\n      const preludeEl = el.appendChild(createElement("div", "view-page-header__prelude"));\n      const contentEl = el.appendChild(createElement("div", "view-page-header__content"));\n      const mixinHandlers = (config2) => typeof onInit !== "function" && typeof onChange4 !== "function" ? config2 : this.composeConfig(config2, {\n        onInit,\n        onChange: onChange4\n      });\n      return Promise.all([\n        host.view.render(preludeEl, mixinHandlers(prelude || []), data, context),\n        host.view.render(contentEl, mixinHandlers(content || "text"), data, context)\n      ]);\n    }, { usage: page_header_usage_default });\n  }\n  var init_page_header = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/page-header.js"() {\n      init_dom();\n      init_page_header_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/popup.js\n  function findTargetRelatedPopup(popup, target) {\n    if (popup.el.contains(target)) {\n      return popup;\n    }\n    return popup.relatedPopups.reduce(\n      (res, related) => res || findTargetRelatedPopup(related, target),\n      null\n    );\n  }\n  function isElementNullOrInDocument(element) {\n    return element ? element.getRootNode({ composed: true }) === document : true;\n  }\n  function hideIfEventOutside(event) {\n    openedPopups.slice().forEach((popup) => popup.hideIfEventOutside(event));\n  }\n  function hideOnTriggerHasLeftDocument() {\n    openedPopups.slice().forEach((popup) => popup.hideOnTriggerHasLeftDocument());\n  }\n  function hideOnResize(event) {\n    openedPopups.slice().forEach((popup) => popup.hideOnResize(event));\n  }\n  function showDelayToMs(value, triggerEl) {\n    if (typeof value === "function") {\n      value = value(triggerEl);\n    }\n    if (typeof value === "number") {\n      return isFinite(value) ? value : 0;\n    }\n    if (typeof value === "boolean") {\n      return value ? defaultShowDelay : 0;\n    }\n    return 0;\n  }\n  function stopDelayedShow(popup) {\n    clearTimeout(popup.showDelayTimer);\n    popup.showDelayTimer = null;\n    popup.showDelayArgs = null;\n    delayedToShowPopups.delete(popup);\n  }\n  function startDelayedShow(popup, triggerEl, render2) {\n    clearTimeout(popup.showDelayTimer);\n    popup.showDelayTimer = setTimeout(() => popup.show(triggerEl, render2, true), showDelayToMs(popup.showDelay, triggerEl));\n    popup.showDelayArgs = [triggerEl, render2];\n    delayedToShowPopups.add(popup);\n  }\n  function appendIfNeeded(parent, child) {\n    if (parent.lastChild !== child) {\n      parent.appendChild(child);\n    }\n  }\n  function ensureNumber(value, fallback = 0) {\n    return Number.isFinite(value) ? value : fallback;\n  }\n  function popup_default(host) {\n    const hoverTriggerInstances = [];\n    const inspectorLockedInstances = /* @__PURE__ */ new Set();\n    let globalListeners = null;\n    let hideAllPopups = null;\n    const addHostElHoverListeners = () => {\n      if (globalListeners !== null) {\n        return;\n      }\n      globalListeners = [\n        host.addHostElEventListener("mouseenter", ({ target }) => {\n          if (target === document) {\n            return;\n          }\n          for (const instance of hoverTriggerInstances) {\n            const targetRelatedPopup = findTargetRelatedPopup(instance, target);\n            const triggerEl = targetRelatedPopup ? targetRelatedPopup.el : target.closest(instance.hoverTriggers);\n            if (triggerEl) {\n              instance.hideTimer = clearTimeout(instance.hideTimer);\n              if (triggerEl !== instance.lastHoverTriggerEl) {\n                if (!targetRelatedPopup || !targetRelatedPopup.hoverPinned) {\n                  instance.lastHoverTriggerEl = triggerEl;\n                }\n                if (!targetRelatedPopup) {\n                  instance.hoverPinned = false;\n                  instance.el.classList.remove("pinned");\n                  instance.show(triggerEl);\n                }\n              }\n            }\n          }\n        }, passiveCaptureOptions),\n        host.addHostElEventListener("mouseleave", ({ target }) => {\n          for (const instance of hoverTriggerInstances) {\n            if (instance.lastHoverTriggerEl === target) {\n              stopDelayedShow(instance);\n              instance.lastHoverTriggerEl = null;\n              instance.hideTimer = setTimeout(instance.hide, 100);\n            }\n          }\n        }, passiveCaptureOptions),\n        host.addGlobalEventListener("scroll", (event) => {\n          hideAllPopups = setTimeout(() => hideIfEventOutside(event), 0);\n        }, true),\n        host.addHostElEventListener("scroll", (event) => {\n          clearTimeout(hideAllPopups);\n          hideIfEventOutside(event);\n        }),\n        host.addGlobalEventListener("click", (event) => {\n          hideAllPopups = setTimeout(() => hideIfEventOutside(event), 0);\n        }, true),\n        host.addHostElEventListener("click", (event) => {\n          clearTimeout(hideAllPopups);\n          hideIfEventOutside(event);\n          setTimeout(hideOnTriggerHasLeftDocument, 50);\n          for (const instance of hoverTriggerInstances) {\n            if (instance.hoverPin === "trigger-click") {\n              if (instance.lastHoverTriggerEl && instance.lastTriggerEl.contains(event.target)) {\n                instance.lastHoverTriggerEl = null;\n                instance.hoverPinned = true;\n                instance.el.classList.add("pinned");\n                event.stopPropagation();\n              }\n            }\n          }\n        }, true)\n      ];\n    };\n    pointerXY.subscribe(() => {\n      for (const popup of openedPopups) {\n        if (popup.position === "pointer" && !popup.hoverPinned && !popup.frozen && !inspectorLockedInstances.has(popup)) {\n          popup.updatePosition();\n        }\n      }\n      for (const popup of delayedToShowPopups) {\n        startDelayedShow(popup, ...popup.showDelayArgs);\n      }\n    });\n    host.inspectMode.subscribe(\n      (enabled) => enabled ? openedPopups.forEach((popup) => inspectorLockedInstances.add(popup)) : inspectorLockedInstances.clear()\n    );\n    host.view.Popup = class Popup {\n      constructor(options2) {\n        options2 = {\n          ...defaultOptions,\n          ...options2\n        };\n        this.el = document.createElement("div");\n        this.el.classList.add("discovery-view-popup");\n        this.showDelayTimer = null;\n        this.showDelayArgs = null;\n        this.showDelay = options2.showDelay;\n        this.hideTimer = null;\n        this.hide = this.hide.bind(this);\n        this.lastTriggerEl = null;\n        this.lastHoverTriggerEl = null;\n        this.hoverPinned = false;\n        this.frozen = false;\n        this.render = options2.render;\n        this.position = options2.position;\n        this.positionMode = options2.positionMode;\n        this.pointerOffsetX = ensureNumber(options2.pointerOffsetX);\n        this.pointerOffsetY = ensureNumber(options2.pointerOffsetY);\n        this.hoverTriggers = options2.hoverTriggers;\n        this.hoverPin = options2.hoverPin;\n        this.hideIfEventOutsideDisabled = !options2.hideIfEventOutside;\n        this.hideOnResizeDisabled = !options2.hideOnResize;\n        if (options2.className) {\n          this.el.classList.add(options2.className);\n        }\n        if (!hoverPinModes.includes(options2.hoverPin)) {\n          host.log("warn", `Bad value for \\`Popup#options.hoverPin\\` (should be ${hoverPinModes.join(", ")}):`, options2.hoverPin);\n          this.hoverPin = false;\n        }\n        if (this.hoverTriggers) {\n          this.el.classList.add("show-on-hover");\n          this.el.dataset.pinMode = this.hoverPin || "none";\n          hoverTriggerInstances.push(this);\n          addHostElHoverListeners();\n        }\n      }\n      get relatedPopups() {\n        return openedPopups.filter((related) => this.el.contains(related.lastTriggerEl));\n      }\n      get visible() {\n        return openedPopups.includes(this);\n      }\n      toggle(...args) {\n        if (this.visible) {\n          this.hide();\n        } else {\n          this.show(...args);\n        }\n      }\n      async show(triggerEl, render2 = this.render, showImmediately = false) {\n        if (!this.visible && !showImmediately && showDelayToMs(this.showDelay, triggerEl) > 0) {\n          startDelayedShow(this, triggerEl, render2);\n          return;\n        }\n        stopDelayedShow(this);\n        inspectorLockedInstances.delete(this);\n        host.view.setViewRoot(this.el, "popup", { config: render2 });\n        const hostEl = host.dom.container;\n        this.hideTimer = clearTimeout(this.hideTimer);\n        this.relatedPopups.forEach((related) => related.hide());\n        this.el.classList.toggle("inspect", host.inspectMode.value);\n        if (this.lastTriggerEl) {\n          this.lastTriggerEl.classList.remove("discovery-view-popup-active");\n        }\n        if (triggerEl) {\n          triggerEl.classList.add("discovery-view-popup-active");\n        }\n        this.lastTriggerEl = triggerEl || null;\n        if (!this.visible) {\n          openedPopups.push(this);\n          if (openedPopups.length === 1) {\n            window.addEventListener("resize", hideOnResize);\n          }\n        }\n        if (typeof render2 === "function") {\n          this.el.innerHTML = "";\n          const renderMarker = Symbol();\n          this.lastRenderMarker = renderMarker;\n          requestAnimationFrame(() => {\n            if (this.lastRenderMarker === renderMarker) {\n              appendIfNeeded(hostEl, this.el);\n              this.updatePosition();\n            }\n          });\n          await render2(this.el, triggerEl, this.hide);\n          if (this.lastRenderMarker !== renderMarker) {\n            return;\n          }\n          this.lastRenderMarker = null;\n        }\n        appendIfNeeded(hostEl, this.el);\n        this.updatePosition();\n      }\n      updatePosition() {\n        const pointerPosition = this.position === "pointer";\n        if (!this.visible || (pointerPosition ? this.frozen : !this.lastTriggerEl)) {\n          return;\n        }\n        const hostEl = host.dom.container;\n        const offsetParent = getOffsetParent(hostEl.firstChild);\n        const viewport = getViewportRect(window, offsetParent);\n        const { x: pointerX, y: pointerY } = pointerXY.value;\n        const { pointerOffsetX, pointerOffsetY } = this;\n        const box = !pointerPosition ? getBoundingRect(this.lastTriggerEl, hostEl) : {\n          left: parseInt(pointerX) - pointerOffsetX,\n          right: parseInt(pointerX) + pointerOffsetX,\n          top: parseInt(pointerY) - pointerOffsetY,\n          bottom: parseInt(pointerY) + pointerOffsetY\n        };\n        const boxLeft = pointerPosition ? box.left : box.right;\n        const boxRight = pointerPosition ? box.right : box.left;\n        const availHeightTop = box.top - viewport.top - 3;\n        const availHeightBottom = viewport.bottom - box.bottom - 3;\n        const availWidthLeft = boxLeft - viewport.left - 3;\n        const availWidthRight = viewport.right - boxRight - 3;\n        let safeRight = availWidthRight >= availWidthLeft;\n        let safeBottom = availHeightBottom >= availHeightTop;\n        if (!safeBottom) {\n          this.el.style.maxHeight = availHeightTop + "px";\n          this.el.style.top = "auto";\n          this.el.style.bottom = viewport.bottom - box.top + "px";\n          this.el.dataset.vTo = "top";\n        }\n        if (!safeRight) {\n          this.el.style.left = "auto";\n          this.el.style.right = viewport.right - boxLeft + "px";\n          this.el.style.maxWidth = availWidthLeft + "px";\n          this.el.dataset.hTo = "left";\n        }\n        if (this.positionMode === "natural" && (!safeRight || !safeBottom)) {\n          const { height, width } = getBoundingRect(this.el);\n          safeBottom = height <= availHeightBottom;\n          safeRight = width <= availWidthRight;\n        }\n        if (safeBottom) {\n          this.el.style.maxHeight = availHeightBottom + "px";\n          this.el.style.top = box.bottom - viewport.top + "px";\n          this.el.style.bottom = "auto";\n          this.el.dataset.vTo = "bottom";\n        }\n        if (safeRight) {\n          this.el.style.left = boxRight - viewport.left + "px";\n          this.el.style.right = "auto";\n          this.el.style.maxWidth = availWidthRight + "px";\n          this.el.dataset.hTo = "right";\n        }\n        this.relatedPopups.forEach((related) => related.updatePosition());\n      }\n      freeze() {\n        this.frozen = true;\n        this.el.classList.add("frozen");\n      }\n      unfreeze() {\n        this.frozen = false;\n        this.el.classList.remove("frozen");\n        this.updatePosition();\n      }\n      hide() {\n        this.hideTimer = clearTimeout(this.hideTimer);\n        this.lastRenderMarker = null;\n        stopDelayedShow(this);\n        if (this.visible && !inspectorLockedInstances.has(this)) {\n          this.relatedPopups.forEach((related) => related.hide());\n          openedPopups.splice(openedPopups.indexOf(this), 1);\n          this.el.remove();\n          this.unfreeze();\n          if (this.lastTriggerEl) {\n            this.lastTriggerEl.classList.remove("discovery-view-popup-active");\n            this.lastTriggerEl = null;\n          }\n          if (openedPopups.length === 0) {\n            window.removeEventListener("resize", hideOnResize);\n          }\n        }\n      }\n      hideIfEventOutside({ target }) {\n        if (this.hideIfEventOutsideDisabled || inspectorLockedInstances.has(this)) {\n          return;\n        }\n        if (this.lastTriggerEl && this.lastTriggerEl.contains(target)) {\n          return;\n        }\n        if (findTargetRelatedPopup(this, target)) {\n          return;\n        }\n        this.hide();\n      }\n      hideOnTriggerHasLeftDocument() {\n        if (!isElementNullOrInDocument(this.lastHoverTriggerEl) || !isElementNullOrInDocument(this.lastTriggerEl)) {\n          this.hide();\n        }\n      }\n      hideOnResize() {\n        if (this.hideOnResizeDisabled || inspectorLockedInstances.has(this)) {\n          return;\n        }\n        this.hide();\n      }\n      destroy() {\n        inspectorLockedInstances.delete(this);\n        stopDelayedShow(this);\n        const popupIndex = hoverTriggerInstances.indexOf(this);\n        if (popupIndex !== -1) {\n          hoverTriggerInstances.splice(popupIndex, 1);\n        }\n        this.hide();\n        this.el = null;\n        this.lastTriggerEl = null;\n        this.lastHoverTriggerEl = null;\n      }\n    };\n  }\n  var openedPopups, delayedToShowPopups, hoverPinModes, defaultShowDelay, defaultOptions;\n  var init_popup = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/popup.js"() {\n      init_layout();\n      init_dom();\n      init_pointer();\n      openedPopups = [];\n      delayedToShowPopups = /* @__PURE__ */ new Set();\n      hoverPinModes = [false, "popup-hover", "trigger-click"];\n      defaultShowDelay = 300;\n      defaultOptions = {\n        position: "trigger",\n        positionMode: "safe",\n        // \'safe\' – choose side with more space, \'natural\' – choose right/bottom when enough space\n        pointerOffsetX: 3,\n        pointerOffsetY: 3,\n        showDelay: false,\n        // false = 0, true = defaultShowDelay\n        hoverTriggers: null,\n        // null or string (a list of css selectors)\n        hoverPin: false,\n        // see hoverPinModes\n        hideIfEventOutside: true,\n        hideOnResize: true,\n        render: void 0\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/section.usage.js\n  var section_usage_default;\n  var init_section_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/section.usage.js"() {\n      section_usage_default = {\n        demo: {\n          view: "section",\n          header: \'text:"I am section"\',\n          content: [\n            \'text:"content"\'\n          ]\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/section.js\n  function section_default(host) {\n    host.view.define("section", function(el, config, data, context) {\n      const { header, content } = config;\n      return host.view.render(el, [\n        { view: "header", content: header },\n        content\n      ], data, context);\n    }, { usage: section_usage_default });\n  }\n  var init_section = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/section.js"() {\n      init_section_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/layout/toc-section.js\n  function toc_section_default(host) {\n    host.view.define("toc-section", function(el, config, data, context) {\n      const { header, content } = config;\n      return host.view.render(el, [\n        {\n          view: "block",\n          className: "header",\n          content: header\n        },\n        {\n          view: "block",\n          className: "content",\n          content\n        }\n      ], data, context);\n    }, {\n      tag: "section"\n    });\n  }\n  var init_toc_section = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/layout/toc-section.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/alerts.usage.js\n  var alerts_usage_default;\n  var init_alerts_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/alerts.usage.js"() {\n      alerts_usage_default = (view, group) => ({\n        demo: {\n          view,\n          data: \'"Alert"\'\n        },\n        examples: [\n          {\n            title: "Variations",\n            demo: group.map((name) => `${name}:"${name}"`)\n          },\n          {\n            title: "Complex content",\n            demo: {\n              view,\n              content: [\n                \'h3:"Some header"\',\n                \'text:"Hello world!"\'\n              ]\n            }\n          }\n        ]\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/alerts.js\n  function alerts_default(host) {\n    function render2(el, config, data, context) {\n      const { content = "text" } = config;\n      el.classList.add("view-alert");\n      return host.view.render(el, content, data, context);\n    }\n    host.view.define("alert", render2, { usage: alerts_usage_default });\n    host.view.define("alert-primary", render2, { usage: alerts_usage_default });\n    host.view.define("alert-success", render2, { usage: alerts_usage_default });\n    host.view.define("alert-danger", render2, { usage: alerts_usage_default });\n    host.view.define("alert-warning", render2, { usage: alerts_usage_default });\n  }\n  var init_alerts = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/alerts.js"() {\n      init_alerts_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/auto-link.js\n  function auto_link_default(host) {\n    host.view.define("auto-link", function(el, config, data, context) {\n      const { content, fallback, href } = config;\n      if (!data) {\n        return;\n      }\n      const links = host.resolveValueLinks(data);\n      const preprocessHref = typeof href === "function" ? href : (value) => value;\n      const processedHref = links ? preprocessHref(links[0].href, data, context) : null;\n      if (processedHref) {\n        return host.view.render(el, { view: "link", content }, {\n          ...links[0],\n          href: processedHref\n        }, context);\n      } else {\n        return host.view.render(el, fallback || content || "text", data, context);\n      }\n    }, {\n      tag: false\n    });\n  }\n  var init_auto_link = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/auto-link.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/badges.usage.js\n  var badges_usage_default;\n  var init_badges_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/badges.usage.js"() {\n      badges_usage_default = (view, group) => ({\n        demo: {\n          view,\n          data: JSON.stringify(view)\n        },\n        examples: [\n          {\n            title: "Variations",\n            demo: group.map((name) => `${name}:"${name}"`)\n          },\n          {\n            title: "Custom colors",\n            beforeDemo: {\n              view: "md",\n              source: [\n                "Data properties to setup a custom colors:",\n                "* `color` \\u2013 default background color",\n                "* `textColor` \\u2013 default text color",\n                "* `darkColor` \\u2013 background color in dark mode",\n                "* `textColor` \\u2013 text color in dark mode"\n              ].join("\\n")\n            },\n            demo: {\n              view,\n              data: {\n                text: "Colored badge",\n                color: "rgba(237, 177, 9, 0.35)",\n                textColor: "orange",\n                darkColor: "#ffff00",\n                darkTextColor: "black"\n              }\n            }\n          },\n          {\n            title: "As a link",\n            demo: {\n              view,\n              data: {\n                text: "Link to something",\n                href: "#",\n                external: true\n              }\n            }\n          },\n          {\n            title: "Prefix and postfix",\n            demo: {\n              view,\n              data: {\n                prefix: "prefix",\n                text: "link",\n                postfix: "postfix"\n              }\n            }\n          },\n          {\n            title: "With a hint",\n            demo: {\n              view,\n              data: {\n                text: "text",\n                hint: "hint"\n              }\n            }\n          }\n        ]\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/badges.js\n  function maybeFix(el, type, value) {\n    if (!value) {\n      return;\n    }\n    const prefixEl = el.appendChild(document.createElement("span"));\n    prefixEl.className = type;\n    prefixEl.textContent = value;\n  }\n  function badges_default(host) {\n    const prepareProps = host.queryFn(`is not array? | {\n        color,\n        textColor,\n        darkColor,\n        darkTextColor,\n        text: is (string or number or boolean) ?: text,\n        content: #.content,\n        href,\n        external,\n        prefix,\n        postfix,\n        hint\n    } | entries().({\n        key,\n        value: #[key] != undefined ? #[key] : value\n    }).fromEntries()`);\n    function render2(el, config, data, context) {\n      const {\n        color,\n        textColor,\n        darkColor,\n        darkTextColor,\n        text,\n        content,\n        href,\n        external,\n        prefix,\n        postfix,\n        hint\n      } = prepareProps(data, config);\n      let render3;\n      if (color) {\n        el.style.setProperty("--discovery-view-badge-color", color);\n      }\n      if (darkColor) {\n        el.style.setProperty("--discovery-view-badge-dark-color", darkColor);\n      }\n      if (textColor) {\n        el.style.setProperty("--discovery-view-badge-text-color", textColor);\n      }\n      if (darkTextColor) {\n        el.style.setProperty("--discovery-view-badge-dark-text-color", darkTextColor);\n      }\n      if (href) {\n        el.href = href;\n      }\n      if (external) {\n        el.target = "_blank";\n      }\n      if (hint) {\n        el.title = hint;\n      }\n      maybeFix(el, "prefix", prefix);\n      if (content) {\n        render3 = this.render(el, content, data, context);\n      } else {\n        el.append(document.createTextNode(text));\n      }\n      maybeFix(el, "postfix", postfix);\n      return render3;\n    }\n    host.view.define("badge", render2, { tag: "a", usage: badges_usage_default });\n    host.view.define("pill-badge", render2, { tag: "a", usage: badges_usage_default });\n  }\n  var init_badges = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/badges.js"() {\n      init_badges_usage();\n    }\n  });\n\n  // node_modules/marked/lib/marked.esm.js\n  function getDefaults() {\n    return {\n      async: false,\n      baseUrl: null,\n      breaks: false,\n      extensions: null,\n      gfm: true,\n      headerIds: true,\n      headerPrefix: "",\n      highlight: null,\n      hooks: null,\n      langPrefix: "language-",\n      mangle: true,\n      pedantic: false,\n      renderer: null,\n      sanitize: false,\n      sanitizer: null,\n      silent: false,\n      smartypants: false,\n      tokenizer: null,\n      walkTokens: null,\n      xhtml: false\n    };\n  }\n  function changeDefaults(newDefaults) {\n    defaults = newDefaults;\n  }\n  function escape(html, encode2) {\n    if (encode2) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n    return html;\n  }\n  function unescape(html) {\n    return html.replace(unescapeTest, (_, n) => {\n      n = n.toLowerCase();\n      if (n === "colon")\n        return ":";\n      if (n.charAt(0) === "#") {\n        return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n      return "";\n    });\n  }\n  function edit(regex, opt) {\n    regex = typeof regex === "string" ? regex : regex.source;\n    opt = opt || "";\n    const obj = {\n      replace: (name, val) => {\n        val = val.source || val;\n        val = val.replace(caret, "$1");\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: () => {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n  function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n      let prot;\n      try {\n        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();\n      } catch (e) {\n        return null;\n      }\n      if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {\n        return null;\n      }\n    }\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n    try {\n      href = encodeURI(href).replace(/%25/g, "%");\n    } catch (e) {\n      return null;\n    }\n    return href;\n  }\n  function resolveUrl(base, href) {\n    if (!baseUrls[" " + base]) {\n      if (justDomain.test(base)) {\n        baseUrls[" " + base] = base + "/";\n      } else {\n        baseUrls[" " + base] = rtrim(base, "/", true);\n      }\n    }\n    base = baseUrls[" " + base];\n    const relativeBase = base.indexOf(":") === -1;\n    if (href.substring(0, 2) === "//") {\n      if (relativeBase) {\n        return href;\n      }\n      return base.replace(protocol, "$1") + href;\n    } else if (href.charAt(0) === "/") {\n      if (relativeBase) {\n        return href;\n      }\n      return base.replace(domain, "$1") + href;\n    } else {\n      return base + href;\n    }\n  }\n  function splitCells(tableRow, count3) {\n    const row = tableRow.replace(/\\|/g, (match2, offset, str) => {\n      let escaped = false, curr = offset;\n      while (--curr >= 0 && str[curr] === "\\\\")\n        escaped = !escaped;\n      if (escaped) {\n        return "|";\n      } else {\n        return " |";\n      }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    if (!cells[0].trim()) {\n      cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n      cells.pop();\n    }\n    if (cells.length > count3) {\n      cells.splice(count3);\n    } else {\n      while (cells.length < count3)\n        cells.push("");\n    }\n    for (; i < cells.length; i++) {\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, "|");\n    }\n    return cells;\n  }\n  function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n      return "";\n    }\n    let suffLen = 0;\n    while (suffLen < l) {\n      const currChar = str.charAt(l - suffLen - 1);\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n    return str.slice(0, l - suffLen);\n  }\n  function findClosingBracket(str, b2) {\n    if (str.indexOf(b2[1]) === -1) {\n      return -1;\n    }\n    const l = str.length;\n    let level = 0, i = 0;\n    for (; i < l; i++) {\n      if (str[i] === "\\\\") {\n        i++;\n      } else if (str[i] === b2[0]) {\n        level++;\n      } else if (str[i] === b2[1]) {\n        level--;\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  function checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");\n    }\n  }\n  function repeatString(pattern, count3) {\n    if (count3 < 1) {\n      return "";\n    }\n    let result = "";\n    while (count3 > 1) {\n      if (count3 & 1) {\n        result += pattern;\n      }\n      count3 >>= 1;\n      pattern += pattern;\n    }\n    return result + pattern;\n  }\n  function outputLink(cap, link, raw, lexer3) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, "$1");\n    if (cap[0].charAt(0) !== "!") {\n      lexer3.state.inLink = true;\n      const token2 = {\n        type: "link",\n        raw,\n        href,\n        title,\n        text,\n        tokens: lexer3.inlineTokens(text)\n      };\n      lexer3.state.inLink = false;\n      return token2;\n    }\n    return {\n      type: "image",\n      raw,\n      href,\n      title,\n      text: escape(text)\n    };\n  }\n  function indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n      return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split("\\n").map((node) => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n      const [indentInNode] = matchIndentInNode;\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n      return node;\n    }).join("\\n");\n  }\n  function smartypants(text) {\n    return text.replace(/---/g, "\\u2014").replace(/--/g, "\\u2013").replace(/(^|[-\\u2014/(\\[{"\\s])\'/g, "$1\\u2018").replace(/\'/g, "\\u2019").replace(/(^|[-\\u2014/(\\[{\\u2018\\s])"/g, "$1\\u201C").replace(/"/g, "\\u201D").replace(/\\.{3}/g, "\\u2026");\n  }\n  function mangle(text) {\n    let out = "", i, ch;\n    const l = text.length;\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n      if (Math.random() > 0.5) {\n        ch = "x" + ch.toString(16);\n      }\n      out += "&#" + ch + ";";\n    }\n    return out;\n  }\n  function onError(silent, async, callback) {\n    return (e) => {\n      e.message += "\\nPlease report this to https://github.com/markedjs/marked.";\n      if (silent) {\n        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";\n        if (async) {\n          return Promise.resolve(msg);\n        }\n        if (callback) {\n          callback(null, msg);\n          return;\n        }\n        return msg;\n      }\n      if (async) {\n        return Promise.reject(e);\n      }\n      if (callback) {\n        callback(e);\n        return;\n      }\n      throw e;\n    };\n  }\n  function parseMarkdown(lexer3, parser3) {\n    return (src, opt, callback) => {\n      if (typeof opt === "function") {\n        callback = opt;\n        opt = null;\n      }\n      const origOpt = { ...opt };\n      opt = { ...marked.defaults, ...origOpt };\n      const throwError = onError(opt.silent, opt.async, callback);\n      if (typeof src === "undefined" || src === null) {\n        return throwError(new Error("marked(): input parameter is undefined or null"));\n      }\n      if (typeof src !== "string") {\n        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));\n      }\n      checkSanitizeDeprecation(opt);\n      if (opt.hooks) {\n        opt.hooks.options = opt;\n      }\n      if (callback) {\n        const highlight = opt.highlight;\n        let tokens;\n        try {\n          if (opt.hooks) {\n            src = opt.hooks.preprocess(src);\n          }\n          tokens = lexer3(src, opt);\n        } catch (e) {\n          return throwError(e);\n        }\n        const done = function(err) {\n          let out;\n          if (!err) {\n            try {\n              if (opt.walkTokens) {\n                marked.walkTokens(tokens, opt.walkTokens);\n              }\n              out = parser3(tokens, opt);\n              if (opt.hooks) {\n                out = opt.hooks.postprocess(out);\n              }\n            } catch (e) {\n              err = e;\n            }\n          }\n          opt.highlight = highlight;\n          return err ? throwError(err) : callback(null, out);\n        };\n        if (!highlight || highlight.length < 3) {\n          return done();\n        }\n        delete opt.highlight;\n        if (!tokens.length)\n          return done();\n        let pending = 0;\n        marked.walkTokens(tokens, function(token2) {\n          if (token2.type === "code") {\n            pending++;\n            setTimeout(() => {\n              highlight(token2.text, token2.lang, function(err, code) {\n                if (err) {\n                  return done(err);\n                }\n                if (code != null && code !== token2.text) {\n                  token2.text = code;\n                  token2.escaped = true;\n                }\n                pending--;\n                if (pending === 0) {\n                  done();\n                }\n              });\n            }, 0);\n          }\n        });\n        if (pending === 0) {\n          done();\n        }\n        return;\n      }\n      if (opt.async) {\n        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer3(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser3(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n      }\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src);\n        }\n        const tokens = lexer3(src, opt);\n        if (opt.walkTokens) {\n          marked.walkTokens(tokens, opt.walkTokens);\n        }\n        let html = parser3(tokens, opt);\n        if (opt.hooks) {\n          html = opt.hooks.postprocess(html);\n        }\n        return html;\n      } catch (e) {\n        return throwError(e);\n      }\n    };\n  }\n  function marked(src, opt, callback) {\n    return parseMarkdown(Lexer.lex, Parser2.parse)(src, opt, callback);\n  }\n  var defaults, escapeTest, escapeReplace, escapeTestNoEncode, escapeReplaceNoEncode, escapeReplacements, getEscapeReplacement, unescapeTest, caret, nonWordAndColonTest, originIndependentUrl, baseUrls, justDomain, protocol, domain, noopTest, Tokenizer, block, inline, Lexer, Renderer, TextRenderer, Slugger, Parser2, Hooks, options, setOptions, use, walkTokens, parseInline, parser2, lexer2;\n  var init_marked_esm = __esm({\n    "node_modules/marked/lib/marked.esm.js"() {\n      defaults = getDefaults();\n      escapeTest = /[&<>"\']/;\n      escapeReplace = new RegExp(escapeTest.source, "g");\n      escapeTestNoEncode = /[<>"\']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n      escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");\n      escapeReplacements = {\n        "&": "&amp;",\n        "<": "&lt;",\n        ">": "&gt;",\n        \'"\': "&quot;",\n        "\'": "&#39;"\n      };\n      getEscapeReplacement = (ch) => escapeReplacements[ch];\n      unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n      caret = /(^|[^\\[])\\^/g;\n      nonWordAndColonTest = /[^\\w:]/g;\n      originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n      baseUrls = {};\n      justDomain = /^[^:]+:\\/*[^/]*$/;\n      protocol = /^([^:]+:)[\\s\\S]*$/;\n      domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n      noopTest = { exec: function noopTest2() {\n      } };\n      Tokenizer = class {\n        constructor(options2) {\n          this.options = options2 || defaults;\n        }\n        space(src) {\n          const cap = this.rules.block.newline.exec(src);\n          if (cap && cap[0].length > 0) {\n            return {\n              type: "space",\n              raw: cap[0]\n            };\n          }\n        }\n        code(src) {\n          const cap = this.rules.block.code.exec(src);\n          if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, "");\n            return {\n              type: "code",\n              raw: cap[0],\n              codeBlockStyle: "indented",\n              text: !this.options.pedantic ? rtrim(text, "\\n") : text\n            };\n          }\n        }\n        fences(src) {\n          const cap = this.rules.block.fences.exec(src);\n          if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || "");\n            return {\n              type: "code",\n              raw,\n              lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],\n              text\n            };\n          }\n        }\n        heading(src) {\n          const cap = this.rules.block.heading.exec(src);\n          if (cap) {\n            let text = cap[2].trim();\n            if (/#$/.test(text)) {\n              const trimmed = rtrim(text, "#");\n              if (this.options.pedantic) {\n                text = trimmed.trim();\n              } else if (!trimmed || / $/.test(trimmed)) {\n                text = trimmed.trim();\n              }\n            }\n            return {\n              type: "heading",\n              raw: cap[0],\n              depth: cap[1].length,\n              text,\n              tokens: this.lexer.inline(text)\n            };\n          }\n        }\n        hr(src) {\n          const cap = this.rules.block.hr.exec(src);\n          if (cap) {\n            return {\n              type: "hr",\n              raw: cap[0]\n            };\n          }\n        }\n        blockquote(src) {\n          const cap = this.rules.block.blockquote.exec(src);\n          if (cap) {\n            const text = cap[0].replace(/^ *>[ \\t]?/gm, "");\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n              type: "blockquote",\n              raw: cap[0],\n              tokens,\n              text\n            };\n          }\n        }\n        list(src) {\n          let cap = this.rules.block.list.exec(src);\n          if (cap) {\n            let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n              type: "list",\n              raw: "",\n              ordered: isordered,\n              start: isordered ? +bull.slice(0, -1) : "",\n              loose: false,\n              items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n              bull = isordered ? bull : "[*+-]";\n            }\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            while (src) {\n              endEarly = false;\n              if (!(cap = itemRegex.exec(src))) {\n                break;\n              }\n              if (this.rules.block.hr.test(src)) {\n                break;\n              }\n              raw = cap[0];\n              src = src.substring(raw.length);\n              line = cap[2].split("\\n", 1)[0].replace(/^\\t+/, (t) => " ".repeat(3 * t.length));\n              nextLine = src.split("\\n", 1)[0];\n              if (this.options.pedantic) {\n                indent = 2;\n                itemContents = line.trimLeft();\n              } else {\n                indent = cap[2].search(/[^ ]/);\n                indent = indent > 4 ? 1 : indent;\n                itemContents = line.slice(indent);\n                indent += cap[1].length;\n              }\n              blankLine = false;\n              if (!line && /^ *$/.test(nextLine)) {\n                raw += nextLine + "\\n";\n                src = src.substring(nextLine.length + 1);\n                endEarly = true;\n              }\n              if (!endEarly) {\n                const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \t][^\\\\n]*)?(?:\\\\n|$))`);\n                const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                while (src) {\n                  rawLine = src.split("\\n", 1)[0];\n                  nextLine = rawLine;\n                  if (this.options.pedantic) {\n                    nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");\n                  }\n                  if (fencesBeginRegex.test(nextLine)) {\n                    break;\n                  }\n                  if (headingBeginRegex.test(nextLine)) {\n                    break;\n                  }\n                  if (nextBulletRegex.test(nextLine)) {\n                    break;\n                  }\n                  if (hrRegex.test(src)) {\n                    break;\n                  }\n                  if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                    itemContents += "\\n" + nextLine.slice(indent);\n                  } else {\n                    if (blankLine) {\n                      break;\n                    }\n                    if (line.search(/[^ ]/) >= 4) {\n                      break;\n                    }\n                    if (fencesBeginRegex.test(line)) {\n                      break;\n                    }\n                    if (headingBeginRegex.test(line)) {\n                      break;\n                    }\n                    if (hrRegex.test(line)) {\n                      break;\n                    }\n                    itemContents += "\\n" + nextLine;\n                  }\n                  if (!blankLine && !nextLine.trim()) {\n                    blankLine = true;\n                  }\n                  raw += rawLine + "\\n";\n                  src = src.substring(rawLine.length + 1);\n                  line = nextLine.slice(indent);\n                }\n              }\n              if (!list.loose) {\n                if (endsWithBlankLine) {\n                  list.loose = true;\n                } else if (/\\n *\\n *$/.test(raw)) {\n                  endsWithBlankLine = true;\n                }\n              }\n              if (this.options.gfm) {\n                istask = /^\\[[ xX]\\] /.exec(itemContents);\n                if (istask) {\n                  ischecked = istask[0] !== "[ ] ";\n                  itemContents = itemContents.replace(/^\\[[ xX]\\] +/, "");\n                }\n              }\n              list.items.push({\n                type: "list_item",\n                raw,\n                task: !!istask,\n                checked: ischecked,\n                loose: false,\n                text: itemContents\n              });\n              list.raw += raw;\n            }\n            list.items[list.items.length - 1].raw = raw.trimRight();\n            list.items[list.items.length - 1].text = itemContents.trimRight();\n            list.raw = list.raw.trimRight();\n            const l = list.items.length;\n            for (i = 0; i < l; i++) {\n              this.lexer.state.top = false;\n              list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n              if (!list.loose) {\n                const spacers = list.items[i].tokens.filter((t) => t.type === "space");\n                const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\\n.*\\n/.test(t.raw));\n                list.loose = hasMultipleLineBreaks;\n              }\n            }\n            if (list.loose) {\n              for (i = 0; i < l; i++) {\n                list.items[i].loose = true;\n              }\n            }\n            return list;\n          }\n        }\n        html(src) {\n          const cap = this.rules.block.html.exec(src);\n          if (cap) {\n            const token2 = {\n              type: "html",\n              raw: cap[0],\n              pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),\n              text: cap[0]\n            };\n            if (this.options.sanitize) {\n              const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n              token2.type = "paragraph";\n              token2.text = text;\n              token2.tokens = this.lexer.inline(text);\n            }\n            return token2;\n          }\n        }\n        def(src) {\n          const cap = this.rules.block.def.exec(src);\n          if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, " ");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];\n            return {\n              type: "def",\n              tag,\n              raw: cap[0],\n              href,\n              title\n            };\n          }\n        }\n        table(src) {\n          const cap = this.rules.block.table.exec(src);\n          if (cap) {\n            const item = {\n              type: "table",\n              header: splitCells(cap[1]).map((c) => {\n                return { text: c };\n              }),\n              align: cap[2].replace(/^ *|\\| *$/g, "").split(/ *\\| */),\n              rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, "").split("\\n") : []\n            };\n            if (item.header.length === item.align.length) {\n              item.raw = cap[0];\n              let l = item.align.length;\n              let i, j2, k2, row;\n              for (i = 0; i < l; i++) {\n                if (/^ *-+: *$/.test(item.align[i])) {\n                  item.align[i] = "right";\n                } else if (/^ *:-+: *$/.test(item.align[i])) {\n                  item.align[i] = "center";\n                } else if (/^ *:-+ *$/.test(item.align[i])) {\n                  item.align[i] = "left";\n                } else {\n                  item.align[i] = null;\n                }\n              }\n              l = item.rows.length;\n              for (i = 0; i < l; i++) {\n                item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {\n                  return { text: c };\n                });\n              }\n              l = item.header.length;\n              for (j2 = 0; j2 < l; j2++) {\n                item.header[j2].tokens = this.lexer.inline(item.header[j2].text);\n              }\n              l = item.rows.length;\n              for (j2 = 0; j2 < l; j2++) {\n                row = item.rows[j2];\n                for (k2 = 0; k2 < row.length; k2++) {\n                  row[k2].tokens = this.lexer.inline(row[k2].text);\n                }\n              }\n              return item;\n            }\n          }\n        }\n        lheading(src) {\n          const cap = this.rules.block.lheading.exec(src);\n          if (cap) {\n            return {\n              type: "heading",\n              raw: cap[0],\n              depth: cap[2].charAt(0) === "=" ? 1 : 2,\n              text: cap[1],\n              tokens: this.lexer.inline(cap[1])\n            };\n          }\n        }\n        paragraph(src) {\n          const cap = this.rules.block.paragraph.exec(src);\n          if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === "\\n" ? cap[1].slice(0, -1) : cap[1];\n            return {\n              type: "paragraph",\n              raw: cap[0],\n              text,\n              tokens: this.lexer.inline(text)\n            };\n          }\n        }\n        text(src) {\n          const cap = this.rules.block.text.exec(src);\n          if (cap) {\n            return {\n              type: "text",\n              raw: cap[0],\n              text: cap[0],\n              tokens: this.lexer.inline(cap[0])\n            };\n          }\n        }\n        escape(src) {\n          const cap = this.rules.inline.escape.exec(src);\n          if (cap) {\n            return {\n              type: "escape",\n              raw: cap[0],\n              text: escape(cap[1])\n            };\n          }\n        }\n        tag(src) {\n          const cap = this.rules.inline.tag.exec(src);\n          if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n              this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n              this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n              this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n              this.lexer.state.inRawBlock = false;\n            }\n            return {\n              type: this.options.sanitize ? "text" : "html",\n              raw: cap[0],\n              inLink: this.lexer.state.inLink,\n              inRawBlock: this.lexer.state.inRawBlock,\n              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n            };\n          }\n        }\n        link(src) {\n          const cap = this.rules.inline.link.exec(src);\n          if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n              if (!/>$/.test(trimmedUrl)) {\n                return;\n              }\n              const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\\\");\n              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                return;\n              }\n            } else {\n              const lastParenIndex = findClosingBracket(cap[2], "()");\n              if (lastParenIndex > -1) {\n                const start = cap[0].indexOf("!") === 0 ? 5 : 4;\n                const linkLen = start + cap[1].length + lastParenIndex;\n                cap[2] = cap[2].substring(0, lastParenIndex);\n                cap[0] = cap[0].substring(0, linkLen).trim();\n                cap[3] = "";\n              }\n            }\n            let href = cap[2];\n            let title = "";\n            if (this.options.pedantic) {\n              const link = /^([^\'"]*[^\\s])\\s+([\'"])(.*)\\2/.exec(href);\n              if (link) {\n                href = link[1];\n                title = link[3];\n              }\n            } else {\n              title = cap[3] ? cap[3].slice(1, -1) : "";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n              if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                href = href.slice(1);\n              } else {\n                href = href.slice(1, -1);\n              }\n            }\n            return outputLink(cap, {\n              href: href ? href.replace(this.rules.inline._escapes, "$1") : href,\n              title: title ? title.replace(this.rules.inline._escapes, "$1") : title\n            }, cap[0], this.lexer);\n          }\n        }\n        reflink(src, links) {\n          let cap;\n          if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            let link = (cap[2] || cap[1]).replace(/\\s+/g, " ");\n            link = links[link.toLowerCase()];\n            if (!link) {\n              const text = cap[0].charAt(0);\n              return {\n                type: "text",\n                raw: text,\n                text\n              };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n          }\n        }\n        emStrong(src, maskedSrc, prevChar = "") {\n          let match2 = this.rules.inline.emStrong.lDelim.exec(src);\n          if (!match2)\n            return;\n          if (match2[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n          const nextChar = match2[1] || match2[2] || "";\n          if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {\n            const lLength = match2[0].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match2[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n            endReg.lastIndex = 0;\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match2 = endReg.exec(maskedSrc)) != null) {\n              rDelim = match2[1] || match2[2] || match2[3] || match2[4] || match2[5] || match2[6];\n              if (!rDelim)\n                continue;\n              rLength = rDelim.length;\n              if (match2[3] || match2[4]) {\n                delimTotal += rLength;\n                continue;\n              } else if (match2[5] || match2[6]) {\n                if (lLength % 3 && !((lLength + rLength) % 3)) {\n                  midDelimTotal += rLength;\n                  continue;\n                }\n              }\n              delimTotal -= rLength;\n              if (delimTotal > 0)\n                continue;\n              rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n              const raw = src.slice(0, lLength + match2.index + (match2[0].length - rDelim.length) + rLength);\n              if (Math.min(lLength, rLength) % 2) {\n                const text2 = raw.slice(1, -1);\n                return {\n                  type: "em",\n                  raw,\n                  text: text2,\n                  tokens: this.lexer.inlineTokens(text2)\n                };\n              }\n              const text = raw.slice(2, -2);\n              return {\n                type: "strong",\n                raw,\n                text,\n                tokens: this.lexer.inlineTokens(text)\n              };\n            }\n          }\n        }\n        codespan(src) {\n          const cap = this.rules.inline.code.exec(src);\n          if (cap) {\n            let text = cap[2].replace(/\\n/g, " ");\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n              text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n              type: "codespan",\n              raw: cap[0],\n              text\n            };\n          }\n        }\n        br(src) {\n          const cap = this.rules.inline.br.exec(src);\n          if (cap) {\n            return {\n              type: "br",\n              raw: cap[0]\n            };\n          }\n        }\n        del(src) {\n          const cap = this.rules.inline.del.exec(src);\n          if (cap) {\n            return {\n              type: "del",\n              raw: cap[0],\n              text: cap[2],\n              tokens: this.lexer.inlineTokens(cap[2])\n            };\n          }\n        }\n        autolink(src, mangle2) {\n          const cap = this.rules.inline.autolink.exec(src);\n          if (cap) {\n            let text, href;\n            if (cap[2] === "@") {\n              text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);\n              href = "mailto:" + text;\n            } else {\n              text = escape(cap[1]);\n              href = text;\n            }\n            return {\n              type: "link",\n              raw: cap[0],\n              text,\n              href,\n              tokens: [\n                {\n                  type: "text",\n                  raw: text,\n                  text\n                }\n              ]\n            };\n          }\n        }\n        url(src, mangle2) {\n          let cap;\n          if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === "@") {\n              text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);\n              href = "mailto:" + text;\n            } else {\n              let prevCapZero;\n              do {\n                prevCapZero = cap[0];\n                cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n              } while (prevCapZero !== cap[0]);\n              text = escape(cap[0]);\n              if (cap[1] === "www.") {\n                href = "http://" + cap[0];\n              } else {\n                href = cap[0];\n              }\n            }\n            return {\n              type: "link",\n              raw: cap[0],\n              text,\n              href,\n              tokens: [\n                {\n                  type: "text",\n                  raw: text,\n                  text\n                }\n              ]\n            };\n          }\n        }\n        inlineText(src, smartypants2) {\n          const cap = this.rules.inline.text.exec(src);\n          if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n              text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n            } else {\n              text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);\n            }\n            return {\n              type: "text",\n              raw: cap[0],\n              text\n            };\n          }\n        }\n      };\n      block = {\n        newline: /^(?: *(?:\\n|$))+/,\n        code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n        fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n        hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n        heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n        blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n        list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n        html: "^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$))",\n        def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n        table: noopTest,\n        lheading: /^((?:.|\\n(?!\\n))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        // regex template, placeholders will be replaced according to different paragraph\n        // interruption rules of commonmark and the original markdown spec:\n        _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n        text: /^[^\\n]+/\n      };\n      block._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n      block._title = /(?:"(?:\\\\"?|[^"\\\\])*"|\'[^\'\\n]*(?:\\n[^\'\\n]+)*\\n?\'|\\([^()]*\\))/;\n      block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();\n      block.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n      block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();\n      block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))").replace("def", "\\\\n+(?=" + block.def.source + ")").getRegex();\n      block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";\n      block._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n      block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\\w.:-]*(?: *= *"[^"\\n]*"| *= *\'[^\'\\n]*\'| *= *[^\\s"\'=<>`]+)?/).getRegex();\n      block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();\n      block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();\n      block.normal = { ...block };\n      block.gfm = {\n        ...block.normal,\n        table: "^ *([^\\\\n ].*\\\\|.*)\\\\n {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)"\n        // Cells\n      };\n      block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();\n      block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();\n      block.pedantic = {\n        ...block.normal,\n        html: edit(\n          `^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:"[^"]*"|\'[^\']*\'|\\\\s[^\'"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))`\n        ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b").getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +(["(][^\\n]+[")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest,\n        // fences not supported\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()\n      };\n      inline = {\n        escape: /^\\\\([!"#$%&\'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n        autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n        url: noopTest,\n        tag: "^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>",\n        // CDATA section\n        link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n        reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n        nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n        reflinkSearch: "reflink|nolink(?!\\\\()",\n        emStrong: {\n          lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n          //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n          //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n          rDelimAst: /^(?:[^_*\\\\]|\\\\.)*?\\_\\_(?:[^_*\\\\]|\\\\.)*?\\*(?:[^_*\\\\]|\\\\.)*?(?=\\_\\_)|(?:[^*\\\\]|\\\\.)+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[^punct*_\\s])/,\n          rDelimUnd: /^(?:[^_*\\\\]|\\\\.)*?\\*\\*(?:[^_*\\\\]|\\\\.)*?\\_(?:[^_*\\\\]|\\\\.)*?(?=\\*\\*)|(?:[^_\\\\]|\\\\.)+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/\n          // ^- Not allowed for _\n        },\n        code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n        br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n        del: noopTest,\n        text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n        punctuation: /^([\\spunctuation])/\n      };\n      inline._punctuation = "!\\"#$%&\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~";\n      inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n      inline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n      inline.escapedEmSt = /(?:^|[^\\\\])(?:\\\\\\\\)*\\\\[*_]/g;\n      inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();\n      inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();\n      inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();\n      inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();\n      inline._escapes = /\\\\([!"#$%&\'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n      inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n      inline._email = /[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n      inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();\n      inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*"[^"]*"|\\s*=\\s*\'[^\']*\'|\\s*=\\s*[^\\s"\'=<>`]+)?/;\n      inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();\n      inline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n      inline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\n      inline._title = /"(?:\\\\"?|[^"\\\\])*"|\'(?:\\\\\'?|[^\'\\\\])*\'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n      inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();\n      inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();\n      inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();\n      inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();\n      inline.normal = { ...inline };\n      inline.pedantic = {\n        ...inline.normal,\n        strong: {\n          start: /^__|\\*\\*/,\n          middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n          endAst: /\\*\\*(?!\\*)/g,\n          endUnd: /__(?!_)/g\n        },\n        em: {\n          start: /^_|\\*/,\n          middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n          endAst: /\\*(?!\\*)/g,\n          endUnd: /_(?!_)/g\n        },\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace("label", inline._label).getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace("label", inline._label).getRegex()\n      };\n      inline.gfm = {\n        ...inline.normal,\n        escape: edit(inline.escape).replace("])", "~|])").getRegex(),\n        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n        url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n        _backpedal: /(?:[^?!.,:;*_\'"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_\'"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&\'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&\'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&\'*+\\/=?_`{\\|}~-]+@)))/\n      };\n      inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();\n      inline.breaks = {\n        ...inline.gfm,\n        br: edit(inline.br).replace("{2,}", "*").getRegex(),\n        text: edit(inline.gfm.text).replace("\\\\b_", "\\\\b_| {2,}\\\\n").replace(/\\{2,\\}/g, "*").getRegex()\n      };\n      Lexer = class _Lexer {\n        constructor(options2) {\n          this.tokens = [];\n          this.tokens.links = /* @__PURE__ */ Object.create(null);\n          this.options = options2 || defaults;\n          this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n          this.tokenizer = this.options.tokenizer;\n          this.tokenizer.options = this.options;\n          this.tokenizer.lexer = this;\n          this.inlineQueue = [];\n          this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n          };\n          const rules = {\n            block: block.normal,\n            inline: inline.normal\n          };\n          if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n          } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n              rules.inline = inline.breaks;\n            } else {\n              rules.inline = inline.gfm;\n            }\n          }\n          this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */\n        static get rules() {\n          return {\n            block,\n            inline\n          };\n        }\n        /**\n         * Static Lex Method\n         */\n        static lex(src, options2) {\n          const lexer3 = new _Lexer(options2);\n          return lexer3.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */\n        static lexInline(src, options2) {\n          const lexer3 = new _Lexer(options2);\n          return lexer3.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */\n        lex(src) {\n          src = src.replace(/\\r\\n|\\r/g, "\\n");\n          this.blockTokens(src, this.tokens);\n          let next;\n          while (next = this.inlineQueue.shift()) {\n            this.inlineTokens(next.src, next.tokens);\n          }\n          return this.tokens;\n        }\n        /**\n         * Lexing\n         */\n        blockTokens(src, tokens = []) {\n          if (this.options.pedantic) {\n            src = src.replace(/\\t/g, "    ").replace(/^ +$/gm, "");\n          } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n              return leading + "    ".repeat(tabs.length);\n            });\n          }\n          let token2, lastToken, cutSrc, lastParagraphClipped;\n          while (src) {\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {\n              if (token2 = extTokenizer.call({ lexer: this }, src, tokens)) {\n                src = src.substring(token2.raw.length);\n                tokens.push(token2);\n                return true;\n              }\n              return false;\n            })) {\n              continue;\n            }\n            if (token2 = this.tokenizer.space(src)) {\n              src = src.substring(token2.raw.length);\n              if (token2.raw.length === 1 && tokens.length > 0) {\n                tokens[tokens.length - 1].raw += "\\n";\n              } else {\n                tokens.push(token2);\n              }\n              continue;\n            }\n            if (token2 = this.tokenizer.code(src)) {\n              src = src.substring(token2.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {\n                lastToken.raw += "\\n" + token2.raw;\n                lastToken.text += "\\n" + token2.text;\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else {\n                tokens.push(token2);\n              }\n              continue;\n            }\n            if (token2 = this.tokenizer.fences(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.heading(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.hr(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.blockquote(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.list(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.html(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.def(src)) {\n              src = src.substring(token2.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {\n                lastToken.raw += "\\n" + token2.raw;\n                lastToken.text += "\\n" + token2.raw;\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else if (!this.tokens.links[token2.tag]) {\n                this.tokens.links[token2.tag] = {\n                  href: token2.href,\n                  title: token2.title\n                };\n              }\n              continue;\n            }\n            if (token2 = this.tokenizer.table(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.lheading(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n              let startIndex = Infinity;\n              const tempSrc = src.slice(1);\n              let tempStart;\n              this.options.extensions.startBlock.forEach(function(getStartIndex) {\n                tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                if (typeof tempStart === "number" && tempStart >= 0) {\n                  startIndex = Math.min(startIndex, tempStart);\n                }\n              });\n              if (startIndex < Infinity && startIndex >= 0) {\n                cutSrc = src.substring(0, startIndex + 1);\n              }\n            }\n            if (this.state.top && (token2 = this.tokenizer.paragraph(cutSrc))) {\n              lastToken = tokens[tokens.length - 1];\n              if (lastParagraphClipped && lastToken.type === "paragraph") {\n                lastToken.raw += "\\n" + token2.raw;\n                lastToken.text += "\\n" + token2.text;\n                this.inlineQueue.pop();\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else {\n                tokens.push(token2);\n              }\n              lastParagraphClipped = cutSrc.length !== src.length;\n              src = src.substring(token2.raw.length);\n              continue;\n            }\n            if (token2 = this.tokenizer.text(src)) {\n              src = src.substring(token2.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && lastToken.type === "text") {\n                lastToken.raw += "\\n" + token2.raw;\n                lastToken.text += "\\n" + token2.text;\n                this.inlineQueue.pop();\n                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n              } else {\n                tokens.push(token2);\n              }\n              continue;\n            }\n            if (src) {\n              const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);\n              if (this.options.silent) {\n                console.error(errMsg);\n                break;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n          }\n          this.state.top = true;\n          return tokens;\n        }\n        inline(src, tokens = []) {\n          this.inlineQueue.push({ src, tokens });\n          return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */\n        inlineTokens(src, tokens = []) {\n          let token2, lastToken, cutSrc;\n          let maskedSrc = src;\n          let match2;\n          let keepPrevChar, prevChar;\n          if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n              while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                if (links.includes(match2[0].slice(match2[0].lastIndexOf("[") + 1, -1))) {\n                  maskedSrc = maskedSrc.slice(0, match2.index) + "[" + repeatString("a", match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                }\n              }\n            }\n          }\n          while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match2.index) + "[" + repeatString("a", match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n          }\n          while ((match2 = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match2.index + match2[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n            this.tokenizer.rules.inline.escapedEmSt.lastIndex--;\n          }\n          while (src) {\n            if (!keepPrevChar) {\n              prevChar = "";\n            }\n            keepPrevChar = false;\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {\n              if (token2 = extTokenizer.call({ lexer: this }, src, tokens)) {\n                src = src.substring(token2.raw.length);\n                tokens.push(token2);\n                return true;\n              }\n              return false;\n            })) {\n              continue;\n            }\n            if (token2 = this.tokenizer.escape(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.tag(src)) {\n              src = src.substring(token2.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && token2.type === "text" && lastToken.type === "text") {\n                lastToken.raw += token2.raw;\n                lastToken.text += token2.text;\n              } else {\n                tokens.push(token2);\n              }\n              continue;\n            }\n            if (token2 = this.tokenizer.link(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.reflink(src, this.tokens.links)) {\n              src = src.substring(token2.raw.length);\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && token2.type === "text" && lastToken.type === "text") {\n                lastToken.raw += token2.raw;\n                lastToken.text += token2.text;\n              } else {\n                tokens.push(token2);\n              }\n              continue;\n            }\n            if (token2 = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.codespan(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.br(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.del(src)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (token2 = this.tokenizer.autolink(src, mangle)) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            if (!this.state.inLink && (token2 = this.tokenizer.url(src, mangle))) {\n              src = src.substring(token2.raw.length);\n              tokens.push(token2);\n              continue;\n            }\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n              let startIndex = Infinity;\n              const tempSrc = src.slice(1);\n              let tempStart;\n              this.options.extensions.startInline.forEach(function(getStartIndex) {\n                tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                if (typeof tempStart === "number" && tempStart >= 0) {\n                  startIndex = Math.min(startIndex, tempStart);\n                }\n              });\n              if (startIndex < Infinity && startIndex >= 0) {\n                cutSrc = src.substring(0, startIndex + 1);\n              }\n            }\n            if (token2 = this.tokenizer.inlineText(cutSrc, smartypants)) {\n              src = src.substring(token2.raw.length);\n              if (token2.raw.slice(-1) !== "_") {\n                prevChar = token2.raw.slice(-1);\n              }\n              keepPrevChar = true;\n              lastToken = tokens[tokens.length - 1];\n              if (lastToken && lastToken.type === "text") {\n                lastToken.raw += token2.raw;\n                lastToken.text += token2.text;\n              } else {\n                tokens.push(token2);\n              }\n              continue;\n            }\n            if (src) {\n              const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);\n              if (this.options.silent) {\n                console.error(errMsg);\n                break;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n          }\n          return tokens;\n        }\n      };\n      Renderer = class {\n        constructor(options2) {\n          this.options = options2 || defaults;\n        }\n        code(code, infostring, escaped) {\n          const lang = (infostring || "").match(/\\S*/)[0];\n          if (this.options.highlight) {\n            const out = this.options.highlight(code, lang);\n            if (out != null && out !== code) {\n              escaped = true;\n              code = out;\n            }\n          }\n          code = code.replace(/\\n$/, "") + "\\n";\n          if (!lang) {\n            return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\\n";\n          }\n          return \'<pre><code class="\' + this.options.langPrefix + escape(lang) + \'">\' + (escaped ? code : escape(code, true)) + "</code></pre>\\n";\n        }\n        /**\n         * @param {string} quote\n         */\n        blockquote(quote2) {\n          return `<blockquote>\n${quote2}</blockquote>\n`;\n        }\n        html(html) {\n          return html;\n        }\n        /**\n         * @param {string} text\n         * @param {string} level\n         * @param {string} raw\n         * @param {any} slugger\n         */\n        heading(text, level, raw, slugger) {\n          if (this.options.headerIds) {\n            const id = this.options.headerPrefix + slugger.slug(raw);\n            return `<h${level} id="${id}">${text}</h${level}>\n`;\n          }\n          return `<h${level}>${text}</h${level}>\n`;\n        }\n        hr() {\n          return this.options.xhtml ? "<hr/>\\n" : "<hr>\\n";\n        }\n        list(body, ordered, start) {\n          const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? \' start="\' + start + \'"\' : "";\n          return "<" + type + startatt + ">\\n" + body + "</" + type + ">\\n";\n        }\n        /**\n         * @param {string} text\n         */\n        listitem(text) {\n          return `<li>${text}</li>\n`;\n        }\n        checkbox(checked) {\n          return "<input " + (checked ? \'checked="" \' : "") + \'disabled="" type="checkbox"\' + (this.options.xhtml ? " /" : "") + "> ";\n        }\n        /**\n         * @param {string} text\n         */\n        paragraph(text) {\n          return `<p>${text}</p>\n`;\n        }\n        /**\n         * @param {string} header\n         * @param {string} body\n         */\n        table(header, body) {\n          if (body)\n            body = `<tbody>${body}</tbody>`;\n          return "<table>\\n<thead>\\n" + header + "</thead>\\n" + body + "</table>\\n";\n        }\n        /**\n         * @param {string} content\n         */\n        tablerow(content) {\n          return `<tr>\n${content}</tr>\n`;\n        }\n        tablecell(content, flags) {\n          const type = flags.header ? "th" : "td";\n          const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;\n          return tag + content + `</${type}>\n`;\n        }\n        /**\n         * span level renderer\n         * @param {string} text\n         */\n        strong(text) {\n          return `<strong>${text}</strong>`;\n        }\n        /**\n         * @param {string} text\n         */\n        em(text) {\n          return `<em>${text}</em>`;\n        }\n        /**\n         * @param {string} text\n         */\n        codespan(text) {\n          return `<code>${text}</code>`;\n        }\n        br() {\n          return this.options.xhtml ? "<br/>" : "<br>";\n        }\n        /**\n         * @param {string} text\n         */\n        del(text) {\n          return `<del>${text}</del>`;\n        }\n        /**\n         * @param {string} href\n         * @param {string} title\n         * @param {string} text\n         */\n        link(href, title, text) {\n          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n          if (href === null) {\n            return text;\n          }\n          let out = \'<a href="\' + href + \'"\';\n          if (title) {\n            out += \' title="\' + title + \'"\';\n          }\n          out += ">" + text + "</a>";\n          return out;\n        }\n        /**\n         * @param {string} href\n         * @param {string} title\n         * @param {string} text\n         */\n        image(href, title, text) {\n          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n          if (href === null) {\n            return text;\n          }\n          let out = `<img src="${href}" alt="${text}"`;\n          if (title) {\n            out += ` title="${title}"`;\n          }\n          out += this.options.xhtml ? "/>" : ">";\n          return out;\n        }\n        text(text) {\n          return text;\n        }\n      };\n      TextRenderer = class {\n        // no need for block level renderers\n        strong(text) {\n          return text;\n        }\n        em(text) {\n          return text;\n        }\n        codespan(text) {\n          return text;\n        }\n        del(text) {\n          return text;\n        }\n        html(text) {\n          return text;\n        }\n        text(text) {\n          return text;\n        }\n        link(href, title, text) {\n          return "" + text;\n        }\n        image(href, title, text) {\n          return "" + text;\n        }\n        br() {\n          return "";\n        }\n      };\n      Slugger = class {\n        constructor() {\n          this.seen = {};\n        }\n        /**\n         * @param {string} value\n         */\n        serialize(value) {\n          return value.toLowerCase().trim().replace(/<[!\\/a-z].*?>/ig, "").replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\\'!"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, "").replace(/\\s/g, "-");\n        }\n        /**\n         * Finds the next safe (unique) slug to use\n         * @param {string} originalSlug\n         * @param {boolean} isDryRun\n         */\n        getNextSafeSlug(originalSlug, isDryRun) {\n          let slug = originalSlug;\n          let occurenceAccumulator = 0;\n          if (this.seen.hasOwnProperty(slug)) {\n            occurenceAccumulator = this.seen[originalSlug];\n            do {\n              occurenceAccumulator++;\n              slug = originalSlug + "-" + occurenceAccumulator;\n            } while (this.seen.hasOwnProperty(slug));\n          }\n          if (!isDryRun) {\n            this.seen[originalSlug] = occurenceAccumulator;\n            this.seen[slug] = 0;\n          }\n          return slug;\n        }\n        /**\n         * Convert string to unique id\n         * @param {object} [options]\n         * @param {boolean} [options.dryrun] Generates the next unique slug without\n         * updating the internal accumulator.\n         */\n        slug(value, options2 = {}) {\n          const slug = this.serialize(value);\n          return this.getNextSafeSlug(slug, options2.dryrun);\n        }\n      };\n      Parser2 = class _Parser {\n        constructor(options2) {\n          this.options = options2 || defaults;\n          this.options.renderer = this.options.renderer || new Renderer();\n          this.renderer = this.options.renderer;\n          this.renderer.options = this.options;\n          this.textRenderer = new TextRenderer();\n          this.slugger = new Slugger();\n        }\n        /**\n         * Static Parse Method\n         */\n        static parse(tokens, options2) {\n          const parser3 = new _Parser(options2);\n          return parser3.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */\n        static parseInline(tokens, options2) {\n          const parser3 = new _Parser(options2);\n          return parser3.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */\n        parse(tokens, top = true) {\n          let out = "", i, j2, k2, l2, l3, row, cell, header, body, token2, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;\n          const l = tokens.length;\n          for (i = 0; i < l; i++) {\n            token2 = tokens[i];\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {\n              ret = this.options.extensions.renderers[token2.type].call({ parser: this }, token2);\n              if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token2.type)) {\n                out += ret || "";\n                continue;\n              }\n            }\n            switch (token2.type) {\n              case "space": {\n                continue;\n              }\n              case "hr": {\n                out += this.renderer.hr();\n                continue;\n              }\n              case "heading": {\n                out += this.renderer.heading(\n                  this.parseInline(token2.tokens),\n                  token2.depth,\n                  unescape(this.parseInline(token2.tokens, this.textRenderer)),\n                  this.slugger\n                );\n                continue;\n              }\n              case "code": {\n                out += this.renderer.code(\n                  token2.text,\n                  token2.lang,\n                  token2.escaped\n                );\n                continue;\n              }\n              case "table": {\n                header = "";\n                cell = "";\n                l2 = token2.header.length;\n                for (j2 = 0; j2 < l2; j2++) {\n                  cell += this.renderer.tablecell(\n                    this.parseInline(token2.header[j2].tokens),\n                    { header: true, align: token2.align[j2] }\n                  );\n                }\n                header += this.renderer.tablerow(cell);\n                body = "";\n                l2 = token2.rows.length;\n                for (j2 = 0; j2 < l2; j2++) {\n                  row = token2.rows[j2];\n                  cell = "";\n                  l3 = row.length;\n                  for (k2 = 0; k2 < l3; k2++) {\n                    cell += this.renderer.tablecell(\n                      this.parseInline(row[k2].tokens),\n                      { header: false, align: token2.align[k2] }\n                    );\n                  }\n                  body += this.renderer.tablerow(cell);\n                }\n                out += this.renderer.table(header, body);\n                continue;\n              }\n              case "blockquote": {\n                body = this.parse(token2.tokens);\n                out += this.renderer.blockquote(body);\n                continue;\n              }\n              case "list": {\n                ordered = token2.ordered;\n                start = token2.start;\n                loose = token2.loose;\n                l2 = token2.items.length;\n                body = "";\n                for (j2 = 0; j2 < l2; j2++) {\n                  item = token2.items[j2];\n                  checked = item.checked;\n                  task = item.task;\n                  itemBody = "";\n                  if (item.task) {\n                    checkbox = this.renderer.checkbox(checked);\n                    if (loose) {\n                      if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {\n                        item.tokens[0].text = checkbox + " " + item.tokens[0].text;\n                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {\n                          item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;\n                        }\n                      } else {\n                        item.tokens.unshift({\n                          type: "text",\n                          text: checkbox\n                        });\n                      }\n                    } else {\n                      itemBody += checkbox;\n                    }\n                  }\n                  itemBody += this.parse(item.tokens, loose);\n                  body += this.renderer.listitem(itemBody, task, checked);\n                }\n                out += this.renderer.list(body, ordered, start);\n                continue;\n              }\n              case "html": {\n                out += this.renderer.html(token2.text);\n                continue;\n              }\n              case "paragraph": {\n                out += this.renderer.paragraph(this.parseInline(token2.tokens));\n                continue;\n              }\n              case "text": {\n                body = token2.tokens ? this.parseInline(token2.tokens) : token2.text;\n                while (i + 1 < l && tokens[i + 1].type === "text") {\n                  token2 = tokens[++i];\n                  body += "\\n" + (token2.tokens ? this.parseInline(token2.tokens) : token2.text);\n                }\n                out += top ? this.renderer.paragraph(body) : body;\n                continue;\n              }\n              default: {\n                const errMsg = \'Token with "\' + token2.type + \'" type was not found.\';\n                if (this.options.silent) {\n                  console.error(errMsg);\n                  return;\n                } else {\n                  throw new Error(errMsg);\n                }\n              }\n            }\n          }\n          return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */\n        parseInline(tokens, renderer) {\n          renderer = renderer || this.renderer;\n          let out = "", i, token2, ret;\n          const l = tokens.length;\n          for (i = 0; i < l; i++) {\n            token2 = tokens[i];\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {\n              ret = this.options.extensions.renderers[token2.type].call({ parser: this }, token2);\n              if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token2.type)) {\n                out += ret || "";\n                continue;\n              }\n            }\n            switch (token2.type) {\n              case "escape": {\n                out += renderer.text(token2.text);\n                break;\n              }\n              case "html": {\n                out += renderer.html(token2.text);\n                break;\n              }\n              case "link": {\n                out += renderer.link(token2.href, token2.title, this.parseInline(token2.tokens, renderer));\n                break;\n              }\n              case "image": {\n                out += renderer.image(token2.href, token2.title, token2.text);\n                break;\n              }\n              case "strong": {\n                out += renderer.strong(this.parseInline(token2.tokens, renderer));\n                break;\n              }\n              case "em": {\n                out += renderer.em(this.parseInline(token2.tokens, renderer));\n                break;\n              }\n              case "codespan": {\n                out += renderer.codespan(token2.text);\n                break;\n              }\n              case "br": {\n                out += renderer.br();\n                break;\n              }\n              case "del": {\n                out += renderer.del(this.parseInline(token2.tokens, renderer));\n                break;\n              }\n              case "text": {\n                out += renderer.text(token2.text);\n                break;\n              }\n              default: {\n                const errMsg = \'Token with "\' + token2.type + \'" type was not found.\';\n                if (this.options.silent) {\n                  console.error(errMsg);\n                  return;\n                } else {\n                  throw new Error(errMsg);\n                }\n              }\n            }\n          }\n          return out;\n        }\n      };\n      Hooks = class {\n        constructor(options2) {\n          this.options = options2 || defaults;\n        }\n        static passThroughHooks = /* @__PURE__ */ new Set([\n          "preprocess",\n          "postprocess"\n        ]);\n        /**\n         * Process markdown before marked\n         */\n        preprocess(markdown) {\n          return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */\n        postprocess(html) {\n          return html;\n        }\n      };\n      marked.options = marked.setOptions = function(opt) {\n        marked.defaults = { ...marked.defaults, ...opt };\n        changeDefaults(marked.defaults);\n        return marked;\n      };\n      marked.getDefaults = getDefaults;\n      marked.defaults = defaults;\n      marked.use = function(...args) {\n        const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n          const opts = { ...pack };\n          opts.async = marked.defaults.async || opts.async || false;\n          if (pack.extensions) {\n            pack.extensions.forEach((ext) => {\n              if (!ext.name) {\n                throw new Error("extension name required");\n              }\n              if (ext.renderer) {\n                const prevRenderer = extensions.renderers[ext.name];\n                if (prevRenderer) {\n                  extensions.renderers[ext.name] = function(...args2) {\n                    let ret = ext.renderer.apply(this, args2);\n                    if (ret === false) {\n                      ret = prevRenderer.apply(this, args2);\n                    }\n                    return ret;\n                  };\n                } else {\n                  extensions.renderers[ext.name] = ext.renderer;\n                }\n              }\n              if (ext.tokenizer) {\n                if (!ext.level || ext.level !== "block" && ext.level !== "inline") {\n                  throw new Error("extension level must be \'block\' or \'inline\'");\n                }\n                if (extensions[ext.level]) {\n                  extensions[ext.level].unshift(ext.tokenizer);\n                } else {\n                  extensions[ext.level] = [ext.tokenizer];\n                }\n                if (ext.start) {\n                  if (ext.level === "block") {\n                    if (extensions.startBlock) {\n                      extensions.startBlock.push(ext.start);\n                    } else {\n                      extensions.startBlock = [ext.start];\n                    }\n                  } else if (ext.level === "inline") {\n                    if (extensions.startInline) {\n                      extensions.startInline.push(ext.start);\n                    } else {\n                      extensions.startInline = [ext.start];\n                    }\n                  }\n                }\n              }\n              if (ext.childTokens) {\n                extensions.childTokens[ext.name] = ext.childTokens;\n              }\n            });\n            opts.extensions = extensions;\n          }\n          if (pack.renderer) {\n            const renderer = marked.defaults.renderer || new Renderer();\n            for (const prop in pack.renderer) {\n              const prevRenderer = renderer[prop];\n              renderer[prop] = (...args2) => {\n                let ret = pack.renderer[prop].apply(renderer, args2);\n                if (ret === false) {\n                  ret = prevRenderer.apply(renderer, args2);\n                }\n                return ret;\n              };\n            }\n            opts.renderer = renderer;\n          }\n          if (pack.tokenizer) {\n            const tokenizer = marked.defaults.tokenizer || new Tokenizer();\n            for (const prop in pack.tokenizer) {\n              const prevTokenizer = tokenizer[prop];\n              tokenizer[prop] = (...args2) => {\n                let ret = pack.tokenizer[prop].apply(tokenizer, args2);\n                if (ret === false) {\n                  ret = prevTokenizer.apply(tokenizer, args2);\n                }\n                return ret;\n              };\n            }\n            opts.tokenizer = tokenizer;\n          }\n          if (pack.hooks) {\n            const hooks = marked.defaults.hooks || new Hooks();\n            for (const prop in pack.hooks) {\n              const prevHook = hooks[prop];\n              if (Hooks.passThroughHooks.has(prop)) {\n                hooks[prop] = (arg) => {\n                  if (marked.defaults.async) {\n                    return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {\n                      return prevHook.call(hooks, ret2);\n                    });\n                  }\n                  const ret = pack.hooks[prop].call(hooks, arg);\n                  return prevHook.call(hooks, ret);\n                };\n              } else {\n                hooks[prop] = (...args2) => {\n                  let ret = pack.hooks[prop].apply(hooks, args2);\n                  if (ret === false) {\n                    ret = prevHook.apply(hooks, args2);\n                  }\n                  return ret;\n                };\n              }\n            }\n            opts.hooks = hooks;\n          }\n          if (pack.walkTokens) {\n            const walkTokens2 = marked.defaults.walkTokens;\n            opts.walkTokens = function(token2) {\n              let values = [];\n              values.push(pack.walkTokens.call(this, token2));\n              if (walkTokens2) {\n                values = values.concat(walkTokens2.call(this, token2));\n              }\n              return values;\n            };\n          }\n          marked.setOptions(opts);\n        });\n      };\n      marked.walkTokens = function(tokens, callback) {\n        let values = [];\n        for (const token2 of tokens) {\n          values = values.concat(callback.call(marked, token2));\n          switch (token2.type) {\n            case "table": {\n              for (const cell of token2.header) {\n                values = values.concat(marked.walkTokens(cell.tokens, callback));\n              }\n              for (const row of token2.rows) {\n                for (const cell of row) {\n                  values = values.concat(marked.walkTokens(cell.tokens, callback));\n                }\n              }\n              break;\n            }\n            case "list": {\n              values = values.concat(marked.walkTokens(token2.items, callback));\n              break;\n            }\n            default: {\n              if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token2.type]) {\n                marked.defaults.extensions.childTokens[token2.type].forEach(function(childTokens) {\n                  values = values.concat(marked.walkTokens(token2[childTokens], callback));\n                });\n              } else if (token2.tokens) {\n                values = values.concat(marked.walkTokens(token2.tokens, callback));\n              }\n            }\n          }\n        }\n        return values;\n      };\n      marked.parseInline = parseMarkdown(Lexer.lexInline, Parser2.parseInline);\n      marked.Parser = Parser2;\n      marked.parser = Parser2.parse;\n      marked.Renderer = Renderer;\n      marked.TextRenderer = TextRenderer;\n      marked.Lexer = Lexer;\n      marked.lexer = Lexer.lex;\n      marked.Tokenizer = Tokenizer;\n      marked.Slugger = Slugger;\n      marked.Hooks = Hooks;\n      marked.parse = marked;\n      options = marked.options;\n      setOptions = marked.setOptions;\n      use = marked.use;\n      walkTokens = marked.walkTokens;\n      parseInline = marked.parseInline;\n      parser2 = Parser2.parse;\n      lexer2 = Lexer.lex;\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/headers.usage.js\n  var headers_usage_default;\n  var init_headers_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/headers.usage.js"() {\n      headers_usage_default = (view, group) => ({\n        demo: `${view}:"Header \\\\"${view}\\\\""`,\n        examples: [\n          {\n            title: "Variations",\n            view: group.map((view2) => `${view2}:"Header \\\\"${view2}\\\\""`)\n          },\n          {\n            title: "Complex content",\n            demo: {\n              view,\n              content: [\n                \'text:"Text "\',\n                \'link:{ text: "Link" }\'\n              ]\n            }\n          },\n          {\n            title: "Using anchor",\n            demo: [\n              {\n                view,\n                anchor: "foo",\n                content: \'text:"Explicit value for an anchor"\'\n              },\n              {\n                view,\n                anchor: true,\n                content: \'text:"Auto generated anchor based on text content of header"\'\n              }\n            ]\n          }\n        ]\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/headers.js\n  function headers_default(host) {\n    const slugger = new Slugger();\n    function render2(el, config, data, context) {\n      const { content, anchor = false } = config;\n      el.classList.add("view-header");\n      const render3 = host.view.render(el, content || "text", data, context);\n      if (anchor) {\n        render3.then(() => {\n          const slug = slugger.slug(anchor === true ? el.textContent : String(anchor), { dryrun: true });\n          const href = host.encodePageHash(\n            host.pageId,\n            host.pageRef,\n            { ...host.pageParams, "!anchor": slug }\n          );\n          el.prepend(createElement("a", {\n            class: "view-header__anchor",\n            id: `!anchor:${slug}`,\n            href\n          }));\n        });\n      }\n      return render3;\n    }\n    host.view.define("header", render2, { tag: "h4", usage: headers_usage_default });\n    host.view.define("h1", render2, { tag: "h1", usage: headers_usage_default });\n    host.view.define("h2", render2, { tag: "h2", usage: headers_usage_default });\n    host.view.define("h3", render2, { tag: "h3", usage: headers_usage_default });\n    host.view.define("h4", render2, { tag: "h4", usage: headers_usage_default });\n    host.view.define("h5", render2, { tag: "h5", usage: headers_usage_default });\n  }\n  var init_headers = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/headers.js"() {\n      init_marked_esm();\n      init_dom();\n      init_headers_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/html.usage.js\n  var html_usage_default;\n  var init_html_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/html.usage.js"() {\n      html_usage_default = {\n        demo: {\n          view: "html",\n          data: \'"<h1>I am inner HTML</h1>"\'\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/html.js\n  function html_default(host) {\n    const buffer = document.createElement("div");\n    host.view.define("html", function(el, config, data) {\n      buffer.innerHTML = data;\n      el.append(...buffer.childNodes);\n    }, {\n      tag: null,\n      usage: html_usage_default\n    });\n  }\n  var init_html2 = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/html.js"() {\n      init_html_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/image.usage.js\n  var demoImageSrc, image_usage_default;\n  var init_image_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/image.usage.js"() {\n      demoImageSrc = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMjggMTI4Ij4KICAgIDxyZWN0IHg9IjY1LjYiIHk9IjI0LjYiIHRyYW5zZm9ybT0ibWF0cml4KDAuOTM5NyAtMC4zNDIgMC4zNDIgMC45Mzk3IC05Ljk0MjYgMzEuODI4KSIgZmlsbD0iI0ZGRkZGRiIgd2lkdGg9IjM5LjMiIGhlaWdodD0iMzkiPjwvcmVjdD4KICAgIDxyZWN0IHg9IjcwLjYiIHk9IjUyLjciIHRyYW5zZm9ybT0ibWF0cml4KC0wLjkzOTcgMC4zNDIgLTAuMzQyIC0wLjkzOTcgMTk0Ljc4NTIgODEuMTIwNCkiIGZpbGw9IiNDN0Q3RTIiIHdpZHRoPSIzOS4zIiBoZWlnaHQ9IjEwIj48L3JlY3Q+CiAgICA8cGF0aCBmaWxsPSIjOThCRUQ4IiBkPSJNMTExLjUsNTQuNmwtMS4xLDEuMUw5Ny4xLDE5LjFsMS41LDAuMmM4LDAuOSwxNC43LDYuMiwxNy40LDEzLjdsMCwwQzExOC44LDQwLjQsMTE3LDQ4LjgsMTExLjUsNTQuNnoiPjwvcGF0aD4KICAgIDxwYXRoIGZpbGw9IiM0NTRCNTQiIGQ9Ik03My41LDcyLjJjLTEuMiwwLTIuNC0wLjgtMi44LTJMNTcuMywzMy41Yy0wLjMtMC43LTAuMi0xLjYsMC4xLTIuM2MwLjMtMC43LDAuOS0xLjMsMS43LTEuNmwzNi45LTEzLjRjMS42LTAuNiwzLjMsMC4yLDMuOCwxLjhsMTMuMywzNi42YzAuMywwLjcsMC4yLDEuNi0wLjEsMi4zYy0wLjMsMC43LTAuOSwxLjMtMS43LDEuNkw3NC41LDcyQzc0LjIsNzIuMSw3My44LDcyLjIsNzMuNSw3Mi4yek02NCwzNC4zbDExLjMsMzFsMzEuMy0xMS40bC0xMS4zLTMxTDY0LDM0LjN6Ij48L3BhdGg+CiAgICA8cmVjdCB4PSIzNSIgeT0iNDYuNyIgdHJhbnNmb3JtPSJtYXRyaXgoMC45Mzk3IC0wLjM0MiAwLjM0MiAwLjkzOTcgLTE2LjIwMTEgMjAuOTg4KSIgZmlsbD0iI0ZGRkZGRiIgd2lkdGg9IjMyLjgiIGhlaWdodD0iMTkuNSI+PC9yZWN0PgogICAgPHJlY3QgeD0iMzcuMyIgeT0iNTkuOCIgdHJhbnNmb3JtPSJtYXRyaXgoLTAuOTM5NyAwLjM0MiAtMC4zNDIgLTAuOTM5NyAxMjUuNjc2MyAxMDMuMzk0NikiIGZpbGw9IiNDN0Q3RTIiIHdpZHRoPSIzMi44IiBoZWlnaHQ9IjYiPjwvcmVjdD4KICAgIDxwYXRoIGZpbGw9IiM0NTRCNTQiIGQ9Ik0zOS40LDc0LjJjLTAuNCwwLTAuOS0wLjEtMS4zLTAuM2MtMC43LTAuMy0xLjMtMC45LTEuNi0xLjdsLTYuNy0xOC4zYy0wLjMtMC43LTAuMi0xLjYsMC4xLTIuM2MwLjMtMC43LDAuOS0xLjMsMS43LTEuNmwzMC44LTExLjJjMC43LTAuMywxLjYtMC4yLDIuMywwLjFjMC43LDAuMywxLjMsMC45LDEuNiwxLjdMNzMsNTljMC42LDEuNi0wLjIsMy4zLTEuOCwzLjhMNDAuNCw3NEM0MCw3NC4xLDM5LjcsNzQuMiwzOS40LDc0LjJ6IE0zNi41LDU0LjdsNC42LDEyLjdsMjUuMi05LjJsLTQuNi0xMi43TDM2LjUsNTQuN3oiPjwvcGF0aD4KICAgIDxwYXRoIGZpbGw9IiM0NTRCNTQiIGQ9Ik03MCwxMTguOWMtMS4yLDAtMi40LTAuNy0yLjgtMS45bC0xNC0zNy4ybC04LjQsMy4xbC0xNy4yLDM0LjRjLTAuNywxLjUtMi41LDIuMS00LDEuM2MtMS41LTAuNy0yLjEtMi41LTEuMy00TDQwLDc5YzAuMy0wLjcsMC45LTEuMiwxLjctMS41TDU0LDczLjFjMS41LTAuNiwzLjMsMC4yLDMuOCwxLjhsMTUsNDBjMC42LDEuNi0wLjIsMy4zLTEuOCwzLjlDNzAuNywxMTguOCw3MC40LDExOC45LDcwLDExOC45eiI+PC9wYXRoPgogICAgPHBhdGggZmlsbD0iIzQ1NEI1NCIgZD0iTTEzLjYsODAuMWMtMS4yLDAtMi40LTAuOC0yLjgtMkw2LjMsNjUuOWMtMC42LTEuNiwwLjItMy4zLDEuOC0zLjhjMS42LTAuNiwzLjMsMC4yLDMuOCwxLjhsNC40LDEyLjJjMC42LDEuNi0wLjIsMy4zLTEuOCwzLjhDMTQuMyw4MC4xLDE0LDgwLjEsMTMuNiw4MC4xeiI+PC9wYXRoPgogICAgPHBhdGggZmlsbD0iIzQ1NEI1NCIgZD0iTTEzLjIsNzMuM2MtMS4yLDAtMi40LTAuOC0yLjgtMmMtMC42LTEuNiwwLjItMy4zLDEuOC0zLjhMMzUsNTkuMmMxLjYtMC42LDMuMywwLjIsMy44LDEuOGMwLjYsMS42LTAuMiwzLjMtMS44LDMuOGwtMjIuOCw4LjNDMTMuOSw3My4zLDEzLjYsNzMuMywxMy4yLDczLjN6Ij48L3BhdGg+Cjwvc3ZnPgo=";\n      image_usage_default = {\n        demo: {\n          view: "image",\n          src: demoImageSrc,\n          height: 100\n        },\n        examples: [\n          {\n            title: "Src is not defined",\n            demo: "image"\n          },\n          {\n            title: "Bad url",\n            demo: \'image{ src: "<bad url>" }\'\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/image.js\n  function image_default(host) {\n    host.view.define("image", function(el, config) {\n      Object.assign(el, config);\n      el.onerror = () => el.classList.add("error");\n      el.onload = () => el.classList.add("loaded");\n    }, { tag: "img", usage: image_usage_default });\n  }\n  var init_image = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/image.js"() {\n      init_image_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/image-preview.usage.js\n  var image_preview_usage_default;\n  var init_image_preview_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/image-preview.usage.js"() {\n      init_image_usage();\n      image_preview_usage_default = {\n        beforeDemo: [\'md:"The same as `image` view but with "\'],\n        demo: {\n          view: "image-preview",\n          src: demoImageSrc,\n          height: 100\n        },\n        examples: [\n          {\n            title: "Src is not defined",\n            demo: "image-preview"\n          },\n          {\n            title: "Bad url",\n            demo: \'image-preview{ src: "<bad url>" }\'\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/image-preview.js\n  function image_preview_default(host) {\n    host.view.define("image-preview", function(el, config, data, context) {\n      this.render(el, {\n        view: "image",\n        ...config\n      }, data, context);\n    }, { usage: image_preview_usage_default });\n  }\n  var init_image_preview = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/image-preview.js"() {\n      init_image_preview_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/indicator.usage.js\n  var indicator_usage_default;\n  var init_indicator_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/indicator.usage.js"() {\n      indicator_usage_default = {\n        demo: {\n          view: "indicator",\n          data: {\n            label: "Label",\n            value: "1234"\n          }\n        },\n        examples: [\n          {\n            title: "Indicator as link",\n            demo: {\n              view: "indicator",\n              data: {\n                label: "Label",\n                value: "4321",\n                href: "#"\n              }\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/indicator.js\n  function indicator_default(host) {\n    host.view.define("indicator", function(el, config, data, context) {\n      const { value, label } = config;\n      const { href } = data || {};\n      const valueEl = document.createElement("div");\n      const labelEl = document.createElement("div");\n      valueEl.className = "value";\n      labelEl.className = "label";\n      if (href) {\n        el.href = href;\n      }\n      return Promise.all([\n        host.view.render(valueEl, value || "text:value", data, context),\n        host.view.render(labelEl, label || "text:label", data, context)\n      ]).then(() => el.append(valueEl, labelEl));\n    }, {\n      tag: "a",\n      usage: indicator_usage_default\n    });\n  }\n  var init_indicator = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/indicator.js"() {\n      init_indicator_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/link.usage.js\n  var link_usage_default;\n  var init_link_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/link.usage.js"() {\n      link_usage_default = {\n        demo: {\n          view: "link",\n          data: {\n            text: "I am link",\n            href: "#"\n          }\n        },\n        examples: [\n          {\n            title: "Link opened in new tab",\n            demo: {\n              view: "link",\n              data: {\n                text: "Discovery github",\n                href: "https://github.com/discoveryjs/discovery",\n                external: true\n              }\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/link.js\n  function link_default(host) {\n    host.view.define("link", function(el, config, data, context) {\n      const { content, onClick: onClick3 } = config;\n      let { href, text, external } = data || {};\n      if (typeof data === "string") {\n        href = text = data;\n      }\n      if (text === void 0 && href) {\n        text = href;\n      } else if (href === void 0 && text) {\n        href = text;\n      }\n      if (href) {\n        el.href = href;\n      }\n      if (external) {\n        el.setAttribute("target", "_blank");\n      }\n      if (typeof onClick3 === "function") {\n        el.classList.add("onclick");\n        el.addEventListener("click", (e) => {\n          e.preventDefault();\n          onClick3(el, data, context);\n        });\n      }\n      if (content) {\n        return host.view.render(el, content, data, context);\n      } else {\n        el.textContent = text;\n      }\n    }, {\n      tag: "a",\n      usage: link_usage_default\n    });\n  }\n  var init_link = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/link.js"() {\n      init_link_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/markdown.usage.js\n  var markdown_usage_default;\n  var init_markdown_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/markdown.usage.js"() {\n      markdown_usage_default = {\n        demo: {\n          view: "markdown",\n          source: "# Markdown example\\n\\n> NOTE: The `markdown` view is based on [marked](https://github.com/markedjs/marked) package\\n\\nMarkdown is good because:\\n* You\'ll get **formatted** *text* with _no tags_\\n* It\'s much simpler than `HTML`\\n\\n```html\\n<b>bold</b><i>italic</i>\\n```\\n[Read more](https://guides.github.com/features/mastering-markdown/)"\n        },\n        examples: [\n          {\n            title: "Inline config",\n            demo: \'markdown{ source: "**Hello** `world`!" }\'\n          },\n          {\n            title: "Shorthand syntax",\n            beforeDemo: [\'md:"You can use `md` as an alias for `markdown` with a string as data. That\\\'s a **shortest** definition for a marked text"\'],\n            demo: \'md:"**Hello** `world`!"\'\n          },\n          {\n            title: "Array of strings as a source",\n            beforeDemo: [\'md:"Array of strings might be passed as a value for `source` property which is useful for a long sources\\\\n> NOTE: This doesn\\\'t work a source passed via data"\'],\n            demo: {\n              view: "markdown",\n              source: ["Array", "of", "`strings`"]\n            }\n          },\n          {\n            title: "Interpolation",\n            beforeDemo: [\'md:"Interpolation can be used almost anywhere in a markdown to embed the result of a jora query into resulting HTML. Just place a jora query between `{{`{{`}}` and `{{`}`+`}`}}`:"\'],\n            demo: {\n              view: "md",\n              source: [\n                "Simple evaluation: 2 + 2 = `{{ 2 + 2 }}`",\n                "",\n                "Markdown view has {{ viewDef.examples.size() }} examples"\n              ]\n            }\n          },\n          {\n            title: "Disable anchors for headers",\n            highlightProps: ["anchors"],\n            beforeDemo: "Hover a header to see a chain icon on the left side of header when anchors are enabled:",\n            demo: [\n              {\n                view: "markdown",\n                source: "## header with default settings"\n              },\n              {\n                view: "markdown",\n                anchors: false,\n                source: "## header with disabled anchor"\n              }\n            ]\n          },\n          {\n            title: "Sections prelude and postlude",\n            highlightProps: [\n              "sectionPrelude",\n              "sectionPostlude"\n            ],\n            demo: {\n              view: "markdown",\n              sectionPrelude: "struct",\n              sectionPostlude: { view: "link", data: \'{ href: "#top", text: "Scroll to top \\u2191" }\' },\n              source: "Some text\\n\\n## Header level 2\\n\\nSome text\\n\\n### Header level 3\\n\\nSome text\\n\\n## Header level 2\\n\\nSome text"\n            }\n          },\n          {\n            title: "Additional action buttons for code blocks",\n            highlightProps: ["codeActionButtons"],\n            beforeDemo: [\'md:"Use `codeActionButtons` to add additional buttons to code blocks. The option is the same as `actionButtons` for `source` view."\'],\n            demo: {\n              view: "markdown",\n              codeActionButtons: [\n                {\n                  view: "button",\n                  content: \'text:"Say \\\\"Hello world\\\\""\',\n                  onClick: new Function(\'return () => alert("Hello world!")\')()\n                }\n              ],\n              source: \'```js\\nconsole.log("Hello world")\\n```\'\n            }\n          },\n          {\n            title: "Configuration for code blocks",\n            highlightProps: ["codeConfig"],\n            beforeDemo: [\'md:"Use `codeConfig` to specify any settings for code blocks available for `source` view."\'],\n            demo: {\n              view: "markdown",\n              codeConfig: {\n                prelude: {\n                  view: "block",\n                  content: ["badge:syntax", \'text:"Length: " + content.size()\']\n                },\n                postlude: "struct:{ data: $, context: # }"\n              },\n              source: \'# Header 1\\n\\n```js\\nconsole.log("Hello world")\\n```\\n\\n## Header 2\\n\\ntext\\n\\n## Header 3\\n\\n\\n\\n```jora\\nfoo.bar.baz\\n```\'\n            }\n          },\n          {\n            title: "Showcase",\n            demo: {\n              view: "markdown",\n              source: `\n# Header\n## Header\n### Header\n#### Header\n##### Header\n* One\n* Two\n    * Three\n\n4. Four\n5. Five\n    6. Six\n- [{{ true }}] Task 1\n- [x] Task 2\n\nInterpolation in text: 2 + 2 = \\`{{ 2 + 2 }}\\`, or in attribute: [link](#dummy-link/{{"exam" + "ple"}} "{{ "example" + " title" }}")\n\nParagraph **bold** __bold__ *italic* _italic_ ~line-through~ \\`code\\` [link](#href)\n\n>Blockquote\n> > Line 2\n\n\\`\\`\\`js\nvar some = "code";\n\\`\\`\\`\n\nfoo | bar\n----|-----\n1 | A\n2 | C\n3 | E\n`.trim().split(/\\n/)\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/markdown.js\n  function markdown_default(host) {\n    const opts = {\n      discovery: host\n    };\n    function applyTextInterpolation(value, values) {\n      return value.replace(/{{(\\d+)}}/gs, (_, index) => values[index]);\n    }\n    function applyInterpolations(el, values) {\n      for (const child of el.childNodes) {\n        switch (child.nodeType) {\n          case document.ELEMENT_NODE:\n            if (!child.classList.contains("view-source")) {\n              applyInterpolations(child, values);\n              for (const attribute of child.attributes) {\n                attribute.nodeValue = applyTextInterpolation(attribute.nodeValue, values);\n              }\n            }\n            break;\n          case document.TEXT_NODE:\n            child.nodeValue = applyTextInterpolation(child.nodeValue, values);\n            break;\n        }\n      }\n    }\n    function render2(el, config, data, context) {\n      const {\n        source,\n        anchors = true,\n        sectionPrelude,\n        sectionPostlude,\n        codeConfig\n      } = config;\n      const interpolations = /* @__PURE__ */ new Map();\n      let mdSource = typeof data === "string" ? data : source || "";\n      if (Array.isArray(mdSource)) {\n        mdSource = mdSource.join("\\n");\n      }\n      mdSource = mdSource.replace(/{{(.+?)}}/gs, (_, query) => {\n        query = query.trim();\n        if (!interpolations.has(query)) {\n          interpolations.set(query, interpolations.size);\n        }\n        return `{{${interpolations.get(query)}}}`;\n      });\n      el.classList.add("view-markdown");\n      return new Promise((resolve) => {\n        marked(\n          mdSource,\n          { ...opts, anchors },\n          (er, html) => {\n            const promises = [];\n            el.innerHTML = html;\n            if (interpolations.size > 0) {\n              const interpolationValues = new Array(interpolations.size);\n              for (const [query, index] of interpolations.entries()) {\n                try {\n                  interpolationValues[index] = host.query(query, data, context);\n                } catch (e) {\n                  host.log("error", "Interpolation query error in markdown:", e);\n                }\n              }\n              applyInterpolations(el, interpolationValues);\n            }\n            const sectionByHeaderEl = /* @__PURE__ */ new Map();\n            let startSectionKey = { after: (buffer) => el.prepend(buffer) };\n            if (codeConfig || sectionPrelude || sectionPostlude) {\n              const { firstElementChild } = el;\n              let prevSection = {\n                next: null,\n                data: {\n                  sectionIdx: 0,\n                  slug: null,\n                  text: null,\n                  href: null\n                }\n              };\n              sectionByHeaderEl.set(startSectionKey, prevSection);\n              for (const headerEl of [...el.querySelectorAll(":scope > :is(h1, h2, h3, h4, h5, h6)")]) {\n                if (headerEl === firstElementChild) {\n                  sectionByHeaderEl.delete(startSectionKey);\n                  startSectionKey = headerEl;\n                  prevSection = null;\n                }\n                const anchorEl = headerEl.querySelector(\':scope > a[id^="!anchor:"]\');\n                const section = {\n                  next: null,\n                  data: {\n                    sectionIdx: sectionByHeaderEl.size,\n                    slug: headerEl.dataset.slug,\n                    text: headerEl.textContent.trim(),\n                    href: anchorEl?.hash\n                  }\n                };\n                sectionByHeaderEl.set(headerEl, section);\n                if (prevSection) {\n                  prevSection.next = headerEl;\n                }\n                prevSection = section;\n              }\n            }\n            for (const codeEl of [...el.querySelectorAll("pre > code")]) {\n              const buffer = document.createDocumentFragment();\n              const content = codeEl.textContent.replace(/\\n$/, "");\n              const syntax = (codeEl.className.match(/discovery-markdown-(\\S+)/) || [])[1];\n              let section = sectionByHeaderEl.get(startSectionKey);\n              let cursor = codeEl.parentNode;\n              while (cursor !== null && cursor !== el) {\n                if (sectionByHeaderEl.has(cursor)) {\n                  section = sectionByHeaderEl.get(cursor);\n                  break;\n                }\n                cursor = cursor.previousSibling || cursor.parentNode;\n              }\n              promises.push(\n                this.render(\n                  buffer,\n                  typeof codeConfig === "object" ? { view: "source", ...codeConfig } : codeConfig || "source",\n                  { syntax, content },\n                  { ...context, section: section?.data }\n                ).then(\n                  () => codeEl.parentNode.replaceWith(buffer)\n                )\n              );\n            }\n            if (sectionPrelude || sectionPostlude) {\n              const renderSectionPrePost = (renderConfig, section, insertCallback) => {\n                const buffer = document.createDocumentFragment();\n                promises.push(\n                  this.render(\n                    buffer,\n                    renderConfig,\n                    data,\n                    { ...context, section: section.data }\n                  ).then(() => insertCallback(buffer))\n                );\n              };\n              for (const [sectionStartEl, section] of sectionByHeaderEl) {\n                if (sectionPrelude) {\n                  renderSectionPrePost(\n                    sectionPrelude,\n                    section,\n                    (buffer) => sectionStartEl.after(buffer)\n                  );\n                }\n                if (sectionPostlude) {\n                  renderSectionPrePost(\n                    sectionPostlude,\n                    section,\n                    (buffer) => section.next ? section.next.before(buffer) : el.append(buffer)\n                  );\n                }\n              }\n            }\n            Promise.all(promises).then(resolve);\n          }\n        );\n      });\n    }\n    host.view.define("markdown", render2, { usage: markdown_usage_default });\n    host.view.define("md", render2, { usage: markdown_usage_default });\n  }\n  var CustomRenderer;\n  var init_markdown = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/markdown.js"() {\n      init_marked_esm();\n      init_markdown_usage();\n      init_html();\n      CustomRenderer = class extends marked.Renderer {\n        heading(text, level, raw, slugger) {\n          const { discovery: host, anchors } = this.options;\n          const slug = slugger.slug(raw);\n          let anchor = "";\n          if (anchors) {\n            const href = host.encodePageHash(\n              host.pageId,\n              host.pageRef,\n              { ...host.pageParams, "!anchor": slug }\n            );\n            anchor = `<a class="view-header__anchor" id="!anchor:${escapeHtml2(slug)}" href="${href}"></a>`;\n          }\n          return `<h${level} class="view-header view-h${level}" data-slug="${slug}">${anchor}${text}</h${level}>\n`;\n        }\n        link(href, title, text) {\n          if (href === null) {\n            return text;\n          }\n          let out = \'<a class="view-link" href="\' + escapeHtml2(href) + \'"\';\n          if (title) {\n            out += \' title="\' + escapeHtml2(title) + \'"\';\n          }\n          if (!href.startsWith("#")) {\n            out += \' target="_blank"\';\n          }\n          out += ">" + text + "</a>";\n          return out;\n        }\n        checkbox(checked) {\n          return \'<label class="view-checkbox"><input type="checkbox" disabled\' + (checked ? " checked" : "") + "/></label> ";\n        }\n        list(body, ordered, start) {\n          const tag = ordered ? "ol" : "ul";\n          const startAttr = ordered && start !== 1 ? ` start="${start}"` : "";\n          return `<${tag} class="view-${tag}"${startAttr}>\n` + body + `\n</${tag}>\n`;\n        }\n        listitem(text) {\n          return \'<li class="view-list-item">\' + text + "</li>\\n";\n        }\n        table(header, body) {\n          return \'<table class="view-table">\\n<thead>\\n\' + header.replace(/ class="view-table-row"/g, "") + "</thead>\\n" + (body ? "<tbody>" + body + "</tbody>" : "") + "</table>\\n";\n        }\n        tablerow(content) {\n          return \'<tr class="view-table-row">\\n\' + content + "</tr>\\n";\n        }\n        tablecell(content, flags) {\n          const type = flags.header ? "th" : "td";\n          return `<${type} class="view-table-cell"${flags.align ? ` align="${flags.align}"` : ""}>` + content + `</${type}>\n`;\n        }\n      };\n      marked.setOptions({\n        smartLists: true,\n        langPrefix: "discovery-markdown-",\n        renderer: new CustomRenderer()\n      });\n    }\n  });\n\n  // node_modules/hitext/src/generator/utils.js\n  var require_utils2 = __commonJS({\n    "node_modules/hitext/src/generator/utils.js"(exports, module) {\n      function newLineLength(source, i) {\n        switch (source.charCodeAt(i)) {\n          default:\n            return 0;\n          case 10:\n            return 1;\n          case 13:\n            return i + 1 < source.length && source.charCodeAt(i + 1) === 10 ? 2 : 1;\n        }\n      }\n      module.exports = {\n        newLineLength\n      };\n    }\n  });\n\n  // node_modules/hitext/src/generator/line.js\n  var require_line = __commonJS({\n    "node_modules/hitext/src/generator/line.js"(exports, module) {\n      var { newLineLength } = require_utils2();\n      module.exports = (source, createRange) => {\n        let line = 1;\n        let lineStart = 0;\n        for (let i = 0; i < source.length; i++) {\n          const nl = newLineLength(source, i);\n          if (nl !== 0) {\n            createRange(lineStart, i + nl, line++);\n            lineStart = i + nl;\n            i += nl - 1;\n          }\n        }\n        createRange(lineStart, source.length, line++);\n      };\n    }\n  });\n\n  // node_modules/hitext/src/generator/line-content.js\n  var require_line_content = __commonJS({\n    "node_modules/hitext/src/generator/line-content.js"(exports, module) {\n      var { newLineLength } = require_utils2();\n      module.exports = (source, createRange) => {\n        let line = 1;\n        let lineStart = 0;\n        for (let i = 0; i < source.length; i++) {\n          const nl = newLineLength(source, i);\n          if (nl !== 0) {\n            createRange(lineStart, i, line++);\n            lineStart = i + nl;\n            i += nl - 1;\n          }\n        }\n        createRange(lineStart, source.length, line++);\n      };\n    }\n  });\n\n  // node_modules/hitext/src/generator/match.js\n  var require_match = __commonJS({\n    "node_modules/hitext/src/generator/match.js"(exports, module) {\n      module.exports = function(pattern) {\n        if (pattern instanceof RegExp) {\n          const flags = pattern.flags.indexOf("g") !== -1 ? pattern.flags : pattern.flags + "g";\n          const matchRx = new RegExp(pattern, flags);\n          return function(source, createRange) {\n            let match2;\n            while (match2 = matchRx.exec(source)) {\n              createRange(match2.index, match2.index + match2[0].length);\n            }\n          };\n        }\n        pattern = String(pattern);\n        return function(source, createRange) {\n          let index = -1;\n          while (true) {\n            index = source.indexOf(pattern, index + 1);\n            if (index === -1) {\n              break;\n            }\n            createRange(index, index + pattern.length);\n          }\n        };\n      };\n    }\n  });\n\n  // node_modules/hitext/src/generator/new-line.js\n  var require_new_line = __commonJS({\n    "node_modules/hitext/src/generator/new-line.js"(exports, module) {\n      var { newLineLength } = require_utils2();\n      module.exports = (source, createRange) => {\n        let line = 1;\n        for (let i = 0; i < source.length; i++) {\n          const nl = newLineLength(source, i);\n          if (nl !== 0) {\n            createRange(i, i + nl, line++);\n            i += nl - 1;\n          }\n        }\n      };\n    }\n  });\n\n  // node_modules/hitext/src/generator/index.js\n  var require_generator = __commonJS({\n    "node_modules/hitext/src/generator/index.js"(exports, module) {\n      module.exports = {\n        lines: require_line(),\n        lineContents: require_line_content(),\n        matches: require_match(),\n        newlines: require_new_line()\n      };\n    }\n  });\n\n  // node_modules/hitext/src/printer/utils.js\n  var require_utils3 = __commonJS({\n    "node_modules/hitext/src/printer/utils.js"(exports, module) {\n      function createPrinter(base) {\n        return forkPrinter.call(null, base);\n      }\n      function forkPrinter(extension) {\n        const base = this === window ? {} : this || {};\n        const newPrinter = {};\n        Object.assign(newPrinter, base, extension, {\n          fork: forkPrinter.bind(newPrinter),\n          ranges: Object.assign({}, base.ranges, extension && extension.ranges)\n        });\n        if (typeof newPrinter.createHook !== "function") {\n          newPrinter.createHook = (fn) => fn();\n        }\n        return newPrinter;\n      }\n      function forkPrinterSet(extension) {\n        const newPrinterSet = Object.assign({}, this);\n        for (let key2 in extension) {\n          const typePrinter = extension[key2];\n          if (!typePrinter || typeof typePrinter !== "object") {\n            continue;\n          }\n          if (hasOwnProperty.call(newPrinterSet, key2)) {\n            const existing = newPrinterSet[key2];\n            newPrinterSet[key2] = existing && typeof existing.fork === "function" ? existing.fork(extension[key2]) : existing;\n          } else {\n            newPrinterSet[key2] = createPrinter(extension[key2]);\n          }\n        }\n        newPrinterSet.fork = forkPrinterSet.bind(newPrinterSet);\n        return newPrinterSet;\n      }\n      module.exports = {\n        createPrinter,\n        forkPrinter,\n        forkPrinterSet\n      };\n    }\n  });\n\n  // node_modules/hitext/src/printer/noop.js\n  var require_noop = __commonJS({\n    "node_modules/hitext/src/printer/noop.js"(exports, module) {\n      module.exports = require_utils3().createPrinter();\n    }\n  });\n\n  // node_modules/hitext/src/printer/html.js\n  var require_html = __commonJS({\n    "node_modules/hitext/src/printer/html.js"(exports, module) {\n      var { createPrinter } = require_utils3();\n      module.exports = createPrinter({\n        print: (chunk) => chunk.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n      });\n    }\n  });\n\n  // node_modules/hitext/src/printer/index.js\n  var require_printer = __commonJS({\n    "node_modules/hitext/src/printer/index.js"(exports, module) {\n      var { forkPrinterSet } = require_utils3();\n      module.exports = forkPrinterSet.call({}, {\n        noop: require_noop(),\n        html: require_html(),\n        tty: require_noop()\n      });\n    }\n  });\n\n  // node_modules/hitext/src/generateRanges.js\n  var require_generateRanges = __commonJS({\n    "node_modules/hitext/src/generateRanges.js"(exports, module) {\n      module.exports = function generateRanges(source, generators) {\n        const ranges = [];\n        generators.forEach(\n          ({ generate, marker }) => generate(\n            source,\n            (start, end, data) => ranges.push({ type: marker, start, end, data })\n          )\n        );\n        return ranges;\n      };\n    }\n  });\n\n  // node_modules/hitext/src/print.js\n  var require_print = __commonJS({\n    "node_modules/hitext/src/print.js"(exports, module) {\n      var emptyString = () => "";\n      var noop3 = function() {\n      };\n      function ensureFunction3(value, alt) {\n        return typeof value === "function" ? value : alt || noop3;\n      }\n      module.exports = function print(source, ranges, printer) {\n        const print2 = ensureFunction3(printer.print, (chunk) => chunk);\n        const printContext = Object.assign(\n          Object.defineProperties(/* @__PURE__ */ Object.create(null), {\n            offset: { get: () => printedOffset },\n            line: { get: () => line },\n            column: { get: () => column },\n            start: { get: () => currentRange.start },\n            end: { get: () => currentRange.end },\n            data: { get: () => currentRange.data }\n          }),\n          ensureFunction3(printer.createContext)()\n        );\n        const openedRanges = [];\n        let currentRange = { start: 0, end: source.length };\n        let rangeHooks = printer.ranges || {};\n        let rangePriority = [];\n        let closingOffset = Infinity;\n        let printedOffset = 0;\n        let line = 1;\n        let column = 1;\n        let buffer = "";\n        buffer += ensureFunction3(printer.open, emptyString)(printContext);\n        rangeHooks = [].concat(\n          Object.getOwnPropertyNames(rangeHooks),\n          Object.getOwnPropertySymbols(rangeHooks)\n        ).reduce((result, type) => {\n          let rangeHook = rangeHooks[type];\n          if (typeof rangeHook === "function") {\n            rangeHooks[type] = rangeHook = printer.createHook(rangeHook);\n          }\n          if (rangeHook) {\n            rangePriority.push(type);\n            result[type] = {\n              open: ensureFunction3(rangeHook.open, emptyString),\n              close: ensureFunction3(rangeHook.close, emptyString),\n              print: ensureFunction3(rangeHook.print, print2)\n            };\n          }\n          return result;\n        }, {});\n        ranges = ranges.slice().sort(\n          (a, b2) => a.start - b2.start || b2.end - a.end || rangePriority.indexOf(a.type) - rangePriority.indexOf(b2.type)\n        );\n        const open = (index) => rangeHooks[(currentRange = openedRanges[index]).type].open(printContext) || "";\n        const close = (index) => rangeHooks[(currentRange = openedRanges[index]).type].close(printContext) || "";\n        const printChunk = (offset) => {\n          if (printedOffset !== offset) {\n            const substring = source.substring(printedOffset, offset);\n            const printSubstr = openedRanges.length ? rangeHooks[openedRanges[openedRanges.length - 1].type].print : print2;\n            for (let i = printedOffset; i < offset; i++) {\n              const ch = source.charCodeAt(i);\n              if (ch === 10 || ch === 13 && (i >= source.length || source.charCodeAt(i + 1) !== 10)) {\n                line++;\n                column = 1;\n              } else {\n                column++;\n              }\n            }\n            buffer += printSubstr(substring, printContext);\n            printedOffset = offset;\n          }\n        };\n        const closeRanges = (offset) => {\n          while (closingOffset <= offset) {\n            printChunk(closingOffset);\n            for (let j2 = openedRanges.length - 1; j2 >= 0; j2--) {\n              if (openedRanges[j2].end !== closingOffset) {\n                break;\n              }\n              buffer += close(j2);\n              openedRanges.pop();\n            }\n            closingOffset = Infinity;\n            for (let j2 = 0; j2 < openedRanges.length; j2++) {\n              if (openedRanges[j2].end < closingOffset) {\n                closingOffset = openedRanges[j2].end;\n              }\n            }\n          }\n        };\n        for (let i = 0; i < ranges.length; i++) {\n          const range = ranges[i];\n          let j2 = 0;\n          if (rangeHooks.hasOwnProperty(range.type) === false) {\n            continue;\n          }\n          if (range.start > range.end || !Number.isFinite(range.start) || !Number.isFinite(range.end)) {\n            continue;\n          }\n          closeRanges(range.start);\n          printChunk(range.start);\n          for (j2 = 0; j2 < openedRanges.length; j2++) {\n            if (openedRanges[j2].end < range.end) {\n              for (let k2 = openedRanges.length - 1; k2 >= j2; k2--) {\n                buffer += close(k2);\n              }\n              break;\n            }\n          }\n          openedRanges.splice(j2, 0, range);\n          for (; j2 < openedRanges.length; j2++) {\n            buffer += open(j2);\n          }\n          if (range.end < closingOffset) {\n            closingOffset = range.end;\n          }\n        }\n        closeRanges(source.length);\n        printChunk(source.length);\n        for (let i = openedRanges.length - 1; i >= 0; i--) {\n          buffer += close(i);\n        }\n        buffer += ensureFunction3(printer.close, emptyString)(printContext) || "";\n        return buffer;\n      };\n    }\n  });\n\n  // node_modules/hitext/src/index.js\n  var require_src = __commonJS({\n    "node_modules/hitext/src/index.js"(exports, module) {\n      var generators = require_generator();\n      var printers = require_printer();\n      var generateRanges = require_generateRanges();\n      var print = require_print();\n      function preprocessGenerator(marker, generate) {\n        return {\n          marker,\n          generate\n        };\n      }\n      function preprocessPrinter(marker, printer) {\n        const newPrinter = {};\n        for (let key2 in printer) {\n          newPrinter[key2] = {\n            ranges: {\n              [marker]: printer[key2]\n            }\n          };\n        }\n        return newPrinter;\n      }\n      function pipelineChain(generators2, printerSet, defaultPrinterType) {\n        const pipeline = (source, printerType) => {\n          const printer = printerSet[printerType || defaultPrinterType] || printers.noop;\n          const ranges = generateRanges(source, generators2);\n          const result = print(source, ranges, printer);\n          return result;\n        };\n        return Object.assign(pipeline, {\n          print: pipeline,\n          generateRanges(source) {\n            return generateRanges(source, generators2);\n          },\n          use(plugin, printer) {\n            const marker = Symbol(plugin.name);\n            const ranges = plugin.ranges || plugin;\n            const generate = Array.isArray(ranges) ? (source, createRange) => ranges.forEach((range) => createRange(...range)) : ranges;\n            if (typeof generate !== "function") {\n              return pipeline;\n            }\n            if (!printer) {\n              printer = plugin.printer;\n            }\n            if (!printer) {\n              return pipeline;\n            }\n            return pipelineChain(\n              generators2.concat(preprocessGenerator(marker, generate)),\n              printerSet.fork(preprocessPrinter(marker, printer)),\n              defaultPrinterType\n            );\n          },\n          printer(selectedPrinter) {\n            return pipelineChain(generators2, printerSet, selectedPrinter);\n          }\n        });\n      }\n      function hitext2(plugins, printerType, printerSet) {\n        let pipeline = pipelineChain([], printerSet || printers, printerType);\n        if (Array.isArray(plugins)) {\n          pipeline = plugins.reduce(\n            (pipeline2, plugin) => Array.isArray(plugin) ? pipeline2.use(...plugin) : pipeline2.use(plugin),\n            pipeline\n          );\n        }\n        return pipeline;\n      }\n      module.exports = Object.assign(hitext2, {\n        gen: generators,\n        printer: Object.assign((...args) => hitext2().printer(...args), printers),\n        use(...args) {\n          return hitext2().use(...args);\n        }\n      });\n    }\n  });\n\n  // node_modules/codemirror/mode/css/css.js\n  var require_css = __commonJS({\n    "node_modules/codemirror/mode/css/css.js"(exports, module) {\n      (function(mod2) {\n        if (typeof exports == "object" && typeof module == "object")\n          mod2(require_codemirror());\n        else if (typeof define == "function" && define.amd)\n          define(["../../lib/codemirror"], mod2);\n        else\n          mod2(CodeMirror);\n      })(function(CodeMirror8) {\n        "use strict";\n        CodeMirror8.defineMode("css", function(config, parserConfig) {\n          var inline2 = parserConfig.inline;\n          if (!parserConfig.propertyKeywords)\n            parserConfig = CodeMirror8.resolveMode("text/css");\n          var indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, documentTypes2 = parserConfig.documentTypes || {}, mediaTypes2 = parserConfig.mediaTypes || {}, mediaFeatures2 = parserConfig.mediaFeatures || {}, mediaValueKeywords2 = parserConfig.mediaValueKeywords || {}, propertyKeywords2 = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords2 = parserConfig.nonStandardPropertyKeywords || {}, fontProperties2 = parserConfig.fontProperties || {}, counterDescriptors2 = parserConfig.counterDescriptors || {}, colorKeywords2 = parserConfig.colorKeywords || {}, valueKeywords2 = parserConfig.valueKeywords || {}, allowNested = parserConfig.allowNested, lineComment = parserConfig.lineComment, supportsAtComponent = parserConfig.supportsAtComponent === true, highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;\n          var type, override;\n          function ret(style, tp) {\n            type = tp;\n            return style;\n          }\n          function tokenBase(stream, state) {\n            var ch = stream.next();\n            if (tokenHooks[ch]) {\n              var result = tokenHooks[ch](stream, state);\n              if (result !== false)\n                return result;\n            }\n            if (ch == "@") {\n              stream.eatWhile(/[\\w\\\\\\-]/);\n              return ret("def", stream.current());\n            } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {\n              return ret(null, "compare");\n            } else if (ch == \'"\' || ch == "\'") {\n              state.tokenize = tokenString(ch);\n              return state.tokenize(stream, state);\n            } else if (ch == "#") {\n              stream.eatWhile(/[\\w\\\\\\-]/);\n              return ret("atom", "hash");\n            } else if (ch == "!") {\n              stream.match(/^\\s*\\w*/);\n              return ret("keyword", "important");\n            } else if (/\\d/.test(ch) || ch == "." && stream.eat(/\\d/)) {\n              stream.eatWhile(/[\\w.%]/);\n              return ret("number", "unit");\n            } else if (ch === "-") {\n              if (/[\\d.]/.test(stream.peek())) {\n                stream.eatWhile(/[\\w.%]/);\n                return ret("number", "unit");\n              } else if (stream.match(/^-[\\w\\\\\\-]*/)) {\n                stream.eatWhile(/[\\w\\\\\\-]/);\n                if (stream.match(/^\\s*:/, false))\n                  return ret("variable-2", "variable-definition");\n                return ret("variable-2", "variable");\n              } else if (stream.match(/^\\w+-/)) {\n                return ret("meta", "meta");\n              }\n            } else if (/[,+>*\\/]/.test(ch)) {\n              return ret(null, "select-op");\n            } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n              return ret("qualifier", "qualifier");\n            } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n              return ret(null, ch);\n            } else if (stream.match(/^[\\w-.]+(?=\\()/)) {\n              if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {\n                state.tokenize = tokenParenthesized;\n              }\n              return ret("variable callee", "variable");\n            } else if (/[\\w\\\\\\-]/.test(ch)) {\n              stream.eatWhile(/[\\w\\\\\\-]/);\n              return ret("property", "word");\n            } else {\n              return ret(null, null);\n            }\n          }\n          function tokenString(quote2) {\n            return function(stream, state) {\n              var escaped = false, ch;\n              while ((ch = stream.next()) != null) {\n                if (ch == quote2 && !escaped) {\n                  if (quote2 == ")")\n                    stream.backUp(1);\n                  break;\n                }\n                escaped = !escaped && ch == "\\\\";\n              }\n              if (ch == quote2 || !escaped && quote2 != ")")\n                state.tokenize = null;\n              return ret("string", "string");\n            };\n          }\n          function tokenParenthesized(stream, state) {\n            stream.next();\n            if (!stream.match(/^\\s*[\\"\\\')]/, false))\n              state.tokenize = tokenString(")");\n            else\n              state.tokenize = null;\n            return ret(null, "(");\n          }\n          function Context(type2, indent, prev) {\n            this.type = type2;\n            this.indent = indent;\n            this.prev = prev;\n          }\n          function pushContext(state, stream, type2, indent) {\n            state.context = new Context(type2, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n            return type2;\n          }\n          function popContext(state) {\n            if (state.context.prev)\n              state.context = state.context.prev;\n            return state.context.type;\n          }\n          function pass(type2, stream, state) {\n            return states[state.context.type](type2, stream, state);\n          }\n          function popAndPass(type2, stream, state, n) {\n            for (var i = n || 1; i > 0; i--)\n              state.context = state.context.prev;\n            return pass(type2, stream, state);\n          }\n          function wordAsValue(stream) {\n            var word = stream.current().toLowerCase();\n            if (valueKeywords2.hasOwnProperty(word))\n              override = "atom";\n            else if (colorKeywords2.hasOwnProperty(word))\n              override = "keyword";\n            else\n              override = "variable";\n          }\n          var states = {};\n          states.top = function(type2, stream, state) {\n            if (type2 == "{") {\n              return pushContext(state, stream, "block");\n            } else if (type2 == "}" && state.context.prev) {\n              return popContext(state);\n            } else if (supportsAtComponent && /@component/i.test(type2)) {\n              return pushContext(state, stream, "atComponentBlock");\n            } else if (/^@(-moz-)?document$/i.test(type2)) {\n              return pushContext(state, stream, "documentTypes");\n            } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type2)) {\n              return pushContext(state, stream, "atBlock");\n            } else if (/^@(font-face|counter-style)/i.test(type2)) {\n              state.stateArg = type2;\n              return "restricted_atBlock_before";\n            } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type2)) {\n              return "keyframes";\n            } else if (type2 && type2.charAt(0) == "@") {\n              return pushContext(state, stream, "at");\n            } else if (type2 == "hash") {\n              override = "builtin";\n            } else if (type2 == "word") {\n              override = "tag";\n            } else if (type2 == "variable-definition") {\n              return "maybeprop";\n            } else if (type2 == "interpolation") {\n              return pushContext(state, stream, "interpolation");\n            } else if (type2 == ":") {\n              return "pseudo";\n            } else if (allowNested && type2 == "(") {\n              return pushContext(state, stream, "parens");\n            }\n            return state.context.type;\n          };\n          states.block = function(type2, stream, state) {\n            if (type2 == "word") {\n              var word = stream.current().toLowerCase();\n              if (propertyKeywords2.hasOwnProperty(word)) {\n                override = "property";\n                return "maybeprop";\n              } else if (nonStandardPropertyKeywords2.hasOwnProperty(word)) {\n                override = highlightNonStandardPropertyKeywords ? "string-2" : "property";\n                return "maybeprop";\n              } else if (allowNested) {\n                override = stream.match(/^\\s*:(?:\\s|$)/, false) ? "property" : "tag";\n                return "block";\n              } else {\n                override += " error";\n                return "maybeprop";\n              }\n            } else if (type2 == "meta") {\n              return "block";\n            } else if (!allowNested && (type2 == "hash" || type2 == "qualifier")) {\n              override = "error";\n              return "block";\n            } else {\n              return states.top(type2, stream, state);\n            }\n          };\n          states.maybeprop = function(type2, stream, state) {\n            if (type2 == ":")\n              return pushContext(state, stream, "prop");\n            return pass(type2, stream, state);\n          };\n          states.prop = function(type2, stream, state) {\n            if (type2 == ";")\n              return popContext(state);\n            if (type2 == "{" && allowNested)\n              return pushContext(state, stream, "propBlock");\n            if (type2 == "}" || type2 == "{")\n              return popAndPass(type2, stream, state);\n            if (type2 == "(")\n              return pushContext(state, stream, "parens");\n            if (type2 == "hash" && !/^#([0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(stream.current())) {\n              override += " error";\n            } else if (type2 == "word") {\n              wordAsValue(stream);\n            } else if (type2 == "interpolation") {\n              return pushContext(state, stream, "interpolation");\n            }\n            return "prop";\n          };\n          states.propBlock = function(type2, _stream, state) {\n            if (type2 == "}")\n              return popContext(state);\n            if (type2 == "word") {\n              override = "property";\n              return "maybeprop";\n            }\n            return state.context.type;\n          };\n          states.parens = function(type2, stream, state) {\n            if (type2 == "{" || type2 == "}")\n              return popAndPass(type2, stream, state);\n            if (type2 == ")")\n              return popContext(state);\n            if (type2 == "(")\n              return pushContext(state, stream, "parens");\n            if (type2 == "interpolation")\n              return pushContext(state, stream, "interpolation");\n            if (type2 == "word")\n              wordAsValue(stream);\n            return "parens";\n          };\n          states.pseudo = function(type2, stream, state) {\n            if (type2 == "meta")\n              return "pseudo";\n            if (type2 == "word") {\n              override = "variable-3";\n              return state.context.type;\n            }\n            return pass(type2, stream, state);\n          };\n          states.documentTypes = function(type2, stream, state) {\n            if (type2 == "word" && documentTypes2.hasOwnProperty(stream.current())) {\n              override = "tag";\n              return state.context.type;\n            } else {\n              return states.atBlock(type2, stream, state);\n            }\n          };\n          states.atBlock = function(type2, stream, state) {\n            if (type2 == "(")\n              return pushContext(state, stream, "atBlock_parens");\n            if (type2 == "}" || type2 == ";")\n              return popAndPass(type2, stream, state);\n            if (type2 == "{")\n              return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");\n            if (type2 == "interpolation")\n              return pushContext(state, stream, "interpolation");\n            if (type2 == "word") {\n              var word = stream.current().toLowerCase();\n              if (word == "only" || word == "not" || word == "and" || word == "or")\n                override = "keyword";\n              else if (mediaTypes2.hasOwnProperty(word))\n                override = "attribute";\n              else if (mediaFeatures2.hasOwnProperty(word))\n                override = "property";\n              else if (mediaValueKeywords2.hasOwnProperty(word))\n                override = "keyword";\n              else if (propertyKeywords2.hasOwnProperty(word))\n                override = "property";\n              else if (nonStandardPropertyKeywords2.hasOwnProperty(word))\n                override = highlightNonStandardPropertyKeywords ? "string-2" : "property";\n              else if (valueKeywords2.hasOwnProperty(word))\n                override = "atom";\n              else if (colorKeywords2.hasOwnProperty(word))\n                override = "keyword";\n              else\n                override = "error";\n            }\n            return state.context.type;\n          };\n          states.atComponentBlock = function(type2, stream, state) {\n            if (type2 == "}")\n              return popAndPass(type2, stream, state);\n            if (type2 == "{")\n              return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);\n            if (type2 == "word")\n              override = "error";\n            return state.context.type;\n          };\n          states.atBlock_parens = function(type2, stream, state) {\n            if (type2 == ")")\n              return popContext(state);\n            if (type2 == "{" || type2 == "}")\n              return popAndPass(type2, stream, state, 2);\n            return states.atBlock(type2, stream, state);\n          };\n          states.restricted_atBlock_before = function(type2, stream, state) {\n            if (type2 == "{")\n              return pushContext(state, stream, "restricted_atBlock");\n            if (type2 == "word" && state.stateArg == "@counter-style") {\n              override = "variable";\n              return "restricted_atBlock_before";\n            }\n            return pass(type2, stream, state);\n          };\n          states.restricted_atBlock = function(type2, stream, state) {\n            if (type2 == "}") {\n              state.stateArg = null;\n              return popContext(state);\n            }\n            if (type2 == "word") {\n              if (state.stateArg == "@font-face" && !fontProperties2.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors2.hasOwnProperty(stream.current().toLowerCase()))\n                override = "error";\n              else\n                override = "property";\n              return "maybeprop";\n            }\n            return "restricted_atBlock";\n          };\n          states.keyframes = function(type2, stream, state) {\n            if (type2 == "word") {\n              override = "variable";\n              return "keyframes";\n            }\n            if (type2 == "{")\n              return pushContext(state, stream, "top");\n            return pass(type2, stream, state);\n          };\n          states.at = function(type2, stream, state) {\n            if (type2 == ";")\n              return popContext(state);\n            if (type2 == "{" || type2 == "}")\n              return popAndPass(type2, stream, state);\n            if (type2 == "word")\n              override = "tag";\n            else if (type2 == "hash")\n              override = "builtin";\n            return "at";\n          };\n          states.interpolation = function(type2, stream, state) {\n            if (type2 == "}")\n              return popContext(state);\n            if (type2 == "{" || type2 == ";")\n              return popAndPass(type2, stream, state);\n            if (type2 == "word")\n              override = "variable";\n            else if (type2 != "variable" && type2 != "(" && type2 != ")")\n              override = "error";\n            return "interpolation";\n          };\n          return {\n            startState: function(base) {\n              return {\n                tokenize: null,\n                state: inline2 ? "block" : "top",\n                stateArg: null,\n                context: new Context(inline2 ? "block" : "top", base || 0, null)\n              };\n            },\n            token: function(stream, state) {\n              if (!state.tokenize && stream.eatSpace())\n                return null;\n              var style = (state.tokenize || tokenBase)(stream, state);\n              if (style && typeof style == "object") {\n                type = style[1];\n                style = style[0];\n              }\n              override = style;\n              if (type != "comment")\n                state.state = states[state.state](type, stream, state);\n              return override;\n            },\n            indent: function(state, textAfter) {\n              var cx = state.context, ch = textAfter && textAfter.charAt(0);\n              var indent = cx.indent;\n              if (cx.type == "prop" && (ch == "}" || ch == ")"))\n                cx = cx.prev;\n              if (cx.prev) {\n                if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {\n                  cx = cx.prev;\n                  indent = cx.indent;\n                } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {\n                  indent = Math.max(0, cx.indent - indentUnit);\n                }\n              }\n              return indent;\n            },\n            electricChars: "}",\n            blockCommentStart: "/*",\n            blockCommentEnd: "*/",\n            blockCommentContinue: " * ",\n            lineComment,\n            fold: "brace"\n          };\n        });\n        function keySet(array) {\n          var keys = {};\n          for (var i = 0; i < array.length; ++i) {\n            keys[array[i].toLowerCase()] = true;\n          }\n          return keys;\n        }\n        var documentTypes_ = [\n          "domain",\n          "regexp",\n          "url",\n          "url-prefix"\n        ], documentTypes = keySet(documentTypes_);\n        var mediaTypes_ = [\n          "all",\n          "aural",\n          "braille",\n          "handheld",\n          "print",\n          "projection",\n          "screen",\n          "tty",\n          "tv",\n          "embossed"\n        ], mediaTypes = keySet(mediaTypes_);\n        var mediaFeatures_ = [\n          "width",\n          "min-width",\n          "max-width",\n          "height",\n          "min-height",\n          "max-height",\n          "device-width",\n          "min-device-width",\n          "max-device-width",\n          "device-height",\n          "min-device-height",\n          "max-device-height",\n          "aspect-ratio",\n          "min-aspect-ratio",\n          "max-aspect-ratio",\n          "device-aspect-ratio",\n          "min-device-aspect-ratio",\n          "max-device-aspect-ratio",\n          "color",\n          "min-color",\n          "max-color",\n          "color-index",\n          "min-color-index",\n          "max-color-index",\n          "monochrome",\n          "min-monochrome",\n          "max-monochrome",\n          "resolution",\n          "min-resolution",\n          "max-resolution",\n          "scan",\n          "grid",\n          "orientation",\n          "device-pixel-ratio",\n          "min-device-pixel-ratio",\n          "max-device-pixel-ratio",\n          "pointer",\n          "any-pointer",\n          "hover",\n          "any-hover",\n          "prefers-color-scheme",\n          "dynamic-range",\n          "video-dynamic-range"\n        ], mediaFeatures = keySet(mediaFeatures_);\n        var mediaValueKeywords_ = [\n          "landscape",\n          "portrait",\n          "none",\n          "coarse",\n          "fine",\n          "on-demand",\n          "hover",\n          "interlace",\n          "progressive",\n          "dark",\n          "light",\n          "standard",\n          "high"\n        ], mediaValueKeywords = keySet(mediaValueKeywords_);\n        var propertyKeywords_ = [\n          "align-content",\n          "align-items",\n          "align-self",\n          "alignment-adjust",\n          "alignment-baseline",\n          "all",\n          "anchor-point",\n          "animation",\n          "animation-delay",\n          "animation-direction",\n          "animation-duration",\n          "animation-fill-mode",\n          "animation-iteration-count",\n          "animation-name",\n          "animation-play-state",\n          "animation-timing-function",\n          "appearance",\n          "azimuth",\n          "backdrop-filter",\n          "backface-visibility",\n          "background",\n          "background-attachment",\n          "background-blend-mode",\n          "background-clip",\n          "background-color",\n          "background-image",\n          "background-origin",\n          "background-position",\n          "background-position-x",\n          "background-position-y",\n          "background-repeat",\n          "background-size",\n          "baseline-shift",\n          "binding",\n          "bleed",\n          "block-size",\n          "bookmark-label",\n          "bookmark-level",\n          "bookmark-state",\n          "bookmark-target",\n          "border",\n          "border-bottom",\n          "border-bottom-color",\n          "border-bottom-left-radius",\n          "border-bottom-right-radius",\n          "border-bottom-style",\n          "border-bottom-width",\n          "border-collapse",\n          "border-color",\n          "border-image",\n          "border-image-outset",\n          "border-image-repeat",\n          "border-image-slice",\n          "border-image-source",\n          "border-image-width",\n          "border-left",\n          "border-left-color",\n          "border-left-style",\n          "border-left-width",\n          "border-radius",\n          "border-right",\n          "border-right-color",\n          "border-right-style",\n          "border-right-width",\n          "border-spacing",\n          "border-style",\n          "border-top",\n          "border-top-color",\n          "border-top-left-radius",\n          "border-top-right-radius",\n          "border-top-style",\n          "border-top-width",\n          "border-width",\n          "bottom",\n          "box-decoration-break",\n          "box-shadow",\n          "box-sizing",\n          "break-after",\n          "break-before",\n          "break-inside",\n          "caption-side",\n          "caret-color",\n          "clear",\n          "clip",\n          "color",\n          "color-profile",\n          "column-count",\n          "column-fill",\n          "column-gap",\n          "column-rule",\n          "column-rule-color",\n          "column-rule-style",\n          "column-rule-width",\n          "column-span",\n          "column-width",\n          "columns",\n          "contain",\n          "content",\n          "counter-increment",\n          "counter-reset",\n          "crop",\n          "cue",\n          "cue-after",\n          "cue-before",\n          "cursor",\n          "direction",\n          "display",\n          "dominant-baseline",\n          "drop-initial-after-adjust",\n          "drop-initial-after-align",\n          "drop-initial-before-adjust",\n          "drop-initial-before-align",\n          "drop-initial-size",\n          "drop-initial-value",\n          "elevation",\n          "empty-cells",\n          "fit",\n          "fit-content",\n          "fit-position",\n          "flex",\n          "flex-basis",\n          "flex-direction",\n          "flex-flow",\n          "flex-grow",\n          "flex-shrink",\n          "flex-wrap",\n          "float",\n          "float-offset",\n          "flow-from",\n          "flow-into",\n          "font",\n          "font-family",\n          "font-feature-settings",\n          "font-kerning",\n          "font-language-override",\n          "font-optical-sizing",\n          "font-size",\n          "font-size-adjust",\n          "font-stretch",\n          "font-style",\n          "font-synthesis",\n          "font-variant",\n          "font-variant-alternates",\n          "font-variant-caps",\n          "font-variant-east-asian",\n          "font-variant-ligatures",\n          "font-variant-numeric",\n          "font-variant-position",\n          "font-variation-settings",\n          "font-weight",\n          "gap",\n          "grid",\n          "grid-area",\n          "grid-auto-columns",\n          "grid-auto-flow",\n          "grid-auto-rows",\n          "grid-column",\n          "grid-column-end",\n          "grid-column-gap",\n          "grid-column-start",\n          "grid-gap",\n          "grid-row",\n          "grid-row-end",\n          "grid-row-gap",\n          "grid-row-start",\n          "grid-template",\n          "grid-template-areas",\n          "grid-template-columns",\n          "grid-template-rows",\n          "hanging-punctuation",\n          "height",\n          "hyphens",\n          "icon",\n          "image-orientation",\n          "image-rendering",\n          "image-resolution",\n          "inline-box-align",\n          "inset",\n          "inset-block",\n          "inset-block-end",\n          "inset-block-start",\n          "inset-inline",\n          "inset-inline-end",\n          "inset-inline-start",\n          "isolation",\n          "justify-content",\n          "justify-items",\n          "justify-self",\n          "left",\n          "letter-spacing",\n          "line-break",\n          "line-height",\n          "line-height-step",\n          "line-stacking",\n          "line-stacking-ruby",\n          "line-stacking-shift",\n          "line-stacking-strategy",\n          "list-style",\n          "list-style-image",\n          "list-style-position",\n          "list-style-type",\n          "margin",\n          "margin-bottom",\n          "margin-left",\n          "margin-right",\n          "margin-top",\n          "marks",\n          "marquee-direction",\n          "marquee-loop",\n          "marquee-play-count",\n          "marquee-speed",\n          "marquee-style",\n          "mask-clip",\n          "mask-composite",\n          "mask-image",\n          "mask-mode",\n          "mask-origin",\n          "mask-position",\n          "mask-repeat",\n          "mask-size",\n          "mask-type",\n          "max-block-size",\n          "max-height",\n          "max-inline-size",\n          "max-width",\n          "min-block-size",\n          "min-height",\n          "min-inline-size",\n          "min-width",\n          "mix-blend-mode",\n          "move-to",\n          "nav-down",\n          "nav-index",\n          "nav-left",\n          "nav-right",\n          "nav-up",\n          "object-fit",\n          "object-position",\n          "offset",\n          "offset-anchor",\n          "offset-distance",\n          "offset-path",\n          "offset-position",\n          "offset-rotate",\n          "opacity",\n          "order",\n          "orphans",\n          "outline",\n          "outline-color",\n          "outline-offset",\n          "outline-style",\n          "outline-width",\n          "overflow",\n          "overflow-style",\n          "overflow-wrap",\n          "overflow-x",\n          "overflow-y",\n          "padding",\n          "padding-bottom",\n          "padding-left",\n          "padding-right",\n          "padding-top",\n          "page",\n          "page-break-after",\n          "page-break-before",\n          "page-break-inside",\n          "page-policy",\n          "pause",\n          "pause-after",\n          "pause-before",\n          "perspective",\n          "perspective-origin",\n          "pitch",\n          "pitch-range",\n          "place-content",\n          "place-items",\n          "place-self",\n          "play-during",\n          "position",\n          "presentation-level",\n          "punctuation-trim",\n          "quotes",\n          "region-break-after",\n          "region-break-before",\n          "region-break-inside",\n          "region-fragment",\n          "rendering-intent",\n          "resize",\n          "rest",\n          "rest-after",\n          "rest-before",\n          "richness",\n          "right",\n          "rotate",\n          "rotation",\n          "rotation-point",\n          "row-gap",\n          "ruby-align",\n          "ruby-overhang",\n          "ruby-position",\n          "ruby-span",\n          "scale",\n          "scroll-behavior",\n          "scroll-margin",\n          "scroll-margin-block",\n          "scroll-margin-block-end",\n          "scroll-margin-block-start",\n          "scroll-margin-bottom",\n          "scroll-margin-inline",\n          "scroll-margin-inline-end",\n          "scroll-margin-inline-start",\n          "scroll-margin-left",\n          "scroll-margin-right",\n          "scroll-margin-top",\n          "scroll-padding",\n          "scroll-padding-block",\n          "scroll-padding-block-end",\n          "scroll-padding-block-start",\n          "scroll-padding-bottom",\n          "scroll-padding-inline",\n          "scroll-padding-inline-end",\n          "scroll-padding-inline-start",\n          "scroll-padding-left",\n          "scroll-padding-right",\n          "scroll-padding-top",\n          "scroll-snap-align",\n          "scroll-snap-type",\n          "shape-image-threshold",\n          "shape-inside",\n          "shape-margin",\n          "shape-outside",\n          "size",\n          "speak",\n          "speak-as",\n          "speak-header",\n          "speak-numeral",\n          "speak-punctuation",\n          "speech-rate",\n          "stress",\n          "string-set",\n          "tab-size",\n          "table-layout",\n          "target",\n          "target-name",\n          "target-new",\n          "target-position",\n          "text-align",\n          "text-align-last",\n          "text-combine-upright",\n          "text-decoration",\n          "text-decoration-color",\n          "text-decoration-line",\n          "text-decoration-skip",\n          "text-decoration-skip-ink",\n          "text-decoration-style",\n          "text-emphasis",\n          "text-emphasis-color",\n          "text-emphasis-position",\n          "text-emphasis-style",\n          "text-height",\n          "text-indent",\n          "text-justify",\n          "text-orientation",\n          "text-outline",\n          "text-overflow",\n          "text-rendering",\n          "text-shadow",\n          "text-size-adjust",\n          "text-space-collapse",\n          "text-transform",\n          "text-underline-position",\n          "text-wrap",\n          "top",\n          "touch-action",\n          "transform",\n          "transform-origin",\n          "transform-style",\n          "transition",\n          "transition-delay",\n          "transition-duration",\n          "transition-property",\n          "transition-timing-function",\n          "translate",\n          "unicode-bidi",\n          "user-select",\n          "vertical-align",\n          "visibility",\n          "voice-balance",\n          "voice-duration",\n          "voice-family",\n          "voice-pitch",\n          "voice-range",\n          "voice-rate",\n          "voice-stress",\n          "voice-volume",\n          "volume",\n          "white-space",\n          "widows",\n          "width",\n          "will-change",\n          "word-break",\n          "word-spacing",\n          "word-wrap",\n          "writing-mode",\n          "z-index",\n          // SVG-specific\n          "clip-path",\n          "clip-rule",\n          "mask",\n          "enable-background",\n          "filter",\n          "flood-color",\n          "flood-opacity",\n          "lighting-color",\n          "stop-color",\n          "stop-opacity",\n          "pointer-events",\n          "color-interpolation",\n          "color-interpolation-filters",\n          "color-rendering",\n          "fill",\n          "fill-opacity",\n          "fill-rule",\n          "image-rendering",\n          "marker",\n          "marker-end",\n          "marker-mid",\n          "marker-start",\n          "paint-order",\n          "shape-rendering",\n          "stroke",\n          "stroke-dasharray",\n          "stroke-dashoffset",\n          "stroke-linecap",\n          "stroke-linejoin",\n          "stroke-miterlimit",\n          "stroke-opacity",\n          "stroke-width",\n          "text-rendering",\n          "baseline-shift",\n          "dominant-baseline",\n          "glyph-orientation-horizontal",\n          "glyph-orientation-vertical",\n          "text-anchor",\n          "writing-mode"\n        ], propertyKeywords = keySet(propertyKeywords_);\n        var nonStandardPropertyKeywords_ = [\n          "accent-color",\n          "aspect-ratio",\n          "border-block",\n          "border-block-color",\n          "border-block-end",\n          "border-block-end-color",\n          "border-block-end-style",\n          "border-block-end-width",\n          "border-block-start",\n          "border-block-start-color",\n          "border-block-start-style",\n          "border-block-start-width",\n          "border-block-style",\n          "border-block-width",\n          "border-inline",\n          "border-inline-color",\n          "border-inline-end",\n          "border-inline-end-color",\n          "border-inline-end-style",\n          "border-inline-end-width",\n          "border-inline-start",\n          "border-inline-start-color",\n          "border-inline-start-style",\n          "border-inline-start-width",\n          "border-inline-style",\n          "border-inline-width",\n          "content-visibility",\n          "margin-block",\n          "margin-block-end",\n          "margin-block-start",\n          "margin-inline",\n          "margin-inline-end",\n          "margin-inline-start",\n          "overflow-anchor",\n          "overscroll-behavior",\n          "padding-block",\n          "padding-block-end",\n          "padding-block-start",\n          "padding-inline",\n          "padding-inline-end",\n          "padding-inline-start",\n          "scroll-snap-stop",\n          "scrollbar-3d-light-color",\n          "scrollbar-arrow-color",\n          "scrollbar-base-color",\n          "scrollbar-dark-shadow-color",\n          "scrollbar-face-color",\n          "scrollbar-highlight-color",\n          "scrollbar-shadow-color",\n          "scrollbar-track-color",\n          "searchfield-cancel-button",\n          "searchfield-decoration",\n          "searchfield-results-button",\n          "searchfield-results-decoration",\n          "shape-inside",\n          "zoom"\n        ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n        var fontProperties_ = [\n          "font-display",\n          "font-family",\n          "src",\n          "unicode-range",\n          "font-variant",\n          "font-feature-settings",\n          "font-stretch",\n          "font-weight",\n          "font-style"\n        ], fontProperties = keySet(fontProperties_);\n        var counterDescriptors_ = [\n          "additive-symbols",\n          "fallback",\n          "negative",\n          "pad",\n          "prefix",\n          "range",\n          "speak-as",\n          "suffix",\n          "symbols",\n          "system"\n        ], counterDescriptors = keySet(counterDescriptors_);\n        var colorKeywords_ = [\n          "aliceblue",\n          "antiquewhite",\n          "aqua",\n          "aquamarine",\n          "azure",\n          "beige",\n          "bisque",\n          "black",\n          "blanchedalmond",\n          "blue",\n          "blueviolet",\n          "brown",\n          "burlywood",\n          "cadetblue",\n          "chartreuse",\n          "chocolate",\n          "coral",\n          "cornflowerblue",\n          "cornsilk",\n          "crimson",\n          "cyan",\n          "darkblue",\n          "darkcyan",\n          "darkgoldenrod",\n          "darkgray",\n          "darkgreen",\n          "darkgrey",\n          "darkkhaki",\n          "darkmagenta",\n          "darkolivegreen",\n          "darkorange",\n          "darkorchid",\n          "darkred",\n          "darksalmon",\n          "darkseagreen",\n          "darkslateblue",\n          "darkslategray",\n          "darkslategrey",\n          "darkturquoise",\n          "darkviolet",\n          "deeppink",\n          "deepskyblue",\n          "dimgray",\n          "dimgrey",\n          "dodgerblue",\n          "firebrick",\n          "floralwhite",\n          "forestgreen",\n          "fuchsia",\n          "gainsboro",\n          "ghostwhite",\n          "gold",\n          "goldenrod",\n          "gray",\n          "grey",\n          "green",\n          "greenyellow",\n          "honeydew",\n          "hotpink",\n          "indianred",\n          "indigo",\n          "ivory",\n          "khaki",\n          "lavender",\n          "lavenderblush",\n          "lawngreen",\n          "lemonchiffon",\n          "lightblue",\n          "lightcoral",\n          "lightcyan",\n          "lightgoldenrodyellow",\n          "lightgray",\n          "lightgreen",\n          "lightgrey",\n          "lightpink",\n          "lightsalmon",\n          "lightseagreen",\n          "lightskyblue",\n          "lightslategray",\n          "lightslategrey",\n          "lightsteelblue",\n          "lightyellow",\n          "lime",\n          "limegreen",\n          "linen",\n          "magenta",\n          "maroon",\n          "mediumaquamarine",\n          "mediumblue",\n          "mediumorchid",\n          "mediumpurple",\n          "mediumseagreen",\n          "mediumslateblue",\n          "mediumspringgreen",\n          "mediumturquoise",\n          "mediumvioletred",\n          "midnightblue",\n          "mintcream",\n          "mistyrose",\n          "moccasin",\n          "navajowhite",\n          "navy",\n          "oldlace",\n          "olive",\n          "olivedrab",\n          "orange",\n          "orangered",\n          "orchid",\n          "palegoldenrod",\n          "palegreen",\n          "paleturquoise",\n          "palevioletred",\n          "papayawhip",\n          "peachpuff",\n          "peru",\n          "pink",\n          "plum",\n          "powderblue",\n          "purple",\n          "rebeccapurple",\n          "red",\n          "rosybrown",\n          "royalblue",\n          "saddlebrown",\n          "salmon",\n          "sandybrown",\n          "seagreen",\n          "seashell",\n          "sienna",\n          "silver",\n          "skyblue",\n          "slateblue",\n          "slategray",\n          "slategrey",\n          "snow",\n          "springgreen",\n          "steelblue",\n          "tan",\n          "teal",\n          "thistle",\n          "tomato",\n          "turquoise",\n          "violet",\n          "wheat",\n          "white",\n          "whitesmoke",\n          "yellow",\n          "yellowgreen"\n        ], colorKeywords = keySet(colorKeywords_);\n        var valueKeywords_ = [\n          "above",\n          "absolute",\n          "activeborder",\n          "additive",\n          "activecaption",\n          "afar",\n          "after-white-space",\n          "ahead",\n          "alias",\n          "all",\n          "all-scroll",\n          "alphabetic",\n          "alternate",\n          "always",\n          "amharic",\n          "amharic-abegede",\n          "antialiased",\n          "appworkspace",\n          "arabic-indic",\n          "armenian",\n          "asterisks",\n          "attr",\n          "auto",\n          "auto-flow",\n          "avoid",\n          "avoid-column",\n          "avoid-page",\n          "avoid-region",\n          "axis-pan",\n          "background",\n          "backwards",\n          "baseline",\n          "below",\n          "bidi-override",\n          "binary",\n          "bengali",\n          "blink",\n          "block",\n          "block-axis",\n          "blur",\n          "bold",\n          "bolder",\n          "border",\n          "border-box",\n          "both",\n          "bottom",\n          "break",\n          "break-all",\n          "break-word",\n          "brightness",\n          "bullets",\n          "button",\n          "buttonface",\n          "buttonhighlight",\n          "buttonshadow",\n          "buttontext",\n          "calc",\n          "cambodian",\n          "capitalize",\n          "caps-lock-indicator",\n          "caption",\n          "captiontext",\n          "caret",\n          "cell",\n          "center",\n          "checkbox",\n          "circle",\n          "cjk-decimal",\n          "cjk-earthly-branch",\n          "cjk-heavenly-stem",\n          "cjk-ideographic",\n          "clear",\n          "clip",\n          "close-quote",\n          "col-resize",\n          "collapse",\n          "color",\n          "color-burn",\n          "color-dodge",\n          "column",\n          "column-reverse",\n          "compact",\n          "condensed",\n          "conic-gradient",\n          "contain",\n          "content",\n          "contents",\n          "content-box",\n          "context-menu",\n          "continuous",\n          "contrast",\n          "copy",\n          "counter",\n          "counters",\n          "cover",\n          "crop",\n          "cross",\n          "crosshair",\n          "cubic-bezier",\n          "currentcolor",\n          "cursive",\n          "cyclic",\n          "darken",\n          "dashed",\n          "decimal",\n          "decimal-leading-zero",\n          "default",\n          "default-button",\n          "dense",\n          "destination-atop",\n          "destination-in",\n          "destination-out",\n          "destination-over",\n          "devanagari",\n          "difference",\n          "disc",\n          "discard",\n          "disclosure-closed",\n          "disclosure-open",\n          "document",\n          "dot-dash",\n          "dot-dot-dash",\n          "dotted",\n          "double",\n          "down",\n          "drop-shadow",\n          "e-resize",\n          "ease",\n          "ease-in",\n          "ease-in-out",\n          "ease-out",\n          "element",\n          "ellipse",\n          "ellipsis",\n          "embed",\n          "end",\n          "ethiopic",\n          "ethiopic-abegede",\n          "ethiopic-abegede-am-et",\n          "ethiopic-abegede-gez",\n          "ethiopic-abegede-ti-er",\n          "ethiopic-abegede-ti-et",\n          "ethiopic-halehame-aa-er",\n          "ethiopic-halehame-aa-et",\n          "ethiopic-halehame-am-et",\n          "ethiopic-halehame-gez",\n          "ethiopic-halehame-om-et",\n          "ethiopic-halehame-sid-et",\n          "ethiopic-halehame-so-et",\n          "ethiopic-halehame-ti-er",\n          "ethiopic-halehame-ti-et",\n          "ethiopic-halehame-tig",\n          "ethiopic-numeric",\n          "ew-resize",\n          "exclusion",\n          "expanded",\n          "extends",\n          "extra-condensed",\n          "extra-expanded",\n          "fantasy",\n          "fast",\n          "fill",\n          "fill-box",\n          "fixed",\n          "flat",\n          "flex",\n          "flex-end",\n          "flex-start",\n          "footnotes",\n          "forwards",\n          "from",\n          "geometricPrecision",\n          "georgian",\n          "grayscale",\n          "graytext",\n          "grid",\n          "groove",\n          "gujarati",\n          "gurmukhi",\n          "hand",\n          "hangul",\n          "hangul-consonant",\n          "hard-light",\n          "hebrew",\n          "help",\n          "hidden",\n          "hide",\n          "higher",\n          "highlight",\n          "highlighttext",\n          "hiragana",\n          "hiragana-iroha",\n          "horizontal",\n          "hsl",\n          "hsla",\n          "hue",\n          "hue-rotate",\n          "icon",\n          "ignore",\n          "inactiveborder",\n          "inactivecaption",\n          "inactivecaptiontext",\n          "infinite",\n          "infobackground",\n          "infotext",\n          "inherit",\n          "initial",\n          "inline",\n          "inline-axis",\n          "inline-block",\n          "inline-flex",\n          "inline-grid",\n          "inline-table",\n          "inset",\n          "inside",\n          "intrinsic",\n          "invert",\n          "italic",\n          "japanese-formal",\n          "japanese-informal",\n          "justify",\n          "kannada",\n          "katakana",\n          "katakana-iroha",\n          "keep-all",\n          "khmer",\n          "korean-hangul-formal",\n          "korean-hanja-formal",\n          "korean-hanja-informal",\n          "landscape",\n          "lao",\n          "large",\n          "larger",\n          "left",\n          "level",\n          "lighter",\n          "lighten",\n          "line-through",\n          "linear",\n          "linear-gradient",\n          "lines",\n          "list-item",\n          "listbox",\n          "listitem",\n          "local",\n          "logical",\n          "loud",\n          "lower",\n          "lower-alpha",\n          "lower-armenian",\n          "lower-greek",\n          "lower-hexadecimal",\n          "lower-latin",\n          "lower-norwegian",\n          "lower-roman",\n          "lowercase",\n          "ltr",\n          "luminosity",\n          "malayalam",\n          "manipulation",\n          "match",\n          "matrix",\n          "matrix3d",\n          "media-play-button",\n          "media-slider",\n          "media-sliderthumb",\n          "media-volume-slider",\n          "media-volume-sliderthumb",\n          "medium",\n          "menu",\n          "menulist",\n          "menulist-button",\n          "menutext",\n          "message-box",\n          "middle",\n          "min-intrinsic",\n          "mix",\n          "mongolian",\n          "monospace",\n          "move",\n          "multiple",\n          "multiple_mask_images",\n          "multiply",\n          "myanmar",\n          "n-resize",\n          "narrower",\n          "ne-resize",\n          "nesw-resize",\n          "no-close-quote",\n          "no-drop",\n          "no-open-quote",\n          "no-repeat",\n          "none",\n          "normal",\n          "not-allowed",\n          "nowrap",\n          "ns-resize",\n          "numbers",\n          "numeric",\n          "nw-resize",\n          "nwse-resize",\n          "oblique",\n          "octal",\n          "opacity",\n          "open-quote",\n          "optimizeLegibility",\n          "optimizeSpeed",\n          "oriya",\n          "oromo",\n          "outset",\n          "outside",\n          "outside-shape",\n          "overlay",\n          "overline",\n          "padding",\n          "padding-box",\n          "painted",\n          "page",\n          "paused",\n          "persian",\n          "perspective",\n          "pinch-zoom",\n          "plus-darker",\n          "plus-lighter",\n          "pointer",\n          "polygon",\n          "portrait",\n          "pre",\n          "pre-line",\n          "pre-wrap",\n          "preserve-3d",\n          "progress",\n          "push-button",\n          "radial-gradient",\n          "radio",\n          "read-only",\n          "read-write",\n          "read-write-plaintext-only",\n          "rectangle",\n          "region",\n          "relative",\n          "repeat",\n          "repeating-linear-gradient",\n          "repeating-radial-gradient",\n          "repeating-conic-gradient",\n          "repeat-x",\n          "repeat-y",\n          "reset",\n          "reverse",\n          "rgb",\n          "rgba",\n          "ridge",\n          "right",\n          "rotate",\n          "rotate3d",\n          "rotateX",\n          "rotateY",\n          "rotateZ",\n          "round",\n          "row",\n          "row-resize",\n          "row-reverse",\n          "rtl",\n          "run-in",\n          "running",\n          "s-resize",\n          "sans-serif",\n          "saturate",\n          "saturation",\n          "scale",\n          "scale3d",\n          "scaleX",\n          "scaleY",\n          "scaleZ",\n          "screen",\n          "scroll",\n          "scrollbar",\n          "scroll-position",\n          "se-resize",\n          "searchfield",\n          "searchfield-cancel-button",\n          "searchfield-decoration",\n          "searchfield-results-button",\n          "searchfield-results-decoration",\n          "self-start",\n          "self-end",\n          "semi-condensed",\n          "semi-expanded",\n          "separate",\n          "sepia",\n          "serif",\n          "show",\n          "sidama",\n          "simp-chinese-formal",\n          "simp-chinese-informal",\n          "single",\n          "skew",\n          "skewX",\n          "skewY",\n          "skip-white-space",\n          "slide",\n          "slider-horizontal",\n          "slider-vertical",\n          "sliderthumb-horizontal",\n          "sliderthumb-vertical",\n          "slow",\n          "small",\n          "small-caps",\n          "small-caption",\n          "smaller",\n          "soft-light",\n          "solid",\n          "somali",\n          "source-atop",\n          "source-in",\n          "source-out",\n          "source-over",\n          "space",\n          "space-around",\n          "space-between",\n          "space-evenly",\n          "spell-out",\n          "square",\n          "square-button",\n          "start",\n          "static",\n          "status-bar",\n          "stretch",\n          "stroke",\n          "stroke-box",\n          "sub",\n          "subpixel-antialiased",\n          "svg_masks",\n          "super",\n          "sw-resize",\n          "symbolic",\n          "symbols",\n          "system-ui",\n          "table",\n          "table-caption",\n          "table-cell",\n          "table-column",\n          "table-column-group",\n          "table-footer-group",\n          "table-header-group",\n          "table-row",\n          "table-row-group",\n          "tamil",\n          "telugu",\n          "text",\n          "text-bottom",\n          "text-top",\n          "textarea",\n          "textfield",\n          "thai",\n          "thick",\n          "thin",\n          "threeddarkshadow",\n          "threedface",\n          "threedhighlight",\n          "threedlightshadow",\n          "threedshadow",\n          "tibetan",\n          "tigre",\n          "tigrinya-er",\n          "tigrinya-er-abegede",\n          "tigrinya-et",\n          "tigrinya-et-abegede",\n          "to",\n          "top",\n          "trad-chinese-formal",\n          "trad-chinese-informal",\n          "transform",\n          "translate",\n          "translate3d",\n          "translateX",\n          "translateY",\n          "translateZ",\n          "transparent",\n          "ultra-condensed",\n          "ultra-expanded",\n          "underline",\n          "unidirectional-pan",\n          "unset",\n          "up",\n          "upper-alpha",\n          "upper-armenian",\n          "upper-greek",\n          "upper-hexadecimal",\n          "upper-latin",\n          "upper-norwegian",\n          "upper-roman",\n          "uppercase",\n          "urdu",\n          "url",\n          "var",\n          "vertical",\n          "vertical-text",\n          "view-box",\n          "visible",\n          "visibleFill",\n          "visiblePainted",\n          "visibleStroke",\n          "visual",\n          "w-resize",\n          "wait",\n          "wave",\n          "wider",\n          "window",\n          "windowframe",\n          "windowtext",\n          "words",\n          "wrap",\n          "wrap-reverse",\n          "x-large",\n          "x-small",\n          "xor",\n          "xx-large",\n          "xx-small"\n        ], valueKeywords = keySet(valueKeywords_);\n        var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);\n        CodeMirror8.registerHelper("hintWords", "css", allWords);\n        function tokenCComment(stream, state) {\n          var maybeEnd = false, ch;\n          while ((ch = stream.next()) != null) {\n            if (maybeEnd && ch == "/") {\n              state.tokenize = null;\n              break;\n            }\n            maybeEnd = ch == "*";\n          }\n          return ["comment", "comment"];\n        }\n        CodeMirror8.defineMIME("text/css", {\n          documentTypes,\n          mediaTypes,\n          mediaFeatures,\n          mediaValueKeywords,\n          propertyKeywords,\n          nonStandardPropertyKeywords,\n          fontProperties,\n          counterDescriptors,\n          colorKeywords,\n          valueKeywords,\n          tokenHooks: {\n            "/": function(stream, state) {\n              if (!stream.eat("*"))\n                return false;\n              state.tokenize = tokenCComment;\n              return tokenCComment(stream, state);\n            }\n          },\n          name: "css"\n        });\n        CodeMirror8.defineMIME("text/x-scss", {\n          mediaTypes,\n          mediaFeatures,\n          mediaValueKeywords,\n          propertyKeywords,\n          nonStandardPropertyKeywords,\n          colorKeywords,\n          valueKeywords,\n          fontProperties,\n          allowNested: true,\n          lineComment: "//",\n          tokenHooks: {\n            "/": function(stream, state) {\n              if (stream.eat("/")) {\n                stream.skipToEnd();\n                return ["comment", "comment"];\n              } else if (stream.eat("*")) {\n                state.tokenize = tokenCComment;\n                return tokenCComment(stream, state);\n              } else {\n                return ["operator", "operator"];\n              }\n            },\n            ":": function(stream) {\n              if (stream.match(/^\\s*\\{/, false))\n                return [null, null];\n              return false;\n            },\n            "$": function(stream) {\n              stream.match(/^[\\w-]+/);\n              if (stream.match(/^\\s*:/, false))\n                return ["variable-2", "variable-definition"];\n              return ["variable-2", "variable"];\n            },\n            "#": function(stream) {\n              if (!stream.eat("{"))\n                return false;\n              return [null, "interpolation"];\n            }\n          },\n          name: "css",\n          helperType: "scss"\n        });\n        CodeMirror8.defineMIME("text/x-less", {\n          mediaTypes,\n          mediaFeatures,\n          mediaValueKeywords,\n          propertyKeywords,\n          nonStandardPropertyKeywords,\n          colorKeywords,\n          valueKeywords,\n          fontProperties,\n          allowNested: true,\n          lineComment: "//",\n          tokenHooks: {\n            "/": function(stream, state) {\n              if (stream.eat("/")) {\n                stream.skipToEnd();\n                return ["comment", "comment"];\n              } else if (stream.eat("*")) {\n                state.tokenize = tokenCComment;\n                return tokenCComment(stream, state);\n              } else {\n                return ["operator", "operator"];\n              }\n            },\n            "@": function(stream) {\n              if (stream.eat("{"))\n                return [null, "interpolation"];\n              if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false))\n                return false;\n              stream.eatWhile(/[\\w\\\\\\-]/);\n              if (stream.match(/^\\s*:/, false))\n                return ["variable-2", "variable-definition"];\n              return ["variable-2", "variable"];\n            },\n            "&": function() {\n              return ["atom", "atom"];\n            }\n          },\n          name: "css",\n          helperType: "less"\n        });\n        CodeMirror8.defineMIME("text/x-gss", {\n          documentTypes,\n          mediaTypes,\n          mediaFeatures,\n          propertyKeywords,\n          nonStandardPropertyKeywords,\n          fontProperties,\n          counterDescriptors,\n          colorKeywords,\n          valueKeywords,\n          supportsAtComponent: true,\n          tokenHooks: {\n            "/": function(stream, state) {\n              if (!stream.eat("*"))\n                return false;\n              state.tokenize = tokenCComment;\n              return tokenCComment(stream, state);\n            }\n          },\n          name: "css",\n          helperType: "gss"\n        });\n      });\n    }\n  });\n\n  // node_modules/codemirror/mode/xml/xml.js\n  var require_xml = __commonJS({\n    "node_modules/codemirror/mode/xml/xml.js"(exports, module) {\n      (function(mod2) {\n        if (typeof exports == "object" && typeof module == "object")\n          mod2(require_codemirror());\n        else if (typeof define == "function" && define.amd)\n          define(["../../lib/codemirror"], mod2);\n        else\n          mod2(CodeMirror);\n      })(function(CodeMirror8) {\n        "use strict";\n        var htmlConfig = {\n          autoSelfClosers: {\n            "area": true,\n            "base": true,\n            "br": true,\n            "col": true,\n            "command": true,\n            "embed": true,\n            "frame": true,\n            "hr": true,\n            "img": true,\n            "input": true,\n            "keygen": true,\n            "link": true,\n            "meta": true,\n            "param": true,\n            "source": true,\n            "track": true,\n            "wbr": true,\n            "menuitem": true\n          },\n          implicitlyClosed: {\n            "dd": true,\n            "li": true,\n            "optgroup": true,\n            "option": true,\n            "p": true,\n            "rp": true,\n            "rt": true,\n            "tbody": true,\n            "td": true,\n            "tfoot": true,\n            "th": true,\n            "tr": true\n          },\n          contextGrabbers: {\n            "dd": { "dd": true, "dt": true },\n            "dt": { "dd": true, "dt": true },\n            "li": { "li": true },\n            "option": { "option": true, "optgroup": true },\n            "optgroup": { "optgroup": true },\n            "p": {\n              "address": true,\n              "article": true,\n              "aside": true,\n              "blockquote": true,\n              "dir": true,\n              "div": true,\n              "dl": true,\n              "fieldset": true,\n              "footer": true,\n              "form": true,\n              "h1": true,\n              "h2": true,\n              "h3": true,\n              "h4": true,\n              "h5": true,\n              "h6": true,\n              "header": true,\n              "hgroup": true,\n              "hr": true,\n              "menu": true,\n              "nav": true,\n              "ol": true,\n              "p": true,\n              "pre": true,\n              "section": true,\n              "table": true,\n              "ul": true\n            },\n            "rp": { "rp": true, "rt": true },\n            "rt": { "rp": true, "rt": true },\n            "tbody": { "tbody": true, "tfoot": true },\n            "td": { "td": true, "th": true },\n            "tfoot": { "tbody": true },\n            "th": { "td": true, "th": true },\n            "thead": { "tbody": true, "tfoot": true },\n            "tr": { "tr": true }\n          },\n          doNotIndent: { "pre": true },\n          allowUnquoted: true,\n          allowMissing: true,\n          caseFold: true\n        };\n        var xmlConfig = {\n          autoSelfClosers: {},\n          implicitlyClosed: {},\n          contextGrabbers: {},\n          doNotIndent: {},\n          allowUnquoted: false,\n          allowMissing: false,\n          allowMissingTagName: false,\n          caseFold: false\n        };\n        CodeMirror8.defineMode("xml", function(editorConf, config_) {\n          var indentUnit = editorConf.indentUnit;\n          var config = {};\n          var defaults2 = config_.htmlMode ? htmlConfig : xmlConfig;\n          for (var prop in defaults2)\n            config[prop] = defaults2[prop];\n          for (var prop in config_)\n            config[prop] = config_[prop];\n          var type, setStyle;\n          function inText(stream, state) {\n            function chain(parser3) {\n              state.tokenize = parser3;\n              return parser3(stream, state);\n            }\n            var ch = stream.next();\n            if (ch == "<") {\n              if (stream.eat("!")) {\n                if (stream.eat("[")) {\n                  if (stream.match("CDATA["))\n                    return chain(inBlock("atom", "]]>"));\n                  else\n                    return null;\n                } else if (stream.match("--")) {\n                  return chain(inBlock("comment", "-->"));\n                } else if (stream.match("DOCTYPE", true, true)) {\n                  stream.eatWhile(/[\\w\\._\\-]/);\n                  return chain(doctype(1));\n                } else {\n                  return null;\n                }\n              } else if (stream.eat("?")) {\n                stream.eatWhile(/[\\w\\._\\-]/);\n                state.tokenize = inBlock("meta", "?>");\n                return "meta";\n              } else {\n                type = stream.eat("/") ? "closeTag" : "openTag";\n                state.tokenize = inTag;\n                return "tag bracket";\n              }\n            } else if (ch == "&") {\n              var ok;\n              if (stream.eat("#")) {\n                if (stream.eat("x")) {\n                  ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(";");\n                } else {\n                  ok = stream.eatWhile(/[\\d]/) && stream.eat(";");\n                }\n              } else {\n                ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(";");\n              }\n              return ok ? "atom" : "error";\n            } else {\n              stream.eatWhile(/[^&<]/);\n              return null;\n            }\n          }\n          inText.isInText = true;\n          function inTag(stream, state) {\n            var ch = stream.next();\n            if (ch == ">" || ch == "/" && stream.eat(">")) {\n              state.tokenize = inText;\n              type = ch == ">" ? "endTag" : "selfcloseTag";\n              return "tag bracket";\n            } else if (ch == "=") {\n              type = "equals";\n              return null;\n            } else if (ch == "<") {\n              state.tokenize = inText;\n              state.state = baseState;\n              state.tagName = state.tagStart = null;\n              var next = state.tokenize(stream, state);\n              return next ? next + " tag error" : "tag error";\n            } else if (/[\\\'\\"]/.test(ch)) {\n              state.tokenize = inAttribute(ch);\n              state.stringStartCol = stream.column();\n              return state.tokenize(stream, state);\n            } else {\n              stream.match(/^[^\\s\\u00a0=<>\\"\\\']*[^\\s\\u00a0=<>\\"\\\'\\/]/);\n              return "word";\n            }\n          }\n          function inAttribute(quote2) {\n            var closure = function(stream, state) {\n              while (!stream.eol()) {\n                if (stream.next() == quote2) {\n                  state.tokenize = inTag;\n                  break;\n                }\n              }\n              return "string";\n            };\n            closure.isInAttribute = true;\n            return closure;\n          }\n          function inBlock(style, terminator) {\n            return function(stream, state) {\n              while (!stream.eol()) {\n                if (stream.match(terminator)) {\n                  state.tokenize = inText;\n                  break;\n                }\n                stream.next();\n              }\n              return style;\n            };\n          }\n          function doctype(depth) {\n            return function(stream, state) {\n              var ch;\n              while ((ch = stream.next()) != null) {\n                if (ch == "<") {\n                  state.tokenize = doctype(depth + 1);\n                  return state.tokenize(stream, state);\n                } else if (ch == ">") {\n                  if (depth == 1) {\n                    state.tokenize = inText;\n                    break;\n                  } else {\n                    state.tokenize = doctype(depth - 1);\n                    return state.tokenize(stream, state);\n                  }\n                }\n              }\n              return "meta";\n            };\n          }\n          function lower(tagName) {\n            return tagName && tagName.toLowerCase();\n          }\n          function Context(state, tagName, startOfLine) {\n            this.prev = state.context;\n            this.tagName = tagName || "";\n            this.indent = state.indented;\n            this.startOfLine = startOfLine;\n            if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)\n              this.noIndent = true;\n          }\n          function popContext(state) {\n            if (state.context)\n              state.context = state.context.prev;\n          }\n          function maybePopContext(state, nextTagName) {\n            var parentTagName;\n            while (true) {\n              if (!state.context) {\n                return;\n              }\n              parentTagName = state.context.tagName;\n              if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) || !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {\n                return;\n              }\n              popContext(state);\n            }\n          }\n          function baseState(type2, stream, state) {\n            if (type2 == "openTag") {\n              state.tagStart = stream.column();\n              return tagNameState;\n            } else if (type2 == "closeTag") {\n              return closeTagNameState;\n            } else {\n              return baseState;\n            }\n          }\n          function tagNameState(type2, stream, state) {\n            if (type2 == "word") {\n              state.tagName = stream.current();\n              setStyle = "tag";\n              return attrState;\n            } else if (config.allowMissingTagName && type2 == "endTag") {\n              setStyle = "tag bracket";\n              return attrState(type2, stream, state);\n            } else {\n              setStyle = "error";\n              return tagNameState;\n            }\n          }\n          function closeTagNameState(type2, stream, state) {\n            if (type2 == "word") {\n              var tagName = stream.current();\n              if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))\n                popContext(state);\n              if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n                setStyle = "tag";\n                return closeState;\n              } else {\n                setStyle = "tag error";\n                return closeStateErr;\n              }\n            } else if (config.allowMissingTagName && type2 == "endTag") {\n              setStyle = "tag bracket";\n              return closeState(type2, stream, state);\n            } else {\n              setStyle = "error";\n              return closeStateErr;\n            }\n          }\n          function closeState(type2, _stream, state) {\n            if (type2 != "endTag") {\n              setStyle = "error";\n              return closeState;\n            }\n            popContext(state);\n            return baseState;\n          }\n          function closeStateErr(type2, stream, state) {\n            setStyle = "error";\n            return closeState(type2, stream, state);\n          }\n          function attrState(type2, _stream, state) {\n            if (type2 == "word") {\n              setStyle = "attribute";\n              return attrEqState;\n            } else if (type2 == "endTag" || type2 == "selfcloseTag") {\n              var tagName = state.tagName, tagStart = state.tagStart;\n              state.tagName = state.tagStart = null;\n              if (type2 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(lower(tagName))) {\n                maybePopContext(state, tagName);\n              } else {\n                maybePopContext(state, tagName);\n                state.context = new Context(state, tagName, tagStart == state.indented);\n              }\n              return baseState;\n            }\n            setStyle = "error";\n            return attrState;\n          }\n          function attrEqState(type2, stream, state) {\n            if (type2 == "equals")\n              return attrValueState;\n            if (!config.allowMissing)\n              setStyle = "error";\n            return attrState(type2, stream, state);\n          }\n          function attrValueState(type2, stream, state) {\n            if (type2 == "string")\n              return attrContinuedState;\n            if (type2 == "word" && config.allowUnquoted) {\n              setStyle = "string";\n              return attrState;\n            }\n            setStyle = "error";\n            return attrState(type2, stream, state);\n          }\n          function attrContinuedState(type2, stream, state) {\n            if (type2 == "string")\n              return attrContinuedState;\n            return attrState(type2, stream, state);\n          }\n          return {\n            startState: function(baseIndent) {\n              var state = {\n                tokenize: inText,\n                state: baseState,\n                indented: baseIndent || 0,\n                tagName: null,\n                tagStart: null,\n                context: null\n              };\n              if (baseIndent != null)\n                state.baseIndent = baseIndent;\n              return state;\n            },\n            token: function(stream, state) {\n              if (!state.tagName && stream.sol())\n                state.indented = stream.indentation();\n              if (stream.eatSpace())\n                return null;\n              type = null;\n              var style = state.tokenize(stream, state);\n              if ((style || type) && style != "comment") {\n                setStyle = null;\n                state.state = state.state(type || style, stream, state);\n                if (setStyle)\n                  style = setStyle == "error" ? style + " error" : setStyle;\n              }\n              return style;\n            },\n            indent: function(state, textAfter, fullLine) {\n              var context = state.context;\n              if (state.tokenize.isInAttribute) {\n                if (state.tagStart == state.indented)\n                  return state.stringStartCol + 1;\n                else\n                  return state.indented + indentUnit;\n              }\n              if (context && context.noIndent)\n                return CodeMirror8.Pass;\n              if (state.tokenize != inTag && state.tokenize != inText)\n                return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n              if (state.tagName) {\n                if (config.multilineTagIndentPastTag !== false)\n                  return state.tagStart + state.tagName.length + 2;\n                else\n                  return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n              }\n              if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter))\n                return 0;\n              var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n              if (tagAfter && tagAfter[1]) {\n                while (context) {\n                  if (context.tagName == tagAfter[2]) {\n                    context = context.prev;\n                    break;\n                  } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {\n                    context = context.prev;\n                  } else {\n                    break;\n                  }\n                }\n              } else if (tagAfter) {\n                while (context) {\n                  var grabbers = config.contextGrabbers[lower(context.tagName)];\n                  if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))\n                    context = context.prev;\n                  else\n                    break;\n                }\n              }\n              while (context && context.prev && !context.startOfLine)\n                context = context.prev;\n              if (context)\n                return context.indent + indentUnit;\n              else\n                return state.baseIndent || 0;\n            },\n            electricInput: /<\\/[\\s\\w:]+>$/,\n            blockCommentStart: "<!--",\n            blockCommentEnd: "-->",\n            configuration: config.htmlMode ? "html" : "xml",\n            helperType: config.htmlMode ? "html" : "xml",\n            skipAttribute: function(state) {\n              if (state.state == attrValueState)\n                state.state = attrState;\n            },\n            xmlCurrentTag: function(state) {\n              return state.tagName ? { name: state.tagName, close: state.type == "closeTag" } : null;\n            },\n            xmlCurrentContext: function(state) {\n              var context = [];\n              for (var cx = state.context; cx; cx = cx.prev)\n                context.push(cx.tagName);\n              return context.reverse();\n            }\n          };\n        });\n        CodeMirror8.defineMIME("text/xml", "xml");\n        CodeMirror8.defineMIME("application/xml", "xml");\n        if (!CodeMirror8.mimeModes.hasOwnProperty("text/html"))\n          CodeMirror8.defineMIME("text/html", { name: "xml", htmlMode: true });\n      });\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/copy-text.js\n  function execCommandFallback(text) {\n    document.body.append(copyTextBufferEl);\n    try {\n      const selection = window.getSelection();\n      const range = document.createRange();\n      copyTextBufferEl.firstChild.nodeValue = text;\n      range.selectNodeContents(copyTextBufferEl);\n      selection.removeAllRanges();\n      selection.addRange(range);\n      document.execCommand("copy");\n    } finally {\n      copyTextBufferEl.remove();\n    }\n  }\n  async function copyText(text) {\n    try {\n      if (navigator.clipboard) {\n        const permissionStatus = await navigator.permissions.query({\n          name: "clipboard-write"\n        });\n        if (permissionStatus.state === "granted" || permissionStatus.state === "prompt") {\n          return navigator.clipboard.writeText(text);\n        }\n      }\n    } catch (_) {\n    }\n    execCommandFallback(text);\n  }\n  var copyTextBufferEl;\n  var init_copy_text = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/copy-text.js"() {\n      init_dom();\n      copyTextBufferEl = createElement("div", {\n        style: [\n          "position: fixed",\n          "overflow: hidden",\n          "font-size: 1px",\n          "width: 1px",\n          "height: 1px",\n          "top: 0",\n          "left: 0",\n          "white-space: pre"\n        ].join(";")\n      }, ["text"]);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/source.usage.js\n  function getSupported() {\n    const modes = /* @__PURE__ */ new Set();\n    const mimeMode = /* @__PURE__ */ new Map();\n    const resolveMode = (ref) => {\n      const mode = import_codemirror5.default.resolveMode(ref);\n      const key2 = [...mimeMode.keys()].find((key3) => equal(key3, mode));\n      if (key2) {\n        return key2;\n      }\n      mimeMode.set(mode, {\n        name: /* @__PURE__ */ new Set(),\n        mime: /* @__PURE__ */ new Set()\n      });\n      return mode;\n    };\n    for (const [alias, mime] of Object.entries(import_codemirror5.default.modeToMime)) {\n      const mode = mimeMode.get(resolveMode(mime));\n      mode.mime.add(mime);\n      mode.name.add(alias);\n      modes.add(alias);\n    }\n    for (const [mime, alias] of Object.entries(import_codemirror5.default.mimeModes)) {\n      const mode = mimeMode.get(resolveMode(mime));\n      mode.mime.add(mime);\n      if (typeof alias === "string") {\n        mode.name.add(alias);\n        modes.add(alias);\n      }\n    }\n    for (const [alias] of Object.entries(import_codemirror5.default.modes)) {\n      if (!modes.has(alias)) {\n        const mode = import_codemirror5.default.modes[alias];\n        if (!mimeMode.has(mode)) {\n          mimeMode.set(mode, {\n            name: /* @__PURE__ */ new Set(),\n            mime: []\n          });\n        }\n        mimeMode.get(mode).name.add(alias);\n      }\n    }\n    return [...mimeMode.values()].map((syntax) => ({\n      name: [...syntax.name],\n      mime: [...syntax.mime]\n    }));\n  }\n  var import_codemirror5, codeExample, lineNum, source_usage_default;\n  var init_source_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/source.usage.js"() {\n      import_codemirror5 = __toESM(require_codemirror(), 1);\n      init_compare2();\n      codeExample = \'let name = "world";\\n\\nconsole.log(`Hello, ${name}!`);\';\n      lineNum = new Function("return num => num + 5")();\n      source_usage_default = {\n        demo: {\n          view: "source",\n          data: { syntax: "js", content: codeExample }\n        },\n        examples: [\n          {\n            title: "Supported syntaxes",\n            beforeDemo: [\n              \'md:"Following values (for both `name` and `mime`) are supported for `syntax` option:"\',\n              \'html:"<br>"\',\n              {\n                view: "table",\n                data: getSupported,\n                cols: {\n                  name: { content: "comma-list:name" },\n                  mime: { content: "comma-list:mime" }\n                }\n              },\n              \'html:"<br>"\',\n              "md:\\"More syntaxes may be added via `import \'codemirror/mode/[name]/[name]\';`\\""\n            ],\n            source: false\n          },\n          {\n            title: "Custom line numbers",\n            highlightProps: ["lineNum"],\n            demo: {\n              view: "source",\n              data: {\n                content: codeExample,\n                syntax: "js",\n                lineNum\n              }\n            }\n          },\n          {\n            title: "Hide line numbers",\n            highlightProps: ["lineNum"],\n            beforeDemo: [\'md:"Pass falsy value to `lineNum` option to hide line numbers:"\'],\n            demo: {\n              view: "source",\n              data: {\n                content: codeExample,\n                syntax: "js",\n                lineNum: false\n              }\n            }\n          },\n          {\n            title: "Additional action buttons",\n            highlightProps: ["actionButtons"],\n            demo: {\n              view: "source",\n              actionButtons: [\n                {\n                  view: "button",\n                  content: \'text:"Say \\\\"Hello world\\\\""\',\n                  onClick: new Function(\'return () => alert("Hello world!")\')()\n                }\n              ],\n              data: {\n                content: codeExample,\n                syntax: "js"\n              }\n            }\n          },\n          {\n            title: "Prelude and postlude slots",\n            highlightProps: [\n              "prelude",\n              "postlude"\n            ],\n            demo: {\n              view: "source",\n              prelude: [\n                \'text:"Prelude:"\',\n                "struct:{ data: $, context: # }"\n              ],\n              postlude: [\n                \'text:"Postlude:"\',\n                "struct:{ data: $, context: # }"\n              ],\n              data: {\n                content: codeExample,\n                syntax: "js"\n              }\n            }\n          },\n          {\n            title: "Highlight ranges",\n            highlightProps: ["refs"],\n            demo: {\n              view: "source",\n              data: {\n                syntax: "js",\n                content: codeExample,\n                refs: [\n                  { range: [4, 8] },\n                  { range: [21, 28], type: "link", href: "#example", tooltip: {\n                    position: "trigger",\n                    content: [\'text:"Link to "\', "text:href"]\n                  } }\n                ]\n              }\n            }\n          },\n          {\n            title: "Max content size for syntax highlight",\n            highlightProps: ["maxSourceSizeToHighlight"],\n            beforeDemo: [\'md:"By default a syntax highlighing is not appling to a source longer than 250Kb. Option `maxSourceSizeToHighlight` is using to change max size of source to be syntax highlighted."\'],\n            demo: {\n              view: "source",\n              data: {\n                content: codeExample,\n                syntax: "js",\n                maxSourceSizeToHighlight: 4\n              }\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/source.js\n  function codeMirrorHighlight(modespec, host) {\n    const mode = import_codemirror6.default.getMode(import_codemirror6.default.defaults, {\n      name: import_codemirror6.default.modeToMime[modespec] || modespec,\n      isDiscoveryViewDefined: (name) => host.view.isDefined(name)\n    });\n    return (source, createRange) => {\n      const state = import_codemirror6.default.startState(mode);\n      const lines = source.split(/(\\n|\\r\\n?)/);\n      let lineOffset = 0;\n      for (let i = 0; i < lines.length; i++) {\n        if (i % 2 === 0) {\n          const stream = new import_codemirror6.default.StringStream(lines[i], 4, {\n            lookAhead: (n) => lines[i + n],\n            baseToken: function() {\n            }\n          });\n          while (!stream.eol()) {\n            const style = mode.token(stream, state);\n            if (style) {\n              createRange(lineOffset + stream.start, lineOffset + stream.pos, style);\n            }\n            stream.start = stream.pos;\n          }\n        }\n        lineOffset += lines[i].length;\n      }\n    };\n  }\n  function classNames(options2, defaultClassNames) {\n    const customClassName = options2 && options2.className;\n    const classNames2 = [\n      defaultClassNames,\n      Array.isArray(customClassName) ? customClassName.join(" ") : typeof customClassName === "string" ? customClassName : false\n    ].filter(Boolean).join(" ");\n    return classNames2 ? ` class="${classNames2}"` : "";\n  }\n  function refAttrs(data) {\n    return `${classNames(data, "spotlight")}${data.marker ? ` data-marker="${data.marker}"` : ""}${typeof data.tooltipId === "number" ? ` data-tooltip-id="${data.tooltipId}"` : ""}`;\n  }\n  function source_default(host) {\n    host.view.define("source", function(el, config, data, context) {\n      const preludeEl = el.appendChild(createElement("div", "view-source__prelude"));\n      const contentEl = el.appendChild(createElement("div", "view-source__content"));\n      const postludeEl = el.appendChild(createElement("div", "view-source__postlude"));\n      const refsTooltips = /* @__PURE__ */ new Map();\n      const decorators = [];\n      const {\n        mime,\n        // deprecated, syntax = name or mime\n        binary: binary2,\n        size,\n        maxSourceSizeToHighlight = defaultMaxSourceSizeToHighlight,\n        syntax,\n        lineNum: lineNum2 = true,\n        content,\n        refs\n      } = data;\n      if (typeof content !== "string") {\n        return;\n      }\n      if (content.length < maxSourceSizeToHighlight) {\n        decorators.push([codeMirrorHighlight(syntax || mime, host), {\n          html: {\n            open({ data: type }) {\n              return \'<span class="token \' + type + \'">\';\n            },\n            close() {\n              return "</span>";\n            }\n          }\n        }]);\n      }\n      if (Array.isArray(refs)) {\n        decorators.push([\n          (_, createRange) => refs.forEach((ref) => {\n            if (ref.range) {\n              let tooltipId = void 0;\n              if (ref.tooltip) {\n                refsTooltips.set(tooltipId = refsTooltips.size, ref);\n              }\n              createRange(\n                ref.range[0],\n                ref.range[1],\n                { type: "spotlight", ...ref, tooltipId }\n              );\n            }\n          }),\n          refsPrinter\n        ]);\n      }\n      if (binary2) {\n        contentEl.innerHTML = "Binary content" + (typeof size === "number" ? " (" + size + " bytes)" : "");\n      } else {\n        const lineOffset = typeof lineNum2 === "function" ? lineNum2 : (idx) => idx + 1;\n        const lines = lineNum2 ? \'<div class="view-source__lines">\' + content.split(/\\r\\n?|\\n/g).map((_, idx) => "<span>" + lineOffset(idx) + "</span>").join("") + "</div>" : "";\n        contentEl.innerHTML = lines + `<div class="view-source__source">${(0, import_hitext.default)(decorators, "html")(content)}</div>`;\n        const actionButtonsEl = createElement("div", "view-source__action-buttons");\n        host.view.render(actionButtonsEl, [\n          config.actionButtons,\n          { view: "button", className: "copy", async onClick(btnEl) {\n            clearTimeout(btnEl.copiedTimer);\n            await copyText(content);\n            btnEl.classList.add("copied");\n            btnEl.copiedTimer = setTimeout(() => btnEl.classList.remove("copied"), 1250);\n          } }\n        ], data, context);\n        contentEl.prepend(actionButtonsEl);\n        for (const refEl of contentEl.querySelectorAll(":scope [data-tooltip-id]")) {\n          const ref = refsTooltips.get(Number(refEl.dataset.tooltipId));\n          delete refEl.dataset.tooltipId;\n          this.tooltip(refEl, ref.tooltip, ref, context);\n        }\n        if (config.prelude) {\n          host.view.render(preludeEl, config.prelude, data, context);\n        }\n        if (config.postlude) {\n          host.view.render(postludeEl, config.postlude, data, context);\n        }\n      }\n    }, {\n      usage: source_usage_default,\n      tag: "pre"\n    });\n  }\n  var import_hitext, import_codemirror6, import_javascript2, import_css, import_xml, defaultMaxSourceSizeToHighlight, refsPrinter;\n  var init_source = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/source.js"() {\n      import_hitext = __toESM(require_src(), 1);\n      import_codemirror6 = __toESM(require_codemirror(), 1);\n      import_javascript2 = __toESM(require_javascript(), 1);\n      import_css = __toESM(require_css(), 1);\n      import_xml = __toESM(require_xml(), 1);\n      init_dom();\n      init_copy_text();\n      init_source_usage();\n      defaultMaxSourceSizeToHighlight = 250 * 1024;\n      import_codemirror6.default.modeToMime = {\n        js: "application/javascript",\n        ts: "application/typescript",\n        typescript: "application/typescript",\n        json: "application/json",\n        html: "text/html",\n        css: "text/css",\n        scss: "text/x-scss",\n        less: "text/x-less"\n      };\n      refsPrinter = {\n        html: {\n          open({ data }) {\n            switch (data.type) {\n              case "link":\n                return `<a href="${data.href}"${refAttrs(data)}>`;\n              case "spotlight":\n                return `<span${refAttrs(data)}>`;\n            }\n          },\n          close({ data }) {\n            switch (data.type) {\n              case "link":\n                return "</a>";\n              case "spotlight":\n                return "</span>";\n            }\n          }\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/text.usage.js\n  var text_usage_default;\n  var init_text_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/text.usage.js"() {\n      text_usage_default = {\n        demo: {\n          view: "text",\n          data: \'"Hello world!"\'\n        },\n        examples: [\n          {\n            title: "Shorthand usage",\n            view: \'text:"Hello world!"\'\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/text.js\n  function text_default(host) {\n    host.view.define("text", function(el, config, data) {\n      el.appendChild(document.createTextNode(String(data)));\n    }, {\n      tag: false,\n      usage: text_usage_default\n    });\n  }\n  var init_text = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/text.js"() {\n      init_text_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/is-type.js\n  var is_type_exports = {};\n  __export(is_type_exports, {\n    isArray: () => isArray,\n    isRegExp: () => isRegExp2,\n    isSet: () => isSet\n  });\n  function isArray(value) {\n    return Array.isArray(value) || ArrayBuffer.isView(value);\n  }\n  function isSet(value) {\n    return toString2.call(value) === "[object Set]";\n  }\n  function isRegExp2(value) {\n    return toString2.call(value) === "[object RegExp]";\n  }\n  var toString2;\n  var init_is_type = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/is-type.js"() {\n      ({ toString: toString2 } = Object.prototype);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/pattern.js\n  var pattern_exports = {};\n  __export(pattern_exports, {\n    has: () => has,\n    matchAll: () => matchAll\n  });\n  function matchWithRx(str, pattern, lastIndex) {\n    const offset = str.slice(lastIndex).search(pattern);\n    return offset !== -1 ? { offset: lastIndex + offset, length: RegExp.lastMatch.length } : null;\n  }\n  function matchWithString(str, pattern, lastIndex) {\n    const offset = str.indexOf(pattern, lastIndex);\n    return offset !== -1 ? { offset, length: pattern.length } : null;\n  }\n  function has(text, pattern, ignoreCase) {\n    if (isRegExp2(pattern)) {\n      return ignoreCase && !pattern.ignoreCase ? new RegExp(pattern, pattern.flags + "i").test(text) : pattern.test(text);\n    }\n    if (typeof pattern === "string") {\n      return ignoreCase ? String(text).toLowerCase().indexOf(pattern.toLowerCase()) : String(text).indexOf(pattern) !== -1;\n    }\n    return false;\n  }\n  function matchAll(text, pattern, onText, onMatch, ignoreCase) {\n    const next = isRegExp2(pattern) ? matchWithRx : typeof pattern === "string" ? matchWithString : null;\n    let matchText = String(text);\n    if (ignoreCase) {\n      switch (next) {\n        case matchWithRx:\n          if (!pattern.ignoreCase) {\n            pattern = new RegExp(pattern, pattern.flags + "i");\n          }\n          break;\n        case matchWithString:\n          matchText = matchText.toLowerCase();\n          pattern = pattern.toLowerCase();\n          break;\n      }\n    }\n    if (next === null) {\n      onText(text);\n      return;\n    }\n    let lastIndex = 0;\n    do {\n      const match2 = next(matchText, pattern, lastIndex);\n      if (match2 === null || match2.length === 0 && match2.offset === lastIndex) {\n        onText(lastIndex > 0 ? text.slice(lastIndex) : text);\n        break;\n      }\n      if (match2.length !== 0) {\n        if (match2.offset !== lastIndex) {\n          onText(text.slice(lastIndex, match2.offset));\n        }\n        onMatch(text.substr(match2.offset, match2.length));\n      }\n      lastIndex = match2.offset + match2.length;\n    } while (lastIndex !== text.length);\n  }\n  var init_pattern = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/pattern.js"() {\n      init_is_type();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/text-match.usage.js\n  var text_match_usage_default;\n  var init_text_match_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/text-match.usage.js"() {\n      text_match_usage_default = {\n        demo: {\n          view: "text-match",\n          data: {\n            text: "I am matched text or a text with matches!",\n            match: /match/\n          }\n        },\n        examples: [\n          {\n            title: "Raw string as match",\n            demo: {\n              view: "text-match",\n              data: {\n                text: "I am matched text or a text with matches!",\n                match: "match"\n              }\n            }\n          },\n          {\n            title: "Using with a link",\n            demo: {\n              view: "link",\n              data: { href: "#" },\n              content: \'text-match:{ text: "Test link", match: /\\\\w+/i }\'\n            }\n          },\n          {\n            title: "Various configurations",\n            demo: {\n              view: "table",\n              cols: [\n                { header: "text-match", content: "text-match" },\n                { header: "Config", content: "struct" }\n              ],\n              data: [\n                null,\n                {},\n                {},\n                {\n                  match: "test"\n                },\n                {\n                  match: "Test"\n                },\n                {\n                  match: "test",\n                  ignoreCase: true\n                },\n                {\n                  match: "Test",\n                  ignoreCase: true\n                },\n                {\n                  match: /test/\n                },\n                {\n                  match: /test/g\n                },\n                {\n                  match: /test/i\n                },\n                {\n                  match: /test/,\n                  ignoreCase: true\n                },\n                {\n                  match: /test/g,\n                  ignoreCase: true\n                }\n              ].map((item, idx) => idx > 1 ? { text: "test Test", ...item } : item)\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/text-match.js\n  function text_match_default(host) {\n    host.view.define("text-match", function(el, config, data) {\n      const { text, match: pattern, ignoreCase = false } = data || {};\n      matchAll(\n        String(text),\n        pattern,\n        (text2) => el.appendChild(createText(text2)),\n        (text2) => el.appendChild(matchWrapperEl.cloneNode()).appendChild(createText(text2)),\n        ignoreCase\n      );\n    }, {\n      tag: false,\n      usage: text_match_usage_default\n    });\n  }\n  var matchWrapperEl;\n  var init_text_match = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/text-match.js"() {\n      init_dom();\n      init_pattern();\n      init_text_match_usage();\n      matchWrapperEl = createElement("span", "view-text-match");\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/text-numeric.usage.js\n  var text_numeric_usage_default;\n  var init_text_numeric_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/text-numeric.usage.js"() {\n      text_numeric_usage_default = {\n        demo: {\n          view: "text-numeric",\n          data: \'"Like a `text` view but adds a thousands separator to integer part of numbers, e.g. 12345678 or 12345.67890"\'\n        },\n        examples: [\n          {\n            title: "Shorthand usage",\n            view: "text-numeric:1234567"\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/text/text-numeric.js\n  function text_numeric_default(host) {\n    host.view.define("text-numeric", function(el, config, data) {\n      el.innerHTML = numDelim2(data);\n    }, {\n      tag: "span",\n      usage: text_numeric_usage_default\n    });\n  }\n  var init_text_numeric = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/text/text-numeric.js"() {\n      init_html();\n      init_text_numeric_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/context.usage.js\n  var context_usage_default;\n  var init_context_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/context.usage.js"() {\n      context_usage_default = {\n        demo: {\n          view: "context",\n          data: { name: "text", demo: 123 },\n          content: [\n            "text:name",\n            "table"\n          ]\n        },\n        examples: [\n          {\n            title: "Using with modifiers",\n            demo: {\n              view: "context",\n              modifiers: [\n                \'h2:"Modifiers"\',\n                {\n                  view: "input",\n                  name: "inputValue"\n                },\n                {\n                  view: "select",\n                  name: "selectValue",\n                  data: ["foo", "bar", "baz"]\n                }\n              ],\n              content: [\n                \'h2:"Values"\',\n                "struct:#"\n              ]\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/context.js\n  function context_default(host) {\n    host.view.define("context", function(el, config, data, context) {\n      function renderContent() {\n        let cursor = contentEndMarker.previousSibling;\n        while (cursor && cursor !== contentStartMarker) {\n          cursor = cursor.previousSibling;\n          cursor.nextSibling.remove();\n        }\n        const buffer = lastRender = document.createDocumentFragment();\n        return host.view.render(buffer, content, data, localContext).then(() => {\n          if (buffer === lastRender) {\n            host.view.adoptFragment(buffer, contentStartMarker);\n            contentStartMarker.after(buffer);\n          }\n        });\n      }\n      function updateContext(value, name) {\n        if (name && (!hasOwnProperty.call(localContext, name) || localContext[name] !== value)) {\n          localContext = {\n            ...localContext,\n            [name]: value\n          };\n          if (inited) {\n            renderContent();\n            if (proxy && typeof onChange4 === "function") {\n              onChange4(value, name);\n            }\n          } else if (typeof onInit === "function") {\n            onInit(value, name);\n          }\n        }\n      }\n      let localContext = context;\n      let contentStartMarker = null;\n      let contentEndMarker = null;\n      let lastRender = null;\n      let inited = false;\n      let { modifiers = [], content = [] } = config;\n      const { proxy, onInit, onChange: onChange4 } = config;\n      if (!Array.isArray(modifiers)) {\n        modifiers = [modifiers];\n      }\n      const renderModifiers = host.view.render(el, this.composeConfig(modifiers, {\n        onInit: updateContext,\n        onChange: updateContext\n      }), data, context);\n      contentStartMarker = el.appendChild(document.createComment(\'{ view: "context" } content start\'));\n      contentEndMarker = el.appendChild(document.createComment(\'{ view: "context" } content end\'));\n      if (proxy && (onInit || onChange4)) {\n        content = this.composeConfig(content, { onInit, onChange: onChange4 });\n      }\n      return renderModifiers.then(() => {\n        inited = true;\n        return renderContent();\n      });\n    }, {\n      tag: false,\n      usage: context_usage_default\n    });\n  }\n  var init_context = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/context.js"() {\n      init_context_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/switch.usage.js\n  var switch_usage_default;\n  var init_switch_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/switch.usage.js"() {\n      switch_usage_default = {\n        demo: {\n          view: "switch",\n          data: { enabled: true },\n          content: [\n            {\n              when: "not enabled",\n              content: \'text:"I am disabled"\'\n            },\n            {\n              when: "enabled",\n              content: \'text:"I am enabled"\'\n            }\n          ]\n        },\n        examples: [\n          {\n            title: "Using with tabs",\n            demo: {\n              view: "context",\n              modifiers: {\n                view: "tabs",\n                tabs: ["foo", "bar", "baz"],\n                name: "section"\n              },\n              content: {\n                view: "switch",\n                content: [\n                  { when: \'#.section="foo"\', content: \'text:"FOO!"\' },\n                  { when: \'#.section="bar"\', content: \'text:"BAR!!"\' },\n                  { content: \'text:"When no other conditions are met"\' }\n                ]\n              }\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/switch.js\n  function switch_default(host) {\n    host.view.define("switch", function(el, config, data, context) {\n      let { content } = config;\n      let renderConfig = \'alert-warning:"No case choosen"\';\n      if (Array.isArray(content)) {\n        for (let i = 0; i < content.length; i++) {\n          const branch = content[i];\n          if (branch && host.queryBool(branch.when || true, data, context)) {\n            renderConfig = "data" in branch ? {\n              view: "context",\n              data: branch.data,\n              content: branch.content\n            } : branch.content;\n            break;\n          }\n        }\n      }\n      return host.view.render(el, renderConfig, data, context);\n    }, {\n      tag: false,\n      usage: switch_usage_default\n    });\n  }\n  var init_switch = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/switch.js"() {\n      init_switch_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/signature/collect-stat.js\n  function collectObjectMap(value, expanded, objectStat) {\n    for (let key2 in value) {\n      if (!hasOwnProperty.call(value, key2)) {\n        continue;\n      }\n      if (!expanded) {\n        objectStat.properties = null;\n        break;\n      }\n      let propMap;\n      if (objectStat.dictMode) {\n        propMap = objectStat.dictMode;\n        propMap.count++;\n        propMap.keys.add(key2);\n      } else if (objectStat.properties.has(key2)) {\n        propMap = objectStat.properties.get(key2);\n        propMap.count++;\n      } else {\n        propMap = {\n          count: 1,\n          map: /* @__PURE__ */ Object.create(null)\n        };\n        objectStat.properties.set(key2, propMap);\n      }\n      collectStat(value[key2], expanded - 1, propMap.map);\n    }\n  }\n  function collectStat(value, expanded, stat = /* @__PURE__ */ Object.create(null)) {\n    const type = value === null ? "null" : isArray(value) ? "array" : isSet(value) ? "set" : typeof value;\n    switch (type) {\n      default:\n        if (type in stat === false) {\n          stat[type] = /* @__PURE__ */ new Map();\n        }\n        stat[type].set(value, (stat[type].get(value) || 0) + 1);\n        break;\n      case "object":\n        if ("object" in stat === false) {\n          stat.object = /* @__PURE__ */ new Map();\n          stat.object.count = 0;\n          stat.object.properties = /* @__PURE__ */ new Map();\n          stat.object.dictMode = null;\n          stat.object.sortKeys = false;\n        }\n        stat.object.count++;\n        if (!stat.object.has(value)) {\n          stat.object.set(value, 1);\n          collectObjectMap(value, expanded, stat.object);\n        } else {\n          stat.object.set(value, stat.object.get(value) + 1);\n        }\n        break;\n      case "array":\n        if ("array" in stat === false) {\n          stat.array = /* @__PURE__ */ new Map();\n          stat.array.count = 0;\n          stat.array.map = /* @__PURE__ */ Object.create(null);\n        }\n        stat.array.count++;\n        stat.array.set(value, (stat.array.get(value) || 0) + 1);\n        for (let i = 0; i < value.length; i++) {\n          collectStat(value[i], expanded, stat.array.map);\n        }\n        break;\n      case "set":\n        if ("set" in stat === false) {\n          stat.set = /* @__PURE__ */ new Map();\n          stat.set.count++;\n          stat.set.map = /* @__PURE__ */ Object.create(null);\n        }\n        stat.set.count++;\n        stat.set.set(value, (stat.set.get(value) || 0) + 1);\n        for (const val of value) {\n          collectStat(val, expanded, stat.set.map);\n        }\n        break;\n    }\n    return stat;\n  }\n  var init_collect_stat = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/signature/collect-stat.js"() {\n      init_is_type();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/signature/const.js\n  var colors, typeOrder2;\n  var init_const2 = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/signature/const.js"() {\n      colors = [\n        "rgba(83,211,75,0.75)",\n        "rgba(241,235,44,0.75)",\n        "rgba(244,152,99,0.75)",\n        "rgba(148,99,244,0.75)",\n        "rgba(44,132,241,0.75)",\n        "rgba(233,117,117,0.75)",\n        "rgba(85,187,155,0.75)",\n        "rgba(151,147,99,0.75)",\n        "rgba(216,107,196,0.75)",\n        "rgba(108,204,227,0.75)",\n        "rgba(164,164,164,0.75)"\n      ];\n      typeOrder2 = [\n        "null",\n        "undefined",\n        "string",\n        "number",\n        "bigint",\n        "boolean",\n        "symbol",\n        "function",\n        "array",\n        "set",\n        "object"\n      ];\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/signature/render-stat.js\n  function renderStat(el, stat, elementToData, path = [], offset = "") {\n    Object.keys(stat).sort((a, b2) => typeOrder2.indexOf(a) - typeOrder2.indexOf(b2)).forEach((type, idx) => {\n      if (idx > 0) {\n        el.appendChild(createText(" | "));\n      }\n      switch (type) {\n        default: {\n          const typeEl = el.appendChild(createElement("span", "type", type));\n          elementToData.set(typeEl, {\n            type: "type",\n            path,\n            stat,\n            name: type\n          });\n          break;\n        }\n        case "object": {\n          const values = stat[type];\n          const { properties, dictMode, sortKeys } = values;\n          if (properties === null) {\n            elementToData.set(el.appendChild(createElement("span", "expand", "{\\u2026}")), {\n              type: "expand",\n              path,\n              map: stat[type],\n              offset\n            });\n            break;\n          }\n          if (properties.size === 0) {\n            el.appendChild(createElement("span", "object", "{}"));\n            break;\n          }\n          const valuesCount = values.size;\n          const entries2 = dictMode ? [["[key]", dictMode]] : [...properties.entries()];\n          const propertyOffset = offset + "    ";\n          const contentEl = el.appendChild(createElement("span", "object", [\n            "{",\n            createElement("span", {\n              "data-action": "collapse"\n            })\n          ]));\n          if (properties.size > 1) {\n            contentEl.appendChild(\n              createElement("span", {\n                title: "Toggle dictionary mode (collapse all the values in a single signature)",\n                "data-action": "dict-mode",\n                "data-enabled": dictMode !== null\n              })\n            );\n            if (entries2.some(([key2], idx2) => idx2 !== 0 && key2 < entries2[idx2 - 1][0])) {\n              contentEl.appendChild(\n                createElement("span", {\n                  title: "Toggle keys sorting",\n                  "data-action": "sort-keys",\n                  "data-enabled": sortKeys\n                })\n              );\n            }\n          }\n          elementToData.set(contentEl, {\n            type: "shape",\n            path,\n            map: stat[type],\n            offset\n          });\n          if (valuesCount > 1) {\n            contentEl.appendChild(createElement("span", "count")).dataset.value = String(valuesCount);\n          }\n          if (sortKeys) {\n            entries2.sort(([a], [b2]) => a < b2 ? -1 : a > b2 ? 1 : 0);\n          }\n          for (const [name, { count: count3, map: map2 }] of entries2) {\n            const propertyEl = createElement("span", "property", [name]);\n            elementToData.set(propertyEl, {\n              type: "property",\n              path,\n              stat,\n              name,\n              map: map2\n            });\n            contentEl.appendChild(createText(`\n${propertyOffset}`));\n            contentEl.appendChild(propertyEl);\n            if (count3 !== valuesCount && dictMode === null) {\n              propertyEl.appendChild(createElement("span", "optional", "?"));\n            }\n            contentEl.appendChild(createText(": "));\n            renderStat(contentEl, map2, elementToData, path.concat(dictMode ? "*" : name), propertyOffset);\n            contentEl.appendChild(createText(";"));\n          }\n          if (contentEl.lastChild.nodeValue === ";") {\n            contentEl.appendChild(createText(`\n${offset}`));\n          }\n          contentEl.appendChild(createText("}"));\n          break;\n        }\n        case "array":\n          el.appendChild(createText("["));\n          renderStat(el, stat[type].map, elementToData, path, offset);\n          el.appendChild(createText("]"));\n          break;\n        case "set":\n          el.appendChild(createText("Set("));\n          renderStat(el, stat[type].map, elementToData, path, offset);\n          el.appendChild(createText(")"));\n          break;\n      }\n    });\n  }\n  var init_render_stat = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/signature/render-stat.js"() {\n      init_dom();\n      init_const2();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/signature/render-details.js\n  function fixedNum(num, prec) {\n    return num.toFixed(prec).replace(/\\.?0+$/, "");\n  }\n  function getCoordinatesForPercent(percent) {\n    const x = Math.cos(2 * Math.PI * percent);\n    const y2 = Math.sin(2 * Math.PI * percent);\n    return [x, y2];\n  }\n  function svgPieChart(slices) {\n    let cumulativePercent = 0;\n    return [\n      \'<svg viewBox="-1 -1 2 2" class="pie">\',\n      ...slices.map((slice2) => {\n        const [startX, startY] = getCoordinatesForPercent(cumulativePercent);\n        const [endX, endY] = getCoordinatesForPercent(cumulativePercent += slice2.percent);\n        const largeArcFlag = slice2.percent > 0.5 ? 1 : 0;\n        const pathData = [\n          `M ${startX} ${startY}`,\n          // Move\n          `A 1 1 0 ${largeArcFlag} 1 ${endX} ${endY}`,\n          // Arc\n          "L 0 0"\n          // Line\n        ];\n        return `<path d="${pathData.join(" ")}" fill="${slice2.color}"/>`;\n      }),\n      "</svg>"\n    ].join("\\n");\n  }\n  function getStatCount(stat) {\n    let count3 = 0;\n    for (let type in stat) {\n      stat[type].forEach((occurrences) => count3 += occurrences);\n    }\n    return count3;\n  }\n  function getStatCounts(stat) {\n    let result = /* @__PURE__ */ Object.create(null);\n    for (let type in stat) {\n      result[type] = 0;\n      stat[type].forEach((occurrences) => result[type] += occurrences);\n    }\n    return result;\n  }\n  function renderPropertyDetails(el, data, host) {\n    const { count: count3, map: map2 } = data.stat.object.dictMode || data.stat.object.properties.get(data.name);\n    const total = (data.stat.object.dictMode || data.stat.object).count;\n    const output = {\n      name: data.name,\n      path: data.path,\n      total,\n      count: count3,\n      percent: fixedNum(100 * count3 / total, 1) + "%"\n    };\n    host.view.render(el, [\n      {\n        view: "block",\n        when: "path",\n        className: "path",\n        data: (data2) => host.pathToQuery(data2.path),\n        content: "text:$"\n      },\n      {\n        view: "h1",\n        className: "property",\n        content: [\n          "text:name",\n          {\n            view: "html",\n            when: "count != total",\n            data: `"<span class=\\\\"usage-stat optional\\\\">" + (\n                        "(in <span class=\\\\"num\\\\">" + count + "</span> of <span class=\\\\"num\\\\">" + total + "</span> objects, <span class=\\\\"num\\\\">" + percent + "</span>)"\n                    ) + "</span>"`\n          }\n        ]\n      }\n    ], output);\n    renderTypeStat(el, {\n      map: map2,\n      count: count3\n    }, host);\n  }\n  function renderTypeStat(el, { map: map2, count: count3 }, host) {\n    const typeCounts = getStatCounts(map2);\n    const typeStat = [];\n    const types = typeOrder2.filter((type) => type in map2);\n    Object.entries(typeCounts).sort(([, a], [, b2]) => a - b2).reverse().forEach(([name, val], idx) => {\n      typeStat.push({\n        name: escapeHtml2(name),\n        count: val,\n        percent: val / count3,\n        percent100: fixedNum(100 * val / count3, 1),\n        color: colors[idx]\n      });\n    });\n    host.view.render(el, {\n      view: "block",\n      when: "typeStat.size() > 1",\n      data: "typeStat",\n      className: "pie-stat",\n      content: [\n        {\n          view: "block",\n          content: {\n            view: "html",\n            data: svgPieChart\n          }\n        },\n        {\n          view: "block",\n          content: [\n            \'html:"<span class=\\\\"list-header\\\\">Types usage:</span>"\',\n            {\n              view: "list",\n              item: `html:\n                            "<span class=\\\\"dot\\\\" style=\\\\"--size: 10px; background-color: " + color + "\\\\"></span> " +\n                            "<span class=\\\\"caption\\\\">" + name + "</span>" +\n                            "<span class=\\\\"times\\\\"> \\xD7 " + count + " (" + percent100 + "%)</span>"\n                        `\n            }\n          ]\n        }\n      ]\n    }, typeStat);\n    types.forEach(\n      (name) => renderTypeDetails(el, { name, stat: map2 }, host)\n    );\n  }\n  function renderTypeDetails(el, data, host) {\n    const stat = data.stat[data.name];\n    const total = getStatCount(data.stat);\n    const renderSections = [];\n    let output;\n    switch (data.name) {\n      case "number": {\n        const values = [];\n        let sum2 = 0;\n        let count3 = 0;\n        let duplicated = 0;\n        let min2 = Infinity;\n        let max2 = -Infinity;\n        stat.forEach((occurrences, value) => {\n          values.push({\n            count: occurrences,\n            value\n          });\n          sum2 += value * occurrences;\n          count3 += occurrences;\n          if (occurrences > 1) {\n            duplicated++;\n          }\n          if (value < min2) {\n            min2 = value;\n          }\n          if (value > max2) {\n            max2 = value;\n          }\n        });\n        output = {\n          type: data.name,\n          count: count3,\n          distinct: stat.size,\n          duplicated,\n          min: min2,\n          max: max2,\n          sum: sum2,\n          avg: fixedNum(sum2 / count3, 3),\n          values: values.sort((a, b2) => b2.count - a.count || a.value - b2.value)\n        };\n        if (output.distinct > 1) {\n          renderSections.push({\n            view: "block",\n            className: "overview-stat",\n            content: `html:\n                        "range: (min) <span class=\\\\"num\\\\">" + min + "</span> ... " +\n                        "<span class=\\\\"num\\\\">" + max + "</span> (max), " +\n                        "avg: <span class=\\\\"num\\\\">" + avg + "</span>"\n                    `\n          });\n        }\n        break;\n      }\n      default: {\n        const values = [];\n        let count3 = 0;\n        let duplicated = 0;\n        stat.forEach((occurrences, value) => {\n          values.push({\n            count: occurrences,\n            value\n          });\n          count3 += occurrences;\n          if (occurrences > 1) {\n            duplicated++;\n          }\n        });\n        output = {\n          type: data.name,\n          count: count3,\n          distinct: stat.size,\n          duplicated,\n          values: data.name === "object" || data.name === "array" || data.name === "set" ? values.sort((a, b2) => b2.count - a.count) : values.sort((a, b2) => b2.count - a.count || a.value > b2.value || -(a.value < b2.value))\n        };\n        break;\n      }\n    }\n    if (data.name !== "undefined" && data.name !== "null") {\n      renderSections.unshift({\n        view: "block",\n        className: "overview-stat",\n        content: [\n          \'html:"<span class=\\\\"num\\\\">" + count + "</span> " + (count > 1 ? "values, " : "value")\',\n          {\n            view: "switch",\n            when: "count > 1",\n            content: [\n              { when: "distinct = 1", content: \'text:"a single unique value:"\' },\n              { when: "distinct = count", content: \'text:"all unique, no duplicates"\' },\n              { content: [\n                \'html:"<span class=\\\\"num\\\\">" + distinct + "</span> unique, "\',\n                \'html:duplicated = distinct ? "all occur more than once" : "<span class=\\\\"num\\\\">" + duplicated + "</span> occur more than once"\'\n              ] }\n            ]\n          }\n        ]\n      });\n      if (output.values.length > 1 && output.duplicated && data.name !== "object" && // exclude object and array since we can\'t presentate those values in legend in short at the moment\n      data.name !== "set" && data.name !== "array") {\n        const segments = [];\n        const maxSegmentsCount = output.values.length === 10 ? 10 : Math.min(9, output.values.length);\n        let duplicateCount = 0;\n        for (let i = 0; i < maxSegmentsCount; i++) {\n          const { count: count3, value } = output.values[i];\n          duplicateCount += count3;\n          segments.push({\n            name: escapeHtml2(String(value)),\n            count: count3,\n            percent: count3 / output.count,\n            percent100: fixedNum(100 * count3 / output.count, 1),\n            color: colors[i]\n          });\n        }\n        if (segments.length) {\n          const count3 = output.count - duplicateCount;\n          if (count3 > 0) {\n            segments.push({\n              name: "...",\n              count: count3,\n              percent: count3 / output.count,\n              percent100: fixedNum(100 * count3 / output.count, 1),\n              color: colors[segments.length]\n            });\n          }\n          renderSections.push({\n            view: "block",\n            className: "pie-stat",\n            data: segments,\n            content: [\n              {\n                view: "block",\n                content: {\n                  view: "html",\n                  data: svgPieChart\n                }\n              },\n              {\n                view: "block",\n                content: [\n                  \'html:"<span class=\\\\"list-header\\\\">Dominators:</span>"\',\n                  {\n                    view: "list",\n                    item: `html:\n                                        "<span class=\\\\"dot\\\\" style=\\\\"--size: 10px; background-color: " + color + "\\\\"></span> " +\n                                        "<span class=\\\\"caption\\\\" title=\\\\"" + name + "\\\\">" + name + "</span>" +\n                                        "<span class=\\\\"times\\\\"> \\xD7 " + count + " (" + percent100 + "%)</span>"\n                                    `\n                  }\n                ]\n              }\n            ]\n          });\n        }\n      }\n      if (output.values.length > 1) {\n        if (data.name === "number" || data.name === "string") {\n          renderSections.push({\n            view: "content-filter",\n            name: "filter",\n            content: {\n              view: "menu",\n              data: "values.[no #.filter or value~=#.filter].sort(=>value)",\n              item: [\n                {\n                  view: "block",\n                  className: "caption",\n                  content: "text-match:{ text: value, match: #.filter }"\n                },\n                {\n                  view: "block",\n                  when: "count > 1",\n                  className: "count",\n                  content: \'text:" \\xD7 " + count\'\n                }\n              ]\n            }\n          });\n        }\n      } else {\n        if (data.name === "number" || data.name === "string" || data.name === "boolean") {\n          renderSections.push({\n            view: "struct",\n            data: "values.pick().value"\n          });\n        }\n      }\n      if (data.name === "object") {\n        renderSections.push({\n          view: "list",\n          className: "struct-list",\n          data: "values",\n          item: [\n            "struct:value",\n            {\n              view: "block",\n              when: "count > 1",\n              className: "count",\n              content: \'text:" \\xD7 " + count\'\n            }\n          ]\n        });\n      }\n      if ((data.name === "array" || data.name === "set") && Object.keys(stat.map).length) {\n        renderSections.push({\n          view: "block",\n          className: data.name === "array" ? "array-types" : "set-types",\n          content: (el2) => renderTypeStat(el2, stat, host)\n        });\n      }\n    }\n    host.view.render(el, [\n      {\n        view: "block",\n        when: "path",\n        className: "path",\n        data: (data2) => host.pathToQuery(data2.path),\n        content: "text"\n      },\n      {\n        view: "h1",\n        className: "type",\n        content: [\n          "text:name",\n          `html:"<span class=\\\\"usage-stat\\\\">" + (\n                    count = total\n                        ? "only this type is used"\n                        : "used in <span class=\\\\"num\\\\">" + count + "</span> of <span class=\\\\"num\\\\">" + total + "</span> cases (<span class=\\\\"num\\\\">" + percent + "</span>)"\n                ) + "</span>"`\n        ]\n      },\n      ...renderSections\n    ], {\n      ...output,\n      name: data.name,\n      path: data.path,\n      total,\n      percent: fixedNum(100 * output.count / total, 1) + "%"\n    }, {});\n  }\n  var init_render_details = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/signature/render-details.js"() {\n      init_html();\n      init_const2();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/signature/signature.usage.js\n  var signature_usage_default;\n  var init_signature_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/signature/signature.usage.js"() {\n      signature_usage_default = {\n        beforeDemo: [\'md:"The `signature` view is used to output a type definition for current data using TypeScript like style:"\'],\n        demo: {\n          view: "signature",\n          expanded: true\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/signature/index.js\n  function signature_default(host) {\n    const elementToData = /* @__PURE__ */ new WeakMap();\n    const clickHandler = ({ target }) => {\n      let action = "expand";\n      let activeEl = target.closest(`\n            .view-signature .expand,\n            .view-signature [data-action]\n        `);\n      if (!activeEl) {\n        return;\n      }\n      if (activeEl.dataset.action) {\n        action = activeEl.dataset.action;\n        activeEl = activeEl.parentNode;\n      }\n      const data = elementToData.get(activeEl);\n      if (data) {\n        const { path, map: map2, offset } = data;\n        const fragment = document.createDocumentFragment();\n        switch (action) {\n          case "sort-keys":\n            map2.sortKeys = !map2.sortKeys;\n            break;\n          case "dict-mode":\n            if (map2.dictMode) {\n              map2.dictMode = null;\n            } else {\n              const dictMode = map2.dictMode = {\n                keys: /* @__PURE__ */ new Set(),\n                count: 0,\n                map: /* @__PURE__ */ Object.create(null)\n              };\n              map2.forEach((_, value) => {\n                for (const key2 in value) {\n                  if (hasOwnProperty.call(value, key2)) {\n                    dictMode.keys.add(key2);\n                    dictMode.count++;\n                    collectStat(value[key2], 1, dictMode.map);\n                  }\n                }\n              });\n            }\n            break;\n          default:\n            if (map2.properties === null) {\n              map2.properties = /* @__PURE__ */ new Map();\n              map2.forEach((_, value) => collectObjectMap(value, 1, map2));\n            } else {\n              map2.properties = null;\n            }\n        }\n        renderStat(fragment, { object: map2 }, elementToData, path, offset);\n        activeEl.replaceWith(fragment);\n      }\n    };\n    host.addHostElEventListener("click", clickHandler, false);\n    new host.view.Popup({\n      className: "signature-details",\n      hoverPin: "trigger-click",\n      hoverTriggers: `\n            .view-signature .property,\n            .view-signature .type\n        `,\n      render: function(popupEl, triggerEl) {\n        const data = elementToData.get(triggerEl);\n        switch (data.type) {\n          case "property":\n            return renderPropertyDetails(popupEl, data, host);\n          case "type":\n            return renderTypeDetails(popupEl, data, host);\n        }\n      }\n    });\n    host.view.define("signature", function(el, config, data) {\n      const { expanded, path } = config;\n      const stat = collectStat(data, expanded);\n      const normPath = Array.isArray(path) ? path : void 0;\n      renderStat(el, stat, elementToData, normPath);\n    }, {\n      usage: signature_usage_default\n    });\n  }\n  var init_signature = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/signature/index.js"() {\n      init_collect_stat();\n      init_render_stat();\n      init_render_details();\n      init_signature_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/click-handler.js\n  var createClickHandler;\n  var init_click_handler = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/click-handler.js"() {\n      createClickHandler = (expandValue, collapseValue, scheduleApplyAnnotations, renderTable, structViewRoots, valueActionsPopup, signaturePopup) => ({ target }) => {\n        let action = "expand";\n        let cursor = target.closest(`\n        .view-struct.struct-expand,\n        .view-struct .struct-expand-value,\n        .view-struct .struct-action-button\n    `);\n        if (!cursor) {\n          return;\n        }\n        if (cursor.dataset.action) {\n          action = cursor.dataset.action;\n        }\n        switch (action) {\n          case "expand":\n            if (cursor.classList.contains("struct-expand")) {\n              cursor = cursor.lastChild;\n            }\n            expandValue(cursor, 0);\n            scheduleApplyAnnotations();\n            cursor.parentNode.classList.add("struct-expanded-value");\n            if (structViewRoots.has(cursor.parentNode)) {\n              cursor.parentNode.classList.remove("struct-expand");\n            }\n            break;\n          case "collapse":\n            cursor = cursor.parentNode;\n            collapseValue(cursor);\n            scheduleApplyAnnotations();\n            cursor.parentNode.classList.remove("struct-expanded-value");\n            cursor.classList.remove("view-as-table");\n            if (structViewRoots.has(cursor.parentNode)) {\n              cursor.parentNode.classList.add("struct-expand");\n            }\n            break;\n          case "show-signature":\n            signaturePopup.show(cursor);\n            break;\n          case "value-actions":\n            valueActionsPopup.show(cursor);\n            break;\n          case "toggle-sort-keys":\n            expandValue(cursor.parentNode, 0, cursor.parentNode.classList.toggle("sort-keys"));\n            scheduleApplyAnnotations();\n            break;\n          case "toggle-string-mode":\n            cursor = cursor.parentNode;\n            const stringTextNode = cursor.querySelector(".string-text").firstChild;\n            stringTextNode.nodeValue = cursor.classList.toggle("string-value-as-text") ? JSON.parse(`"${stringTextNode.nodeValue}"`) : JSON.stringify(stringTextNode.nodeValue).slice(1, -1);\n            break;\n          case "toggle-view-as-table":\n            cursor = cursor.parentNode;\n            const asTable = cursor.classList.toggle("view-as-table");\n            if (asTable) {\n              renderTable(cursor);\n            } else {\n              const tableEl = cursor.querySelector(":scope > .view-table");\n              if (tableEl) {\n                tableEl.remove();\n              }\n            }\n            break;\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/json-ext/dist/version.js\n  var require_version = __commonJS({\n    "node_modules/@discoveryjs/json-ext/dist/version.js"(exports, module) {\n      module.exports = "0.5.7";\n    }\n  });\n\n  // node_modules/@discoveryjs/json-ext/src/stringify-info.js\n  var require_stringify_info = __commonJS({\n    "node_modules/@discoveryjs/json-ext/src/stringify-info.js"(exports, module) {\n      var {\n        normalizeReplacer,\n        normalizeSpace,\n        replaceValue,\n        getTypeNative,\n        getTypeAsync,\n        isLeadingSurrogate,\n        isTrailingSurrogate,\n        escapableCharCodeSubstitution,\n        type: {\n          PRIMITIVE,\n          OBJECT,\n          ARRAY,\n          PROMISE,\n          STRING_STREAM,\n          OBJECT_STREAM\n        }\n      } = require_utils();\n      var charLength2048 = Array.from({ length: 2048 }).map((_, code) => {\n        if (escapableCharCodeSubstitution.hasOwnProperty(code)) {\n          return 2;\n        }\n        if (code < 32) {\n          return 6;\n        }\n        return code < 128 ? 1 : 2;\n      });\n      function stringLength(str) {\n        let len = 0;\n        let prevLeadingSurrogate = false;\n        for (let i = 0; i < str.length; i++) {\n          const code = str.charCodeAt(i);\n          if (code < 2048) {\n            len += charLength2048[code];\n          } else if (isLeadingSurrogate(code)) {\n            len += 6;\n            prevLeadingSurrogate = true;\n            continue;\n          } else if (isTrailingSurrogate(code)) {\n            len = prevLeadingSurrogate ? len - 2 : len + 6;\n          } else {\n            len += 3;\n          }\n          prevLeadingSurrogate = false;\n        }\n        return len + 2;\n      }\n      function primitiveLength(value) {\n        switch (typeof value) {\n          case "string":\n            return stringLength(value);\n          case "number":\n            return Number.isFinite(value) ? String(value).length : 4;\n          case "boolean":\n            return value ? 4 : 5;\n          case "undefined":\n          case "object":\n            return 4;\n          default:\n            return 0;\n        }\n      }\n      function spaceLength(space) {\n        space = normalizeSpace(space);\n        return typeof space === "string" ? space.length : 0;\n      }\n      module.exports = function jsonStringifyInfo2(value, replacer, space, options2) {\n        function walk37(holder, key2, value2) {\n          if (stop) {\n            return;\n          }\n          value2 = replaceValue(holder, key2, value2, replacer);\n          let type = getType(value2);\n          if (type !== PRIMITIVE && stack.has(value2)) {\n            circular.add(value2);\n            length += 4;\n            if (!options2.continueOnCircular) {\n              stop = true;\n            }\n            return;\n          }\n          switch (type) {\n            case PRIMITIVE:\n              if (value2 !== void 0 || Array.isArray(holder)) {\n                length += primitiveLength(value2);\n              } else if (holder === root) {\n                length += 9;\n              }\n              break;\n            case OBJECT: {\n              if (visited.has(value2)) {\n                duplicate.add(value2);\n                length += visited.get(value2);\n                break;\n              }\n              const valueLength = length;\n              let entries2 = 0;\n              length += 2;\n              stack.add(value2);\n              for (const key3 in value2) {\n                if (hasOwnProperty.call(value2, key3) && (allowlist === null || allowlist.has(key3))) {\n                  const prevLength = length;\n                  walk37(value2, key3, value2[key3]);\n                  if (prevLength !== length) {\n                    length += stringLength(key3) + 1;\n                    entries2++;\n                  }\n                }\n              }\n              if (entries2 > 1) {\n                length += entries2 - 1;\n              }\n              stack.delete(value2);\n              if (space > 0 && entries2 > 0) {\n                length += (1 + (stack.size + 1) * space + 1) * entries2;\n                length += 1 + stack.size * space;\n              }\n              visited.set(value2, length - valueLength);\n              break;\n            }\n            case ARRAY: {\n              if (visited.has(value2)) {\n                duplicate.add(value2);\n                length += visited.get(value2);\n                break;\n              }\n              const valueLength = length;\n              length += 2;\n              stack.add(value2);\n              for (let i = 0; i < value2.length; i++) {\n                walk37(value2, i, value2[i]);\n              }\n              if (value2.length > 1) {\n                length += value2.length - 1;\n              }\n              stack.delete(value2);\n              if (space > 0 && value2.length > 0) {\n                length += (1 + (stack.size + 1) * space) * value2.length;\n                length += 1 + stack.size * space;\n              }\n              visited.set(value2, length - valueLength);\n              break;\n            }\n            case PROMISE:\n            case STRING_STREAM:\n              async.add(value2);\n              break;\n            case OBJECT_STREAM:\n              length += 2;\n              async.add(value2);\n              break;\n          }\n        }\n        let allowlist = null;\n        replacer = normalizeReplacer(replacer);\n        if (Array.isArray(replacer)) {\n          allowlist = new Set(replacer);\n          replacer = null;\n        }\n        space = spaceLength(space);\n        options2 = options2 || {};\n        const visited = /* @__PURE__ */ new Map();\n        const stack = /* @__PURE__ */ new Set();\n        const duplicate = /* @__PURE__ */ new Set();\n        const circular = /* @__PURE__ */ new Set();\n        const async = /* @__PURE__ */ new Set();\n        const getType = options2.async ? getTypeAsync : getTypeNative;\n        const root = { "": value };\n        let stop = false;\n        let length = 0;\n        walk37(root, "", value);\n        return {\n          minLength: isNaN(length) ? Infinity : length,\n          circular: [...circular],\n          duplicate: [...duplicate],\n          async: [...async]\n        };\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/json-ext/src/stringify-stream-browser.js\n  var require_stringify_stream_browser = __commonJS({\n    "node_modules/@discoveryjs/json-ext/src/stringify-stream-browser.js"(exports, module) {\n      module.exports = () => {\n        throw new Error("Method is not supported");\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/json-ext/src/index.js\n  var require_src2 = __commonJS({\n    "node_modules/@discoveryjs/json-ext/src/index.js"(exports, module) {\n      module.exports = {\n        version: require_version(),\n        stringifyInfo: require_stringify_info(),\n        stringifyStream: require_stringify_stream_browser(),\n        parseChunked: require_parse_chunked()\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/json.js\n  var json_exports = {};\n  __export(json_exports, {\n    jsonStringifyAsJavaScript: () => jsonStringifyAsJavaScript,\n    jsonStringifyInfo: () => jsonStringifyInfo\n  });\n  function prettyFn(fn, ws, property) {\n    const src = String(fn);\n    const [prefix, name] = src.match(/^(?:\\S+\\s+)?(\\S+)\\(/) || [];\n    if (prefix !== "function" && prefix !== "function*" && name === property.trim().slice(0, -1)) {\n      property = "";\n    }\n    if (src.indexOf("\\n") === -1) {\n      return property + src;\n    }\n    const lines = src.split(/\\n/);\n    const minOffset = lines[lines.length - 1].match(/^\\s*/)[0].length;\n    const stripOffset = new RegExp("^\\\\s{0," + minOffset + "}");\n    return property + lines.map((line, idx) => idx && line.length ? line.replace(stripOffset, ws) : line).join("\\n");\n  }\n  function restoreValue(value, ws, property) {\n    if (typeof value === "function") {\n      return prettyFn(value, ws, property);\n    }\n    if (value instanceof Date) {\n      return `${property}new Date("${value.toISOString()}")`;\n    }\n    return property + String(value);\n  }\n  function jsonStringifyAsJavaScript(value, replacer, space = 4) {\n    const specials = [];\n    const jsReplacer = function(key2, value2) {\n      if (typeof value2 === "string" && toString3.call(this[key2]) === "[object Date]") {\n        value2 = this[key2];\n      }\n      if (value2 !== null && specialValueTypes.has(toString3.call(value2))) {\n        specials.push(value2);\n        return "{{{__placeholder__}}}";\n      }\n      return value2;\n    };\n    return String(JSON.stringify(value, replacer || jsReplacer, space)).replace(\n      /"((?:\\\\.|[^"])*)"(:?)/g,\n      (_, content, colon) => colon && /^[a-z$_][a-z$_\\d]*$/i.test(content) ? content + colon : `\'${content.replace(/\\\\"/g, \'"\').replace(/\'/g, "\\\\\'")}\'` + colon\n    ).replace(\n      /(^|\\n)([ \\t]*)(.*?)([a-zA-Z$_][a-zA-Z0-9$_]+:\\s*)?\'{{{__placeholder__}}}\'/g,\n      (_, rn, ws, any, property) => rn + ws + any + restoreValue(specials.shift(), ws, property)\n    );\n  }\n  var import_json_ext, jsonStringifyInfo, toString3, specialValueTypes;\n  var init_json2 = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/json.js"() {\n      import_json_ext = __toESM(require_src2(), 1);\n      ({\n        stringifyInfo: jsonStringifyInfo\n      } = import_json_ext.default);\n      ({ toString: toString3 } = Object.prototype);\n      specialValueTypes = /* @__PURE__ */ new Set([\n        "[object Function]",\n        "[object RegExp]",\n        "[object Date]"\n      ]);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/popup-value-actions.js\n  function formatSize(size) {\n    if (!size) {\n      return "";\n    }\n    return ", " + numDelim2(size) + " bytes";\n  }\n  function createValueActionsPopup(host, elementData, buildPathForElement) {\n    return new host.view.Popup({\n      className: "view-struct-actions-popup",\n      render: (popupEl, triggerEl, hide) => {\n        const el = triggerEl.parentNode;\n        const data = elementData.get(el);\n        let actions = [];\n        if (typeof data === "string") {\n          actions = [\n            {\n              text: "Copy as quoted string",\n              action: () => copyText(JSON.stringify(data))\n            },\n            {\n              text: "Copy as unquoted string",\n              action: () => copyText(JSON.stringify(data).slice(1, -1))\n            },\n            {\n              text: "Copy a value (unescaped)",\n              action: () => copyText(data)\n            }\n          ];\n        } else {\n          const path = host.pathToQuery(buildPathForElement(el));\n          const maxAllowedSize = 1024 * 1024 * 1024;\n          let jsonFormattedStringifyError = false;\n          let jsonCompactStringifyError = false;\n          let compactSize = 0;\n          let formattedSize = 0;\n          try {\n            const { minLength, circular } = jsonStringifyInfo(data);\n            compactSize = minLength;\n            if (circular.length) {\n              jsonCompactStringifyError = "Converting circular structure to JSON";\n            } else if (compactSize > maxAllowedSize) {\n              jsonCompactStringifyError = "Resulting JSON is over 1 Gb";\n            } else {\n              formattedSize = jsonStringifyInfo(data, null, 4).minLength;\n              if (formattedSize > maxAllowedSize) {\n                jsonFormattedStringifyError = "Resulting JSON is over 1 Gb";\n              }\n            }\n          } catch (e) {\n            jsonCompactStringifyError = /Maximum call stack size|too much recursion/i.test(e.message) ? "Too much nested structure" : e.message;\n          }\n          if (jsonCompactStringifyError) {\n            jsonCompactStringifyError = "Can\'t be copied: " + jsonCompactStringifyError;\n            if (!jsonFormattedStringifyError) {\n              jsonFormattedStringifyError = jsonCompactStringifyError;\n            }\n          }\n          if (path) {\n            actions.push({\n              text: "Copy path:",\n              notes: escapeHtml2(path),\n              action: () => copyText(path)\n            });\n          }\n          actions.push({\n            text: "Copy as JSON",\n            notes: `(formatted${formatSize(formattedSize)})`,\n            error: jsonFormattedStringifyError,\n            disabled: Boolean(jsonFormattedStringifyError),\n            action: () => copyText(JSON.stringify(data, null, 4))\n          });\n          actions.push({\n            text: "Copy as JSON",\n            notes: `(compact${jsonCompactStringifyError ? "" : formatSize(compactSize)})`,\n            error: jsonCompactStringifyError,\n            disabled: Boolean(jsonCompactStringifyError),\n            action: () => copyText(JSON.stringify(data))\n          });\n        }\n        host.view.render(popupEl, {\n          view: "menu",\n          onClick(item) {\n            hide();\n            item.action();\n          },\n          item: [\n            "html:text",\n            {\n              view: "block",\n              when: "notes",\n              className: "notes",\n              content: "html:notes"\n            },\n            {\n              view: "block",\n              when: "error",\n              className: "error",\n              content: "text:error"\n            }\n          ]\n        }, actions);\n      }\n    });\n  }\n  var init_popup_value_actions = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/popup-value-actions.js"() {\n      init_html();\n      init_json2();\n      init_copy_text();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/value-to-html.js\n  function token(type, str) {\n    return `<span class="${type}">${str}</span>`;\n  }\n  function more(num) {\n    return token("more", `\\u2026${numDelim2(num)} more\\u2026`);\n  }\n  function value2html(value, compact, options2) {\n    switch (typeof value) {\n      case "boolean":\n      case "undefined":\n        return token("keyword", value);\n      case "number":\n      case "bigint":\n        return token("number", numDelim2(value));\n      case "symbol":\n        return token("symbol", String(value));\n      case "function":\n        return "\\u0192n";\n      case "string": {\n        const maxLength = compact ? options2.maxCompactStringLength : options2.maxStringLength;\n        const shortString = value.length > maxLength + options2.allowedExcessStringLength;\n        const stringContent = shortString ? escapeHtml2(JSON.stringify(value.slice(0, maxLength)).slice(1, -1)) : escapeHtml2(JSON.stringify(value).slice(1, -1));\n        const stringRest = shortString ? more(value.length - maxLength) : "";\n        return token(\n          "string",\n          !compact && (value[0] === "h" || value[0] === "/") && urlRx.test(value) ? `"<a href="${escapeHtml2(value)}" target="_blank">${stringContent}</a>${stringRest}"` : `"${stringContent}${stringRest}"`\n        );\n      }\n      case "object": {\n        if (value === null) {\n          return token("keyword", "null");\n        }\n        if (isArray(value)) {\n          const limitCollapsed = options2.limitCollapsed === false || options2.limitCollapsed > value.length ? value.length : options2.limitCollapsed;\n          const content2 = Array.from({ length: limitCollapsed }, (_, index) => value2html(value[index], true, options2));\n          if (value.length > limitCollapsed) {\n            content2.push(`${more(value.length - limitCollapsed)} `);\n          }\n          return `[${content2.join(", ")}]`;\n        }\n        switch (toString4.call(value)) {\n          case "[object Set]": {\n            const limitCollapsed = options2.limitCollapsed === false || options2.limitCollapsed > value.size ? value.size : options2.limitCollapsed;\n            const iterator = value.values();\n            const content2 = Array.from({ length: limitCollapsed }, () => value2html(iterator.next().value, true, options2));\n            if (value.size > limitCollapsed) {\n              content2.push(`${more(value.size - limitCollapsed)} `);\n            }\n            return `[${content2.join(", ")}]`;\n          }\n          case "[object Date]":\n            return token("date", value);\n          case "[object RegExp]":\n            return token("regexp", value);\n        }\n        if (compact && options2.limitCompactObjectEntries === 0) {\n          for (let key2 in value) {\n            if (hasOwnProperty.call(value, key2)) {\n              return "{\\u2026}";\n            }\n          }\n          return "{}";\n        }\n        const limitObjectEntries = compact ? options2.limitCompactObjectEntries === false ? Infinity : options2.limitCompactObjectEntries : options2.limitCollapsed === false ? Infinity : options2.limitCollapsed;\n        const content = [];\n        let count3 = 0;\n        for (let key2 in value) {\n          if (hasOwnProperty.call(value, key2)) {\n            if (count3 < limitObjectEntries) {\n              const property = escapeHtml2(\n                key2.length > options2.maxCompactPropertyLength ? key2.slice(0, options2.maxCompactPropertyLength) + "\\u2026" : key2\n              );\n              content.push(`${token("property", property)}: ${value2html(value[key2], true, options2)}`);\n            }\n            count3++;\n          }\n        }\n        if (count3 > limitObjectEntries) {\n          content.push(more(count3 - limitObjectEntries));\n        }\n        return content.length ? `{ ${content.join(", ")} }` : "{}";\n      }\n      default:\n        return `unknown type "${typeof value}"`;\n    }\n  }\n  var urlRx, toString4;\n  var init_value_to_html = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/value-to-html.js"() {\n      init_html();\n      init_is_type();\n      urlRx = /^(?:https?:)?\\/\\/(?:[a-z0-9\\-]+(?:\\.[a-z0-9\\-]+)+|\\d+(?:\\.\\d+){3})(?:\\:\\d+)?(?:\\/\\S*?)?$/i;\n      toString4 = Object.prototype.toString;\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/render-annotations.js\n  function renderAnnotations(annotations) {\n    const renderUntil = Date.now() + 8;\n    let i = 0;\n    for (; i < annotations.length; i++) {\n      if (Date.now() > renderUntil) {\n        break;\n      }\n      const { el, config, renderer, data, context } = annotations[i];\n      const {\n        place = "after",\n        className,\n        text = typeof config !== "object" ? String(config) : "",\n        icon,\n        href,\n        external,\n        tooltip\n      } = config;\n      const style = styles2.includes(config.style) ? config.style : place === "before" ? "none" : "default";\n      const hasText = text !== "";\n      const elClassName = [\n        "value-annotation",\n        "style-" + style,\n        place === "before" ? "before" : "after",\n        hasText ? "has-text" : "",\n        className || ""\n      ].join(" ");\n      const annotationEl = createElement(href ? "a" : "span", {\n        class: elClassName,\n        href: typeof href === "string" ? href : void 0,\n        target: external ? "_blank" : void 0\n      });\n      if (hasText) {\n        if (/\\d{4}/.test(text)) {\n          annotationEl.innerHTML = numDelim2(text);\n        } else {\n          annotationEl.append(text);\n        }\n      }\n      if (icon) {\n        annotationEl.classList.add("icon");\n        if (/^[a-z_$][a-z0-9_$-]*$/i.test(icon)) {\n          annotationEl.classList.add("icon-" + icon);\n        } else {\n          annotationEl.style.setProperty("--annotation-image", `url("${icon}")`);\n        }\n      }\n      if (tooltip) {\n        renderer.tooltip(annotationEl, tooltip, data, { ...context, config });\n      }\n      if (place === "before") {\n        el.before(annotationEl);\n      } else {\n        const parentEl = el.parentNode;\n        if (!el.annotationsEl) {\n          el.annotationsEl = createElement("span", "value-annotations");\n          if (parentEl.classList.contains("struct-expanded-value")) {\n            el.querySelector(":scope > .value-size, :scope > .string-length").after(el.annotationsEl);\n          } else {\n            parentEl.append(el.annotationsEl);\n          }\n        }\n        el.annotationsEl.append(annotationEl);\n      }\n    }\n    annotations.splice(0, i);\n  }\n  var styles2;\n  var init_render_annotations = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/render-annotations.js"() {\n      init_dom();\n      init_html();\n      styles2 = ["none", "default", "badge"];\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/struct.usage.js\n  var defaultDemoData, struct_usage_default;\n  var init_struct_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/struct.usage.js"() {\n      defaultDemoData = {\n        level_1: {\n          level_2_1: {\n            level_3_1: {\n              level_4_1: {}\n            },\n            level_3_2: 2,\n            level_3_3: 3,\n            level_3_4: 4,\n            level_3_5: 5,\n            level_3_6: 6\n          },\n          level_2_2: [{ foo: 1, bar: 2 }, { foo: 3 }],\n          level_2_3: 3,\n          level_2_4: 4,\n          level_2_5: 5,\n          level_2_6: 6\n        },\n        level_1_2: 2,\n        level_1_3: 3,\n        level_1_4: 4,\n        level_1_5: 5,\n        level_1_6: 6,\n        level_1_7: 7\n      };\n      struct_usage_default = {\n        beforeDemo: [\'md:"View to display the structure of any value. This is the simplest yet powerful way to enable data exploration."\'],\n        demo: {\n          view: "struct",\n          data: {\n            foo: "bar",\n            baz: [1, 2, 3]\n          }\n        },\n        examples: [\n          {\n            title: "Default expanded depth",\n            highlightProps: ["expanded"],\n            beforeDemo: [\'md:"By default `struct` view is collapsed in one line. The `expanded` option is using to specify an initial expanded depth. A value for the option can be a boolean (`false` \\u2192 `0`, `true` \\u2192 `1`) or a positive number."\'],\n            demoData: defaultDemoData,\n            demo: [\n              \'badge:"Default (expanded option is not used)"\',\n              {\n                view: "struct"\n              },\n              \'badge:"expanded = true"\',\n              {\n                view: "struct",\n                expanded: true\n              },\n              \'badge:"expanded = 2"\',\n              {\n                view: "struct",\n                expanded: 2\n              }\n            ]\n          },\n          {\n            title: "Annotations",\n            highlightProps: ["annotations"],\n            beforeDemo: [{\n              view: "md",\n              source: [\n                "Clarity of data can be improved by adding annotations. An annotation is special marker before or after a value which displaying for expanded objects and arrays only.",\n                "Any number of annotations can be applied to a single value.",\n                "",\n                "Annotations are adding with `annotations` option which should contain an array of strings (jora queries) and functions to compute an annotation config. An annotation config is an object with following fields:",\n                "```ts",\n                "type AnnotationConfig = {",\n                \'   place?: "before" | "after"; // the placement of an annotation, "after" is by default\',\n                \'   style?: "none" | "badge" | "default"; // appereance of annotation, "default" is by default\',\n                "   className?: string;         // a class to add to an annotation element",\n                "   text?: any;                 // text content of an annotation element",\n                "   icon?: string;              // name of icon or url to an image",\n                "   href?: string;              // annotation is a link and that\'s an URL",\n                "   external?: boolean;         // open a link in new tab, make sence when `href` is specified only",\n                "   tooltip?: TooltipConfig;    // configuration for a tooltip, the same as for any view",\n                "}",\n                "```",\n                "",\n                \'An annotation is not displayed (not rendered) when computed annotation config is a falsy value. Any other value (truthy, but not an object) is used as value for `text` option, i.e. `"example"` is the same as `{ text: "example" }`.\',\n                "",\n                "In addition to a string or function, an object can be used as an element of `annotations` array",\n                "* `query` \\u2013 a string (jora query) or a function to compute an annotation config",\n                "* `debug` (optional) - when truthy a debug information is output to the console; when value is a string, it\'s used in debug message"\n              ]\n            }],\n            demoData: {\n              items: [\n                { id: 1, value: "example" },\n                { id: 2, value: "bar" },\n                { id: 3, value: "baz" }\n              ],\n              "annotation styles": [\n                "none",\n                "default",\n                "badge"\n              ]\n            },\n            demo: {\n              view: "struct",\n              expanded: 3,\n              annotations: [\n                \'#.key = "items" ? { place: "before", style: "badge", text: "view as table", tooltip: "table" } : null\',\n                `$ ~= /az/ and "Value has \'az\' substring!"`,\n                \'$ in ["none", "default", "badge"] and { style: $, place: "before", text: $ + " before" }\',\n                \'$ in ["none", "default", "badge"] and { style: $, text: $ + " after" }\'\n              ]\n            }\n          },\n          {\n            title: "Limit number of array elements and object entries",\n            beforeDemo: {\n              view: "md",\n              source: [\n                "The following options define the maximum number of elements in array or entries in object:",\n                "* `limit` (default: `50`) \\u2013 max number of elements/entries for expanded array/object",\n                "* `limitCollapsed` (default: `4`) \\u2013 max of elements/entries for collapsed array/object",\n                "* `limitCompactObjectEntries` (default: `0`) \\u2013 max number of entries in a object which appears in a collapsed array or object",\n                "",\n                "> Use `false` for any of these options to disable a limitation"\n              ]\n            },\n            highlightProps: [\n              "limit",\n              "limitCollapsed",\n              "limitCompactObjectEntries"\n            ],\n            demoData: defaultDemoData,\n            demo: {\n              view: "struct",\n              limit: 4,\n              limitCollapsed: 1,\n              expanded: 2\n            }\n          },\n          {\n            title: "Maximum length for strings",\n            beforeDemo: {\n              view: "md",\n              source: [\n                "The following options define the maximum string length in various cases:",\n                "* `maxStringLength` (default: `150`) \\u2013 max string length when a host value is expanded",\n                "* `maxCompactStringLength` (default: `40`) \\u2013 max of string length when a host value is collapsed",\n                \'* `allowedExcessStringLength` (default: `10`) \\u2013 allowed excess in length before a string will be cut and \\\\"N more\\\\" label will be added\',\n                "* `maxPropertyLength` (default: `Infinity`) \\u2013 max of property name length",\n                "* `maxCompactPropertyLength` (default: `35`) \\u2013 max of property name length in collapsed objects",\n                "",\n                "> Expand and collapse `level2` branch to see difference in a value presentation"\n              ]\n            },\n            highlightProps: [\n              "maxStringLength",\n              "maxCompactStringLength",\n              "allowedExcessStringLength",\n              "maxPropertyLength",\n              "maxCompactPropertyLength"\n            ],\n            demo: {\n              view: "struct",\n              maxStringLength: 30,\n              maxCompactStringLength: 10,\n              allowedExcessStringLength: 5,\n              maxPropertyLength: 30,\n              maxCompactPropertyLength: 15,\n              expanded: 1\n            },\n            demoData: {\n              stringsInExpandedObject: "Quite a long string value Quite a long string value",\n              string_34_chars: "String with 34 chars length demo x",\n              string_35_chars: "String with 35 chars length demo xx",\n              string_36_chars: "String with 36 chars length demo xxx",\n              very_very_very_very_very_very_very_very_very_very_long_property_name: "a property name should be truncated due to settings, but will not be by default",\n              level2: {\n                stringsInCollapsedObject: "Quite a long string value Quite a long string value",\n                string_14_chars: "Short string x",\n                string_15_chars: "Short string xx",\n                string_16_chars: "Short string xxx"\n              }\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/el-proto.js\n  var valueButtons, stringValueProto, arrayValueProto, objectValueProto, entryProtoEl, valueProtoEl, objectKeyProtoEl;\n  var init_el_proto = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/el-proto.js"() {\n      init_dom();\n      valueButtons = {\n        get collapse() {\n          return createElement("span", {\n            class: "struct-action-button struct-collapse-value",\n            "data-action": "collapse"\n          });\n        },\n        get signature() {\n          return createElement("span", {\n            class: "struct-action-button show-signature",\n            "data-action": "show-signature"\n          });\n        },\n        get actions() {\n          return createElement("span", {\n            class: "struct-action-button",\n            title: "Value actions",\n            "data-action": "value-actions"\n          });\n        },\n        get stringMode() {\n          return createElement("span", {\n            class: "struct-action-button",\n            title: "Toggle string show mode",\n            "data-action": "toggle-string-mode"\n          });\n        },\n        get viewAsTable() {\n          return createElement("span", {\n            class: "struct-action-button",\n            title: "Toggle view as table",\n            "data-action": "toggle-view-as-table"\n          });\n        },\n        get sortKeys() {\n          return createElement("span", {\n            class: "struct-action-button",\n            title: "Toggle key sorting",\n            "data-action": "toggle-sort-keys"\n          });\n        }\n      };\n      stringValueProto = createFragment(\n        \'"\',\n        valueButtons.collapse,\n        valueButtons.actions,\n        valueButtons.stringMode,\n        createElement("span", "string-length"),\n        createElement("span", "string-text-wrapper", [\n          createElement("span", "string-text")\n        ]),\n        \'"\'\n      );\n      arrayValueProto = createFragment(\n        "[",\n        valueButtons.collapse,\n        valueButtons.signature,\n        valueButtons.actions,\n        valueButtons.viewAsTable,\n        createElement("span", "value-size"),\n        "]"\n      );\n      objectValueProto = createFragment(\n        "{",\n        valueButtons.collapse,\n        valueButtons.signature,\n        valueButtons.actions,\n        valueButtons.viewAsTable,\n        valueButtons.sortKeys,\n        createElement("span", "value-size"),\n        "}"\n      );\n      entryProtoEl = createElement("div", "entry-line");\n      valueProtoEl = createElement("span", "value");\n      objectKeyProtoEl = createElement("span", "label", [\n        "\\xA0\\xA0\\xA0\\xA0",\n        createElement("span", "property"),\n        ":\\xA0"\n      ]);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/poup-signature.js\n  function createSignaturePopup(host, elementData, buildPathForElement) {\n    return new host.view.Popup({\n      className: "view-struct-signature-popup",\n      hoverPin: "popup-hover",\n      hoverTriggers: ".view-struct .show-signature",\n      showDelay: 50,\n      render: function(popupEl, triggerEl) {\n        const el = triggerEl.parentNode;\n        const data = elementData.get(el);\n        popupEl.classList.add("computing");\n        setTimeout(() => {\n          host.view.render(popupEl, {\n            view: "signature",\n            expanded: 2,\n            path: buildPathForElement(el)\n          }, data).then(() => popupEl.classList.remove("computing"));\n        }, 16);\n      }\n    });\n  }\n  var init_poup_signature = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/poup-signature.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/struct/index.js\n  function intOption(value, defaultValue) {\n    if (typeof value === "number" && isFinite(value) && value >= 1) {\n      return parseInt(value, 10);\n    }\n    return defaultValue;\n  }\n  function isValueExpandable(value, options2) {\n    if (typeof value === "string") {\n      return value.length > options2.maxStringLength || /[\\r\\n\\f\\t]/.test(value);\n    }\n    if (isArray(value)) {\n      return value.length > 0;\n    }\n    if (typeof value === "object" && value !== null) {\n      switch (toString5.call(value)) {\n        case "[object Set]": {\n          return value.size > 0;\n        }\n        case "[object Object]": {\n          for (const key2 in value) {\n            if (hasOwnProperty4.call(value, key2)) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n  function appendText(el, text) {\n    el.appendChild(document.createTextNode(text));\n  }\n  function renderValueSize(el, size, unit) {\n    if (size > 1) {\n      el.lastElementChild.innerHTML = numDelim2(size) + " " + unit;\n    }\n  }\n  function renderSorting(el, entries2, sort) {\n    const sorted = entries2.length < 2 || entries2.every(([key2], idx) => idx === 0 || key2 > entries2[idx - 1][0]);\n    if (sorted) {\n      el.querySelector(\'[data-action="toggle-sort-keys"]\').remove();\n    } else if (sort) {\n      entries2.sort(([a], [b2]) => a < b2 ? -1 : a > b2 ? 1 : 0);\n    }\n  }\n  function renderObjectKey(container, name, maxLength) {\n    const objectKeyEl = objectKeyProtoEl.cloneNode(true);\n    const fittedToMaxLength = name.length > maxLength ? name.slice(0, maxLength) + "\\u2026" : name;\n    appendText(objectKeyEl.firstElementChild, fittedToMaxLength);\n    container.appendChild(objectKeyEl);\n  }\n  function struct_default(host) {\n    function collapseValue(el) {\n      const options2 = elementOptions.get(el);\n      const data = elementData.get(el);\n      el.classList.add("struct-expand-value");\n      el.innerHTML = value2html(data, false, options2);\n      if (el.annotationsEl) {\n        el.parentNode.append(el.annotationsEl);\n      }\n    }\n    function expandValue(el, autoExpandLimit, sort) {\n      const data = elementData.get(el);\n      el.classList.remove("struct-expand-value");\n      if (typeof data === "string") {\n        const valueEl = stringValueProto.cloneNode(true);\n        const stringValueEl = valueEl.lastChild.previousSibling;\n        const sizeEl = stringValueEl.previousSibling;\n        const text = JSON.stringify(data);\n        appendText(stringValueEl.firstChild, text.slice(1, -1));\n        sizeEl.innerHTML = `length: ${numDelim2(text.length)} chars`;\n        el.replaceChildren(valueEl);\n        moveAnnotationsEl(el, sizeEl);\n      } else if (isArray(data) || isSet(data)) {\n        const context = elementContext.get(el);\n        const options2 = elementOptions.get(el);\n        const size = typeof data.size === "number" ? data.size : data.length;\n        el.replaceChildren(arrayValueProto.cloneNode(true));\n        renderValueSize(el, size, "elements");\n        moveAnnotationsEl(el, el.lastElementChild);\n        renderEntries(el, el.lastChild, data.values(), size, (entryEl, value, index) => {\n          renderValue(entryEl, value, autoExpandLimit, options2, Object.freeze({\n            parent: context,\n            host: data,\n            key: index,\n            index\n          }));\n        }, 0, options2.limit);\n      } else {\n        const context = elementContext.get(el);\n        const options2 = elementOptions.get(el);\n        const entries2 = Object.entries(data);\n        el.replaceChildren(objectValueProto.cloneNode(true));\n        renderValueSize(el, entries2.length, "entries");\n        moveAnnotationsEl(el, el.lastElementChild);\n        renderSorting(el, entries2, sort);\n        renderEntries(el, el.lastChild, entries2.values(), entries2.length, (entryEl, [key2, value], index) => {\n          renderObjectKey(entryEl, key2, options2.maxPropertyLength);\n          renderValue(entryEl, value, autoExpandLimit, options2, Object.freeze({\n            parent: context,\n            host: data,\n            key: key2,\n            index\n          }));\n        }, 0, options2.limit);\n      }\n    }\n    function renderValue(container, value, autoExpandLimit, options2, context) {\n      const expandable = isValueExpandable(value, options2);\n      const valueEl = valueProtoEl.cloneNode(true);\n      elementData.set(valueEl, value);\n      elementContext.set(valueEl, context);\n      elementOptions.set(valueEl, options2);\n      if (expandable && typeof value !== "string" && autoExpandLimit) {\n        container.classList.add("struct-expanded-value");\n        expandValue(valueEl, autoExpandLimit - 1);\n      } else {\n        if (expandable) {\n          valueEl.classList.add("struct-expand-value");\n        }\n        valueEl.innerHTML = value2html(value, false, options2);\n      }\n      applyAnnotations(valueEl, value, options2, context);\n      container.appendChild(valueEl);\n    }\n    function renderEntries(container, beforeEl, entries2, entriesCount, renderEntryContent, offset = 0, limit = defaultExpandedItemsLimit) {\n      if (limit === false) {\n        limit = Infinity;\n      }\n      const buffer = document.createDocumentFragment();\n      const lastIndex = entriesCount - 1;\n      let rendered = 0;\n      for (; rendered < limit; rendered++, offset++) {\n        const { done, value: entry } = entries2.next();\n        if (done) {\n          break;\n        }\n        const el = entryProtoEl.cloneNode(true);\n        renderEntryContent(el, entry, offset);\n        if (offset !== lastIndex) {\n          appendText(el, ",");\n        }\n        buffer.appendChild(el);\n      }\n      container.insertBefore(buffer, beforeEl);\n      host.view.maybeMoreButtons(\n        container,\n        beforeEl,\n        entriesCount,\n        offset,\n        limit,\n        (offset2, limit2) => renderEntries(container, beforeEl, entries2, entriesCount, renderEntryContent, offset2, limit2)\n      );\n    }\n    function renderTable(el) {\n      const options2 = elementOptions.get(el);\n      let data = elementData.get(el);\n      if (!isArray(data) && !isSet(data)) {\n        data = Object.entries(data).map(([key2, value]) => ({ "[key]": key2, "[value]": value }));\n      }\n      host.view.render(el, "table", data, options2.context);\n      el.append(el.lastChild.previousSibling);\n    }\n    function buildPathForElement(el) {\n      let path = [];\n      let context = elementContext.get(el);\n      while (context !== null && context.parent !== null) {\n        path.unshift(context.key);\n        context = context.parent;\n      }\n      return path;\n    }\n    function moveAnnotationsEl(valueEl, relEl) {\n      if (valueEl.annotationsEl) {\n        relEl.after(valueEl.annotationsEl);\n      }\n    }\n    function applyAnnotations(el, value, options2, context) {\n      if (!options2.annotations.length) {\n        return;\n      }\n      for (const annotation of options2.annotations) {\n        try {\n          const { query, debug } = annotation;\n          const queryContext = { ...context, context: options2.context };\n          const config = host.query(query, value, queryContext);\n          if (debug) {\n            host.log(\n              "info",\n              `Compute struct view annotation${typeof debug === "string" ? ` "${debug}"` : ""}:`,\n              { data: value, context: queryContext, query, queryResult: config }\n            );\n          }\n          if (config) {\n            annotationsToRender.push(\n              config.tooltip ? {\n                el,\n                config,\n                renderer: options2.renderer,\n                data: value,\n                context: queryContext\n              } : { el, config }\n            );\n          }\n        } catch (e) {\n          host.log("error", e);\n        }\n      }\n      scheduleApplyAnnotations();\n    }\n    function scheduleApplyAnnotations() {\n      if (annotationsTimer === null && annotationsToRender.length) {\n        annotationsTimer = Promise.resolve().then(() => {\n          annotationsTimer = null;\n          renderAnnotations(annotationsToRender);\n          if (annotationsToRender.length) {\n            scheduleApplyAnnotations();\n          }\n        });\n      }\n    }\n    const elementData = /* @__PURE__ */ new WeakMap();\n    const elementContext = /* @__PURE__ */ new WeakMap();\n    const elementOptions = /* @__PURE__ */ new WeakMap();\n    const structViewRoots = /* @__PURE__ */ new WeakSet();\n    const annotationsToRender = [];\n    let annotationsTimer = null;\n    const valueActionsPopup = createValueActionsPopup(host, elementData, buildPathForElement);\n    const signaturePopup = createSignaturePopup(host, elementData, buildPathForElement);\n    const clickHandler = createClickHandler(\n      expandValue,\n      collapseValue,\n      scheduleApplyAnnotations,\n      renderTable,\n      structViewRoots,\n      valueActionsPopup,\n      signaturePopup\n    );\n    host.addHostElEventListener("click", clickHandler, false);\n    host.view.define("struct", function(el, config, data, context) {\n      const {\n        annotations,\n        expanded,\n        limit,\n        limitCollapsed,\n        limitCompactObjectEntries,\n        maxStringLength,\n        maxCompactStringLength,\n        allowedExcessStringLength,\n        maxPropertyLength,\n        maxCompactPropertyLength\n      } = config;\n      const normalizedAnnotations = annotations ? (host.annotations || []).concat(annotations.map(\n        (annotation) => typeof annotation === "string" || typeof annotation === "function" ? { query: annotation } : annotation\n      )) : host.annotations;\n      const options2 = {\n        renderer: this,\n        context,\n        annotations: normalizedAnnotations,\n        limit: host.view.listLimit(limit, defaultExpandedItemsLimit),\n        limitCollapsed: host.view.listLimit(limitCollapsed, defaultCollapsedItemsLimit),\n        limitCompactObjectEntries: host.view.listLimit(limitCompactObjectEntries, defaultCollapsedObjectEntries),\n        maxStringLength: intOption(maxStringLength, defaultMaxStringLength),\n        maxCompactStringLength: intOption(maxCompactStringLength, defaultMaxCompactStringLength),\n        allowedExcessStringLength: intOption(allowedExcessStringLength, defaultAllowedExcessStringLength),\n        maxPropertyLength: intOption(maxPropertyLength, defaultMaxPropertyLength),\n        maxCompactPropertyLength: intOption(maxCompactPropertyLength, defaultMaxCompactPropertyLength)\n      };\n      structViewRoots.add(el);\n      renderValue(el, data, expanded, options2, {\n        parent: null,\n        host: { "": data },\n        key: "",\n        index: 0\n      });\n      scheduleApplyAnnotations();\n      if (!expanded && isValueExpandable(data, options2)) {\n        el.classList.add("struct-expand");\n      }\n    }, {\n      usage: struct_usage_default\n    });\n    return () => {\n      document.removeEventListener("click", clickHandler, false);\n    };\n  }\n  var hasOwnProperty4, toString5, defaultExpandedItemsLimit, defaultCollapsedItemsLimit, defaultCollapsedObjectEntries, defaultMaxStringLength, defaultMaxCompactStringLength, defaultAllowedExcessStringLength, defaultMaxPropertyLength, defaultMaxCompactPropertyLength;\n  var init_struct = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/struct/index.js"() {\n      init_html();\n      init_is_type();\n      init_click_handler();\n      init_popup_value_actions();\n      init_value_to_html();\n      init_render_annotations();\n      init_struct_usage();\n      init_el_proto();\n      init_poup_signature();\n      hasOwnProperty4 = Object.prototype.hasOwnProperty;\n      toString5 = Object.prototype.toString;\n      defaultExpandedItemsLimit = 50;\n      defaultCollapsedItemsLimit = 4;\n      defaultCollapsedObjectEntries = 0;\n      defaultMaxStringLength = 150;\n      defaultMaxCompactStringLength = 40;\n      defaultAllowedExcessStringLength = 10;\n      defaultMaxPropertyLength = Infinity;\n      defaultMaxCompactPropertyLength = 35;\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/table/table.usage.js\n  var table_usage_default;\n  var init_table_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/table/table.usage.js"() {\n      table_usage_default = {\n        demo: {\n          view: "table",\n          data: [\n            {\n              foo: 1,\n              bar: "bar",\n              baz: "zab"\n            },\n            {\n              foo: 2,\n              baz: "xyz"\n            },\n            {\n              foo: 3,\n              bar: "qux",\n              baz: "baz"\n            },\n            {\n              foo: 4,\n              bar: "aaa",\n              baz: "abc"\n            }\n          ]\n        },\n        examples: [\n          {\n            title: "Columns setup",\n            demo: {\n              view: "table",\n              cols: [\n                {\n                  header: "Header Col 1",\n                  data: "col1",\n                  content: \'text:"prefix-" + $\'\n                },\n                {\n                  header: "Header Col 3",\n                  data: "col3",\n                  content: \'text:$ + "-suffix"\'\n                }\n              ],\n              data: [\n                {\n                  col1: "foo",\n                  col2: "bar",\n                  col3: "baz"\n                },\n                {\n                  col1: "qux",\n                  col2: "oof",\n                  col3: "zab"\n                }\n              ]\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/table/table.js\n  function configFromName(name) {\n    return {\n      header: name,\n      view: "table-cell",\n      data: (obj) => obj[name],\n      sorting: `$[${JSON.stringify(name)}] ascN`\n    };\n  }\n  function sortingFromConfig(col, host, context) {\n    let prefix = "";\n    let query = "";\n    if ("data" in col && col.data !== void 0) {\n      switch (typeof col.data) {\n        case "string":\n          query = `(${col.data})`;\n          break;\n        case "function":\n          prefix = "$dataQuery;";\n          query = "$dataQuery(#)";\n          break;\n        default:\n          prefix = "$dataQuery;";\n          query = "$dataQuery";\n      }\n    }\n    if (typeof col.content === "string") {\n      const colonIndex = col.content.indexOf(":");\n      const viewName = col.content.slice(0, colonIndex);\n      if (colonIndex === -1 || !host.view.has(viewName)) {\n        return;\n      }\n      const viewQuery = col.content.slice(colonIndex + 1);\n      if (viewQuery) {\n        query = query ? `(${query} | ${viewQuery})` : `(${viewQuery})`;\n      }\n    }\n    return query ? host.query(`${prefix} ${query} ascN`, { dataQuery: col.data }, context) : false;\n  }\n  function resolveColConfig(name, config) {\n    if (typeof config === "string") {\n      config = { content: config };\n    }\n    return hasOwnProperty5.call(config, "content") || hasOwnProperty5.call(config, "data") ? {\n      header: name,\n      view: "table-cell",\n      ...config\n    } : {\n      ...configFromName(name),\n      ...config\n    };\n  }\n  function getOrder(host, data, sorting) {\n    if (typeof sorting !== "function") {\n      return false;\n    }\n    let order = 0;\n    try {\n      for (let i = 1; i < data.length; i++) {\n        const sign = Math.sign(sorting(data[i - 1], data[i]));\n        if (sign) {\n          if (order && sign !== order) {\n            return false;\n          }\n          order = sign;\n        }\n      }\n    } catch (e) {\n      host.log("error", "Error on column order detection in table view", e);\n      return 0;\n    }\n    return -order;\n  }\n  function table_default(host) {\n    const isScalarAssertion = "is (null or not object or regexp)";\n    const isScalar = host.queryFn(isScalarAssertion);\n    host.view.define("table", function(el, config, data, context) {\n      let { cols, rowConfig, limit, scalarCol = false } = config;\n      let renderRowConfig;\n      if (isSet(data)) {\n        data = [...data];\n      }\n      if (!isArray(data)) {\n        data = data ? [data] : [];\n      }\n      const headEl = el.appendChild(createElement("thead")).appendChild(createElement("tr"));\n      const headerCells = [];\n      const bodyEl = el.appendChild(createElement("tbody"));\n      const moreEl = el.appendChild(createElement("tbody"));\n      const moreButtonsEl = moreEl.appendChild(createElement("tr")).appendChild(createElement("td"));\n      const render2 = (orderedData) => {\n        bodyEl.innerHTML = "";\n        moreButtonsEl.innerHTML = "";\n        for (const headerCell of headerCells) {\n          const order = getOrder(host, orderedData, headerCell.sorting);\n          headerCell.el.classList.toggle("asc", order === 1);\n          headerCell.el.classList.toggle("desc", order === -1);\n        }\n        return host.view.renderList(\n          bodyEl,\n          renderRowConfig,\n          orderedData,\n          { ...context, cols },\n          0,\n          host.view.listLimit(limit, 25),\n          moreButtonsEl\n        ).then(() => moreEl.hidden = !moreButtonsEl.firstChild);\n      };\n      if (Array.isArray(cols)) {\n        cols = cols.map(\n          (def, idx) => typeof def === "string" ? configFromName(def) : {\n            header: "col" + idx,\n            view: "table-cell",\n            ...def\n          }\n        );\n      } else {\n        const colNames = /* @__PURE__ */ new Set();\n        const colsMap = cols && typeof cols === "object" ? cols : {};\n        cols = [];\n        for (const value of data) {\n          if (isScalar(value)) {\n            scalarCol = true;\n          } else {\n            for (const key2 of Object.keys(value)) {\n              colNames.add(key2);\n            }\n          }\n        }\n        for (const key2 of Object.keys(colsMap)) {\n          if (colsMap[key2]) {\n            colNames.add(key2);\n          } else {\n            colNames.delete(key2);\n          }\n        }\n        for (const name of colNames) {\n          cols.push(\n            hasOwnProperty5.call(colsMap, name) ? resolveColConfig(name, colsMap[name]) : configFromName(name)\n          );\n        }\n      }\n      if (scalarCol) {\n        cols.unshift({\n          header: "[value]",\n          view: "table-cell",\n          sorting: "$ ascN",\n          scalarAsStruct: true,\n          colSpan: `=${isScalarAssertion} ? #.cols.size() : 1`\n        });\n      }\n      cols = cols.filter(\n        (col) => !hasOwnProperty5.call(col, "when") || host.queryBool(col.when, data, context)\n      );\n      for (const col of cols) {\n        if (hasOwnProperty5.call(col, "whenData") && col.whenData !== void 0) {\n          const { whenData, content } = col;\n          col.whenData = void 0;\n          col.content = (data2, context2) => host.queryBool(whenData, data2, context2) ? { content } : void 0;\n        }\n        const headerCellEl = headEl.appendChild(createElement("th"));\n        const headerCell = {\n          el: headerCellEl\n        };\n        headerCells.push(headerCell);\n        headerCellEl.textContent = col.header;\n        const sorting = hasOwnProperty5.call(col, "sorting") ? host.query(col.sorting, null, context) : sortingFromConfig(col, host, context);\n        const defaultOrder = typeof sorting === "function" ? getOrder(host, data, sorting) : 0;\n        if (defaultOrder !== 0) {\n          col.sorting = sorting;\n          headerCell.sorting = sorting;\n          headerCellEl.classList.add("sortable");\n          headerCellEl.addEventListener("click", () => {\n            if (headerCellEl.classList.contains("asc")) {\n              render2(data.slice().sort((a, b2) => -sorting(a, b2)));\n            } else if (headerCellEl.classList.contains("desc") && !defaultOrder) {\n              render2(data);\n            } else {\n              render2(data.slice().sort(sorting));\n            }\n          });\n        } else {\n          col.sorting = false;\n        }\n      }\n      moreButtonsEl.colSpan = cols.length;\n      renderRowConfig = this.composeConfig({\n        view: "table-row",\n        cols: `=${isScalarAssertion} ? [#.cols[]] : #.cols`\n      }, rowConfig);\n      return render2(data);\n    }, {\n      tag: "table",\n      usage: table_usage_default\n    });\n  }\n  var hasOwnProperty5;\n  var init_table = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/table/table.js"() {\n      init_table_usage();\n      init_is_type();\n      init_dom();\n      hasOwnProperty5 = Object.hasOwnProperty;\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/table/table-row.js\n  function table_row_default(host) {\n    host.view.define("table-row", function(el, config, data, context) {\n      const { cols } = config;\n      if (Array.isArray(cols)) {\n        return Promise.all(cols.map(\n          (col, index) => host.view.render(el, col, data, { ...context, colIndex: index })\n        ));\n      }\n    }, { tag: "tr" });\n  }\n  var init_table_row = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/table/table-row.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/table/table-cell.js\n  function defaultCellRender(el, data, isDataObject) {\n    if (Array.isArray(data)) {\n      el.classList.add("number");\n      el.textContent = data.length || "";\n      return;\n    }\n    if (isDataObject) {\n      el.classList.add("complex");\n      for (let k2 in data) {\n        if (hasOwnProperty6.call(data, k2)) {\n          el.textContent = "{\\u2026}";\n          return;\n        }\n      }\n      el.textContent = "{}";\n      return;\n    }\n    if (data === void 0) {\n      return;\n    }\n    if (typeof data === "number") {\n      let str = String(data);\n      el.classList.add("number");\n      if (str.length > 3) {\n        el.innerHTML = numDelim2(str, false);\n      } else {\n        el.textContent = str;\n      }\n      return;\n    }\n    el.textContent = String(data);\n  }\n  function table_cell_default(host) {\n    host.view.define("table-cell", function(el, config, data, context) {\n      let { content, details, colSpan, scalarAsStruct } = config;\n      const isDataObject = data !== null && (Array.isArray(data) ? data.length > 0 : typeof data === "object") && data instanceof RegExp === false;\n      if (typeof colSpan === "number" && colSpan > 1) {\n        el.colSpan = colSpan;\n      }\n      if (typeof content === "function") {\n        content = content(data, context);\n        if (!content) {\n          return;\n        }\n        content = content.content;\n      }\n      if (details || !content && isDataObject) {\n        el.classList.add("details");\n        el.addEventListener("click", (e) => {\n          let node = e.target;\n          if (node === el) {\n            const rowEl = node.parentNode;\n            const bodyEl = rowEl.parentNode;\n            const currentDetailsEl = Array.from(bodyEl.querySelectorAll(".view-table-cell.details-expanded")).find((td) => td.parentNode.parentNode === bodyEl);\n            let detailsEl = null;\n            if (currentDetailsEl) {\n              const currentDetailsRowEl = currentDetailsEl.parentNode;\n              currentDetailsEl.classList.remove("details-expanded");\n              if (currentDetailsEl === el) {\n                rowEl.parentNode.removeChild(rowEl.nextSibling);\n                return;\n              }\n              if (currentDetailsRowEl !== rowEl) {\n                currentDetailsRowEl.parentNode.removeChild(currentDetailsRowEl.nextSibling);\n              } else {\n                detailsEl = rowEl.nextSibling.firstChild;\n                detailsEl.innerHTML = "";\n              }\n            }\n            if (detailsEl === null) {\n              detailsEl = rowEl.parentNode.insertBefore(document.createElement("tr"), rowEl.nextSibling).appendChild(document.createElement("td"));\n              detailsEl.parentNode.className = "view-table-cell-details-row";\n              detailsEl.className = "view-cell-details-content";\n              detailsEl.colSpan = 1e3;\n            }\n            el.classList.add("details-expanded");\n            host.view.render(detailsEl, details || defaultDetailsRender, data, context);\n          }\n        });\n      }\n      if (scalarAsStruct && !content && !isDataObject) {\n        content = "struct";\n      }\n      if (content) {\n        return host.view.render(el, content, data, context);\n      }\n      defaultCellRender(el, data, isDataObject);\n    }, {\n      tag: "td"\n    });\n  }\n  var defaultDetailsRender, hasOwnProperty6;\n  var init_table_cell = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/table/table-cell.js"() {\n      init_html();\n      defaultDetailsRender = { view: "struct", expanded: 1 };\n      hasOwnProperty6 = Object.hasOwnProperty;\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/tree/tree.usage.js\n  var onToggle, createTree, tree_usage_default;\n  var init_tree_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/tree/tree.usage.js"() {\n      onToggle = () => alert("toggled!");\n      createTree = ([len, ...rest], path = "") => {\n        const result = [];\n        for (let i = 0; i < len; i++) {\n          const leafPath = path + "." + (i + 1);\n          result.push({\n            title: leafPath,\n            children: rest.length ? createTree(rest, leafPath) : null\n          });\n        }\n        return result;\n      };\n      tree_usage_default = {\n        demo: {\n          view: "tree",\n          item: "text:text",\n          data: {\n            text: "Root",\n            children: [\n              { text: "Child" },\n              { text: "Another child", children: [\n                { text: "Lvl 2 child" },\n                { text: "Lvl 2 child" }\n              ] }\n            ]\n          }\n        },\n        examples: [\n          {\n            title: "Expanded tree",\n            highlightProps: ["expanded"],\n            demo: {\n              view: "tree",\n              item: "text:text",\n              expanded: 999\n            },\n            demoData: {\n              text: "Root",\n              children: [\n                { text: "Child" },\n                { text: "Another child", children: [\n                  { text: "Lvl 2 child" },\n                  { text: "Lvl 2 child" }\n                ] }\n              ]\n            }\n          },\n          {\n            title: "With empty text",\n            highlightProps: ["emptyText"],\n            demo: {\n              view: "tree",\n              emptyText: "This tree is empty",\n              data: null\n            }\n          },\n          {\n            title: "With toggle handler",\n            highlightProps: ["onToggle"],\n            demo: {\n              view: "tree",\n              item: "text:text",\n              onToggle\n            },\n            demoData: {\n              text: "Root",\n              children: [\n                { text: "Child" },\n                { text: "Another child", children: [\n                  { text: "Lvl 2 child" },\n                  { text: "Lvl 2 child" }\n                ] }\n              ]\n            }\n          },\n          {\n            title: "limitLines",\n            highlightProps: ["limitLines"],\n            demoData: createTree([5, 3, 3]),\n            demo: {\n              view: "tree",\n              item: "text:title",\n              limitLines: 7\n            }\n          }\n        ]\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/tree/tree.js\n  function tree_default(host) {\n    function renderTreeLines(container, renderStack, data, context, offset, limit) {\n      if (limit === false) {\n        limit = data.length;\n      }\n      container.classList.add("incomplete");\n      return data.slice(offset, offset + limit).reduce(\n        (pipeline, entry) => pipeline.then(() => {\n          const {\n            container: targetContainer,\n            itemConfig\n          } = renderStack;\n          return host.view.render(targetContainer, host.view.composeConfig(itemConfig, {\n            expanded: entry.expanded,\n            last: entry.last,\n            hasChildren: entry.hasChildren,\n            children: entry.children\n          }), entry.data, context).then(() => {\n            if (entry.expanded && entry.hasChildren) {\n              const container2 = targetContainer.lastChild.querySelector(".view-tree-leaf-children");\n              container2.classList.add("incomplete");\n              renderStack = {\n                container: container2,\n                itemConfig: host.view.composeConfig(itemConfig, itemConfig.itemConfig),\n                prev: renderStack\n              };\n            } else {\n              while (entry.shift--) {\n                renderStack.container.classList.remove("incomplete");\n                renderStack = renderStack.prev;\n              }\n            }\n          });\n        }),\n        Promise.resolve()\n      ).then(() => host.view.maybeMoreButtons(\n        container,\n        null,\n        data.length,\n        offset + limit,\n        limit,\n        (offset2, limit2) => renderTreeLines(container, renderStack, data, context, offset2, limit2)\n      ) || container.classList.remove("incomplete"));\n    }\n    function buildTreeLines(data, context, itemConfig, expanded) {\n      function processChildren(array, expanded2, itemConfig2, popCount = 0) {\n        array.forEach((data2, index, array2) => {\n          const children = host.query(itemConfig2.children, data2, context);\n          const hasChildren = Array.isArray(children) && children.length > 0;\n          const last = index === array2.length - 1;\n          const leafExpanded = visited.has(data2) ? 0 : typeof expanded2 === "function" ? expanded2(data2, context) : expanded2;\n          visited.add(data2);\n          leafs.push({\n            data: data2,\n            expanded: leafExpanded,\n            last,\n            hasChildren,\n            children: leafExpanded ? null : itemConfig2.children,\n            shift: last && (!leafExpanded || !hasChildren) ? popCount + 1 : 0\n          });\n          if (hasChildren && leafExpanded) {\n            processChildren(\n              children,\n              typeof expanded2 === "number" ? expanded2 - 1 : expanded2,\n              host.view.composeConfig(itemConfig2, itemConfig2.itemConfig),\n              last ? popCount + 1 : 0\n            );\n          }\n        });\n      }\n      const leafs = [];\n      const visited = /* @__PURE__ */ new Set();\n      processChildren(data, expanded, itemConfig);\n      return leafs;\n    }\n    host.view.define("tree", function render2(el, config, data, context) {\n      const { children = "children", item = "text", itemConfig, collapsible, emptyText, onToggle: onToggle2 } = config;\n      let { expanded, limit, limitLines = true } = config;\n      if (emptyText !== false && emptyText !== "") {\n        el.setAttribute("emptyText", emptyText || "Empty tree");\n      }\n      if (!Array.isArray(data) && data) {\n        data = [data];\n      }\n      if (Array.isArray(data)) {\n        limit = host.view.listLimit(limit, 25);\n        limitLines = host.view.listLimit(limitLines, 25);\n        expanded = typeof expanded === "function" ? expanded : host.view.listLimit(expanded, 1);\n        if (limitLines) {\n          const lines = buildTreeLines(data, context, this.composeConfig({ children }, itemConfig), expanded);\n          const renderStack = {\n            container: el,\n            itemConfig: this.composeConfig({\n              view: "tree-leaf",\n              itemConfig,\n              content: item,\n              collapsible,\n              onToggle: onToggle2\n            }, itemConfig)\n          };\n          return renderTreeLines(el, renderStack, lines, context, 0, limitLines);\n        }\n        return this.renderList(el, this.composeConfig({\n          view: "tree-leaf",\n          itemConfig,\n          content: item,\n          collapsible,\n          expanded,\n          children,\n          limit,\n          onToggle: onToggle2\n        }, itemConfig), data, context, 0, limit);\n      }\n    }, {\n      tag: "ul",\n      usage: tree_usage_default\n    });\n  }\n  var init_tree = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/tree/tree.js"() {\n      init_tree_usage();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/tree/tree-leaf.js\n  function tree_leaf_default(host) {\n    const elementToData = /* @__PURE__ */ new WeakMap();\n    const clickHandler = ({ target }) => {\n      const toggleEl = target.closest(".view-tree-leaf-toggle");\n      if (toggleEl) {\n        const state = elementToData.get(toggleEl);\n        const expanded = !toggleEl.parentNode.classList.toggle("collapsed");\n        if (typeof state.render === "function") {\n          state.render();\n        }\n        if (typeof state.onToggle === "function") {\n          state.onToggle(expanded, toggleEl.parentNode, state.data, state.context);\n        }\n      }\n    };\n    host.addHostElEventListener("click", clickHandler, false);\n    host.view.define("tree-leaf", async function(el, config, data, context) {\n      const { expanded, content = "text", itemConfig, collapsible = true, last, hasChildren, children, limit, onToggle: onToggle2 } = config;\n      const toggleEl = el.appendChild(createElement("span", "view-tree-leaf-toggle"));\n      const contentEl = el.appendChild(createElement("span", "view-tree-leaf-content"));\n      let childrenData = null;\n      let hasChildrenEl = hasChildren;\n      if (last) {\n        el.classList.add("last");\n      }\n      if (!collapsible) {\n        el.classList.add("non-collapsible");\n      }\n      await this.render(contentEl, content, data, context);\n      if (children) {\n        childrenData = host.query(children, data, context);\n        hasChildrenEl = Array.isArray(childrenData) && childrenData.length > 0;\n      }\n      if (hasChildrenEl) {\n        const childrenEl = el.appendChild(createElement("ul", "view-tree-leaf-children"));\n        const state = { data, context, onToggle: onToggle2, render: null };\n        const renderChildren = (data2, expanded2) => {\n          if (typeof expanded2 === "number") {\n            expanded2--;\n          }\n          this.renderList(childrenEl, this.composeConfig({\n            view: "tree-leaf",\n            expanded: expanded2,\n            itemConfig,\n            content,\n            collapsible,\n            children,\n            limit,\n            onToggle: onToggle2\n          }, itemConfig), data2, context, 0, this.listLimit(limit, 25));\n        };\n        el.classList.add("has-children");\n        elementToData.set(toggleEl, state);\n        if (typeof expanded === "function" ? expanded(data, context) : expanded) {\n          if (childrenData) {\n            await renderChildren(childrenData, expanded);\n          }\n        } else {\n          el.classList.add("collapsed");\n          if (childrenData) {\n            state.render = () => {\n              state.render = null;\n              renderChildren(childrenData, expanded || 1);\n            };\n          }\n        }\n      }\n    }, {\n      tag: "li"\n    });\n  }\n  var init_tree_leaf = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/tree/tree-leaf.js"() {\n      init_dom();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/index.js\n  var views_exports = {};\n  __export(views_exports, {\n    alerts: () => alerts_default,\n    autoLink: () => auto_link_default,\n    badges: () => badges_default,\n    block: () => block_default,\n    button: () => button_default,\n    checkbox: () => checkbox_default,\n    checkboxList: () => checkbox_list_default,\n    column: () => column_default,\n    columns: () => columns_default,\n    contentFilter: () => content_filter_default,\n    context: () => context_default,\n    dropdown: () => dropdown_default,\n    editors: () => editors_default,\n    expand: () => expand_default,\n    headers: () => headers_default,\n    hstack: () => hstack_default,\n    html: () => html_default,\n    image: () => image_default,\n    imagePreview: () => image_preview_default,\n    indicator: () => indicator_default,\n    input: () => input_default,\n    link: () => link_default,\n    listItem: () => list_item_default,\n    lists: () => lists_default,\n    markdown: () => markdown_default,\n    menu: () => menu_default,\n    menuItem: () => menu_item_default,\n    navButton: () => nav_button_default,\n    pageHeader: () => page_header_default,\n    popup: () => popup_default,\n    progressbar: () => progress_default,\n    section: () => section_default,\n    select: () => select_default,\n    signature: () => signature_default,\n    source: () => source_default,\n    struct: () => struct_default,\n    switch: () => switch_default,\n    tab: () => tab_default,\n    table: () => table_default,\n    tableCell: () => table_cell_default,\n    tableRow: () => table_row_default,\n    tabs: () => tabs_default,\n    text: () => text_default,\n    textMatch: () => text_match_default,\n    textNumeric: () => text_numeric_default,\n    tocSection: () => toc_section_default,\n    toggle: () => toggle_default,\n    toggleGroup: () => toggle_group_default,\n    tree: () => tree_default,\n    treeItem: () => tree_leaf_default\n  });\n  var init_views = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/index.js"() {\n      init_button();\n      init_checkbox_list();\n      init_checkbox();\n      init_content_filter();\n      init_dropdown();\n      init_input();\n      init_menu();\n      init_menu_item();\n      init_nav_button();\n      init_progress();\n      init_select();\n      init_tabs();\n      init_tab();\n      init_toggle();\n      init_toggle_group();\n      init_editors();\n      init_block();\n      init_column();\n      init_columns();\n      init_expand();\n      init_hstack();\n      init_list_item();\n      init_lists();\n      init_page_header();\n      init_popup();\n      init_section();\n      init_toc_section();\n      init_alerts();\n      init_auto_link();\n      init_badges();\n      init_headers();\n      init_html2();\n      init_image();\n      init_image_preview();\n      init_indicator();\n      init_link();\n      init_markdown();\n      init_source();\n      init_text();\n      init_text_match();\n      init_text_numeric();\n      init_context();\n      init_switch();\n      init_signature();\n      init_struct();\n      init_table();\n      init_table_row();\n      init_table_cell();\n      init_tree();\n      init_tree_leaf();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/default.js\n  function default_default2(host) {\n    host.page.define("default", {\n      view: "switch",\n      content: [\n        {\n          when: "not #.datasets",\n          content: [\n            {\n              view: "h1",\n              className: "no-data-loaded",\n              content: \'text:"Discovery.js"\'\n            },\n            {\n              view: "markdown",\n              when: "#.meta.description",\n              source: "=#.meta.description"\n            },\n            \'html:"<br>"\',\n            "preset/upload"\n          ]\n        },\n        {\n          content: [\n            \'page-header{ content: "h1:#.name" }\',\n            { view: "struct", expanded: 1 }\n          ]\n        }\n      ]\n    });\n  }\n  var init_default2 = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/default.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/not-found.js\n  function not_found_default(host) {\n    host.page.define("not-found", [\n      \'alert-warning:"Page `" + name + "` not found"\'\n    ]);\n  }\n  var init_not_found = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/not-found.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/base64.js\n  var base64_exports = {};\n  __export(base64_exports, {\n    decode: () => decode,\n    encode: () => encode\n  });\n  function toUTF8(input) {\n    let output = "";\n    for (let i = 0; i < input.length; i++) {\n      const c = input.charCodeAt(i);\n      if (c < 128) {\n        output += chars[c];\n      } else {\n        if (c < 2048) {\n          output += chars[c >> 6 | 192] + chars[c & 63 | 128];\n        } else {\n          output += chars[c >> 12 | 224] + chars[c >> 6 & 63 | 128] + chars[c & 63 | 128];\n        }\n      }\n    }\n    return output;\n  }\n  function toUTF8Bytes(input) {\n    input = toUTF8(input);\n    const output = new Array(input.length);\n    for (let i = 0; i < input.length; i++) {\n      output[i] = input.charCodeAt(i);\n    }\n    return output;\n  }\n  function fromUTF8(input) {\n    let output = "";\n    for (let i = 0; i < input.length; ) {\n      const c1 = input.charCodeAt(i++);\n      if (c1 < 128) {\n        output += String.fromCharCode(c1);\n      } else {\n        const c2 = input.charCodeAt(i++);\n        if (c1 & 32) {\n          const c3 = input.charCodeAt(i++);\n          output += String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n        } else {\n          output += String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n        }\n      }\n    }\n    return output;\n  }\n  function fromUTF8Bytes(input) {\n    return fromUTF8(input.map(function(b2) {\n      return chars[b2];\n    }).join(""));\n  }\n  function encode(input) {\n    let output = "";\n    if (!Array.isArray(input)) {\n      input = toUTF8Bytes(input);\n    }\n    for (let i = 0; i < input.length; ) {\n      const chr1 = input[i++];\n      const chr2 = input[i++];\n      const chr3 = input[i++];\n      let enc1 = chr1 >> 2;\n      let enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n      let enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n      let enc4 = chr3 & 63;\n      if (chr2 == void 0) {\n        enc3 = enc4 = 64;\n      } else if (chr3 == void 0) {\n        enc4 = 64;\n      }\n      output += b64chars[enc1] + b64chars[enc2] + b64chars[enc3] + b64chars[enc4];\n    }\n    return output;\n  }\n  function decode(input) {\n    let output = [];\n    let enc1;\n    let enc2;\n    let enc3;\n    let enc4;\n    input = input.replace(/[^a-zA-Z0-9\\+\\/]/g, "");\n    for (let i = 0; i < input.length; ) {\n      enc1 = charIndex[input.charAt(i++)];\n      enc2 = charIndex[input.charAt(i++)];\n      enc3 = charIndex[input.charAt(i++)];\n      enc4 = charIndex[input.charAt(i++)];\n      const chr1 = enc1 << 2 | enc2 >> 4;\n      const chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n      const chr3 = (enc3 & 3) << 6 | enc4;\n      output.push(chr1, chr2, chr3);\n    }\n    if (enc3 == null || enc3 == 64) {\n      output.pop();\n    }\n    if (enc4 == null || enc4 == 64) {\n      output.pop();\n    }\n    return fromUTF8Bytes(output);\n  }\n  var chars, b64chars, charIndex, i;\n  var init_base64 = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/base64.js"() {\n      chars = [];\n      b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("");\n      charIndex = b64chars.reduce(function(res, item, index) {\n        res[item] = index;\n        return res;\n      }, {});\n      for (i = 0; i < 255; i++) {\n        chars[i] = String.fromCharCode(i);\n      }\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/discover/params.js\n  function ensureString(value, fallback) {\n    return typeof value === "string" ? value : fallback || "";\n  }\n  function encodeParams(params) {\n    const { query, graph, view, title, dzen, noedit, ...extra } = typeof params === "string" ? { query: params } : params;\n    const pairs = [];\n    if (dzen) {\n      pairs.push(["dzen"]);\n    }\n    if (noedit) {\n      pairs.push(["noedit"]);\n    }\n    if (title) {\n      pairs.push(["title", title]);\n    }\n    if (query) {\n      pairs.push(["q", encode(query)]);\n    }\n    if (graph) {\n      pairs.push(["graph", encode(JSON.stringify(graph))]);\n    }\n    if (typeof view === "string") {\n      pairs.push(view ? ["v", encode(view)] : ["v"]);\n    }\n    Object.keys(extra || {}).sort().forEach((name) => {\n      if (!decodedSpecialParams.includes(name)) {\n        pairs.push([\n          name,\n          name.endsWith("-b64") && typeof extra[name] === "string" ? encode(extra[name]) : extra[name]\n        ]);\n      }\n    });\n    return pairs;\n  }\n  function decodeParams(pairs) {\n    const params = Object.fromEntries(pairs);\n    const decodedParams = {\n      title: params.title || "",\n      query: decode(ensureString(params.q, "")),\n      graph: JSON.parse(decode(ensureString(params.graph, "")) || "null"),\n      view: "v" in params ? decode(ensureString(params.v, "")) : void 0,\n      dzen: "dzen" in params,\n      noedit: "noedit" in params\n    };\n    Object.keys(params).forEach((name) => {\n      if (!encodedSpecialParams.includes(name)) {\n        decodedParams[name] = name.endsWith("-b64") && typeof params[name] === "string" ? decode(params[name]) : params[name];\n      }\n    });\n    return decodedParams;\n  }\n  function filterDecodedParams(params) {\n    return Object.fromEntries(Object.entries(params).filter(\n      ([key2]) => !decodedSpecialParams.includes(key2)\n    ));\n  }\n  function isEqual(a, b2, skipKey) {\n    for (const key2 of Object.keys(a)) {\n      if (key2 !== skipKey && a[key2] !== b2[key2]) {\n        return false;\n      }\n    }\n    for (const key2 of Object.keys(b2)) {\n      if (key2 !== skipKey && a[key2] !== b2[key2]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function contextWithoutEditorParams(newContext, currentContext = {}) {\n    const stableNewContext = {\n      ...newContext,\n      params: filterDecodedParams(newContext.params)\n    };\n    if (!isEqual(currentContext, stableNewContext, "params") || !isEqual(currentContext.params, stableNewContext.params)) {\n      return stableNewContext;\n    }\n    return currentContext;\n  }\n  var decodedSpecialParams, encodedSpecialParams;\n  var init_params = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/discover/params.js"() {\n      init_base64();\n      decodedSpecialParams = ["query", "graph", "view", "title", "dzen", "noedit"];\n      encodedSpecialParams = ["q", "graph", "v", "title", "dzen", "noedit"];\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/discover/header.js\n  function quote(str) {\n    return str.replace(/\\\\/g, "\\\\\\\\").replace(/\\t/g, "\\\\t").replace(/\\r/g, "\\\\r").replace(/\\n/g, "\\\\n").replace(/\'/g, "\\\\\'");\n  }\n  function exportStateAsJson(pageParams) {\n    let { title, query, view } = pageParams;\n    const res = { title, query, view };\n    return `{\n${Object.keys(res).reduce(\n      (props, k2) => props.concat(res[k2] ? `    ${k2}: \'${quote(res[k2])}\'` : []),\n      []\n    ).join(",\\n")}\n}`;\n  }\n  function toDate(value) {\n    if (value && (typeof value === "number" || typeof value === "string")) {\n      const date = new Date(value);\n      return !isNaN(date) ? date : null;\n    }\n    return value instanceof Date ? value : null;\n  }\n  function formatDate(value) {\n    const date = toDate(value);\n    if (date) {\n      return date.toISOString().replace(/^(\\d{4})-(\\d{2})-(\\d{2})T([\\d:]+).*/, "$3/$2/$1 $4 UTC");\n    }\n    return null;\n  }\n  function header_default(host, updateParams) {\n    let titleInputEl;\n    let dataDateTimeEl;\n    let viewDateTimeEl;\n    let noeditToggleEl;\n    const shareOptionsPopup = new host.view.Popup({\n      render: (popupEl, _, hide) => host.view.render(popupEl, {\n        view: "menu",\n        data: [\n          {\n            text: "Copy page permalink",\n            disabled: !host.action.has("permalink"),\n            action: async () => copyText(await host.action.call("permalink", host.pageHash))\n          },\n          {\n            text: "Copy page hash",\n            action: () => copyText(host.pageHash)\n          },\n          {\n            text: "Copy page as JSON",\n            action: () => copyText(exportStateAsJson(host.pageParams))\n          }\n        ],\n        onClick(item) {\n          hide();\n          item.action();\n        }\n      })\n    });\n    const actionsPanel = createElement("div", "discovery-actions", [\n      noeditToggleEl = createElement("button", {\n        class: "edit-mode discovery-hidden-in-dzen",\n        title: "Toggle edit mode",\n        onclick: ({ target }) => {\n          target.blur();\n          updateParams({\n            noedit: !host.pageParams.noedit\n          });\n        }\n      }),\n      createElement("button", {\n        class: "share",\n        title: "Sharing",\n        onclick: ({ target }) => {\n          target.blur();\n          shareOptionsPopup.show(target);\n        }\n      }),\n      createElement("button", {\n        class: "toggle-fullscreen",\n        title: "Toggle full page mode",\n        onclick: ({ target }) => {\n          target.blur();\n          updateParams({\n            dzen: !host.pageParams.dzen\n          });\n        }\n      })\n    ]);\n    const updateHeaderTitle = (target) => {\n      target.parentNode.dataset.title = target.value || target.placeholder;\n    };\n    const headerEl = createElement("div", "discovery-header", [\n      createElement("div", { class: "discovery-header-text", "data-title": "\\xA0" }, [\n        titleInputEl = createElement("input", {\n          class: "discovery-hidden-in-dzen",\n          placeholder: "Untitled discovery",\n          oninput: ({ target }) => {\n            updateHeaderTitle(target);\n          },\n          onchange: ({ target }) => {\n            updateHeaderTitle(target);\n            updateParams({\n              title: target.value\n            }, true);\n          },\n          onkeypress: (e) => {\n            if (e.charCode === 13 || e.keyCode === 13) {\n              e.target.blur();\n            }\n          }\n        }),\n        createElement("span", "timestamp", [\n          dataDateTimeEl = createElement("span", null, "&nbsp;"),\n          viewDateTimeEl = createElement("span")\n        ])\n      ])\n    ]);\n    return {\n      el: [\n        actionsPanel,\n        headerEl\n      ],\n      render(data, context) {\n        const { title, noedit } = context.params;\n        const createdAt = formatDate(context.datasets?.[0]?.resource?.createdAt);\n        titleInputEl.value = title;\n        updateHeaderTitle(titleInputEl);\n        noeditToggleEl.classList.toggle("disabled", noedit);\n        dataDateTimeEl.innerText = createdAt ? "Data collected at " + createdAt + " | " : "";\n        viewDateTimeEl.innerText = "Rendered at " + formatDate(/* @__PURE__ */ new Date());\n      }\n    };\n  }\n  var init_header = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/discover/header.js"() {\n      init_dom();\n      init_copy_text();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/discover/editor-query.js\n  function count2(value, one, many) {\n    return value.length ? `${value.length} ${value.length === 1 ? one : many}` : "empty";\n  }\n  function valueDescriptor(value) {\n    if (Array.isArray(value)) {\n      return `Array (${count2(value, "element", "elements")})`;\n    }\n    if (value && typeof value === "object") {\n      return `Object (${count2(Object.keys(value), "entry", "entries")})`;\n    }\n    return `Scalar (${value === null ? "null" : typeof value})`;\n  }\n  function svg(tagName, attributes) {\n    const el = document.createElementNS("http://www.w3.org/2000/svg", tagName);\n    if (attributes) {\n      for (const [k2, v2] of Object.entries(attributes)) {\n        el.setAttribute(k2, v2);\n      }\n    }\n    return el;\n  }\n  function buildQueryGraph(el, graph, host) {\n    function createBox() {\n      return el.appendChild(createElement("div", "query-graph-box"));\n    }\n    function walk37(box, node, path, currentPath) {\n      if (!Array.isArray(currentPath)) {\n        currentPath = [];\n      }\n      if (!box) {\n        box = createBox();\n      }\n      const isTarget = currentPath.length === 1;\n      const isCurrent = currentPath.length > 1;\n      const nodeEl = box.appendChild(createElement("div", {\n        "data-path": path.join(" "),\n        class: `query-graph-node${isTarget ? " target" : isCurrent ? " current" : ""}`\n      }));\n      host.view.attachTooltip(nodeEl, {\n        className: "query-graph-tooltip",\n        content: isTarget ? \'badge:"Current query"\' : {\n          view: "source",\n          data: !node.query ? { content: "<empty query>", lineNum: false } : {\n            syntax: "jora",\n            content: node.query || "",\n            lineNum: false\n          }\n        }\n      });\n      if (Array.isArray(node.children)) {\n        for (let i = 0; i < node.children.length; i++) {\n          const childEl = walk37(\n            box.nextSibling,\n            node.children[i],\n            path.concat(i),\n            currentPath[1] === i ? currentPath.slice(1) : []\n          );\n          connections.push([nodeEl, childEl]);\n        }\n      }\n      return nodeEl;\n    }\n    let connections = [];\n    for (let i = 0; i < graph.children.length; i++) {\n      walk37(el.firstChild, graph.children[i], [i], graph.current[0] === i ? graph.current : []);\n    }\n    requestAnimationFrame(() => {\n      const svgEl = el.appendChild(svg("svg"));\n      for (const [fromEl, toEl] of connections) {\n        const fromBox = getBoundingRect(fromEl, svgEl);\n        const toBox = getBoundingRect(toEl, svgEl);\n        const x1 = fromBox.right - 2;\n        const y1 = fromBox.top + fromBox.height / 2;\n        const x2 = toBox.left + 2;\n        const y2 = toBox.top + toBox.height / 2;\n        const dx = (x2 - x1) / 3;\n        svgEl.append(\n          y1 === y2 ? svg("line", {\n            stroke: "#888",\n            x1,\n            y1,\n            x2,\n            y2\n          }) : svg("path", {\n            stroke: "#888",\n            fill: "none",\n            d: `M ${x1} ${y1} C ${x1 + 2 * dx} ${y1} ${x2 - 2 * dx} ${y2} ${x2} ${y2}`\n          })\n        );\n      }\n    });\n  }\n  function normalizeGraph(graph) {\n    if (!Array.isArray(graph.current)) {\n      graph.current = [];\n    }\n    if (graph.current.length === 0) {\n      graph.current.push(0);\n    }\n    if (!Array.isArray(graph.children)) {\n      graph.children = [];\n    }\n    if (graph.children.length === 0) {\n      graph.children.push({});\n    }\n  }\n  function getPathInGraph(graph, path) {\n    const result = [graph];\n    let cursor = graph;\n    for (let i = 0; i < path.length; i++) {\n      cursor = cursor.children[path[i]];\n      result.push(cursor);\n    }\n    return result;\n  }\n  function editor_query_default(host, updateParams) {\n    let expandQueryInput = false;\n    let expandQueryInputData = NaN;\n    let expandQueryResults = false;\n    let expandQueryResultData = NaN;\n    let currentQuery;\n    let currentView;\n    let currentGraph = null;\n    let currentContext;\n    let errorMarker = null;\n    let scheduledCompute = null;\n    let computationCache = [];\n    const defaultGraph = {};\n    let queryEditorLiveEditEl;\n    const getQuerySuggestions = (query, offset, data, context) => host.querySuggestions(query, offset, data, context);\n    const queryEditor = new host.view.QueryEditor(getQuerySuggestions).on(\n      "change",\n      (value) => queryEditorLiveEditEl.checked && updateParams({ query: value }, true)\n    );\n    const queryEngineInfo = host.getQueryEngineInfo();\n    const queryGraphButtonsEl = createElement("div", "query-graph-actions");\n    const queryEditorButtonsEl = createElement("div", "buttons");\n    const queryEditorInputEl = createElement("div", "query-input");\n    const queryEditorInputDetailsEl = createElement("div", "query-input-details");\n    const queryEditorResultEl = createElement("div", "data-query-result");\n    const queryEditorResultDetailsEl = createElement("div", "data-query-result-details");\n    const queryGraphEl = createElement("div", "query-graph");\n    const queryPathEl = createElement("div", "query-path");\n    const queryEditorFormEl = createElement("div", "form query-editor-form", [\n      queryGraphEl,\n      queryPathEl,\n      createElement("div", "query-editor", [\n        queryEditor.el\n      ])\n    ]);\n    queryEditor.inputPanelEl.append(\n      queryGraphButtonsEl,\n      queryEditorInputEl,\n      queryEditorInputDetailsEl,\n      createElement("a", { class: "view-link query-engine", href: queryEngineInfo.link, target: "_blank" }, [\n        `${queryEngineInfo.name} ${queryEngineInfo.version || ""}`\n      ])\n    );\n    queryEditor.outputPanelEl.append(\n      queryEditorResultEl,\n      queryEditorButtonsEl,\n      queryEditorResultDetailsEl\n    );\n    const hintTooltip = (text) => ({\n      position: "trigger",\n      className: "hint-tooltip",\n      showDelay: true,\n      content: { view: "context", data: { text }, content: "text:text" }\n    });\n    host.view.render(queryGraphButtonsEl, [\n      { view: "button", className: "subquery", tooltip: hintTooltip("Create a new query for a result of current one"), onClick() {\n        mutateGraph(({ nextGraph, last }) => {\n          if (!Array.isArray(last.children)) {\n            last.children = [];\n          }\n          last.query = currentQuery;\n          last.view = currentView;\n          nextGraph.current.push(last.children.push({}) - 1);\n          return {\n            query: "",\n            view: void 0,\n            graph: nextGraph\n          };\n        });\n      } },\n      { view: "button", className: "stash", tooltip: hintTooltip("Stash current query and create a new empty query for current parent"), onClick() {\n        mutateGraph(({ nextGraph, last, preLast }) => {\n          last.query = currentQuery;\n          last.view = currentView;\n          nextGraph.current[nextGraph.current.length - 1] = preLast.children.push({}) - 1;\n          return {\n            query: "",\n            view: void 0,\n            graph: nextGraph\n          };\n        });\n      } },\n      { view: "button", className: "clone", tooltip: hintTooltip("Clone current query"), onClick() {\n        mutateGraph(({ nextGraph, last, preLast }) => {\n          last.query = currentQuery;\n          last.view = currentView;\n          nextGraph.current[nextGraph.current.length - 1] = preLast.children.push({}) - 1;\n          return {\n            graph: nextGraph\n          };\n        });\n      } },\n      { view: "button", className: "delete", tooltip: hintTooltip("Delete current query and all the descendants"), onClick() {\n        mutateGraph(({ nextGraph, last, preLast }) => {\n          const index = preLast.children.indexOf(last);\n          let nextQuery = preLast.query;\n          preLast.children.splice(index, 1);\n          if (preLast.children.length === 0) {\n            preLast.children = void 0;\n          }\n          nextGraph.current.pop();\n          if (nextGraph.current.length === 0) {\n            const targetIndex = Math.max(0, Math.min(index - 1, (nextGraph.children?.length || 0) - 1));\n            nextGraph.current.push(targetIndex);\n            nextQuery = nextGraph.children?.[targetIndex]?.query;\n          }\n          return {\n            query: nextQuery,\n            graph: nextGraph\n          };\n        });\n      } }\n    ]);\n    queryEditorButtonsEl.append(\n      createElement("label", "view-checkbox", [\n        queryEditorLiveEditEl = createElement("input", {\n          class: "live-update",\n          type: "checkbox",\n          checked: true,\n          onchange: (e) => {\n            if (e.target.checked) {\n              updateParams({\n                query: queryEditor.getValue()\n              }, true);\n            }\n          }\n        }),\n        createElement("span", "view-checkbox__label", "process on input")\n      ])\n    );\n    host.view.render(queryEditorButtonsEl, {\n      view: "button-primary",\n      content: \'text:"Process"\',\n      onClick: () => {\n        computationCache = computationCache.slice(0, currentGraph.current.length - 1);\n        updateParams({\n          query: queryEditor.getValue()\n        }, true);\n        host.scheduleRender("page");\n      }\n    });\n    queryPathEl.addEventListener("click", (e) => {\n      const idx = [...queryPathEl.children].indexOf(e.target.closest(".query-path > *"));\n      if (idx !== -1) {\n        mutateGraph(({ nextGraph, currentPath, last }) => {\n          last.query = currentQuery;\n          nextGraph.current = nextGraph.current.slice(0, idx + 1);\n          updateParams({\n            query: currentPath[idx + 1].query,\n            graph: nextGraph\n          });\n        });\n      }\n    });\n    queryGraphEl.addEventListener("click", (e) => {\n      const path = e.target.dataset.path;\n      if (typeof path === "string" && path !== currentGraph.current.join(" ")) {\n        mutateGraph(({ nextGraph, last }) => {\n          const nextPath = path.split(" ").map(Number);\n          const nextGraphPath = getPathInGraph(nextGraph, nextPath);\n          const nextTarget = nextGraphPath[nextGraphPath.length - 1];\n          const nextQuery = nextTarget.query;\n          const nextView = nextTarget.view;\n          nextTarget.query = void 0;\n          nextTarget.view = void 0;\n          last.query = currentQuery;\n          last.view = currentView;\n          nextGraph.current = nextPath;\n          return {\n            query: nextQuery,\n            view: nextView,\n            graph: nextGraph\n          };\n        });\n      }\n    });\n    function mutateGraph(fn) {\n      const nextGraph = JSON.parse(JSON.stringify(currentGraph));\n      const currentPath = getPathInGraph(nextGraph, nextGraph.current);\n      const last = currentPath[currentPath.length - 1];\n      const preLast = currentPath[currentPath.length - 2];\n      const params = fn({ nextGraph, currentPath, last, preLast });\n      updateParams(params);\n      setTimeout(() => {\n        queryEditor.focus();\n        queryEditor.cm.setCursor(queryEditor.cm.lineCount(), 0);\n      }, 0);\n    }\n    function scheduleCompute(fn) {\n      const id = setTimeout(fn, 16);\n      return () => clearTimeout(id);\n    }\n    function syncInputData(computation) {\n      queryEditorInputEl.innerHTML = "";\n      queryEditorInputEl.append(\n        createElement("div", {\n          class: "query-input-data",\n          onclick() {\n            expandQueryInput = expandQueryInput === "data" ? false : "data";\n            syncExpandInputData(computation);\n          }\n        }, [\n          createElement("span", { class: "query-input-variable", "data-name": "input" }, ["@"]),\n          computation.state === "awaiting" ? "Computing..." : computation.state === "canceled" ? "Not available (undefined)" : valueDescriptor(computation.data)\n        ]),\n        createElement("div", {\n          class: "query-input-context",\n          onclick() {\n            expandQueryInput = expandQueryInput === "context" ? false : "context";\n            syncExpandInputData(computation);\n          }\n        }, [\n          createElement("span", { class: "query-input-variable", "data-name": "context" }, ["#"]),\n          computation.state === "awaiting" ? "Computing..." : computation.state === "canceled" ? "Not available (undefined)" : valueDescriptor(computation.context)\n        ])\n      );\n      syncExpandInputData(computation);\n    }\n    function syncExpandInputData(computation) {\n      queryEditor.inputPanelEl.classList.toggle("details-expanded", expandQueryInput);\n      queryEditorInputEl.dataset.details = expandQueryInput;\n      if (expandQueryInput) {\n        const newData = computation.state !== "awaiting" && computation.state !== "canceled" ? computation[expandQueryInput] : NaN;\n        if (newData !== expandQueryInputData) {\n          expandQueryInputData = newData;\n          if (computation.state === "awaiting") {\n            queryEditorInputDetailsEl.textContent = "Computing...";\n          } else if (computation.state === "canceled") {\n            queryEditorInputDetailsEl.textContent = "Not available because one of ancestor queries failed";\n          } else {\n            queryEditorInputDetailsEl.innerHTML = "";\n            host.view.render(\n              queryEditorInputDetailsEl,\n              [\n                { view: "struct", expanded: 1 }\n              ],\n              expandQueryInputData\n            );\n          }\n        }\n      } else {\n        expandQueryInputData = NaN;\n        queryEditorInputDetailsEl.innerHTML = "";\n      }\n    }\n    function renderOutputExpander(computation, prelude, message) {\n      if (!message) {\n        message = prelude;\n        prelude = null;\n      }\n      const content = [\n        createElement("span", "query-output-message", Array.isArray(message) ? message : [message])\n      ];\n      if (prelude) {\n        content.unshift(createElement("span", "query-output-prelude", [prelude]));\n      }\n      queryEditorResultEl.replaceChildren(\n        createElement("div", {\n          class: "query-result-data" + (computation.state === "failed" ? " error" : ""),\n          onclick() {\n            expandQueryResults = !expandQueryResults;\n            syncExpandOutputData(computation);\n          }\n        }, content)\n      );\n    }\n    function syncOutputData(computation) {\n      if (errorMarker) {\n        errorMarker.clear();\n        errorMarker = null;\n      }\n      switch (computation.state) {\n        case "canceled": {\n          queryEditor.setValue(computation.query);\n          renderOutputExpander(computation, "Result", "Not available");\n          break;\n        }\n        case "awaiting": {\n          queryEditor.setValue(computation.query);\n          renderOutputExpander(computation, "Avaiting...");\n          break;\n        }\n        case "computing": {\n          queryEditor.setValue(computation.query, computation.data, computation.context);\n          renderOutputExpander(computation, "Computing...");\n          break;\n        }\n        case "successful": {\n          queryEditor.setValue(computation.query, computation.data, computation.context);\n          renderOutputExpander(computation, "Result", [\n            valueDescriptor(computation.computed),\n            ` in ${parseInt(computation.duration, 10)}ms`\n          ]);\n          break;\n        }\n        case "failed": {\n          const { error } = computation;\n          const loc = error.details && error.details.loc;\n          const doc = queryEditor.cm.doc;\n          if (loc) {\n            const [start, end] = error.details.loc.range;\n            errorMarker = error.details.token === "EOF" || start === end || computation.query[start] === "\\n" ? doc.setBookmark(\n              doc.posFromIndex(start),\n              { widget: createElement("span", "discovery-editor-error", " ") }\n            ) : doc.markText(\n              doc.posFromIndex(start),\n              doc.posFromIndex(end),\n              { className: "discovery-editor-error" }\n            );\n          }\n          queryEditor.setValue(computation.query, computation.data, computation.context);\n          renderOutputExpander(computation, "Error", [\n            error.message.split(/\\n/)[0].replace(/^(Parse error|Bad input).+/s, "Parse error")\n          ]);\n          break;\n        }\n      }\n      syncExpandOutputData(computation);\n    }\n    function syncExpandOutputData(computation) {\n      queryEditor.outputPanelEl.classList.toggle("details-expanded", expandQueryResults);\n      if (expandQueryResults) {\n        const newData = computation.state !== "awaiting" && computation.state !== "canceled" && computation.state !== "computing" ? computation.error || computation.computed : NaN;\n        if (newData !== expandQueryResultData) {\n          expandQueryResultData = newData;\n          switch (computation.state) {\n            case "awaiting":\n              queryEditorResultDetailsEl.innerHTML = \'<div class="state-message">Awaiting for all of ancestor queries done<div>\';\n              break;\n            case "canceled":\n              queryEditorResultDetailsEl.innerHTML = \'<div class="state-message">Not available because one of ancestor queries failed<div>\';\n              break;\n            case "failed":\n              queryEditorResultDetailsEl.innerHTML = \'<div class="discovery-error query-error">\' + escapeHtml2(computation.error.message) + "</div>";\n              break;\n            case "successful":\n              queryEditorResultDetailsEl.innerHTML = "";\n              host.view.render(queryEditorResultDetailsEl, { view: "struct", expanded: 1 }, expandQueryResultData);\n              break;\n          }\n        }\n      } else {\n        expandQueryResultData = NaN;\n        queryEditorResultDetailsEl.innerHTML = "";\n      }\n    }\n    function syncComputeState(computation) {\n      const path = computation.path.join(" ");\n      const graphNodeEl = queryGraphEl.querySelector(`[data-path="${path}"]`);\n      if (graphNodeEl) {\n        graphNodeEl.dataset.state = computation.state;\n      }\n      if (computationCache[currentGraph.current.length - 1] === computation) {\n        syncInputData(computation);\n        syncOutputData(computation);\n      }\n    }\n    function compute(computeIndex, computeData, computeContext, first) {\n      if (scheduledCompute) {\n        scheduledCompute.cancel();\n        scheduledCompute.computation.state = "canceled";\n        scheduledCompute = null;\n      }\n      let computeError = false;\n      if (first) {\n        for (let i = computeIndex; i < currentGraph.current.length; i++) {\n          const computation = computationCache[i];\n          if (computation.state !== "computing") {\n            syncComputeState(computation);\n          }\n        }\n      }\n      for (let i = computeIndex; i < currentGraph.current.length; i++) {\n        const computation = computationCache[i];\n        const isTarget = i === currentGraph.current.length - 1;\n        if (computation.state === "awaiting") {\n          computation.state = "computing";\n        }\n        if (computation.state === "failed") {\n          computeError = true;\n        } else if (computeError) {\n          computation.state = "canceled";\n        }\n        if (computation.state !== "computing") {\n          computeData = computation.computed;\n          computeContext = computation.context;\n          syncComputeState(computation);\n          if (isTarget) {\n            return Promise.resolve(computation);\n          }\n          continue;\n        }\n        return new Promise((resolve, reject) => {\n          computation.data = computeData;\n          computation.context = computeContext;\n          syncComputeState(computation);\n          scheduledCompute = {\n            computation,\n            cancel: scheduleCompute(() => {\n              let startTime = Date.now();\n              scheduledCompute = null;\n              try {\n                computation.computed = host.query(computation.query, computation.data, computation.context);\n                computation.state = "successful";\n              } catch (error) {\n                computation.error = error;\n                computation.state = "failed";\n              }\n              computation.duration = Date.now() - startTime;\n              compute(\n                i,\n                computeData,\n                computeContext\n              ).then(resolve, reject);\n            })\n          };\n        });\n      }\n    }\n    function makeComputationPlan(computeData, computeContext) {\n      const graphPath = getPathInGraph(currentGraph, currentGraph.current).slice(1);\n      let firstComputation = -1;\n      let computeError = null;\n      for (let i = 0; i < currentGraph.current.length; i++) {\n        const graphNode = graphPath[i];\n        const cache = computationCache[i] || {};\n        const isTarget = i === currentGraph.current.length - 1;\n        const computeQuery = isTarget ? currentQuery : graphNode.query;\n        const computePath = currentGraph.current.slice(0, i + 1);\n        if (firstComputation === -1 && cache.query === computeQuery && cache.data === computeData && cache.context === computeContext && String(cache.path) === String(computePath)) {\n          computeData = cache.computed;\n          computeError = cache.error;\n          continue;\n        }\n        const computation = computationCache[i] = {\n          state: "awaiting",\n          path: currentGraph.current.slice(0, i + 1),\n          query: computeQuery,\n          data: void 0,\n          context: void 0,\n          computed: void 0,\n          error: null,\n          duration: 0\n        };\n        if (computeError) {\n          computation.state = "canceled";\n          continue;\n        }\n        if (firstComputation === -1) {\n          firstComputation = i;\n          computation.state = "computing";\n          computation.data = computeData;\n          computation.context = computeContext;\n          continue;\n        }\n      }\n      return firstComputation !== -1 ? computationCache.slice(firstComputation, currentGraph.current.length) : [];\n    }\n    return {\n      el: queryEditorFormEl,\n      perform(data, context) {\n        const queryContext = contextWithoutEditorParams(context, currentContext);\n        const pageQuery = context.params.query;\n        const pageView = context.params.view;\n        const pageGraph = { ...context.params.graph || defaultGraph };\n        normalizeGraph(pageGraph);\n        queryGraphEl.innerHTML = "";\n        buildQueryGraph(queryGraphEl, pageGraph, host);\n        queryPathEl.innerHTML = "";\n        for (const node of getPathInGraph(pageGraph, pageGraph.current).slice(1, -1)) {\n          queryPathEl.append(createElement("div", "query", node.query || ""));\n        }\n        currentGraph = pageGraph;\n        currentContext = queryContext;\n        currentQuery = pageQuery;\n        currentView = pageView;\n        makeComputationPlan(data, queryContext);\n        return compute(0, data, queryContext, true);\n      }\n    };\n  }\n  var init_editor_query = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/discover/editor-query.js"() {\n      init_dom();\n      init_html();\n      init_layout();\n      init_params();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/views/_usage.js\n  function isTextNode(node) {\n    return Boolean(node && node.nodeType === Node.TEXT_NODE);\n  }\n  function childrenHtml(node, level = "\\n") {\n    let res = "";\n    for (const child of node.childNodes) {\n      if (!isTextNode(child) && child.previousSibling && !isTextNode(child.previousSibling)) {\n        res += level;\n      }\n      res += nodeHtml(child, level);\n    }\n    return res;\n  }\n  function nodeHtml(node, level = "\\n") {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        const [start, end = ""] = node.cloneNode().outerHTML.split(/(?=<\\/[^>]+>$)/);\n        return start + (node.firstChild && !isTextNode(node.firstChild) ? level + "  " : "") + childrenHtml(node, level + "  ") + (node.lastChild && !isTextNode(node.lastChild) ? level : "") + end;\n      case Node.TEXT_NODE:\n        return node.nodeValue;\n      case Node.COMMENT_NODE:\n        return "<!--" + node.nodeValue + "-->";\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        return childrenHtml(node, level);\n    }\n    return "";\n  }\n  function highlightRefs(data, content) {\n    const refs = [];\n    const highlights = [\n      ...Array.isArray(data.highlight) ? data.highlight : data.highlight ? [data.highlight] : []\n    ];\n    if (Array.isArray(data.highlightProps)) {\n      highlights.push(`(")?(?:${data.highlightProps.join("|")})\\\\1(?=:)`);\n    }\n    for (const highlight of highlights) {\n      const rx = new RegExp(highlight, "gm");\n      let match2;\n      while (match2 = rx.exec(content)) {\n        refs.push({ range: [match2.index, match2.index + match2[0].length] });\n      }\n    }\n    return refs;\n  }\n  function usage_default(host) {\n    const renderDemo = {\n      view: "context",\n      modifiers: [\n        {\n          view: "switch",\n          when: "beforeDemo",\n          content: [\n            { when: ({ beforeDemo }) => typeof beforeDemo === "string", content: \'html:"<p>" + beforeDemo + "</p>"\' },\n            { content: {\n              view: "render",\n              config: "beforeDemo",\n              context: "{ __demoContext: true, ...(viewDef | { name, group, options }) }"\n            } }\n          ]\n        },\n        {\n          view: "block",\n          when: "demo or view",\n          className: "usage-render",\n          postRender: (el, { onInit }, { demoFixed }) => {\n            if (demoFixed) {\n              el.classList.add("demo-fixed");\n              el.style.height = demoFixed + "px";\n            }\n            onInit(el, "root");\n          },\n          content: {\n            view: "render",\n            config: "demo or view",\n            data: "demoData",\n            context: "{ __demoContext: true, ...(viewDef | { name, group, options }) }"\n          }\n        },\n        {\n          view: "switch",\n          when: "afterDemo",\n          content: [\n            { when: ({ afterDemo }) => typeof afterDemo === "string", content: \'html:"<p>" + afterDemo + "</p>"\' },\n            { content: {\n              view: "render",\n              config: "afterDemo",\n              context: "{ __demoContext: true, ...(viewDef | { name, group, options }) }"\n            } }\n          ]\n        }\n      ],\n      content: {\n        view: "tabs",\n        when: "source != false",\n        className: "usage-sources",\n        name: "code",\n        tabs: [\n          { value: "config", text: "Config (JS)" },\n          { value: "config-json", text: "Config (JSON)" },\n          { value: "html", text: "Rendered HTML" }\n        ],\n        content: {\n          view: "switch",\n          content: [\n            { when: \'#.code="config"\', content: [{\n              view: "expand",\n              when: \'"demoData" in $\',\n              header: \'text:"Input data"\',\n              content: {\n                view: "struct",\n                expanded: 2,\n                data: "demoData"\n              }\n            }, {\n              view: "source",\n              className: "first-tab",\n              data: (data) => {\n                const content = jsonStringifyAsJavaScript(data.demo || data.view);\n                return {\n                  syntax: "discovery-view",\n                  content,\n                  refs: highlightRefs(data, content)\n                };\n              }\n            }] },\n            { when: \'#.code="config-json"\', content: [{\n              view: "expand",\n              when: \'"demoData" in $\',\n              header: \'text:"Input data"\',\n              content: {\n                view: "struct",\n                expanded: 2,\n                data: "demoData"\n              }\n            }, {\n              view: "source",\n              data: (data) => {\n                const content = JSON.stringify(data.demo || data.view, null, 4);\n                return {\n                  syntax: "json",\n                  content,\n                  refs: highlightRefs(data, content)\n                };\n              }\n            }] },\n            { when: \'#.code="html"\', content: {\n              view: "source",\n              data: (data, context) => ({\n                syntax: "html",\n                content: childrenHtml(context.root)\n              })\n            } }\n          ]\n        }\n      }\n    };\n    return {\n      view: "block",\n      className: "discovery-view-usage",\n      data({ name, options: options2 }, context) {\n        const group = [...host.view.values].filter((view) => view.options.usage === options2.usage).map((view) => view.name);\n        if (!group.includes(name)) {\n          group.unshift(name);\n        }\n        return context.viewDef = {\n          demo: { view: name, data: \'"\' + name + \'"\' },\n          ...typeof options2.usage === "function" ? options2.usage(name, group) : Array.isArray(options2.usage) ? { examples: options2.usage } : options2.usage,\n          name,\n          group,\n          options: options2\n        };\n      },\n      content: [\n        "h1:name",\n        renderDemo,\n        {\n          view: "list",\n          data: "examples",\n          whenData: true,\n          itemConfig: {\n            className: "usage-section"\n          },\n          item: [\n            "h2{ anchor: true, data: title }",\n            renderDemo\n          ]\n        }\n      ]\n    };\n  }\n  var init_usage = __esm({\n    "node_modules/@discoveryjs/discovery/src/views/_usage.js"() {\n      init_json2();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/discover/editor-view.js\n  function createPresetTab(name, content, updateParams) {\n    return createElement("div", {\n      class: "discovery-editor-tab",\n      onclick: () => updateParams({\n        view: content\n        // JSON.stringify(content, null, 4)\n      })\n    }, name || "Untitled preset");\n  }\n  function editor_view_default(host, updateParams) {\n    let lastView = {};\n    const viewPresets = Array.isArray(host.options.viewPresets) ? defaultViewPresets.concat(host.options.viewPresets) : defaultViewPresets;\n    let viewSetupEl;\n    let availableViewsEl;\n    let availableViewsTextEl;\n    let availableViewsListEl;\n    let viewModeTabsEls;\n    let viewLiveEditEl;\n    const viewEditor = new host.view.ViewEditor(host).on(\n      "change",\n      (value) => viewLiveEditEl.checked && updateParams({ view: value }, true)\n    );\n    const viewEditorButtonsEl = createElement("div", "buttons");\n    const viewEditorFormEl = createElement("div", "form view-editor-form", [\n      createElement("div", "view-editor-form-header", [\n        createElement("div", "discovery-editor-tabs view-mode", viewModeTabsEls = ["Default", "Custom"].map(\n          (viewMode) => createElement("div", {\n            class: "discovery-editor-tab",\n            "data-mode": viewMode.toLowerCase(),\n            onclick: () => updateParams({\n              view: viewMode === "Default" ? void 0 : defaultViewSource\n            }, true)\n          }, viewMode)\n        )),\n        /* availablePresetListEl = */\n        createElement("div", "discovery-editor-tabs presets", viewPresets.map(\n          ({ name, content }) => createPresetTab(name, content, updateParams)\n        )),\n        createElement("div", "view-editor-form-header-links", \'<a href="#views-showcase" class="view-link">Views showcase</a>\')\n      ]),\n      viewSetupEl = createElement("div", {\n        class: "view-editor-form-content",\n        hidden: true\n      }, [\n        createElement("button", {\n          class: "view-button formatting",\n          title: "Prettify (input should be a JSON)",\n          onclick() {\n            viewEditor.focus();\n            try {\n              const currentText = viewEditor.getValue().trim();\n              const json = new Function("return 0," + currentText)();\n              updateParams({\n                view: jsonStringifyAsJavaScript(json)\n              });\n            } catch (e) {\n              host.log("error", "View editor prettify failed:", e);\n            }\n          }\n        }),\n        viewEditor.el,\n        createElement("div", "editor-toolbar", [\n          availableViewsEl = createElement("div", "view-expand", [\n            createElement("div", {\n              class: "header",\n              onclick: () => {\n                availableViewsEl.classList.toggle("expanded");\n                availableViewsListEl.classList.toggle("visible");\n              }\n            }, [\n              availableViewsTextEl = createElement("div", "header-content"),\n              createElement("div", "trigger")\n            ]),\n            availableViewsListEl = createElement("div", "view-editor-view-list")\n          ]),\n          createElement("label", "view-checkbox", [\n            viewLiveEditEl = createElement("input", {\n              class: "live-update",\n              type: "checkbox",\n              checked: true,\n              onchange: (e) => {\n                if (e.target.checked) {\n                  updateParams({ view: viewEditor.getValue() }, true);\n                }\n              }\n            }),\n            createElement("span", "view-checkbox__label", "build on input")\n          ]),\n          viewEditorButtonsEl\n        ])\n      ])\n    ]);\n    host.view.render(viewEditorButtonsEl, {\n      view: "button-primary",\n      content: \'text:"Build"\',\n      onClick: () => {\n        lastView = {};\n        updateParams({\n          view: viewEditor.getValue()\n        }, true);\n        host.scheduleRender("page");\n      }\n    });\n    new host.view.Popup({\n      className: "view-editor-view-list-hint",\n      hoverTriggers: ".view-editor-view-list .item.with-usage",\n      // hoverPin: \'trigger-click\',\n      render: function(popupEl, triggerEl) {\n        host.view.render(popupEl, usage_default(host), host.view.get(triggerEl.textContent), {});\n      }\n    });\n    availableViewsTextEl.textContent = `Available ${[...host.view.entries].filter(([, view]) => view.options.usage).length} views`;\n    const updateAvailableViewList = () => availableViewsListEl.innerHTML = \'<a href="#views-showcase" class="view-link">Views showcase</a><br><br>\' + [...host.view.entries].sort().map(([name, view]) => `<div><a class="item view-link${view.options.usage ? " with-usage" : ""}" ${view.options.usage ? \'href="#views-showcase:\' + name + \'"\' : ""}>${name}</a></div>`).join("");\n    updateAvailableViewList();\n    host.view.on("define", debounce(updateAvailableViewList, 100));\n    return {\n      el: viewEditorFormEl,\n      render(data, context, discoveryContentEl) {\n        const viewContext = contextWithoutEditorParams(context, lastView.context);\n        const viewMode = typeof context.params.view === "string" ? "custom" : "default";\n        let pageView = context.params.view;\n        let view = null;\n        viewEditor.setValue(pageView);\n        viewSetupEl.hidden = viewMode !== "custom";\n        viewModeTabsEls.forEach(\n          (el) => el.classList.toggle("active", el.dataset.mode === viewMode)\n        );\n        if (!pageView && viewMode === "default") {\n          pageView = defaultViewSource;\n        }\n        if (lastView.view !== pageView || lastView.data !== data || lastView.context !== viewContext) {\n          discoveryContentEl.innerHTML = "";\n          try {\n            view = Function("return " + (pageView ? "0," + pageView : "null"))();\n            host.view.render(discoveryContentEl, view, data, viewContext);\n          } catch (e) {\n            host.view.render(discoveryContentEl, (el) => {\n              el.className = "discovery-error render-error";\n              el.innerHTML = escapeHtml2(String(e)) + "<br>(see details in console)";\n              host.log("error", e);\n            });\n          }\n          lastView = {\n            data,\n            context: viewContext,\n            view: pageView\n          };\n        }\n      }\n    };\n  }\n  var defaultViewSource, defaultViewPresets;\n  var init_editor_view = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/discover/editor-view.js"() {\n      init_debounce();\n      init_dom();\n      init_html();\n      init_json2();\n      init_params();\n      init_usage();\n      defaultViewSource = "{\\n    view: \'struct\',\\n    expanded: 1\\n}";\n      defaultViewPresets = [\n        {\n          name: "Table",\n          content: jsonStringifyAsJavaScript({\n            view: "table"\n          })\n        },\n        {\n          name: "Auto-link list",\n          content: jsonStringifyAsJavaScript({\n            view: "ol",\n            item: "auto-link"\n          })\n        },\n        {\n          name: "Signature",\n          content: jsonStringifyAsJavaScript({\n            view: "signature",\n            expanded: 2\n          })\n        }\n      ];\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/discover.js\n  function discover_default(host) {\n    function updateParams(delta, replace) {\n      return host.setPageParams({\n        ...host.pageParams,\n        ...delta\n      }, replace);\n    }\n    function get() {\n      if (refs !== null) {\n        return refs;\n      }\n      const header = header_default(host, updateParams);\n      const queryEditor = editor_query_default(host, updateParams);\n      const viewEditor = editor_view_default(host, updateParams);\n      const discoverEditorEl = createElement("div", { class: "discovery-editor discovery-hidden-in-dzen", hidden: true }, [\n        queryEditor.el,\n        viewEditor.el\n      ]);\n      const discoverContentEl = createElement("div", "discovery-content");\n      const layout = [\n        ...header.el,\n        discoverEditorEl,\n        discoverContentEl\n      ];\n      return refs = {\n        header,\n        queryEditor,\n        viewEditor,\n        discoverEditorEl,\n        discoverContentEl,\n        layout\n      };\n    }\n    let refs = null;\n    let lastRequest = null;\n    host.page.define("discovery", function(el, data, context) {\n      const {\n        header,\n        queryEditor,\n        viewEditor,\n        discoverEditorEl,\n        discoverContentEl\n      } = get();\n      discoverEditorEl.hidden = context.params.noedit;\n      header.render(data, context);\n      const request = lastRequest = {};\n      queryEditor.perform(data, context).then((queryResult) => {\n        if (lastRequest !== request) {\n          return;\n        }\n        if (queryResult.error) {\n          viewEditor.el.hidden = true;\n          discoverContentEl.hidden = true;\n          return;\n        }\n        viewEditor.el.hidden = false;\n        discoverContentEl.hidden = false;\n        viewEditor.render(\n          queryResult.computed,\n          /* queryResult.context */\n          context,\n          discoverContentEl\n        );\n      });\n    }, {\n      reuseEl: true,\n      init(el) {\n        get().layout.forEach((child) => el.appendChild(child));\n      },\n      encodeParams,\n      decodeParams\n    });\n  }\n  var init_discover = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/discover.js"() {\n      init_dom();\n      init_params();\n      init_header();\n      init_editor_query();\n      init_editor_view();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/views-showcase.js\n  function views_showcase_default(host) {\n    host.page.define("views-showcase", {\n      view: "context",\n      data: () => [...host.view.values],\n      modifiers: [\n        {\n          view: "block",\n          className: "sidebar",\n          content: {\n            view: "content-filter",\n            content: {\n              view: "menu",\n              name: "view",\n              limit: false,\n              data: `\n                            .[name ~= #.filter]\n                            .sort(name asc)\n                            .({ ..., disabled: no options.usage })\n                        `,\n              item: "text-match:{ text: name, match: #.filter }"\n            }\n          }\n        }\n      ],\n      content: {\n        view: "block",\n        className: "content",\n        data: "$[=> name=(#.view.name or #.id)]",\n        content: {\n          view: "switch",\n          content: [\n            { when: "no $ and #.id", content: \'alert-warning:"View \\\\"" + #.id + "\\\\" not found"\' },\n            { when: "no $", content: [\n              \'h1:"Views showcase"\',\n              \'alert:"\\u2190 Select a view to get details"\',\n              { view: "markdown", source: intro }\n            ] },\n            { content: [\n              { view: "context", postRender: function(el, config, data, context) {\n                host.setPageRef(data.name);\n                host.cancelScheduledRender();\n                context.id = host.pageRef;\n              } },\n              usage_default(host)\n            ] }\n          ]\n        }\n      }\n    }, {\n      sidebar: false\n    });\n  }\n  var intro;\n  var init_views_showcase = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/views-showcase.js"() {\n      init_usage();\n      intro = `\n## Working with views\n\nIn Discovery.js, a presentation is set up as a tree of views.\nThere are several ways to define a view, each suitable for different cases.\nThe primary notation is an object, and all other notations are converted to it.\nThe only required property is \\`view\\`, which defines the view\'s name. Any other properties are optional.\n\n\\`\\`\\`discovery-view\n{\n    view: "view-name"\n}\n\\`\\`\\`\n\nThe following properties are supported by any view:\n\n- \\`when\\`: Controls view rendering (should it be rendered or not) before input data is transformed (\\`data\\` is applied).\n- \\`data\\`: Transforms input data for the view and its nested views.\n- \\`whenData\\`: Controls view rendering after input data is transformed.\n- \\`className\\`: Adds class name(s) to the root element of the view if any.\n- \\`postRender\\`: A function to be invoked after view rendering but before placing it in the destination place in the DOM.\n- \\`tooltip\\`: Sets up a tooltip to show on view hovering; can be applied for views with a container only.\n\nThe order of evaluation during view rendering:\n\n\\`\\`\\`js\n                          input data | output data (the result of "data" evaluation if any)\n                                     |\nrender start ---> [when] --> [data] -|-> [whenData] --> [postRender] --> [className] --> render finish\n                                     |\n\\`\\`\\`\n\nWhen the \\`data\\` property is specified, it changes the flow\'s data according to the following rules:\n\n- A string: Treated as a query whose result is used as the output data.\n- A function like \\`fn(data, context)\\`: The result of the function invocation is used as the output data.\n- Any other value is used as the output data.\n\n> Note: Only \\`when\\` and \\`data\\` properties receive input data; any other functions and queries receive the result of the \\`data\\` property evaluation. When \\`data\\` is not specified, all queries and functions receive the same input data.\n\nProperties \\`when\\` and \\`whenData\\` can take:\n\n- A string: Treated as a query.\n- \\`true\\`: Treated as an empty query, which means that the data itself is examined with no transformation.\n- \\`undefined\\`: Same as when not specified; just render (ignore the property).\n- A function like \\`fn(data, context)\\`.\n- Any other value is used as is.\n\nRegardless of how the value is obtained, it is coerced to a boolean.\nPlease note that Jora rules are used, which means that empty arrays and objects with no own keys are falsy (truthy in JavaScript).\nThe view is only rendered if the resulting value is truthy.\n\n## Queries for properties\n\nIn some cases, it is necessary to compute the value of a property based on the data.\nTo do this, you can use a string value for a property that starts with \\`=\\`.\nThis means that everything after the \\`=\\` is a query that will take output data and produce a value for the property.\nOther values are passed to the view render as is, without any changes.\n\nFor example, limit the number of items rendered at once only if there are more than 12 items:\n\n\\`\\`\\`discovery-view\n{\n    view: \'list\',\n    limit: \'=size() <= 12 ? false : 10\'\n}\n\\`\\`\\`\n\n> Note: In those rare cases when you need to pass a property a string that starts with \\`=\\`, you can use a query like \\`"=some string"\\`, e.g., \\`{ view: \'example\', prop: \'="=string="\' }\\`.\n\n## Shorthand notations\n\n| Shorthand notation | Expands into... |\n| --- | --- |\n| \\`\'name\'\\` | \\`{ view: \'name\' }\\`\n| \\`\'name:<query>\'\\` | \\`{ view: \'name\', data: \'<query>\' }\\`\n| \\`\'name{ foo: size() / 2, bar: "qux" }\'\\` | \\`{ view: \'name\', foo: \'=size() / 2\', bar: \'qux\' }\\`\n\n## List of views\n\nIf you need to specify a list of views, you must use an array.\nAn array with view definitions can be passed anywhere a view is accepted as a value.\n\n\\`\\`\\`discovery-view\n[\n    {\n        view: \'list\',\n        item: [\n            \'text:name\',\n            { view: \'badge\', data: \'something.size()\' }\n        ]\n    },\n    \'table{ limit: 10 }\'\n]\n\\`\\`\\`\n\n## Tooltip\n\nA canonical form for a tooltip setup is an object with fields (all are optional, defaults provided below):\n\n\\`\\`\\`js\n{\n    className: \'string\',     // additional class names for tooltip\'s element\n    position: \'pointer\',     // \'trigger\' or \'pointer\'\n    positionMode: \'natural\', // \'safe\' or \'natural\'\n    pointerOffsetX: 3,       // tooltip offset from the pointer\n    pointerOffsetY: 3,       // tooltip offset from the pointer\n    showDelay: true,         // true (300ms), false (0ms), a number, or a function which takes a triggerEl and returns showDelay value\n    content: \'a view config\' // view config for tooltip\'s content\n}\n\\`\\`\\`\n\nInstead of such an object, any view notation can be used, i.e., a string, an object with a \\`view\\` property, an array, or a function:\n\n| Shorthand notation | Expands into... |\n| --- | --- |\n| \\`\'name\'\\` | \\`{ content: \'name\' }\\`\n| \\`{ view: \'name\' }\\` | \\`{ content: { view: \'name\' } }\\`\n| \\`[\'view\', { view: \'name\' }]\\` | \\`{ content: [\'view\', { view: \'name\' }] }\\`\n\nThe content is rendered into a popup container. When \\`className\\` is used, it behaves the same as for a view but applies to a popup container.\n`;\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/pages/index.js\n  var pages_exports = {};\n  __export(pages_exports, {\n    default: () => default_default2,\n    discover: () => discover_default,\n    notFound: () => not_found_default,\n    viewsShowcase: () => views_showcase_default\n  });\n  var init_pages = __esm({\n    "node_modules/@discoveryjs/discovery/src/pages/index.js"() {\n      init_default2();\n      init_not_found();\n      init_discover();\n      init_views_showcase();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/nav/buttons.js\n  var buttons_exports = {};\n  __export(buttons_exports, {\n    darkmodeToggle: () => darkmodeToggle,\n    discoveryPage: () => discoveryPage,\n    indexPage: () => indexPage,\n    inspect: () => inspect,\n    loadData: () => loadData\n  });\n  function indexPage(host) {\n    host.nav.append({\n      name: "index-page",\n      when: "#.widget | pageId != defaultPageId",\n      data: \'{ text: "Index", href: pageLink(#.widget.defaultPageId) }\'\n    });\n  }\n  function discoveryPage(host) {\n    host.nav.append({\n      name: "discovery-page",\n      when: "#.widget | pageId != discoveryPageId",\n      data: \'{ text: "Discover", href: pageLink(#.widget.discoveryPageId) }\'\n    });\n  }\n  function loadData(host) {\n    host.nav.append({\n      name: "load-data",\n      when: "#.actions.uploadFile and (#.datasets or (#.widget | pageId != defaultPageId))",\n      content: \'text:"Open file\\u2026"\',\n      onClick: "=#.actions.uploadFile"\n    });\n  }\n  function darkmodeToggle(host) {\n    let detachToggleDarkMode = () => {\n    };\n    host.nav.menu.append({\n      view: "block",\n      className: ["toggle-menu-item", "dark-mode-switcher"],\n      name: "dark-mode",\n      when: \'#.widget | darkmode.mode not in ["disabled", "only"]\',\n      postRender: (el, opts, data, { widget, hide }) => {\n        let selfValue;\n        detachToggleDarkMode();\n        detachToggleDarkMode = widget.darkmode.subscribe((value, mode) => {\n          const newValue = mode === "auto" ? "auto" : value;\n          if (newValue === selfValue) {\n            return;\n          }\n          el.innerHTML = "";\n          selfValue = newValue;\n          widget.view.render(el, {\n            view: "toggle-group",\n            beforeToggles: \'text:"Color schema"\',\n            onChange: (value2) => {\n              selfValue = value2;\n              widget.darkmode.set(value2);\n              hide();\n            },\n            value: newValue,\n            data: [\n              { value: false, text: "Light" },\n              { value: true, text: "Dark" },\n              { value: "auto", text: "Auto" }\n            ]\n          }, null, { widget });\n        }, true);\n      }\n    });\n  }\n  function inspect(host) {\n    const suspendSeconds = 3;\n    let suspendInspectTimer = null;\n    let suspendInspectSeconds = 0;\n    host.nav.append({\n      name: "inspect",\n      tooltip: {\n        position: "trigger",\n        showDelay: true,\n        content: \'md:"**Enable view inspection**<br>To suspend enabling inspect mode by \' + suspendSeconds + \' seconds,<br>click the button with Cmd (\\u2318) or Ctrl-key"\'\n      },\n      onClick: (el, data, context, event) => {\n        if (!host.inspectMode.value && (event.metaKey || event.ctrlKey)) {\n          if (suspendInspectTimer === null) {\n            suspendInspectSeconds = 0;\n            suspendInspectTimer = setTimeout(function tick() {\n              suspendInspectSeconds--;\n              if (suspendInspectSeconds === 0) {\n                suspendInspectTimer = null;\n                delete el.dataset.suspendSeconds;\n                host.inspectMode.set(true);\n              } else {\n                suspendInspectTimer = setTimeout(tick, 1e3);\n                el.dataset.suspendSeconds = suspendInspectSeconds;\n              }\n            }, 1e3);\n          }\n          suspendInspectSeconds += suspendSeconds;\n          el.dataset.suspendSeconds = suspendInspectSeconds;\n        } else if (suspendInspectTimer !== null) {\n          clearTimeout(suspendInspectTimer);\n          suspendInspectTimer = null;\n          delete el.dataset.suspendSeconds;\n        } else {\n          host.view.tooltip?.hide();\n          host.inspectMode.set(!host.inspectMode.value);\n        }\n      }\n    });\n  }\n  var init_buttons = __esm({\n    "node_modules/@discoveryjs/discovery/src/nav/buttons.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/nav/index.js\n  function createNavArray(host, defaults2) {\n    const items = [];\n    const insert = (config, position, ref) => {\n      switch (position) {\n        case "after":\n          position = items.findIndex((item) => item.name === ref);\n          if (position === -1) {\n            position = items.length;\n          } else {\n            position++;\n          }\n          break;\n        case "before":\n          position = items.findIndex((item) => item.name === ref);\n          if (position === -1) {\n            position = items.length;\n          }\n          break;\n        default:\n          if (position === void 0 || isNaN(position) || !isFinite(position)) {\n            position = items.length;\n          }\n      }\n      items.splice(Math.max(0, Math.min(items.length, position)), 0, host.view.composeConfig(defaults2, config));\n    };\n    return Object.assign(items, {\n      insert,\n      prepend(config) {\n        insert(config, 0);\n      },\n      append(config) {\n        insert(config);\n      },\n      before(name, config) {\n        insert(config, "before", name);\n      },\n      after(name, config) {\n        insert(config, "after", name);\n      },\n      replace(name, config) {\n        const position = items.findIndex((item) => item.name === name);\n        if (position !== -1) {\n          items[position] = config;\n        } else {\n          insert(config);\n        }\n      },\n      remove(name) {\n        const position = items.findIndex((item) => item.name === name);\n        if (position !== -1) {\n          return items.splice(position, 1)[0];\n        }\n      }\n    });\n  }\n  var WidgetNavigation;\n  var init_nav = __esm({\n    "node_modules/@discoveryjs/discovery/src/nav/index.js"() {\n      init_dom();\n      init_size();\n      init_version();\n      init_buttons();\n      WidgetNavigation = class {\n        constructor(host) {\n          const poweredByDiscovery = createElement("div", "powered-by-discoveryjs", [\n            "powered by ",\n            createElement("a", {\n              class: "view-link",\n              href: "https://github.com/discoveryjs/discovery",\n              target: "_blank"\n            }, "Discovery.js"),\n            ` ${version}`\n          ]);\n          this.host = host;\n          this.popup = null;\n          this.data = null;\n          this.context = null;\n          this.primary = createNavArray(host, "nav-button");\n          this.secondary = createNavArray(host, "nav-button");\n          this.menu = createNavArray(host, "menu-item");\n          this.config = [\n            this.secondary,\n            {\n              view: "nav-button",\n              name: "burger",\n              data: () => {\n                const fragment = createFragment();\n                return this.host.view.render(fragment, this.menu, this.host.data, {\n                  ...this.context,\n                  hide: () => this.popup && this.popup.hide()\n                }).then(() => [...fragment.childNodes].filter((node) => node.nodeType === 1 || node.nodeType === 3));\n              },\n              whenData: true,\n              onClick: (el, nodes2) => {\n                if (!this.popup) {\n                  this.popup = new this.host.view.Popup({\n                    className: "discovery-nav-popup"\n                  });\n                  this.popup.el.addEventListener("click", ({ target }) => {\n                    if (target.closest("a[href]")) {\n                      setTimeout(() => this.popup.hide(), 50);\n                    }\n                  }, true);\n                }\n                this.popup.toggle(el, (el2) => el2.append(...nodes2, poweredByDiscovery));\n              }\n            },\n            this.primary\n          ];\n          Object.assign(this, this.secondary);\n          this.contentRect = new ContentRect();\n          this.contentRect.subscribe(({ width, height }) => {\n            const { container } = host.dom;\n            if (container) {\n              container.style.setProperty("--discovery-nav-width", width + "px");\n              container.style.setProperty("--discovery-nav-height", height + "px");\n            }\n          });\n        }\n        render(el, data, context) {\n          this.contentRect.observe(el);\n          if (el) {\n            this.data = data;\n            this.context = {\n              ...context,\n              widget: this.host\n            };\n            this.host.view.setViewRoot(el, "nav", {\n              config: this.config,\n              data: this.data,\n              context: this.context\n            });\n            el.innerHTML = "";\n            this.host.view.render(el, this.config, this.data, this.context);\n          }\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/object-marker.js\n  function flushWarnings() {\n    groupWarningsTimer = null;\n    for (const [caption, messages] of warnings.entries()) {\n      console.groupCollapsed(`${caption} (${messages.length})`);\n      messages.forEach((item) => console.warn(...item));\n      console.groupEnd();\n    }\n    warnings.clear();\n  }\n  function groupWarning(caption, ...details) {\n    if (groupWarningsTimer === null && warnings.size === 0) {\n      groupWarningsTimer = setTimeout(flushWarnings, 1);\n    }\n    if (warnings.has(caption)) {\n      warnings.get(caption).push(details);\n    } else {\n      warnings.set(caption, [details]);\n    }\n  }\n  function getter(name, getter2, reference) {\n    switch (typeof getter2) {\n      case "function":\n        return getter2;\n      case "string":\n        return Object.assign(\n          (value) => value && Object.hasOwnProperty.call(value, getter2) ? value[getter2] : void 0,\n          { getterFromString: `object[${JSON.stringify(getter2)}]` }\n        );\n      default:\n        throw new Error(`[Discovery] Bad type "${typeof key}" for ${reference} in object marker "${name}" config (must be a string or a function)`);\n    }\n  }\n  function configGetter(name, config, property, fallback) {\n    if (config && hasOwnProperty.call(config, property)) {\n      return getter(name, config[property], `"${property}" option`);\n    }\n    return fallback;\n  }\n  function configArrayGetter(name, config, property) {\n    return (Array.isArray(config[property]) ? config[property] : []).map((key2) => getter(name, key2, `"${property}" option`));\n  }\n  function createObjectMarker(config) {\n    const {\n      name,\n      indexRefs,\n      lookupRefs,\n      page,\n      getRef,\n      getTitle\n    } = config;\n    if (page) {\n      if (getRef !== null) {\n        indexRefs.unshift(getRef);\n      } else {\n        console.warn(`Option "ref" for "${name}" marker must be specified when "page" options is defined ("page" option ignored)`);\n      }\n    }\n    if (indexRefs.length > 0) {\n      lookupRefs.unshift((value) => value);\n    }\n    const markedObjects = /* @__PURE__ */ new Set();\n    const indexedRefs = /* @__PURE__ */ new Map();\n    const markers = /* @__PURE__ */ new Map();\n    const weakRefs = /* @__PURE__ */ new WeakMap();\n    const mark = (value) => {\n      if (value === null || typeof value !== "object") {\n        console.warn(`Invalid value used for "${name}" marker (should be an object)`);\n        return;\n      }\n      markedObjects.add(value);\n      for (const indexRefGetter of indexRefs) {\n        const ref = indexRefGetter(value);\n        const type = ref === null ? "null" : typeof ref;\n        if (type === "object" || type === "string" || type === "number") {\n          if (!indexedRefs.has(ref)) {\n            indexedRefs.set(ref, value);\n            continue;\n          }\n          if (indexedRefs.get(ref) !== value) {\n            groupWarning(`The same reference value used for different objects for "${name}" marker`, `Reference value "${ref}"`, {\n              refGetter: indexRefGetter.getterFromString || indexRefGetter,\n              ref,\n              currentObject: indexedRefs.get(ref),\n              newObject: value\n            });\n          }\n        }\n      }\n    };\n    const lookup = (value) => {\n      const valueType = value === null ? "null" : typeof value;\n      if (valueType !== "object" && valueType !== "string" && valueType !== "number") {\n        return null;\n      }\n      if (markers.has(value)) {\n        return markers.get(value);\n      }\n      if (weakRefs.has(value)) {\n        return weakRefs.get(value);\n      }\n      let marker = null;\n      let resolvedValue = null;\n      if (markedObjects.has(value)) {\n        resolvedValue = value;\n      } else {\n        for (const getLookupRef of lookupRefs) {\n          const ref = getLookupRef(value);\n          if (indexedRefs.has(ref)) {\n            resolvedValue = indexedRefs.get(ref);\n            break;\n          }\n        }\n      }\n      if (resolvedValue !== null) {\n        if (markers.has(resolvedValue)) {\n          marker = markers.get(resolvedValue);\n        } else {\n          const ref = getRef !== null ? getRef(resolvedValue) : null;\n          marker = Object.freeze({\n            type: name,\n            object: resolvedValue,\n            ref,\n            title: getTitle(resolvedValue),\n            href: page !== null && ref !== null ? `#${encodeURIComponent(page)}:${encodeURIComponent(ref)}` : null\n          });\n          markers.set(resolvedValue, marker);\n        }\n        if (value !== resolvedValue) {\n          if (typeof value !== "object") {\n            markers.set(value, marker);\n          } else {\n            weakRefs.set(value, marker);\n          }\n        }\n      }\n      return marker;\n    };\n    return {\n      page: getRef !== null ? page : null,\n      mark,\n      lookup\n    };\n  }\n  var warnings, groupWarningsTimer, ObjectMarker;\n  var init_object_marker = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/object-marker.js"() {\n      init_dict();\n      warnings = /* @__PURE__ */ new Map();\n      groupWarningsTimer = null;\n      ObjectMarker = class extends Dictionary {\n        define(name, config) {\n          if (this.isDefined(name)) {\n            console.error(`[Discovery] Object marker "${name}" is already defined, new definition ignored`);\n            return;\n          }\n          config = config || {};\n          const indexRefs = configArrayGetter(name, config, "refs");\n          const lookupRefs = configArrayGetter(name, config, "lookupRefs");\n          const page = typeof config.page === "string" ? config.page : null;\n          const getRef = configGetter(name, config, "ref", null);\n          const getTitle = configGetter(name, config, "title", getRef || (() => null));\n          return super.define(name, createObjectMarker({\n            name,\n            indexRefs,\n            lookupRefs,\n            page,\n            getRef,\n            getTitle\n          }));\n        }\n        lookup(value, marker) {\n          if (marker) {\n            return this.get(marker)?.lookup(value);\n          }\n          for (const { lookup } of this.values) {\n            const marker2 = lookup(value);\n            if (marker2 !== null) {\n              return marker2;\n            }\n          }\n          return null;\n        }\n        lookupAll(value) {\n          const markers = [];\n          for (const { lookup } of this.values) {\n            const marker = lookup(value);\n            if (marker !== null) {\n              markers.push(marker);\n            }\n          }\n          return markers;\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/main/data-extension-api.js\n  function createDataExtensionApi(host) {\n    const objectMarkers = new ObjectMarker();\n    const linkResolvers = [];\n    const annotations = [];\n    const methods2 = {\n      rejectData(message, renderContent) {\n        throw Object.assign(new Error(message), { renderContent });\n      },\n      defineObjectMarker,\n      lookupObjectMarker,\n      lookupObjectMarkerAll,\n      resolveValueLinks,\n      addValueAnnotation,\n      addQueryHelpers(helpers) {\n        joraSetup = src_default.setup({\n          methods: queryCustomMethods = {\n            ...queryCustomMethods,\n            ...helpers\n          }\n        });\n      },\n      query(query, ...args) {\n        return host.queryFn.call({ queryFnFromString: joraSetup }, query)(...args);\n      }\n    };\n    let queryCustomMethods = {\n      query: (...args) => host.query(...args),\n      pageLink: (pageRef, pageId, pageParams) => host.encodePageHash(pageId, pageRef, pageParams),\n      marker: lookupObjectMarker,\n      markerAll: lookupObjectMarkerAll,\n      callAction,\n      actionHandler: (actionName, ...args) => host.action.has(actionName) ? () => callAction(actionName, ...args) : void 0\n    };\n    let joraSetup = src_default.setup({ methods: queryCustomMethods });\n    return Object.assign((host2) => Object.assign(host2, {\n      objectMarkers,\n      linkResolvers,\n      resolveValueLinks,\n      annotations,\n      queryFnFromString: joraSetup\n    }), { methods: methods2 });\n    function defineObjectMarker(name, options2) {\n      const annotateScalars = Boolean(options2?.annotateScalars);\n      const { page, mark, lookup } = objectMarkers.define(name, options2) || {};\n      if (!lookup) {\n        return () => {\n        };\n      }\n      if (page !== null) {\n        if (!host.page.isDefined(options2.page)) {\n          host.log("error", `Page reference "${options2.page}" doesn\'t exist`);\n          return;\n        }\n        linkResolvers.push((value) => {\n          const marker = lookup(value);\n          if (marker !== null) {\n            return {\n              type: page,\n              text: marker.title,\n              href: marker.href,\n              entity: marker.object\n            };\n          }\n        });\n      }\n      addValueAnnotation((value, context) => {\n        const marker = annotateScalars || typeof value === "object" && value !== null ? lookup(value) : null;\n        if (marker !== null && marker.object !== context.host) {\n          return {\n            place: "before",\n            style: "badge",\n            text: name,\n            href: marker.href\n          };\n        }\n      });\n      return mark;\n    }\n    function lookupObjectMarker(value, type) {\n      return objectMarkers.lookup(value, type);\n    }\n    function lookupObjectMarkerAll(value) {\n      return objectMarkers.lookupAll(value);\n    }\n    function addValueAnnotation(query, options2 = false) {\n      if (typeof options2 === "boolean") {\n        options2 = {\n          debug: options2\n        };\n      }\n      annotations.push({\n        query,\n        ...options2\n      });\n    }\n    function resolveValueLinks(value) {\n      const result = [];\n      const type = typeof value;\n      if (value && (type === "object" || type === "string")) {\n        for (const resolver of linkResolvers) {\n          const link = resolver(value);\n          if (link) {\n            result.push(link);\n          }\n        }\n      }\n      return result.length ? result : null;\n    }\n    function callAction(actionName, ...args) {\n      let callback = null;\n      if (typeof args[args.length - 1] === "function") {\n        callback = args.pop();\n      }\n      const ret = host.action.call(actionName, ...args);\n      if (ret && callback && typeof ret.then === "function") {\n        return ret.then(callback);\n      }\n      return callback ? callback(ret) : ret;\n    }\n  }\n  var init_data_extension_api = __esm({\n    "node_modules/@discoveryjs/discovery/src/main/data-extension-api.js"() {\n      init_object_marker();\n      init_src2();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/main/query-suggestions.js\n  function stringifyValue(value, text) {\n    if (typeof value !== "string") {\n      return String(value);\n    }\n    value = JSON.stringify(value);\n    if (text[0] !== "\'") {\n      return value;\n    }\n    return `\'${value.slice(1, -1).replace(\n      /\\\\.|\'/g,\n      (m2) => m2 === \'\\\\"\' ? \'"\' : m2 === "\'" ? "\\\\\'" : m2\n    )}\'`;\n  }\n  function isSameSuggestions(api2, pos1, pos2) {\n    if (pos1 === pos2) {\n      return true;\n    }\n    const ranges1 = api2.stat(pos1) || [];\n    const ranges2 = api2.stat(pos2) || [];\n    if (ranges1.length !== ranges2.length) {\n      return false;\n    }\n    for (let i = 0; i < ranges1.length; i++) {\n      const range1 = ranges1[i];\n      const range2 = ranges2[i];\n      for (const key2 of Object.keys(range1)) {\n        if (range1[key2] !== range2[key2]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  function querySuggestions(host, query, offset, data, context) {\n    try {\n      let stat = lastQuerySuggestionsStat.get(host);\n      if (!stat || stat.query !== query || stat.data !== data || stat.context !== context) {\n        const options2 = {\n          tolerant: true,\n          stat: true\n        };\n        lastQuerySuggestionsStat.set(host, stat = {\n          query,\n          data,\n          context,\n          offset: -1,\n          suggestions: null,\n          api: null\n        });\n        stat.api = host.queryFnFromString(query, options2)(data, context);\n      }\n      if (stat.api === null) {\n        return null;\n      }\n      if (stat.offset !== -1 && isSameSuggestions(stat.api, stat.offset, offset)) {\n        return stat.suggestions;\n      }\n      const suggestionsByType = stat.api.suggestion(stat.offset = offset, {\n        sort: true,\n        filter: suggestionValueFilter,\n        limit: 50\n      });\n      if (suggestionsByType) {\n        stat.suggestions = [];\n        for (const entry of suggestionsByType.sort(sortByType)) {\n          stat.suggestions.push(...entry.suggestions.map((value) => ({\n            type: entry.type,\n            from: entry.from,\n            to: entry.to,\n            text: entry.text,\n            value: entry.type === "value" ? stringifyValue(value, entry.text) : value\n          })));\n        }\n      } else {\n        stat.suggestions = null;\n      }\n      return stat.suggestions;\n    } catch (e) {\n      host.log({\n        level: "error",\n        message: "Error while attempting to retrieve suggestions for the query",\n        collapsed: e\n      });\n      return;\n    }\n  }\n  var lastQuerySuggestionsStat, typeOrder3, sortByType, suggestionValueFilter;\n  var init_query_suggestions = __esm({\n    "node_modules/@discoveryjs/discovery/src/main/query-suggestions.js"() {\n      lastQuerySuggestionsStat = /* @__PURE__ */ new WeakMap();\n      typeOrder3 = ["variable", "property", "value", "method"];\n      sortByType = (a, b2) => typeOrder3.indexOf(a.type) - typeOrder3.indexOf(b2.type);\n      suggestionValueFilter = (pattern) => {\n        const patternLowerCased = pattern.toLowerCase();\n        return (value) => value !== pattern && // 2022-04-08\n        // v8: includes() is 20-30% slower than indexOf() !== -1\n        // Firefox & Safari approximate the same\n        (typeof value === "string" ? value : String(value)).toLowerCase().indexOf(patternLowerCased) !== -1;\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/main/widget.js\n  function setDatasetValue(el, key2, value) {\n    if (value) {\n      el.dataset[key2] = value;\n    } else {\n      delete el.dataset[key2];\n    }\n  }\n  function getPageOption(host, pageId, name, fallback) {\n    const page = host.page.get(pageId);\n    return page && Object.hasOwnProperty.call(page.options, name) ? page.options[name] : fallback;\n  }\n  function getPageMethod(host, pageId, name, fallback) {\n    const method = getPageOption(host, pageId, name, fallback);\n    return typeof method === "function" ? method : fallback;\n  }\n  var lastSetDataPromise, renderScheduler, logLevels, logPrefix, noopLogger, defaultEncodeParams, defaultDecodeParams, Widget2;\n  var init_widget = __esm({\n    "node_modules/@discoveryjs/discovery/src/main/widget.js"() {\n      init_src2();\n      init_dom();\n      init_inject_styles();\n      init_compare2();\n      init_utils();\n      init_action();\n      init_darkmode();\n      init_emitter();\n      init_page();\n      init_view();\n      init_preset();\n      init_publisher();\n      init_inspector();\n      init_views();\n      init_pages();\n      init_nav();\n      init_data_extension_api();\n      init_query_suggestions();\n      lastSetDataPromise = /* @__PURE__ */ new WeakMap();\n      renderScheduler = /* @__PURE__ */ new WeakMap();\n      logLevels = ["silent", "error", "warn", "info", "perf", "debug"];\n      logPrefix = "[Discovery]";\n      noopLogger = new Proxy({}, { get: () => () => {\n      } });\n      defaultEncodeParams = (params) => params;\n      defaultDecodeParams = (pairs) => Object.fromEntries(pairs);\n      Widget2 = class extends Emitter {\n        constructor(options2 = {}) {\n          super();\n          this.options = options2 || {};\n          const {\n            logLevel,\n            logger = console,\n            darkmode = "disabled",\n            darkmodePersistent = false,\n            defaultPage,\n            defaultPageId,\n            discoveryPageId,\n            reportToDiscoveryRedirect = true,\n            extensions,\n            inspector: useInspector = false\n          } = this.options;\n          this.logger = logger || noopLogger;\n          this.logLevel = logLevels.includes(logLevel) ? logLevel : "perf";\n          this.darkmode = new DarkModeController(darkmode, darkmodePersistent);\n          this.inspectMode = new Publisher(false);\n          this.initDom();\n          this.action = new ActionManager();\n          this.action.on("define", () => {\n            if (this.context) {\n              this.scheduleRender("sidebar");\n              this.scheduleRender("page");\n            }\n          }).on("revoke", () => {\n            if (this.context) {\n              this.scheduleRender("sidebar");\n              this.scheduleRender("page");\n            }\n          });\n          this.view = new ViewRenderer(this);\n          this.nav = new WidgetNavigation(this);\n          this.preset = new PresetRenderer(this.view);\n          this.page = new PageRenderer(this).on("define", (pageId) => {\n            if (this.pageId === pageId && this.pageHash !== "#") {\n              const hash = this.pageHash;\n              this.pageHash = "#";\n              this.setPageHash(hash);\n              this.cancelScheduledRender();\n            }\n          });\n          renderScheduler.set(this, /* @__PURE__ */ new Set());\n          this.datasets = [];\n          this.encodings = normalizeEncodings(options2.encodings);\n          this.data = void 0;\n          this.context = void 0;\n          this.prepare = (data) => data;\n          this.defaultPageId = defaultPageId || "default";\n          this.discoveryPageId = discoveryPageId || "discovery";\n          this.reportToDiscoveryRedirect = Boolean(reportToDiscoveryRedirect);\n          this.pageId = this.defaultPageId;\n          this.pageRef = null;\n          this.pageParams = {};\n          this.pageHash = this.encodePageHash(this.pageId, this.pageRef, this.pageParams);\n          this.apply(createDataExtensionApi(this));\n          this.apply(views_exports);\n          this.apply(pages_exports);\n          if (extensions) {\n            this.apply(extensions);\n          }\n          if (defaultPage) {\n            this.page.define(this.defaultPageId, defaultPage);\n          }\n          if (useInspector) {\n            this.apply(inspector_default);\n          }\n          this.nav.render(this.dom.nav, this.data, this.getRenderContext());\n          this.setContainer(this.options.container);\n        }\n        apply(extensions) {\n          if (Array.isArray(extensions)) {\n            extensions.forEach((extension) => this.apply(extension));\n          } else if (typeof extensions === "function") {\n            extensions.call(null, this);\n          } else if (extensions) {\n            this.apply(Object.values(extensions));\n          }\n        }\n        log(levelOrOpts, ...args) {\n          const { level, lazy, message, collapsed } = levelOrOpts && typeof levelOrOpts === "object" ? levelOrOpts : { level: levelOrOpts };\n          const levelIndex = logLevels.indexOf(level);\n          if (levelIndex > 0 && levelIndex <= logLevels.indexOf(this.logLevel)) {\n            const method = level === "perf" ? "log" : level;\n            if (collapsed) {\n              this.logger.groupCollapsed(`${logPrefix} ${message || args?.[0]}`);\n              const entries2 = typeof collapsed === "function" ? collapsed() : collapsed;\n              for (const entry of Array.isArray(entries2) ? entries2 : [entries2]) {\n                this.logger[method](...Array.isArray(entry) ? entry : [entry]);\n              }\n              this.logger.groupEnd();\n            } else {\n              this.logger[method](logPrefix, ...typeof lazy === "function" ? lazy() : args);\n            }\n          } else if (levelIndex === -1) {\n            this.logger.error(`${logPrefix} Bad log level "${level}", supported: ${logLevels.slice(1).join(", ")}`);\n          }\n        }\n        //\n        // Data\n        //\n        setPrepare(fn) {\n          if (typeof fn !== "function") {\n            throw new Error("An argument should be a function");\n          }\n          this.prepare = fn;\n        }\n        setData(data, context = {}, options2) {\n          options2 = options2 || {};\n          const startTime = Date.now();\n          const prepareExtension = createDataExtensionApi(this);\n          const checkIsNotPrevented = () => {\n            const lastPromise = lastSetDataPromise.get(this);\n            if (lastPromise !== setDataPromise) {\n              throw new Error("Prevented by another setData()");\n            }\n          };\n          const setDataPromise = Promise.resolve().then(() => {\n            checkIsNotPrevented();\n            return this.prepare(data, prepareExtension.methods) || data;\n          }).then((data2) => {\n            checkIsNotPrevented();\n            this.datasets = [{ ...options2.dataset, data: data2 }];\n            this.data = data2;\n            this.context = context;\n            this.apply(prepareExtension);\n            this.emit("data");\n            this.log("perf", `Data prepared in ${Date.now() - startTime}ms`);\n          });\n          lastSetDataPromise.set(this, setDataPromise);\n          if ("render" in options2 === false || options2.render) {\n            setDataPromise.then(() => {\n              this.scheduleRender("sidebar");\n              this.scheduleRender("page");\n            });\n          }\n          return setDataPromise;\n        }\n        async setDataProgress(data, context, options2) {\n          const {\n            dataset,\n            progressbar\n          } = options2 || {};\n          this.emit("startSetData", (...args) => progressbar?.subscribeSync(...args));\n          await progressbar?.setState({ stage: "prepare" });\n          await this.setData(data, context, {\n            dataset,\n            render: false\n          });\n          await progressbar?.setState({ stage: "initui" });\n          this.scheduleRender("sidebar");\n          this.scheduleRender("page");\n          await Promise.all([\n            this.dom.wrapper.parentNode ? this.dom.ready : true,\n            renderScheduler.get(this).timer\n          ]);\n          await progressbar?.finish();\n        }\n        unloadData() {\n          if (!this.hasDatasets()) {\n            return;\n          }\n          this.datasets = [];\n          this.data = void 0;\n          this.context = void 0;\n          this.scheduleRender("sidebar");\n          this.scheduleRender("page");\n          this.emit("unloadData");\n        }\n        hasDatasets() {\n          return this.datasets.length !== 0;\n        }\n        // The method is overriding by createDataExtensionApi().apply()\n        resolveValueLinks() {\n          return null;\n        }\n        //\n        // Data query\n        //\n        queryFn(query) {\n          switch (typeof query) {\n            case "function":\n              return query;\n            case "string":\n              return this.queryFnFromString(query);\n          }\n        }\n        query(query, data, context) {\n          switch (typeof query) {\n            case "function":\n              return query(data, context);\n            case "string":\n              return this.queryFn(query)(data, context);\n            default:\n              return query;\n          }\n        }\n        queryBool(...args) {\n          return src_default.buildin.bool(this.query(...args));\n        }\n        queryToConfig(view, query) {\n          const { ast } = src_default.syntax.parse(query);\n          const config = { view };\n          if (ast.type !== "Block") {\n            throw new SyntaxError(\'[Discovery] Widget#queryToConfig(): query root must be a "Block"\');\n          }\n          if (ast.body.type !== "Object") {\n            throw new SyntaxError(\'[Discovery] Widget#queryToConfig(): query root must return an "Object"\');\n          }\n          for (const entry of ast.body.properties) {\n            if (entry.type !== "ObjectEntry") {\n              throw new SyntaxError(\'[Discovery] Widget#queryToConfig(): unsupported object entry type "\' + entry.type + \'"\');\n            }\n            let key2;\n            let value = entry.value;\n            switch (entry.key.type) {\n              case "Literal":\n                key2 = entry.key.value;\n                break;\n              case "Identifier":\n                key2 = entry.key.name;\n                value ||= entry.key;\n                break;\n              case "Reference":\n                key2 = entry.key.name.name;\n                value ||= entry.key;\n                break;\n              default:\n                throw new SyntaxError(\'[Discovery] Widget#queryToConfig(): unsupported object key type "\' + entry.key.type + \'"\');\n            }\n            if (key2 === "view" || key2 === "postRender") {\n              throw new SyntaxError(\'[Discovery] Widget#queryToConfig(): set a value for "\' + key2 + \'" property in shorthand notation is prohibited\');\n            }\n            if (key2 === "when" || key2 === "data" || key2 === "whenData") {\n              config[key2] = value.type === "Literal" && typeof value.value !== "string" ? value.value : src_default.syntax.stringify(value);\n            } else {\n              config[key2] = value.type === "Literal" && (typeof value.value !== "string" || value.value[0] !== "=") ? value.value : "=" + src_default.syntax.stringify(value);\n            }\n          }\n          return config;\n        }\n        querySuggestions(query, offset, data, context) {\n          return querySuggestions(this, query, offset, data, context);\n        }\n        pathToQuery(path) {\n          return path.map(\n            (part, idx) => part === "*" ? idx === 0 ? "values()" : ".values()" : typeof part === "number" || !/^[a-zA-Z_][a-zA-Z_$0-9]*$/.test(part) ? idx === 0 ? `$[${JSON.stringify(part)}]` : `[${JSON.stringify(part)}]` : idx === 0 ? part : "." + part\n          ).join("");\n        }\n        getQueryEngineInfo() {\n          return {\n            name: "jora",\n            version: src_default.version,\n            link: "https://discoveryjs.github.io/jora/#article:jora-syntax"\n          };\n        }\n        //\n        // UI\n        //\n        initDom() {\n          const wrapper = createElement("div", "discovery init");\n          const shadow = wrapper.attachShadow({ mode: "open" });\n          const readyStyles = injectStyles(shadow, this.options.styles);\n          const container = shadow.appendChild(createElement("div"));\n          this.dom = {};\n          this.dom.ready = Promise.all([readyStyles]);\n          this.dom.wrapper = wrapper;\n          this.dom.root = shadow;\n          this.dom.container = container;\n          container.classList.add("discovery-root", "discovery");\n          container.append(\n            this.dom.nav = createElement("div", "discovery-nav discovery-hidden-in-dzen"),\n            this.dom.sidebar = createElement("nav", "discovery-sidebar discovery-hidden-in-dzen"),\n            this.dom.content = createElement("main", "discovery-content", [\n              this.dom.pageContent = createElement("article")\n            ])\n          );\n          shadow.addEventListener("click", (event) => {\n            const linkEl = event.target.closest("a");\n            if (!linkEl || linkEl.getAttribute("target")) {\n              return;\n            }\n            if (linkEl.origin !== location.origin || linkEl.pathname !== location.pathname) {\n              return;\n            }\n            event.preventDefault();\n            if (!linkEl.classList.contains("ignore-href")) {\n              this.setPageHash(linkEl.hash);\n            }\n          }, true);\n          this.dom.detachDarkMode = this.darkmode.subscribe(\n            (dark) => container.classList.toggle("discovery-root-darkmode", dark),\n            true\n          );\n          this.dom.ready.then(() => {\n            getComputedStyle(this.dom.wrapper).opacity;\n            this.dom.wrapper.classList.remove("init");\n          });\n        }\n        setContainer(container) {\n          if (container instanceof Node) {\n            container.append(this.dom.wrapper);\n          } else {\n            this.dom.wrapper.remove();\n          }\n        }\n        disposeDom() {\n          if (typeof this.dom.detachDarkMode === "function") {\n            this.dom.detachDarkMode();\n            this.dom.detachDarkMode = null;\n          }\n          this.dom.container.remove();\n          this.dom = null;\n        }\n        addGlobalEventListener(eventName, handler, options2) {\n          document.addEventListener(eventName, handler, options2);\n          return () => document.removeEventListener(eventName, handler, options2);\n        }\n        addHostElEventListener(eventName, handler, options2) {\n          const el = this.dom.container;\n          el.addEventListener(eventName, handler, options2);\n          return () => el.removeEventListener(eventName, handler, options2);\n        }\n        //\n        // Render common\n        //\n        scheduleRender(subject) {\n          const scheduledRenders = renderScheduler.get(this);\n          if (scheduledRenders.has(subject)) {\n            return;\n          }\n          scheduledRenders.add(subject);\n          if (scheduledRenders.timer) {\n            return;\n          }\n          scheduledRenders.timer = Promise.resolve().then(async () => {\n            for (const subject2 of scheduledRenders) {\n              switch (subject2) {\n                case "sidebar":\n                  await this.renderSidebar();\n                  break;\n                case "page":\n                  await this.renderPage();\n                  break;\n              }\n            }\n            scheduledRenders.timer = null;\n          });\n          return scheduledRenders.timer;\n        }\n        cancelScheduledRender(subject) {\n          const scheduledRenders = renderScheduler.get(this);\n          if (scheduledRenders) {\n            if (subject) {\n              scheduledRenders.delete(subject);\n            } else {\n              scheduledRenders.clear();\n            }\n          }\n        }\n        getRenderContext() {\n          return {\n            page: this.pageId,\n            id: this.pageRef,\n            params: this.pageParams,\n            actions: this.action.actionMap,\n            datasets: this.datasets,\n            data: this.data,\n            ...this.context\n          };\n        }\n        //\n        // Sidebar\n        //\n        renderSidebar() {\n          renderScheduler.get(this).delete("sidebar");\n          if (this.hasDatasets() && this.view.isDefined("sidebar")) {\n            const renderStartTime = Date.now();\n            const data = this.data;\n            const context = this.getRenderContext();\n            this.view.setViewRoot(this.dom.sidebar, "sidebar", { data, context });\n            this.dom.sidebar.innerHTML = "";\n            return this.view.render(this.dom.sidebar, "sidebar", data, context).finally(() => this.log("perf", `Sidebar rendered in ${Date.now() - renderStartTime}ms`));\n          }\n        }\n        //\n        // Page\n        //\n        encodePageHash(pageId, pageRef, pageParams) {\n          const encodeParams2 = getPageMethod(this, pageId, "encodeParams", defaultEncodeParams);\n          let encodedParams = encodeParams2(pageParams || {});\n          if (encodedParams && typeof encodedParams !== "string") {\n            if (!Array.isArray(encodedParams)) {\n              encodedParams = Object.entries(encodedParams);\n            }\n            encodedParams = encodedParams.map((pair) => pair.map(encodeURIComponent).join("=")).join("&");\n          }\n          return `#${pageId !== this.defaultPageId ? encodeURIComponent(pageId) : ""}${typeof pageRef === "string" && pageRef || typeof pageRef === "number" ? ":" + encodeURIComponent(pageRef) : ""}${encodedParams ? "&" + encodedParams : ""}`;\n        }\n        decodePageHash(hash) {\n          const delimIndex = (hash.indexOf("&") + 1 || hash.length + 1) - 1;\n          const [pageId, pageRef] = hash.substring(hash[0] === "#" ? 1 : 0, delimIndex).split(":").map(decodeURIComponent);\n          const decodeParams2 = getPageMethod(this, pageId || this.defaultPageId, "decodeParams", defaultDecodeParams);\n          const pairs = hash.substr(delimIndex + 1).split("&").filter(Boolean).map((pair) => {\n            const eqIndex = pair.indexOf("=");\n            return eqIndex !== -1 ? [decodeURIComponent(pair.slice(0, eqIndex)), decodeURIComponent(pair.slice(eqIndex + 1))] : [decodeURIComponent(pair), true];\n          });\n          return {\n            pageId: pageId || this.defaultPageId,\n            pageRef,\n            pageParams: decodeParams2(pairs)\n          };\n        }\n        setPage(pageId, pageRef, pageParams, replace = false) {\n          return this.setPageHash(\n            this.encodePageHash(pageId || this.defaultPageId, pageRef, pageParams),\n            replace\n          );\n        }\n        setPageRef(pageRef, replace = false) {\n          return this.setPage(this.pageId, pageRef, this.pageParams, replace);\n        }\n        setPageParams(pageParams, replace = false) {\n          return this.setPage(this.pageId, this.pageRef, pageParams, replace);\n        }\n        setPageHash(hash, replace = false) {\n          let { pageId, pageRef, pageParams } = this.decodePageHash(hash);\n          if (this.reportToDiscoveryRedirect && pageId === "report") {\n            setTimeout(() => this.pageId === "report" && this.setPage("discovery", this.pageRef, this.pageParams, true));\n          }\n          if (this.pageId !== pageId || this.pageRef !== pageRef || !deepEqual(this.pageParams, pageParams)) {\n            this.pageId = pageId;\n            this.pageRef = pageRef;\n            this.pageParams = pageParams;\n            this.scheduleRender("page");\n            if (hash !== this.pageHash) {\n              this.pageHash = hash;\n              this.emit("pageHashChange", replace);\n              return true;\n            }\n          }\n          return false;\n        }\n        renderPage() {\n          renderScheduler.get(this).delete("page");\n          const data = this.data;\n          const context = this.getRenderContext();\n          const { pageEl, renderState, config } = this.page.render(\n            this.dom.pageContent,\n            this.pageId,\n            data,\n            context\n          );\n          this.view.setViewRoot(pageEl, "Page: " + this.pageId, {\n            inspectable: false,\n            config,\n            data,\n            context\n          });\n          this.dom.pageContent = pageEl;\n          this.nav.render(this.dom.nav, data, context);\n          setDatasetValue(this.dom.container, "page", this.pageId);\n          setDatasetValue(this.dom.container, "dzen", Boolean(this.pageParams.dzen));\n          setDatasetValue(this.dom.container, "compact", Boolean(this.options.compact));\n          renderState.then(() => {\n            if (this.pageParams["!anchor"]) {\n              const el = pageEl.querySelector("#" + CSS.escape("!anchor:" + this.pageParams["!anchor"]));\n              if (el) {\n                const pageHeaderEl = pageEl.querySelector(".view-page-header");\n                el.style.scrollMargin = pageHeaderEl ? pageHeaderEl.offsetHeight + "px" : "";\n                el.scrollIntoView(true);\n              }\n            }\n          });\n          return renderState;\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/extensions/upload.js\n  function setup3(options2) {\n    options2 = options2 || true;\n    return function(host) {\n      const accept = options2.accept ? String(options2.accept) : "application/json,application/jsonxl,.json,.jsonxl";\n      const dragdrop = Boolean(options2.dragdrop || options2.dragdrop === void 0);\n      const acceptTokens = accept.split(",");\n      if (dragdrop) {\n        host.dom.container.addEventListener("drop", (event) => {\n          host.loadDataFromEvent(event);\n        }, true);\n        host.dom.container.addEventListener("dragover", (event) => {\n          event.stopPropagation();\n          event.preventDefault();\n        }, true);\n      }\n      host.preset.define("upload", [\n        {\n          view: "button-primary",\n          onClick: "=#.actions.uploadFile",\n          content: \'text:`Open file ${#.actions.uploadFile.fileExtensions | $ ? "(" + join(", ") + ")" : ""}`\'\n        },\n        {\n          view: "context",\n          when: "#.actions.uploadFile.dragdrop",\n          content: [\n            \'html:"<span style=\\\\"color: #888; padding: 0 1ex\\\\"> or </span>"\',\n            \'text:"drop a file on the page"\'\n          ]\n        }\n      ]);\n      host.action.define("unloadData", () => {\n        host.unloadData();\n      });\n      host.action.define("uploadFile", Object.assign(\n        () => {\n          createElement("input", {\n            type: "file",\n            accept,\n            onchange: (event) => host.loadDataFromEvent(event)\n          }).click();\n        },\n        {\n          fileExtensions: acceptTokens.filter((token2) => isExtension(token2)),\n          mimeTypes: acceptTokens.filter((token2) => !isExtension(token2)),\n          dragdrop\n        }\n      ));\n    };\n  }\n  var upload_default, isExtension;\n  var init_upload = __esm({\n    "node_modules/@discoveryjs/discovery/src/extensions/upload.js"() {\n      init_dom();\n      upload_default = Object.assign(setup3(), { setup: setup3 });\n      isExtension = (value) => /^\\./.test(value);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/extensions/embed-client.js\n  function darkmodeValue({ mode, value }) {\n    return mode === "auto" ? "auto" : value ? "dark" : "light";\n  }\n  function setup4(options2) {\n    options2 = options2 || {};\n    return function(host) {\n      let loadChunkedDataStatus = null;\n      let loadDataUnsubscribe = noop2;\n      const cancelLoadChunkedDataApi = () => {\n        loadChunkedDataStatus?.finish();\n        loadChunkedDataStatus = null;\n      };\n      const hostId = options2.hostId || randomId();\n      const parentWindow = window.parent;\n      const actionCalls = /* @__PURE__ */ new Map();\n      const sendMessage = (type, payload = null) => {\n        parentWindow.postMessage({\n          from: "discoveryjs-app",\n          id: hostId,\n          type,\n          payload\n        }, "*");\n      };\n      const setLoadDataUnsubscribe = (fn) => {\n        loadDataUnsubscribe = () => {\n          if (fn !== null) {\n            loadDataUnsubscribe = noop2;\n            fn();\n          }\n        };\n      };\n      const trackDataLoading = (loadDataStatus) => {\n        const result = typeof host.trackLoadDataProgress === "function" ? host.trackLoadDataProgress(loadDataStatus) : loadDataStatus.result.then((dataset) => host.setData(dataset.data, null, { dataset }));\n        result.catch(() => {\n        });\n      };\n      const processIncomingMessage = (event) => {\n        const { id, type, payload } = event.data || {};\n        if (id === hostId) {\n          switch (type) {\n            case "defineAction": {\n              const name = payload;\n              host.action.define(\n                name,\n                (...args) => new Promise((resolve, reject) => {\n                  const callId = randomId();\n                  actionCalls.set(callId, { resolve, reject });\n                  setTimeout(() => {\n                    actionCalls.delete(callId);\n                    reject(new Error("Timeout"));\n                  }, 3e4);\n                  sendMessage("action", {\n                    callId,\n                    name,\n                    args\n                  });\n                })\n              );\n              break;\n            }\n            case "actionResult": {\n              const { callId, value, error } = payload;\n              if (!actionCalls.has(callId)) {\n                host.log("error", `[Discovery.js] Unknown action call id "${callId}"`);\n                break;\n              }\n              const { resolve, reject } = actionCalls.get(callId);\n              if (error) {\n                reject(error);\n              } else {\n                resolve(value);\n              }\n              break;\n            }\n            case "setPageHash": {\n              const { replace, hash } = payload || {};\n              host.setPageHash(hash || "", replace || false);\n              break;\n            }\n            case "setPage": {\n              const { replace, id: id2, ref, params } = payload || {};\n              host.setPage(id2, ref, params, replace);\n              break;\n            }\n            case "setPageRef": {\n              const { replace, ref } = payload || {};\n              host.setPageRef(ref, replace);\n              break;\n            }\n            case "setPageParams": {\n              const { replace, params } = payload || {};\n              host.setPageParams(params, replace);\n              break;\n            }\n            case "setDarkmode": {\n              const mode = payload;\n              const supportedValues = ["auto", "light", "dark"];\n              if (!supportedValues.includes(mode)) {\n                host.log("warn", `Wrong value for darkmode "${mode}", supported values: ${supportedValues.map((value) => JSON.stringify(value)).join(", ")}`);\n                break;\n              }\n              host.darkmode.set(mode === "auto" ? "auto" : mode === "dark");\n              break;\n            }\n            case "setRouterPreventLocationUpdate": {\n              host.routerPreventLocationUpdate = Boolean(payload);\n              break;\n            }\n            case "changeNavButtons": {\n              const {\n                section = "primary",\n                action = "append",\n                name,\n                position,\n                commands: rawCommands,\n                config: rawConfig\n              } = payload || {};\n              if (!navSection.includes(section)) {\n                host.log("warn", `Wrong value for nav button place "${section}", supported values: ${navSection.map((value) => JSON.stringify(value)).join(", ")}`);\n                break;\n              }\n              const commands = rawCommands || {};\n              const config = JSON.parse(\n                JSON.stringify(rawConfig),\n                (_, value) => commands.includes(value) ? () => sendMessage("navMethod", value) : value\n              );\n              switch (action) {\n                case "insert":\n                  host.nav[section].insert(config, position, name);\n                  break;\n                case "prepend":\n                case "append":\n                  host.nav[section][action](config);\n                  break;\n                case "before":\n                case "after":\n                case "replace":\n                  host.nav[section][action](name, config);\n                  break;\n                case "remove":\n                  host.nav[section].remove(name);\n                  break;\n                default:\n                  host.log("warn", `Wrong value for nav button action "${action}", supported values: ${navAction.map((value) => JSON.stringify(value)).join(", ")}`);\n              }\n              break;\n            }\n            case "unloadData": {\n              cancelLoadChunkedDataApi();\n              host.unloadData();\n              break;\n            }\n            case "dataStream": {\n              const { stream, resource } = payload;\n              cancelLoadChunkedDataApi();\n              trackDataLoading(loadDataFromStream(stream, { resource }));\n              break;\n            }\n            case "startChunkedDataUpload": {\n              const { acceptToken, resource } = payload;\n              cancelLoadChunkedDataApi();\n              loadChunkedDataStatus = Object.assign(loadDataFromPush({ resource }), { acceptToken });\n              trackDataLoading(loadChunkedDataStatus);\n              break;\n            }\n            case "cancelChunkedDataUpload": {\n              const { acceptToken, error } = payload;\n              if (loadChunkedDataStatus?.acceptToken === acceptToken) {\n                cancelLoadChunkedDataApi(error);\n              }\n            }\n            case "dataChunk": {\n              const { acceptToken, value, done } = payload;\n              if (loadChunkedDataStatus === null) {\n                host.log("warn", "Loading data is not inited");\n                break;\n              }\n              if (loadChunkedDataStatus.acceptToken !== acceptToken) {\n                host.log("warn", "Bad accept token");\n                break;\n              }\n              if (value) {\n                loadChunkedDataStatus.push(value);\n              }\n              if (done) {\n                cancelLoadChunkedDataApi();\n              }\n              break;\n            }\n            default:\n              host.log("warn", `Got a post-message addressed to discovery app but with unknown "${type}" type`);\n          }\n        }\n      };\n      if (parentWindow === window) {\n        return;\n      }\n      host.on(\n        "pageHashChange",\n        (replace) => sendMessage("pageHashChanged", {\n          replace,\n          hash: host.pageHash || "#",\n          id: host.pageId,\n          ref: host.pageRef,\n          params: host.pageParams\n        })\n      );\n      host.on("startLoadData", (subscribe) => {\n        loadDataUnsubscribe();\n        setLoadDataUnsubscribe(subscribe((state) => sendMessage("loadingState", state)));\n      });\n      host.on("startSetData", (subscribe) => {\n        loadDataUnsubscribe();\n        setLoadDataUnsubscribe(subscribe((state) => sendMessage("loadingState", state)));\n      });\n      host.on("unloadData", () => {\n        loadDataUnsubscribe();\n        sendMessage("unloadData");\n      });\n      host.on("data", () => {\n        sendMessage("data");\n      });\n      host.darkmode.subscribe(\n        (value, mode) => sendMessage("darkmodeChanged", {\n          mode,\n          value: darkmodeValue({ mode, value })\n        })\n      );\n      if (options2.postponeMessages) {\n        Promise.resolve().then(() => {\n          for (let message of options2.postponeMessages) {\n            processIncomingMessage({ data: message });\n          }\n        });\n      }\n      addEventListener("message", processIncomingMessage, false);\n      addEventListener("unload", () => sendMessage("destroy"), false);\n      sendMessage("ready", {\n        page: {\n          hash: host.pageHash || "#",\n          id: host.pageId,\n          ref: host.pageRef,\n          params: host.pageParams\n        },\n        darkmode: {\n          mode: host.darkmode.mode,\n          value: darkmodeValue(host.darkmode)\n        }\n      });\n    };\n  }\n  var embed_client_default, noop2, navSection, navAction;\n  var init_embed_client = __esm({\n    "node_modules/@discoveryjs/discovery/src/extensions/embed-client.js"() {\n      init_id();\n      init_load_data();\n      embed_client_default = Object.assign(setup4(), { setup: setup4 });\n      noop2 = () => {\n      };\n      navSection = ["primary", "secondary", "menu"];\n      navAction = /* @__PURE__ */ new Map([\n        ["insert", 0],\n        ["prepend", 0],\n        ["append", 0],\n        ["before", 1],\n        ["after", 1],\n        ["replace", 1],\n        ["remove"]\n      ]);\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/extensions/router.js\n  function router_default(host) {\n    host.setPageHash(location.hash);\n    host.cancelScheduledRender();\n    host.action.define("permalink", (hash) => new URL(hash, location).href);\n    window.addEventListener("hashchange", () => host.setPageHash(location.hash), false);\n    host.on("pageHashChange", function(replace) {\n      const newPageHash = host.pageHash || "#";\n      if (host.routerPreventLocationUpdate) {\n        return;\n      }\n      if (newPageHash === "#" && !location.hash) {\n        return;\n      }\n      if (replace) {\n        location.replace(newPageHash);\n      } else {\n        location.hash = newPageHash;\n      }\n    });\n  }\n  var init_router = __esm({\n    "node_modules/@discoveryjs/discovery/src/extensions/router.js"() {\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/main/app.js\n  var coalesceOption, mixinEncodings, App;\n  var init_app = __esm({\n    "node_modules/@discoveryjs/discovery/src/main/app.js"() {\n      init_widget();\n      init_upload();\n      init_embed_client();\n      init_router();\n      init_dom();\n      init_progressbar();\n      init_buttons();\n      init_load_data();\n      coalesceOption = (value, fallback) => value !== void 0 ? value : fallback;\n      mixinEncodings = (host, options2) => ({\n        ...options2,\n        encodings: Array.isArray(options2?.encodings) ? [...options2.encodings, ...host.encodings] : host.encodings\n      });\n      App = class extends Widget2 {\n        constructor(options2 = {}) {\n          const extensions = options2.extensions ? [options2.extensions] : [];\n          extensions.push(darkmodeToggle);\n          if (coalesceOption(options2.router, true)) {\n            extensions.push(router_default);\n          }\n          if (options2.mode !== "modelfree") {\n            extensions.push(indexPage);\n            extensions.push(discoveryPage);\n          }\n          if (coalesceOption(options2.upload, false)) {\n            extensions.push(upload_default.setup(options2.upload));\n            extensions.push(loadData);\n          }\n          if (coalesceOption(options2.embed, false)) {\n            extensions.push(embed_client_default);\n          }\n          if (coalesceOption(options2.inspector, true)) {\n            extensions.push(inspect);\n          }\n          super({\n            container: document.body,\n            ...options2,\n            extensions,\n            darkmode: coalesceOption(options2.darkmode, "auto"),\n            darkmodePersistent: coalesceOption(options2.darkmodePersistent, true)\n          });\n          this.mode = this.options.mode;\n        }\n        setLoadingState(state, { error, progressbar } = {}) {\n          const loadingOverlayEl = this.dom.loadingOverlay;\n          switch (state) {\n            case "init": {\n              loadingOverlayEl.classList.remove("error", "done");\n              if (progressbar.el.parentNode) {\n                return;\n              }\n              loadingOverlayEl.innerHTML = "";\n              loadingOverlayEl.append(progressbar.el);\n              loadingOverlayEl.classList.add("init");\n              requestAnimationFrame(() => loadingOverlayEl.classList.remove("init"));\n              break;\n            }\n            case "success": {\n              loadingOverlayEl.classList.add("done");\n              break;\n            }\n            case "error": {\n              loadingOverlayEl.classList.add("error");\n              loadingOverlayEl.innerHTML = "";\n              this.view.render(loadingOverlayEl, [\n                {\n                  view: "block",\n                  className: "action-buttons",\n                  content: [\n                    {\n                      view: "preset/upload",\n                      when: this.preset.isDefined("upload")\n                    }\n                  ]\n                },\n                error.renderContent || {\n                  view: "alert-danger",\n                  content: [\n                    {\n                      view: "h3",\n                      content: [\n                        \'badge:"Error"\',\n                        { view: "text", when: "stage", data: "`[${stage}] `" },\n                        "text:errorText"\n                      ]\n                    },\n                    \'text:"(see details in the console)"\'\n                  ]\n                }\n              ], {\n                stage: progressbar?.lastStage,\n                errorText: error.message || String(error),\n                errorStack: (error.stack || "").replace(/^Error:\\s*(\\S+Error:)/, "$1")\n              }, {\n                actions: this.action.actionMap\n              }).then(() => {\n                this.log("error", error);\n                progressbar?.setState({ error });\n              });\n              break;\n            }\n          }\n        }\n        async setDataProgress(data, context, options2) {\n          const dataset = options2?.dataset;\n          const progressbar = options2?.progressbar || this.progressbar({ title: "Set data" });\n          try {\n            this.setLoadingState("init", { progressbar });\n            await super.setDataProgress(data, context, { dataset, progressbar });\n            this.setLoadingState("success");\n          } catch (error) {\n            this.setLoadingState("error", { error, progressbar });\n          }\n        }\n        progressbar(options2) {\n          return new Progressbar({\n            delay: 200,\n            domReady: this.dom.ready,\n            onFinish: (timings) => this.log({\n              level: "perf",\n              message: `${options2.title || "Load data"} (${timings[timings.length - 1].duration}ms)`,\n              collapsed: () => timings.map((timing) => `${timing.title}: ${timing.duration}ms`)\n            }),\n            ...options2\n          });\n        }\n        trackLoadDataProgress(loader) {\n          const progressbar = this.progressbar({ title: loader.title });\n          this.setLoadingState("init", { progressbar });\n          this.emit("startLoadData", progressbar.subscribe.bind(progressbar));\n          syncLoaderWithProgressbar(loader, progressbar).then(\n            (dataset) => this.setDataProgress(dataset.data, null, { dataset, progressbar }),\n            (error) => this.setLoadingState("error", { error, progressbar })\n          );\n          return loader.result;\n        }\n        loadDataFromStream(stream, options2) {\n          return this.trackLoadDataProgress(loadDataFromStream(\n            stream,\n            mixinEncodings(this, typeof options2 === "number" ? { size: options2 } : options2)\n          ));\n        }\n        loadDataFromEvent(event, options2) {\n          if (this.options.mode === "modelfree" && this.defaultPageId !== this.discoveryPageId) {\n            this._defaultPageId = this.defaultPageId;\n            this.defaultPageId = this.discoveryPageId;\n            this.setPageHash(this.pageHash, true);\n            this.cancelScheduledRender();\n          }\n          return this.trackLoadDataProgress(loadDataFromEvent(event, mixinEncodings(this, options2)));\n        }\n        loadDataFromFile(file, options2) {\n          return this.trackLoadDataProgress(loadDataFromFile(file, mixinEncodings(this, options2)));\n        }\n        loadDataFromUrl(url, options2) {\n          return this.trackLoadDataProgress(loadDataFromUrl(url, mixinEncodings(this, options2)));\n        }\n        unloadData() {\n          if (this.hasDatasets() && this.options.mode === "modelfree" && this._defaultPageId !== this.defaultPageId) {\n            this.defaultPageId = this._defaultPageId;\n            this.setPageHash(this.pageHash, true);\n            this.cancelScheduledRender();\n          }\n          super.unloadData();\n        }\n        initDom() {\n          super.initDom();\n          this.dom.container.append(\n            this.dom.loadingOverlay = createElement("div", "loading-overlay done")\n          );\n        }\n        renderPage() {\n          document.title = this.getRenderContext().name || document.title;\n          return super.renderPage();\n        }\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/main/index.js\n  var init_main = __esm({\n    "node_modules/@discoveryjs/discovery/src/main/index.js"() {\n      init_widget();\n      init_app();\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/core/utils/index.js\n  var utils_default;\n  var init_utils3 = __esm({\n    "node_modules/@discoveryjs/discovery/src/core/utils/index.js"() {\n      init_container_styles();\n      init_base64();\n      init_compare2();\n      init_copy_text();\n      init_debounce();\n      init_dom();\n      init_html();\n      init_inject_styles();\n      init_is_type();\n      init_json2();\n      init_layout();\n      init_load_data();\n      init_pattern();\n      init_persistent();\n      init_pointer();\n      init_progressbar();\n      init_safe_filter_rx();\n      init_size();\n      utils_default = {\n        ...container_styles_exports,\n        base64: base64_exports,\n        ...compare_exports,\n        copyText,\n        ...load_data_exports,\n        debounce,\n        ...dom_exports,\n        ...html_exports,\n        injectStyles,\n        ...is_type_exports,\n        ...json_exports,\n        ...layout_exports,\n        pattern: pattern_exports,\n        persistent: persistent_exports,\n        ...pointer_exports,\n        progressbar: Progressbar,\n        safeFilterRx,\n        ...size_exports\n      };\n    }\n  });\n\n  // node_modules/@discoveryjs/discovery/src/lib.js\n  var lib_exports = {};\n  __export(lib_exports, {\n    App: () => App,\n    Widget: () => Widget2,\n    embed: () => embed_client_default,\n    inspector: () => inspector_default,\n    jsonxl: () => jsonxl_default,\n    navButtons: () => buttons_exports,\n    pages: () => pages_exports,\n    router: () => router_default,\n    upload: () => upload_default,\n    utils: () => utils_default,\n    version: () => version,\n    views: () => views_exports\n  });\n  var init_lib = __esm({\n    "node_modules/@discoveryjs/discovery/src/lib.js"() {\n      init_version();\n      init_main();\n      init_views();\n      init_pages();\n      init_inspector();\n      init_upload();\n      init_router();\n      init_embed_client();\n      init_nav();\n      init_jsonxl();\n      init_utils3();\n    }\n  });\n\n  // app/views/flamechart/color-utils.ts\n  function generateHash(str) {\n    let hash = 0;\n    let maxHash = 0;\n    let weight = 1;\n    const mod2 = 10;\n    if (str) {\n      for (let i = 0; i < str.length; i++) {\n        if (i > MAX_CHAR) {\n          break;\n        }\n        hash += weight * (str.charCodeAt(i) % mod2);\n        maxHash += weight * (mod2 - 1);\n        weight *= 0.7;\n      }\n      if (maxHash > 0) {\n        hash = hash / maxHash;\n      }\n    }\n    return hash;\n  }\n  function generateColorVector(str) {\n    return str ? generateHash(str) : 0;\n  }\n  function calculateColor(hue, vector) {\n    let r;\n    let g2;\n    let b2;\n    switch (hue) {\n      case "red": {\n        r = 200 + Math.round(55 * vector);\n        g2 = 50 + Math.round(80 * vector);\n        b2 = g2;\n        break;\n      }\n      case "orange": {\n        r = 190 + Math.round(65 * vector);\n        g2 = 90 + Math.round(65 * vector);\n        b2 = 0;\n        break;\n      }\n      case "yellow": {\n        r = 175 + Math.round(55 * vector);\n        g2 = r;\n        b2 = 50 + Math.round(20 * vector);\n        break;\n      }\n      case "green": {\n        r = 50 + Math.round(60 * vector);\n        g2 = 200 + Math.round(55 * vector);\n        b2 = r;\n        break;\n      }\n      case "pastelgreen": {\n        r = 163 + Math.round(75 * vector);\n        g2 = 195 + Math.round(49 * vector);\n        b2 = 72 + Math.round(149 * vector);\n        break;\n      }\n      case "blue": {\n        r = 91 + Math.round(126 * vector);\n        g2 = 156 + Math.round(76 * vector);\n        b2 = 221 + Math.round(26 * vector);\n        break;\n      }\n      case "aqua": {\n        r = 50 + Math.round(60 * vector);\n        g2 = 165 + Math.round(55 * vector);\n        b2 = g2;\n        break;\n      }\n      case "cold": {\n        r = 0 + Math.round(55 * (1 - vector));\n        g2 = 0 + Math.round(230 * (1 - vector));\n        b2 = 200 + Math.round(55 * vector);\n        break;\n      }\n      default: {\n        r = 50 + 70 + Math.round(120 * vector);\n        g2 = 50 + 93 + Math.round(90 * (1 - vector));\n        b2 = 61 + Math.round(150 * (1e3 * vector % 2 ? vector : 1 - vector));\n      }\n    }\n    return [r, g2, b2].join(",");\n  }\n  var MAX_CHAR;\n  var init_color_utils = __esm({\n    "app/views/flamechart/color-utils.ts"() {\n      MAX_CHAR = 6;\n    }\n  });\n\n  // app/views/flamechart/event-emmiter.ts\n  var EventEmitter;\n  var init_event_emmiter = __esm({\n    "app/views/flamechart/event-emmiter.ts"() {\n      EventEmitter = class {\n        listeners;\n        constructor() {\n          this.listeners = /* @__PURE__ */ Object.create(null);\n        }\n        on(event, callback) {\n          this.listeners[event] = {\n            callback,\n            next: this.listeners[event] || null\n          };\n          return this;\n        }\n        once(event, callback) {\n          return this.on(event, function wrapper(...args) {\n            callback.apply(this, args);\n            this.off(event, wrapper);\n          });\n        }\n        off(event, callback) {\n          let cursor = this.listeners[event] || null;\n          let prev = null;\n          while (cursor !== null) {\n            if (cursor.callback === callback) {\n              cursor.callback = null;\n              if (prev) {\n                prev.next = cursor.next;\n              } else {\n                this.listeners[event] = cursor.next;\n              }\n              break;\n            }\n            prev = cursor;\n            cursor = cursor.next;\n          }\n          return this;\n        }\n        emit(event, ...args) {\n          let cursor = this.listeners[event] || null;\n          let hadListeners = false;\n          while (cursor !== null) {\n            if (typeof cursor.callback === "function") {\n              cursor.callback.apply(this, args);\n            }\n            hadListeners = true;\n            cursor = cursor.next;\n          }\n          return hadListeners;\n        }\n      };\n    }\n  });\n\n  // app/views/flamechart/index.ts\n  var flamechart_exports = {};\n  __export(flamechart_exports, {\n    FlameChart: () => FlameChart\n  });\n  function ensureFunction2(value, fallback) {\n    return typeof value === "function" ? value : fallback;\n  }\n  function defaultColorMapper(frame, colorHue = null) {\n    const { name } = frame;\n    const vector = generateColorVector(name);\n    const libtype = void 0;\n    let hue = colorHue || "warm";\n    if (!colorHue && !(typeof libtype === "undefined" || libtype === "")) {\n      hue = "red";\n      if (typeof name !== "undefined" && name && name.indexOf("::") !== -1) {\n        hue = "yellow";\n      }\n      if (libtype === "kernel") {\n        hue = "orange";\n      } else if (libtype === "jit") {\n        hue = "green";\n      } else if (libtype === "inlined") {\n        hue = "aqua";\n      }\n    }\n    return calculateColor(hue, vector);\n  }\n  var defaultGetName, defaultGetValue, FlameChart;\n  var init_flamechart = __esm({\n    "app/views/flamechart/index.ts"() {\n      init_color_utils();\n      init_event_emmiter();\n      defaultGetName = (frameData) => frameData.name;\n      defaultGetValue = (frameData) => frameData.value;\n      FlameChart = class extends EventEmitter {\n        el;\n        #resizeObserver = null;\n        #colorMapper = defaultColorMapper;\n        #colorHue = null;\n        #scheduleRenderTimer = null;\n        #childrenSort = null;\n        #lastVisibleFramesEpoch = 0;\n        #epoch = 0;\n        #width = 0;\n        // graph width\n        #minFrameWidth = 2;\n        zoomStart = 0;\n        zoomEnd = 1;\n        #getValue = defaultGetValue;\n        tree;\n        nodesMaxDepth;\n        nodesDepth;\n        nodesValue;\n        nodesX;\n        children;\n        childrenOffset;\n        childrenComputed;\n        nodesNames;\n        nodesColors;\n        zoomedNode = 0;\n        zoomedNodesStack = [];\n        selectedNode = -1;\n        frameEls = /* @__PURE__ */ new Map();\n        frameByEl = /* @__PURE__ */ new WeakMap();\n        constructor() {\n          super();\n          this.el = this.createElement(this);\n          this.on("frame:click", (nodeIndex, _, event) => {\n            if (event.metaKey) {\n              this.selectFrame(nodeIndex);\n            } else {\n              this.zoomFrame(nodeIndex, true);\n            }\n          });\n        }\n        createElement(chart) {\n          const chartEl = document.createElement("div");\n          chartEl.className = "flamechart";\n          chartEl.addEventListener("click", (event) => {\n            const result = chart.findFrameByEl(event.target);\n            if (result !== null) {\n              chart.emit("frame:click", result.frame.nodeIndex, result.element, event);\n            }\n          }, true);\n          chartEl.addEventListener("pointerenter", (event) => {\n            const result = chart.findFrameByEl(event.target);\n            if (result !== null) {\n              chart.emit("frame:enter", result.frame.nodeIndex, result.element);\n            }\n          }, true);\n          chartEl.addEventListener("pointerleave", () => {\n            chart.emit("frame:leave");\n          }, true);\n          if (typeof ResizeObserver === "function") {\n            this.#resizeObserver = new ResizeObserver((entries2) => {\n              const newWidth = entries2[entries2.length - 1].contentRect.width;\n              if (typeof newWidth === "number" && this.#width !== newWidth) {\n                this.#width = newWidth;\n                this.scheduleRender();\n              }\n            });\n            this.#resizeObserver.observe(chartEl);\n          }\n          return chartEl;\n        }\n        findFrameByEl(cursor) {\n          if (this.el.contains(cursor)) {\n            while (cursor !== null && cursor !== this.el) {\n              if (this.frameByEl.has(cursor)) {\n                return {\n                  element: cursor,\n                  frame: this.frameByEl.get(cursor)\n                };\n              }\n              cursor = cursor.parentNode;\n            }\n          }\n          return null;\n        }\n        selectFrame(nodeIndex) {\n          const prevSelected = this.selectedNode;\n          const subjectId = this.tree.nodes[nodeIndex];\n          const selectedSubjectId = this.tree.nodes[this.selectedNode];\n          if (selectedSubjectId !== subjectId && nodeIndex !== 0) {\n            this.selectedNode = nodeIndex;\n          } else {\n            this.selectedNode = -1;\n          }\n          this.emit("select", this.selectedNode, prevSelected);\n          this.scheduleRender();\n          return this.selectedNode;\n        }\n        resetFrameRefs() {\n          this.zoomedNode = 0;\n          this.zoomedNodesStack = [];\n          this.selectedNode = -1;\n          this.frameByEl = /* @__PURE__ */ new WeakMap();\n          this.frameEls.clear();\n        }\n        setData(tree, options2) {\n          options2 = options2 || {};\n          const getName = ensureFunction2(options2.name, defaultGetName);\n          const getValue = ensureFunction2(options2.value, defaultGetValue);\n          this.#childrenSort = options2.childrenSort === true || options2.childrenSort === "value" ? (a, b2) => values[b2] - values[a] : options2.childrenSort === "name" ? (a, b2) => {\n            const nameA = names[a];\n            const nameB = names[b2];\n            return nameA > nameB ? 1 : nameA < nameB ? -1 : 0;\n          } : ensureFunction2(options2.childrenSort, null);\n          const nodes2 = tree.nodes;\n          const parent = tree.parent;\n          const subtreeSize = tree.subtreeSize;\n          const depth = new Uint32Array(nodes2.length);\n          const children = new Uint32Array(nodes2.length);\n          const childrenOffset = new Uint32Array(nodes2.length);\n          const childrenComputed = new Uint32Array(nodes2.length);\n          const names = tree.dictionary.map(getName);\n          const values = new Uint32Array(nodes2.length);\n          const x = new Uint32Array(nodes2.length);\n          const nodesLength = nodes2.length;\n          let maxDepth = 0;\n          let childrenCursor = 0;\n          for (let i = 0; i < nodes2.length; i++) {\n            const nodeDepth = depth[parent[i]] + (i !== 0 ? 1 : 0);\n            let cursor = i + 1;\n            depth[i] = nodeDepth;\n            values[i] = getValue(i);\n            if (maxDepth < nodeDepth) {\n              maxDepth = nodeDepth;\n            }\n            if (cursor !== nodesLength && parent[cursor] === i) {\n              const end = i + subtreeSize[i];\n              while (cursor <= end) {\n                children[childrenCursor++] = cursor;\n                cursor += subtreeSize[cursor] + 1;\n              }\n            }\n            childrenOffset[i] = childrenCursor;\n          }\n          this.#epoch++;\n          this.#getValue = getValue;\n          this.nodesMaxDepth = maxDepth;\n          this.nodesDepth = depth;\n          this.nodesValue = values;\n          this.nodesX = x;\n          this.children = children;\n          this.childrenOffset = childrenOffset;\n          this.childrenComputed = childrenComputed;\n          this.nodesNames = names;\n          this.nodesColors = tree.dictionary.map((entry) => this.#colorMapper(entry, this.#colorHue));\n          this.tree = tree;\n          this.scheduleRender();\n        }\n        resetValues() {\n          this.#epoch++;\n          this.scheduleRender();\n        }\n        #computeChildren(nodeIdx, nodeX) {\n          const { nodesX, nodesValue, children, childrenOffset, childrenComputed } = this;\n          const { subtreeSize } = this.tree;\n          const getValue = this.#getValue;\n          if (childrenComputed[nodeIdx] === 0) {\n            childrenComputed[nodeIdx] = 1;\n            if (subtreeSize[nodeIdx] > 0) {\n              const offsetEnd = childrenOffset[nodeIdx];\n              const count3 = offsetEnd - (nodeIdx === 0 ? 0 : childrenOffset[nodeIdx - 1]);\n              const offset = offsetEnd - count3;\n              if (count3 > 1) {\n                const array = this.children.subarray(offset, offset + count3);\n                for (let j2 = 0; j2 < array.length; j2++) {\n                  const childId = array[j2];\n                  nodesValue[childId] = getValue(childId);\n                }\n                if (this.#childrenSort !== null) {\n                  array.sort(this.#childrenSort);\n                }\n                for (let j2 = 0, childX = nodeX; j2 < array.length; j2++) {\n                  const childId = array[j2];\n                  nodesX[childId] = childX;\n                  childX += nodesValue[childId];\n                }\n              } else if (count3 === 1) {\n                const childId = children[offset];\n                nodesValue[childId] = getValue(childId);\n                nodesX[childId] = nodeX;\n              }\n            }\n          }\n        }\n        #syncChildrenComputations() {\n          if (this.#lastVisibleFramesEpoch !== this.#epoch) {\n            this.#lastVisibleFramesEpoch = this.#epoch;\n            this.childrenComputed.fill(0);\n            this.#computeChildren(0, 0);\n            let rootValue = 0;\n            for (const childIndex of this.tree.children(0)) {\n              rootValue += this.nodesValue[childIndex];\n            }\n            this.nodesValue[0] = rootValue;\n            if (this.zoomedNode > 0) {\n              for (const ancestorIdx of [...this.tree.ancestors(this.zoomedNode)].reverse()) {\n                this.#computeChildren(ancestorIdx, this.nodesX[ancestorIdx]);\n              }\n              this.zoomFrame(this.zoomedNode);\n            }\n          }\n        }\n        getVisibleFrames(start = this.zoomStart, end = this.zoomEnd, minScale = 0) {\n          if (this.tree === null) {\n            return [];\n          }\n          const { nodesX, nodesValue, nodesDepth } = this;\n          const { dictionary, nodes: nodes2, subtreeSize } = this.tree;\n          this.#syncChildrenComputations();\n          const rootWidth = nodesValue[0];\n          const minValue = (end - start) * rootWidth * minScale;\n          const nodeList = [];\n          for (let i = 0; i < nodes2.length; i++) {\n            const nodeValue = nodesValue[i];\n            const nodeX = nodesX[i];\n            const x0 = nodeX / rootWidth;\n            const x1 = (nodeX + nodeValue) / rootWidth;\n            if (x0 < end && x1 > start && nodeValue >= minValue) {\n              nodeList.push({\n                nodeIndex: i,\n                value: dictionary[nodes2[i]],\n                name: this.nodesNames[nodes2[i]],\n                color: this.nodesColors[nodes2[i]],\n                x0,\n                x1,\n                depth: nodesDepth[i]\n              });\n              this.#computeChildren(i, nodeX);\n            } else {\n              i += subtreeSize[i];\n            }\n          }\n          return nodeList;\n        }\n        scheduleRender() {\n          if (this.#scheduleRenderTimer === null) {\n            const requestId = requestAnimationFrame(() => {\n              if (this.#scheduleRenderTimer === requestId) {\n                this.render();\n                this.#scheduleRenderTimer = null;\n              }\n            });\n            this.#scheduleRenderTimer = requestId;\n          }\n        }\n        render() {\n          this.#syncChildrenComputations();\n          this.#scheduleRenderTimer = null;\n          if (this.#width === 0 && this.#resizeObserver) {\n            return;\n          }\n          const widthScale = 1 / (this.#width || 1e3);\n          const xScale = 1 / (this.zoomEnd - this.zoomStart);\n          const xOffset = this.zoomStart * xScale;\n          const firstEnter = !this.frameEls.size;\n          const removeFrameNodeIndecies = new Set(this.frameEls.keys());\n          const visibleFrames = this.getVisibleFrames(\n            this.zoomStart,\n            this.zoomEnd,\n            this.#minFrameWidth * widthScale\n          );\n          const enterFramesBuffer = document.createDocumentFragment();\n          const nodes2 = this.tree.nodes;\n          const selectedId = this.selectedNode !== -1 ? nodes2[this.selectedNode] : -1;\n          let maxDepth = 0;\n          for (const frame of visibleFrames) {\n            const nodeIndex = frame.nodeIndex;\n            const className = nodeIndex === 0 ? "frame" : `frame${nodeIndex < this.zoomedNode ? " fade" : ""}${this.zoomedNode === nodeIndex ? " zoomed" : ""}${nodes2[nodeIndex] === selectedId ? " similar" : ""}`;\n            const x0 = Math.max(0, frame.x0 * xScale - xOffset);\n            const x1 = Math.max(0, frame.x1 * xScale - xOffset);\n            let frameEl = this.frameEls.get(frame.nodeIndex);\n            if (frame.depth > maxDepth) {\n              maxDepth = frame.depth;\n            }\n            if (frameEl === void 0) {\n              frameEl = document.createElement("div");\n              frameEl.className = className;\n              frameEl.style.setProperty("--x0", x0.toFixed(8));\n              frameEl.style.setProperty("--x1", x1.toFixed(8));\n              frameEl.style.setProperty("--depth", String(frame.depth));\n              frameEl.style.setProperty("--color", frame.color);\n              const labelEl = frameEl.appendChild(document.createElement("div"));\n              labelEl.className = "frame-label";\n              labelEl.textContent = frame.name;\n              enterFramesBuffer.append(frameEl);\n              this.frameByEl.set(frameEl, frame);\n              this.frameEls.set(frame.nodeIndex, frameEl);\n            } else {\n              frameEl.className = className;\n              frameEl.style.setProperty("--x0", x0.toFixed(8));\n              frameEl.style.setProperty("--x1", x1.toFixed(8));\n            }\n            removeFrameNodeIndecies.delete(frame.nodeIndex);\n          }\n          for (const nodeIndex of removeFrameNodeIndecies) {\n            this.frameEls.get(nodeIndex)?.remove();\n            this.frameEls.delete(nodeIndex);\n          }\n          this.el.classList.toggle("first-enter", firstEnter);\n          this.el.style.setProperty("--max-depth", String(maxDepth));\n          this.el.style.setProperty("--width-scale", widthScale.toFixed(8));\n          if (enterFramesBuffer.firstChild !== null) {\n            const enterFramesGroupEl = this.el.querySelector(".frames-group:empty") || document.createElement("div");\n            enterFramesGroupEl.append(enterFramesBuffer);\n            enterFramesGroupEl.className = "frames-group frames-group_init-enter-state";\n            setTimeout(() => enterFramesGroupEl.classList.remove("frames-group_init-enter-state"), 1);\n            this.el.prepend(enterFramesGroupEl);\n          }\n          this.emit(\n            "render",\n            this.frameEls.get(0)?.firstElementChild || null,\n            this.frameByEl.get(this.frameEls.get(0)) || null,\n            this.nodesValue[0]\n          );\n        }\n        zoomFrame(nodeIndex = 0, toggle = false) {\n          const rootValue = this.nodesValue[0];\n          const nodesDepth = this.nodesDepth;\n          const prevZoomedNode = this.zoomedNode;\n          const prevZoomStart = this.zoomStart;\n          const prevZoomEnd = this.zoomEnd;\n          if (this.zoomedNode !== nodeIndex && nodeIndex !== 0) {\n            if (this.zoomedNode !== 0) {\n              this.zoomedNodesStack = this.zoomedNodesStack.filter((item) => nodesDepth[item] < nodesDepth[nodeIndex]);\n              if (nodesDepth[this.zoomedNode] < nodesDepth[nodeIndex]) {\n                this.zoomedNodesStack.push(this.zoomedNode);\n              }\n            }\n            this.zoomedNode = nodeIndex;\n          } else if (this.zoomedNode === nodeIndex) {\n            if (toggle) {\n              this.zoomedNode = 0;\n              if (this.zoomedNodesStack.length > 0) {\n                this.zoomedNode = this.zoomedNodesStack.pop();\n              }\n            } else {\n              while (this.zoomedNode !== 0 && this.nodesValue[this.zoomedNode] === 0 && this.zoomedNodesStack.length > 0) {\n                this.zoomedNode = this.zoomedNodesStack.pop();\n              }\n              if (this.nodesValue[this.zoomedNode] === 0) {\n                this.zoomedNode = 0;\n              }\n            }\n          } else if (this.zoomedNode !== 0) {\n            this.zoomedNode = 0;\n            this.zoomedNodesStack = [];\n          }\n          this.zoomStart = this.nodesX[this.zoomedNode] / rootValue;\n          this.zoomEnd = this.zoomStart + this.nodesValue[this.zoomedNode] / rootValue;\n          if (prevZoomedNode !== this.zoomedNode || prevZoomStart !== this.zoomStart || prevZoomEnd !== this.zoomEnd) {\n            this.emit("zoom", this.zoomedNode, this.zoomStart, this.zoomEnd);\n          }\n          this.scheduleRender();\n        }\n        resetZoom() {\n          this.zoomFrame(0);\n        }\n        get colorHue() {\n          return this.#colorHue;\n        }\n        set colorHue(colorHue) {\n          this.#colorHue = colorHue;\n          this.scheduleRender();\n        }\n        get colorMapper() {\n          return this.#colorMapper;\n        }\n        set colorMapper(colorMapper) {\n          this.#colorMapper = colorMapper;\n          this.scheduleRender();\n        }\n        get minFrameWidth() {\n          return this.#minFrameWidth;\n        }\n        set minFrameWidth(minWidth) {\n          this.#minFrameWidth = minWidth;\n          this.scheduleRender();\n        }\n        destroy() {\n          this.emit("destroy");\n          this.resetFrameRefs();\n          if (this.#resizeObserver) {\n            this.#resizeObserver.disconnect();\n            this.#resizeObserver = null;\n          }\n          this.el.remove();\n          this.el = null;\n        }\n      };\n    }\n  });\n\n  // app/views/flamechart/tooltip.js\n  var tooltip_exports = {};\n  __export(tooltip_exports, {\n    default: () => tooltip_default\n  });\n  function tooltip_default(host, render2) {\n    let hideTimer;\n    let renderedFrame = null;\n    let popup = new host.view.Popup({\n      className: "flamechart-tooltip",\n      position: "pointer",\n      positionMode: "natural",\n      showDelay: 150\n    });\n    return {\n      show(frame) {\n        if (popup === null) {\n          return;\n        }\n        clearTimeout(hideTimer);\n        popup.show(null, renderedFrame !== frame ? (el) => render2(el, frame) : void 0);\n        renderedFrame = frame;\n      },\n      hide() {\n        if (popup === null) {\n          return;\n        }\n        clearTimeout(hideTimer);\n        hideTimer = setTimeout(() => popup.hide(), 150);\n      },\n      destroy() {\n        if (popup === null) {\n          return;\n        }\n        clearTimeout(hideTimer);\n        renderedFrame = null;\n        popup.destroy?.();\n        popup = null;\n      }\n    };\n  }\n  var init_tooltip = __esm({\n    "app/views/flamechart/tooltip.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/flamechart.js\n  var flamechart_exports2 = {};\n  __export(flamechart_exports2, {\n    default: () => flamechart_default\n  });\n  function flamechart_default(discovery) {\n    const { utils } = (init_lib(), __toCommonJS(lib_exports));\n    const { FlameChart: FlameChart2 } = (init_flamechart(), __toCommonJS(flamechart_exports));\n    const Tooltip = (init_tooltip(), __toCommonJS(tooltip_exports)).default;\n    function findFirstPageContentChild(el) {\n      let cursor = el;\n      while (cursor !== null && cursor.parentNode !== discovery.dom.pageContent) {\n        cursor = cursor.parentNode;\n      }\n      return cursor;\n    }\n    const defaultRootContent = {\n      view: "block",\n      className: "root-content",\n      content: [\n        "text:root.name",\n        "duration:{ time: rootValue, total: #.data.totalTime }",\n        {\n          view: "block",\n          className: "zoom-timings",\n          when: "zoomedNode.node != rootNode.node",\n          content: "duration:{ time: zoomedNode.totalTime, total: #.data.totalTime }"\n        }\n      ]\n    };\n    const defaultTooltipContent = [\n      {\n        view: "switch",\n        data: "node.value",\n        content: [\n          { when: \'marker("package")\', content: [\n            "package-badge"\n          ] },\n          { when: \'marker("module")\', content: [\n            "module-badge"\n          ] },\n          { when: \'marker("function")\', content: [\n            "module-badge:module",\n            { view: "block", content: "text:name" }\n          ] },\n          { content: [\n            { view: "block", content: "text:name" }\n          ] }\n        ]\n      },\n      {\n        view: "duration",\n        className: "total",\n        data: "{ time: totalTime, total: #.data.totalTime }"\n      },\n      {\n        view: "duration",\n        className: "self",\n        data: "{ time: selfTime, total: #.data.totalTime }"\n      }\n    ];\n    const defaultDetailsContent = [\n      {\n        view: "block",\n        content: {\n          view: "switch",\n          data: "value or node.value",\n          content: [\n            { when: \'marker("package")\', content: [\n              "package-badge"\n            ] },\n            { when: \'marker("module")\', content: [\n              "module-badge"\n            ] },\n            { when: \'marker("function")\', content: [\n              "module-badge:module",\n              { view: "block", content: \'link:{ text: name, href: marker("function").href }\' }\n            ] },\n            { content: [\n              \'badge:{ text: name, href: marker("category").href }\'\n            ] }\n          ]\n        }\n      },\n      {\n        view: "block",\n        content: [\n          {\n            view: "duration",\n            className: "total",\n            data: "{ time: totalTime, total: #.data.totalTime }"\n          },\n          {\n            view: "duration",\n            className: "self",\n            data: "{ time: selfTime, total: #.data.totalTime }"\n          }\n        ]\n      }\n    ];\n    discovery.view.define("flamechart", function(el, config, data, context) {\n      const {\n        tree,\n        timings,\n        timingsMap,\n        lockScrolling,\n        rootContent = defaultRootContent,\n        tooltipContent = defaultTooltipContent,\n        detailsContent = defaultDetailsContent\n      } = config;\n      const contentEl = utils.createElement("div", "view-flamechart__content");\n      const destroyEl = utils.createElement("destroy-flamechart");\n      const getNodeTimings = (nodeIndex) => timings.getTimings(timingsMap ? timingsMap[nodeIndex] : nodeIndex);\n      const enableScrolling = (e) => {\n        if (e.which !== 3 && el.classList.contains("fully-visible")) {\n          setTimeout(() => el.classList.remove("disable-scrolling"), 0);\n        }\n      };\n      const enableScrollingEl = utils.createElement("div", {\n        class: "view-flamechart__enable-scrolling-button",\n        onclick: enableScrolling\n      }, "Start interacting with the chart or click the button to enable scrolling");\n      const tooltip = new Tooltip(\n        discovery,\n        (el2, nodeIndex) => this.render(el2, tooltipContent, getNodeTimings(nodeIndex), context)\n      );\n      let detailsNodeIndex = -1;\n      let selectedNodeIndex = -1;\n      let zoomedNodeIndex = -1;\n      const detailsEl = utils.createElement("div", "view-flamechart__details", "test");\n      const renderDetails = (force) => {\n        const nextDetailsNodeIndex = selectedNodeIndex !== -1 ? selectedNodeIndex : zoomedNodeIndex > 0 ? zoomedNodeIndex : -1;\n        if (nextDetailsNodeIndex !== detailsNodeIndex || force) {\n          detailsNodeIndex = nextDetailsNodeIndex;\n          if (detailsNodeIndex >= 0) {\n            detailsEl.classList.add("has-details");\n            detailsEl.innerHTML = "";\n            this.render(\n              detailsEl,\n              detailsContent,\n              selectedNodeIndex !== -1 ? timings.getValueTimings(tree.nodes[detailsNodeIndex]) : getNodeTimings(detailsNodeIndex),\n              context\n            );\n          } else {\n            detailsEl.classList.remove("has-details");\n          }\n        }\n      };\n      const chart = new FlameChart2(contentEl).on("render", (rootEl, rootFrame, rootValue) => {\n        if (rootEl !== null && rootContent) {\n          rootEl.innerHTML = "";\n          this.render(rootEl, rootContent, {\n            root: rootFrame,\n            rootValue,\n            rootNode: getNodeTimings(0),\n            zoomedNode: getNodeTimings(zoomedNodeIndex !== -1 ? zoomedNodeIndex : 0)\n          }, context);\n        }\n      }).on("select", (nodeIndex) => {\n        selectedNodeIndex = nodeIndex;\n        renderDetails();\n      }).on("zoom", (nodeIndex) => {\n        zoomedNodeIndex = nodeIndex;\n        renderDetails();\n      }).on("frame:enter", tooltip.show).on("frame:leave", tooltip.hide).on("destroy", tooltip.destroy);\n      chart.colorMapper = discovery.queryFn(`\n        | (package or $ | registry or type) or category.name or name\n        | color(true)\n    `);\n      const { selfTimes, nestedTimes } = timings;\n      const unsubscribeTimings = timings.on(utils.debounce(() => {\n        chart.resetValues();\n        renderDetails(true);\n        if (lockScrolling) {\n          el.classList.add("disable-scrolling");\n        }\n      }, 16, { maxWait: 48 }));\n      chart.setData(tree, {\n        name: (value) => value.name || value.packageRelPath,\n        value: timingsMap ? (nodeIndex) => selfTimes[timingsMap[nodeIndex]] + nestedTimes[timingsMap[nodeIndex]] : (nodeIndex) => selfTimes[nodeIndex] + nestedTimes[nodeIndex],\n        childrenSort: true\n      });\n      renderDetails();\n      contentEl.append(chart.el);\n      el.append(contentEl, detailsEl, enableScrollingEl, destroyEl);\n      if (lockScrolling) {\n        el.classList.add("lock-scrolling", "disable-scrolling");\n      }\n      const removeOnScrollListener = discovery.addHostElEventListener("scroll", ({ target }) => {\n        if (el.classList.contains("disable-scrolling")) {\n          return;\n        }\n        if (target.contains(el) && !el.contains(target)) {\n          el.classList.add("disable-scrolling");\n        }\n      }, {\n        capture: true,\n        passive: true\n      });\n      let removeOnPointerDownListener = null;\n      let intersectionObserver = null;\n      let detailsResizeObserver = null;\n      destroyEl.onConnect = () => {\n        const firstPageContentChild = findFirstPageContentChild(el);\n        if (firstPageContentChild) {\n          firstPageContentChild.addEventListener("pointerdown", enableScrolling, true);\n          removeOnPointerDownListener = () => firstPageContentChild.removeEventListener("pointerdown", enableScrolling, true);\n        }\n        intersectionObserver = new IntersectionObserver(function(entries2) {\n          for (const entry of entries2) {\n            el.classList.toggle("fully-visible", entry.intersectionRatio === 1);\n          }\n        }, {\n          root: document.body,\n          threshold: [0, 0.999, 1]\n        });\n        intersectionObserver.observe(el);\n        detailsResizeObserver = new ResizeObserver(function(entries2) {\n          for (const entry of entries2) {\n            el.style.setProperty("--details-height", `${entry.borderBoxSize[0].blockSize}px`);\n          }\n        });\n        detailsResizeObserver.observe(detailsEl);\n      };\n      destroyEl.onDestroy = () => {\n        removeOnPointerDownListener?.();\n        removeOnScrollListener();\n        unsubscribeTimings();\n        intersectionObserver.disconnect();\n        intersectionObserver = null;\n        detailsResizeObserver.disconnect();\n        detailsResizeObserver = null;\n        tooltip.destroy();\n        chart.destroy();\n      };\n    }, { tag: "div" });\n    class FlameChartElement extends HTMLElement {\n      connectedCallback() {\n        this.onConnect();\n        this.onConnect = null;\n      }\n      disconnectedCallback() {\n        this.onDestroy();\n        this.onDestroy = null;\n      }\n    }\n    customElements.define("destroy-flamechart", FlameChartElement);\n  }\n  var init_flamechart2 = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/flamechart.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/flamechart-expand.js\n  var flamechart_expand_exports = {};\n  __export(flamechart_expand_exports, {\n    default: () => flamechart_expand_default\n  });\n  function flamechart_expand_default(discovery) {\n    const { FocusCallTree: FocusCallTree2 } = (init_call_tree(), __toCommonJS(call_tree_exports));\n    discovery.view.define("flamechart-expand", function(el, config, data, context) {\n      const { header, tree, timings, value } = config;\n      const focusTree = new FocusCallTree2(tree, value);\n      return this.render(el, {\n        view: "expand",\n        expanded: true,\n        className: "flamechart-expand trigger-outside",\n        header: header || \'text:"Subtrees flame chart"\',\n        content: {\n          view: "context",\n          modifiers: {\n            view: "block",\n            className: "toolbar",\n            content: [\n              {\n                view: "toggle-group",\n                name: "dataset",\n                data: [\n                  { text: "Categories", value: "categoriesTree", active: tree === context.data.categoriesTree },\n                  { text: "Packages", value: "packagesTree", active: tree === context.data.packagesTree },\n                  { text: "Modules", value: "modulesTree", active: tree === context.data.modulesTree },\n                  { text: "Functions", value: "functionsTree", active: tree === context.data.functionsTree }\n                ]\n              }\n            ]\n          },\n          content: {\n            view: "flamechart",\n            tree: focusTree,\n            timings,\n            timingsMap: focusTree.timingsMap,\n            lockScrolling: true,\n            postRender(el2) {\n              el2.classList.toggle("lock-scrolling", true);\n            }\n          }\n        }\n      }, data, context);\n    }, { tag: false });\n  }\n  var init_flamechart_expand = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/flamechart-expand.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/loc-badge.js\n  var loc_badge_exports = {};\n  __export(loc_badge_exports, {\n    default: () => loc_badge_default\n  });\n  function loc_badge_default(discovery) {\n    discovery.view.define("loc-badge", {\n      view: "badge",\n      className: "function-loc",\n      data: \'function or $ | marker("function").object |? { ..., text: loc }\',\n      whenData: "text",\n      content: \'html:text.split(/:/).join(`<span class="delim">:</span>`)\',\n      postRender(el, _, data) {\n        let useProtocol = false;\n        if (data.module.path && data.module.path.match(/^(?:\\/|[a-z]:|file:\\/\\/)/i)) {\n          const filepath = data.module.path + data.text;\n          if (window.handleOpenInEditor) {\n            window.handleOpenInEditor(el, filepath);\n          }\n          if (useProtocol) {\n            el.href = "localfile://" + filepath;\n          } else {\n            el.target = "_blank";\n            el.href = "https://localfile.link?" + new URLSearchParams({\n              file: filepath\n            }).toString();\n          }\n        }\n      }\n    }, { tag: false });\n  }\n  var init_loc_badge = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/loc-badge.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/nested-timings-tree.js\n  var nested_timings_tree_exports = {};\n  __export(nested_timings_tree_exports, {\n    default: () => nested_timings_tree_default\n  });\n  function nested_timings_tree_default(discovery) {\n    discovery.view.define("nested-timings-tree", {\n      view: "update-on-timings-change",\n      timings: "=timings",\n      content: {\n        view: "tree",\n        limitLines: 10,\n        expanded: false,\n        emptyText: "No nesting calls",\n        data: `\n            $tree;\n            $subject;\n            $functions: #.data.functionsTreeTimingsFiltered.nestedTimings(subject, tree);\n            $totalTime: $functions.sum(=>selfTime);\n\n            $functions\n                .({ function: entry, time: selfTime, total: $totalTime })\n                .sort(time desc)\n                .group(=>function.module)\n                    .({ module: key, time: value.sum(=>time), total: $totalTime, functions: value })\n                    .sort(time desc)\n                .group(=>module.package)\n                    .({ package: key, time: value.sum(=>time), total: $totalTime, modules: value })\n                    .sort(time desc)\n        `,\n        itemConfig: {\n          content: ["package-badge:package", "duration"],\n          children: "modules",\n          itemConfig: {\n            content: ["module-badge:module", "duration"],\n            children: "functions",\n            itemConfig: {\n              content: ["function-badge:function", "duration"]\n            }\n          }\n        }\n      }\n    });\n  }\n  var init_nested_timings_tree = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/nested-timings-tree.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/page-indicator.js\n  var page_indicator_exports = {};\n  __export(page_indicator_exports, {\n    default: () => page_indicator_default\n  });\n  function page_indicator_default(discovery) {\n    const { utils: { createElement: createElement2 } } = (init_lib(), __toCommonJS(lib_exports));\n    function ensureArray2(value) {\n      return Array.isArray(value) ? value : value ? [value] : [];\n    }\n    discovery.view.define("page-indicators", function(el, config, data, context) {\n      const content = ensureArray2(this.normalizeConfig(config.content));\n      const normalizedContent = [];\n      let lastGroup = null;\n      for (let item of content) {\n        if (item.view === "page-indicator-group") {\n          normalizedContent.push(lastGroup = {\n            ...item,\n            content: ensureArray2(item.content)\n          });\n        } else {\n          if (lastGroup === null) {\n            normalizedContent.push(lastGroup = {\n              view: "page-indicator-group",\n              content: []\n            });\n          }\n          lastGroup.content.push(item);\n        }\n      }\n      return this.render(el, normalizedContent, data, context);\n    });\n    discovery.view.define("page-indicator-group", function(el, config, data, context) {\n      const content = ensureArray2(this.normalizeConfig(config.content)).map((item) => ({\n        view: "page-indicator",\n        ...item\n      }));\n      return this.render(el, content, data, context);\n    });\n    discovery.view.define("page-indicator", function(el, config, data, context) {\n      const { title, value, unit, annotation, content, hint } = config;\n      const titleEl = createElement2("span", "title", title);\n      const valueEl = createElement2("span", "value");\n      if (content) {\n        discovery.view.render(valueEl, content, data, context);\n      } else {\n        discovery.view.render(valueEl, { view: "text-with-unit", value, unit, content }, data, context);\n      }\n      el.append(titleEl, valueEl);\n      if (hint) {\n        const hintEl = createElement2("span", "hint");\n        this.tooltip(hintEl, {\n          showDelay: true,\n          className: "hint-tooltip",\n          ...typeof hint === "object" && !Array.isArray(hint) && !hint.view ? hint : { content: hint }\n        }, data, context);\n        el.append(hintEl);\n      }\n      if (annotation) {\n        const annotationEl = createElement2("span", "annotation");\n        this.render(annotationEl, annotation, data, context);\n        el.append(annotationEl);\n      }\n    });\n  }\n  var init_page_indicator = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/page-indicator.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/page-indicator-timings.js\n  var page_indicator_timings_exports = {};\n  __export(page_indicator_timings_exports, {\n    default: () => page_indicator_timings_default\n  });\n  function page_indicator_timings_default(discovery) {\n    const definitions = {\n      selfTime: "The time spent executing a function\'s own code, excluding any time used by other functions it calls.",\n      nestedTime: "The time accounted for the execution of functions that are called by a given function, excluding the time taken to execute the original function\'s own code itself.",\n      totalTime: "The complete time taken to execute a function. It includes both \'self time\', which is the time the function spends executing its own code, and \'nested time\', which is the time spent executing all other functions that are called from within this function."\n    };\n    function hint(title, slug) {\n      return \'md{ source: "#### \' + title + "\\\\n\\\\" + definitions[slug] + \'\\\\n\\\\nFor modules, packages, or categories, it represents the accumulated time for all functions that belong to them.\\\\n\\\\nA \\\\`Filtered\\\\` badge indicates that the displayed time represents only a portion of the total time, due to a selected range on the timeline." }\';\n    }\n    function hintPercent(title, slug) {\n      return \'md{ source: "#### \' + title + ", %\\\\n\\\\nRepresents the proportion of the total duration of a profiling session.\\\\n\\\\n`100%` \\xD7 `{{filtered." + slug + " | ms()}}` \\u2044 `{{#.data.totalTime | ms()}}` = `{{filtered." + slug + \' | totalPercent(2)}}`" }\';\n    }\n    discovery.view.define("page-indicator-timings", {\n      view: "page-indicator-group",\n      className: "view-page-indicator-timings",\n      content: [\n        {\n          title: "Self time",\n          hint: hint("Self time", "selfTime"),\n          content: [\n            { view: "text-with-unit", value: \'=filtered.selfTime | ? ms() : "\\u2014"\', unit: true },\n            { view: "text-with-unit", value: \'=full.selfTime | ? ms() : "\\u2014"\', unit: true }\n          ],\n          annotation: {\n            view: "badge",\n            when: "filtered.selfTime != full.selfTime",\n            content: \'text:"filtered"\'\n          }\n        },\n        {\n          title: "Self time, %",\n          hint: hintPercent("Self time", "selfTime"),\n          value: \'=filtered.selfTime | ? totalPercent() : "\\u2014"\',\n          unit: true\n        },\n        {\n          title: "Nested time",\n          hint: hint("Nested time", "nestedTime"),\n          content: [\n            { view: "text-with-unit", value: \'=filtered.nestedTime | ? ms() : "\\u2014"\', unit: true },\n            { view: "text-with-unit", value: \'=full.nestedTime | ? ms() : "\\u2014"\', unit: true }\n          ],\n          annotation: {\n            view: "badge",\n            when: "filtered.nestedTime != full.nestedTime",\n            content: \'text:"filtered"\'\n          }\n        },\n        {\n          title: "Nested time, %",\n          hint: hintPercent("Nested time", "nestedTime"),\n          value: \'=filtered.nestedTime | ? totalPercent() : "\\u2014"\',\n          unit: true\n        },\n        {\n          title: "Total time",\n          hint: hint("Total time", "totalTime"),\n          content: [\n            { view: "text-with-unit", value: \'=filtered.totalTime | ? ms() : "\\u2014"\', unit: true },\n            { view: "text-with-unit", value: \'=full.totalTime | ? ms() : "\\u2014"\', unit: true }\n          ],\n          annotation: {\n            view: "badge",\n            when: "filtered.totalTime != full.totalTime",\n            content: \'text:"filtered"\'\n          }\n        },\n        {\n          title: "Total time, %",\n          hint: hintPercent("Total time", "totalTime"),\n          value: \'=filtered.totalTime | ? totalPercent() : "\\u2014"\',\n          unit: true\n        }\n      ]\n    }, { tag: false });\n  }\n  var init_page_indicator_timings = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/page-indicator-timings.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/subject-badges.js\n  var subject_badges_exports = {};\n  __export(subject_badges_exports, {\n    default: () => subject_badges_default\n  });\n  function subject_badges_default(discovery) {\n    discovery.view.define("package-badge", {\n      view: "badge",\n      data: `(module.package or package or $).marker("package") |? {\n        ...,\n        text: title,\n        match: #.filter\n    }`,\n      whenData: true,\n      className: "=`package subject-badge subject-badge_type__${object | registry or type}`",\n      content: "text-match",\n      postRender(el, _, data) {\n        const { registry, cdn, version: version3 } = data.object;\n        if (cdn && cdn !== registry) {\n          el.dataset.cdn = cdn;\n        }\n        if (version3) {\n          el.dataset.version = version3;\n        }\n      }\n    }, { tag: false });\n    discovery.view.define("module-badge", {\n      view: "badge",\n      data: `(module or $).marker("module") |? {\n        ...,\n        text: object | packageRelPath or path or name,\n        prefix: object.package | path and name != \'(script)\' and type not in [\'node\', \'deno\'] and name,\n        match: #.filter\n    }`,\n      whenData: true,\n      className: "=`module subject-badge subject-badge_type__${object.package | registry or type}`",\n      content: "text-match",\n      postRender(el, _, data) {\n        const { registry, cdn } = data.object.package;\n        if (cdn && cdn !== registry) {\n          el.dataset.cdn = cdn;\n        }\n      }\n    }, { tag: false });\n    discovery.view.define("function-badge", {\n      view: "badge",\n      data: `(function or $).marker("function") |? {\n        $name: object.name;\n        ...,\n        text: $name,\n        prefix: object.module |\n            package.type in ["node", "deno"]\n                ? packageRelPath\n                : (package | name not in ["(script)", "(compiled script)", $name] and name),\n        match: #.filter\n    }`,\n      whenData: true,\n      className: "=`function subject-badge subject-badge_type__${object.module.package | registry or type}`",\n      content: "text-match",\n      postRender(el, _, data) {\n        const { registry, cdn } = data.object.package;\n        if (cdn && cdn !== registry) {\n          el.dataset.cdn = cdn;\n        }\n      }\n    }, { tag: false });\n  }\n  var init_subject_badges = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/subject-badges.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/subject-with-nested-timeline.js\n  var subject_with_nested_timeline_exports = {};\n  __export(subject_with_nested_timeline_exports, {\n    default: () => subject_with_nested_timeline_default\n  });\n  function subject_with_nested_timeline_default(discovery) {\n    discovery.view.define("subject-with-nested-timeline", {\n      view: "context",\n      data: `\n        $subject;\n        $tree;\n        $subtree: $tree.subtreeSamples($subject);\n        $getCategory: $subject.marker(\'category\') ? =>$ : =>category;\n        $totalTime: #.data.totalTime;\n        $binCount: 500;\n        $binTime: $totalTime / $binCount;\n        $binSamples: $binCount.countSamples();\n        $totalTimeBins: $subtree.mask.binCallsFromMask($binCount);\n\n        {\n            $subject,\n            $subtree,\n            bins: $tree.binCalls($subject, $binCount),\n            $binCount,\n            $binTime,\n            $binSamples,\n            totalTime: $totalTime,\n            $totalTimeBins,\n            color: $subject.$getCategory().name.color(),\n            nested: (\n                $selector: $subtree.sampleSelector;\n                $subtree.entries.($getCategory()).sort(id asc).({\n                    $category: $;\n                    $category,\n                    color: name.color(),\n                    $binTime,\n                    bins: #.data.categoriesTree.binCalls(=>($=$category and $selector($$)), $binCount),\n                    $totalTimeBins\n                })\n            )\n        }\n    `,\n      content: [\n        {\n          view: "time-ruler",\n          labels: "top",\n          duration: "=totalTime",\n          segments: "=binCount",\n          selectionStart: "=#.data.samplesTimingsFiltered.rangeStart",\n          selectionEnd: "=#.data.samplesTimingsFiltered.rangeEnd",\n          onChange: (state, name, el, data, context) => {\n            if (state.timeStart !== null) {\n              context.data.samplesTimingsFiltered.setRange(state.timeStart, state.timeEnd);\n            } else {\n              context.data.samplesTimingsFiltered.resetRange();\n            }\n          },\n          details: [\n            {\n              view: "block",\n              className: "timeline-segment-info",\n              content: [\n                { view: "block", content: "text:`Range: ${#.timeStart.formatMicrosecondsTime(totalTime)} \\u2013 ${#.timeEnd.formatMicrosecondsTime(totalTime)}`" },\n                { view: "block", content: "text:`Samples: ${binSamples[#.segmentStart:#.segmentEnd + 1].sum()}`" },\n                { view: "block", content: [\'text:"Duration: "\', "duration:{ time: #.timeEnd - #.timeStart, total: totalTime }"] }\n              ]\n            },\n            {\n              view: "block",\n              className: "timeline-segment-info",\n              content: [\n                { view: "block", content: [\'text:"Self time: "\', "duration:{ time: bins[#.segmentStart:#.segmentEnd + 1].sum(), total: totalTime }"] },\n                { view: "block", content: [\'text:"Nested time: "\', "duration:{ time: totalTimeBins[#.segmentStart:#.segmentEnd + 1].sum(), total: totalTime }"] }\n              ]\n            },\n            {\n              view: "list",\n              className: "category-timings-list",\n              data: "nested",\n              itemConfig: {\n                className: \'=bins[#.segmentStart:#.segmentEnd + 1].sum() = 0 ? "no-time"\',\n                postRender: (el, _, data) => el.style.setProperty("--color", data.color),\n                content: [\n                  \'block{ className: "category-name", content: "text:category.name" }\',\n                  "duration{ data: { time: bins[#.segmentStart:#.segmentEnd + 1].sum(), total: totalTimeBins[#.segmentStart:#.segmentEnd + 1].sum() } }"\n                ]\n              }\n            }\n          ]\n        },\n        {\n          view: "timeline-segments-bin",\n          className: "self-time",\n          bins: "=bins",\n          presence: "=totalTimeBins",\n          max: "=binTime",\n          binsMax: true,\n          color: "=color",\n          height: 30\n        },\n        {\n          view: "timeline-segments-bin",\n          className: "nested-time",\n          bins: "=totalTimeBins",\n          max: "=binTime",\n          binsMax: true,\n          color: "=nested.size() > 1 ? color : nested[].color",\n          height: 30\n        },\n        {\n          view: "list",\n          className: "nested-work",\n          data: "nested",\n          whenData: "size() > 1",\n          item: {\n            view: "timeline-segments-bin",\n            bins: "=bins",\n            max: "=binTime",\n            binsMax: true,\n            color: "=color",\n            height: 20\n          }\n        }\n      ]\n    });\n  }\n  var init_subject_with_nested_timeline = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/subject-with-nested-timeline.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/text-with-unit.js\n  var text_with_unit_exports = {};\n  __export(text_with_unit_exports, {\n    default: () => text_with_unit_default\n  });\n  function text_with_unit_default(discovery) {\n    discovery.view.define("text-with-unit", function(el, config, data, context) {\n      const { value, unit, content } = config;\n      const valueText = unit === true ? String(value).replace(/[^\\d]+$/, "") : value;\n      if (content) {\n        this.render(el, content, data, context);\n      } else {\n        this.render(el, "text-numeric", valueText, context);\n      }\n      if (unit) {\n        const unitEl = document.createElement("span");\n        unitEl.className = "unit";\n        unitEl.textContent = unit === true ? String(value).slice(String(value).replace(/[^\\d]+$/, "").length) : unit;\n        el.append(unitEl);\n      }\n    }, { tag: "span" });\n  }\n  var init_text_with_unit = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/text-with-unit.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/time.js\n  var time_exports = {};\n  __export(time_exports, {\n    default: () => time_default\n  });\n  function time_default(discovery) {\n    const delim = \'<span class="num-delim"></span>\';\n    const definitions = {\n      selfTime: "#### Self time\\n\\nThe time spent executing a function\'s own code, excluding any time used by other functions it calls.",\n      nestedTime: "#### Nested time\\n\\nThe time accounted for the execution of functions that are called by a given function, excluding the time taken to execute the original function\'s own code itself.",\n      totalTime: "#### Total time\\n\\nThe complete time taken to execute a function. It includes both \'self time\', which is the time the function spends executing its own code, and \'nested time\', which is the time spent executing all other functions that are called from within this function."\n    };\n    function formatDuration(time) {\n      time /= 1e3;\n      const number = time === 0 ? 0 : time >= 1e3 ? time.toFixed(1).replace(/\\..+$|\\B(?=(\\d{3})+(\\D|$))/g, (m2) => m2 || delim) : time.toFixed(1);\n      return `${number}${delim}ms`;\n    }\n    function createRender(slug, getter2) {\n      return function render2(el, config, data, context) {\n        const time = typeof data === "number" ? data : getter2(data);\n        const valueEl = document.createElement("span");\n        const value = time !== 0 ? formatDuration(time) : "\\u2014";\n        const unit = value.match(/[a-z]*$/i)[0];\n        el.classList.add("view-time");\n        valueEl.className = "value";\n        valueEl.dataset.unit = unit;\n        valueEl.innerHTML = unit ? value.slice(0, -unit.length) : value;\n        el.append(valueEl);\n        this.tooltip(el, {\n          showDelay: true,\n          className: "hint-tooltip",\n          content: {\n            view: "md",\n            source: definitions[slug]\n          }\n        });\n        if (time) {\n          const fractionEl = document.createElement("span");\n          fractionEl.className = "fraction";\n          fractionEl.append(discovery.query("totalPercent()", time, context));\n          el.append(fractionEl);\n        }\n      };\n    }\n    discovery.view.define("self-time", createRender("selfTime", (data) => data?.selfTime), { tag: "span" });\n    discovery.view.define("nested-time", createRender("nestedTime", (data) => data?.totalTime - data?.selfTime), { tag: "span" });\n    discovery.view.define("total-time", createRender("totalTime", (data) => data?.totalTime), { tag: "span" });\n  }\n  var init_time = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/time.js"() {\n    }\n  });\n\n  // app/views/time-ruler.usage.js\n  var time_ruler_usage_exports = {};\n  __export(time_ruler_usage_exports, {\n    default: () => time_ruler_usage_default\n  });\n  var time_ruler_usage_default;\n  var init_time_ruler_usage = __esm({\n    "app/views/time-ruler.usage.js"() {\n      time_ruler_usage_default = {\n        demo: {\n          view: "time-ruler",\n          duration: 5e5,\n          content: \'text:"demo"\'\n        },\n        examples: [\n          {\n            title: "Using with context",\n            highlightProps: ["name"],\n            demo: {\n              view: "context",\n              modifiers: {\n                view: "time-ruler",\n                name: "myRuler",\n                duration: 5e5\n              },\n              content: "struct{ data: #.myRuler, expanded: 1 }"\n            }\n          },\n          {\n            title: "Segmented ruler",\n            highlightProps: ["segments"],\n            demo: {\n              view: "context",\n              modifiers: {\n                view: "time-ruler",\n                name: "ruler",\n                duration: 11,\n                segments: 10\n              },\n              content: "struct{ data: #.ruler, expanded: 1 }"\n            }\n          },\n          {\n            title: "Details popup",\n            highlightProps: ["segments"],\n            demo: [\n              {\n                view: "time-ruler",\n                duration: 15e5,\n                details: "struct{ data: #, expanded: 1 }"\n              },\n              \'badge:"Hover me and hold the pointer for a while"\'\n            ]\n          },\n          {\n            title: "Starting selection",\n            highlightProps: ["segments"],\n            demo: [\n              {\n                view: "time-ruler",\n                duration: 15e5,\n                selectionStart: 923499,\n                selectionEnd: 1230853,\n                details: "struct{ data: #, expanded: 1 }"\n              },\n              \'badge:"Hover me and hold the pointer for a while"\'\n            ]\n          }\n        ]\n      };\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/time-ruler.js\n  var time_ruler_exports = {};\n  __export(time_ruler_exports, {\n    default: () => time_ruler_default\n  });\n  function time_ruler_default(discovery) {\n    const { utils } = (init_lib(), __toCommonJS(lib_exports));\n    const { formatMicrosecondsTime: formatMicrosecondsTime2 } = (init_time_utils(), __toCommonJS(time_utils_exports));\n    const usage = (init_time_ruler_usage(), __toCommonJS(time_ruler_usage_exports)).default;\n    const SELECTION_NONE = "none";\n    const SELECTION_HOVERED = "hovered";\n    const SELECTION_SELECTING = "selecting";\n    const SELECTION_SELECTED = "selected";\n    const MOVING_NONE = "none";\n    const MOVING_TRIGGER = "trigger";\n    const MOVING_RANGE = "range";\n    const viewByEl = /* @__PURE__ */ new WeakMap();\n    const detailsTooltip = new discovery.view.Popup({\n      className: "view-time-ruler-tooltip",\n      position: "pointer",\n      positionMode: "natural",\n      pointerOffsetX: 30,\n      pointerOffsetY: 15,\n      showDelay: 100\n    });\n    let startSelectingRange = null;\n    let startSelectingPointerX = null;\n    let startSelectingPointerY = null;\n    let movingRange = null;\n    let movingPointerDelta = null;\n    let movingMode = MOVING_NONE;\n    let prevAnchorStart = null;\n    let prevAnchorEnd = null;\n    let currentViewEl = null;\n    function computeStep(n) {\n      let b2 = 1;\n      while (n > 10) {\n        b2 *= 10;\n        n = Math.floor(n / 10);\n      }\n      return n > 5 ? b2 : n >= 2.5 ? b2 / 2 : b2 / 4;\n    }\n    function nullIfNotNumber(value) {\n      return Number.isFinite(value) ? value : null;\n    }\n    function createState(duration2, segments, selectionStart = null, selectionEnd = null) {\n      selectionStart = nullIfNotNumber(selectionStart);\n      selectionEnd = nullIfNotNumber(selectionEnd);\n      if (!segments) {\n        segments = 1e3;\n      }\n      let segmentStart = null;\n      let segmentEnd = null;\n      let timeStart = null;\n      let timeEnd = null;\n      let start = null;\n      let end = null;\n      if (selectionStart !== null && selectionEnd !== null) {\n        segmentStart = Math.min(Math.floor(selectionStart * segments), segments - 1);\n        segmentEnd = Math.min(Math.floor(selectionEnd * segments), segments - 1);\n        if (segmentEnd === selectionEnd * segments && segmentStart !== segmentEnd) {\n          segmentEnd--;\n        }\n        start = segmentStart / segments;\n        end = (segmentEnd + 1) / segments;\n        timeStart = Math.ceil(start * duration2);\n        timeEnd = Math.min(Math.floor(end * duration2), duration2);\n      }\n      return {\n        duration: duration2,\n        segments,\n        start,\n        end,\n        segmentStart,\n        segmentEnd,\n        timeStart,\n        timeEnd\n      };\n    }\n    function getRulerFractionForPoint(timeRulerEl, x) {\n      const { segments, state: currentState } = viewByEl.get(timeRulerEl);\n      const rect = timeRulerEl.getBoundingClientRect();\n      const width = timeRulerEl.clientWidth;\n      const segmentsCount = segments || width;\n      const fractionRaw = Math.min(width, Math.max(0, x - rect.left)) / width;\n      const fraction = Math.round(fractionRaw * width) / width;\n      return { fraction, segmentsCount, rect, width, currentState };\n    }\n    function updateRulerSelection(timeRulerEl, x) {\n      const delta = movingMode !== MOVING_NONE ? movingPointerDelta : 0;\n      let { fraction, segmentsCount } = getRulerFractionForPoint(timeRulerEl, x + delta);\n      const hasSelection = timeRulerEl.dataset.state === SELECTION_SELECTED;\n      const isSelecting = timeRulerEl.dataset.state === SELECTION_SELECTING;\n      const {\n        data,\n        context,\n        render: render2,\n        state: currentState,\n        duration: duration2,\n        name,\n        details,\n        onChange: onChange4\n      } = viewByEl.get(timeRulerEl);\n      if (timeRulerEl !== currentViewEl) {\n        detailsTooltip.hide();\n        if (hasSelection) {\n          prevAnchorStart = currentState.start;\n          prevAnchorEnd = currentState.end;\n        } else {\n          timeRulerEl.dataset.state = SELECTION_HOVERED;\n          prevAnchorStart = null;\n          prevAnchorEnd = null;\n        }\n      }\n      if (fraction !== prevAnchorEnd || hasSelection) {\n        if (movingMode === MOVING_RANGE) {\n          fraction = Math.min(fraction, 1 - movingRange);\n          prevAnchorStart = fraction + movingRange;\n        }\n        if (!hasSelection) {\n          prevAnchorEnd = fraction;\n        }\n        const selectionStart = Math.min(prevAnchorStart !== null ? prevAnchorStart : prevAnchorEnd, prevAnchorEnd);\n        const selectionEnd = Math.max(prevAnchorStart !== null ? prevAnchorStart : prevAnchorEnd, prevAnchorEnd);\n        const hoverState = createState(duration2, segmentsCount, selectionStart, selectionEnd);\n        const newState = prevAnchorStart !== null ? hoverState : createState(duration2, segmentsCount);\n        if (!hasSelection) {\n          timeRulerEl.style.setProperty("--selection-start", hoverState.start);\n          timeRulerEl.style.setProperty("--selection-end", hoverState.end);\n          if (isSelecting) {\n            timeRulerEl.dataset.activeTrigger = movingMode === MOVING_RANGE ? "both" : selectionEnd === prevAnchorEnd ? "finish" : "start";\n          }\n        }\n        if (details) {\n          if (!hasSelection || fraction >= selectionStart && fraction <= selectionEnd) {\n            detailsTooltip.show(\n              timeRulerEl,\n              (el) => render2(el, details, data, {\n                ...context,\n                ...hasSelection ? newState : hoverState\n              })\n            );\n          } else {\n            detailsTooltip.hide();\n          }\n        }\n        if (!utils.equal(currentState, newState)) {\n          Object.assign(currentState, newState);\n          if (typeof onChange4 === "function") {\n            onChange4(newState, name, timeRulerEl, data, context);\n          }\n        }\n      }\n    }\n    discovery.addHostElEventListener("dragstart", (e) => {\n      if (currentViewEl !== null) {\n        e.preventDefault();\n      }\n    }, true);\n    discovery.addHostElEventListener("selectstart", (e) => {\n      if (currentViewEl !== null) {\n        e.preventDefault();\n      }\n    }, true);\n    discovery.addGlobalEventListener("pointerup", () => {\n      startSelectingRange = null;\n    });\n    discovery.addHostElEventListener("pointerdown", ({ buttons, pointerId, x, y: y2, target }) => {\n      if (currentViewEl === null || (buttons & 1) === 0) {\n        return;\n      }\n      if (currentViewEl.dataset.state === SELECTION_SELECTED) {\n        const rulerViewEl = currentViewEl;\n        const moverEl = rulerViewEl.querySelector(".view-time-ruler__selection-overlay-mover");\n        const { fraction, rect, width, currentState } = getRulerFractionForPoint(rulerViewEl, x);\n        if (moverEl.contains(target)) {\n          switch (target.dataset.trigger) {\n            case "start": {\n              movingMode = MOVING_TRIGGER;\n              movingPointerDelta = rect.left + currentState.start * width - x;\n              prevAnchorStart = currentState.end;\n              break;\n            }\n            case "finish": {\n              movingMode = MOVING_TRIGGER;\n              movingPointerDelta = rect.left + currentState.end * width - x;\n              prevAnchorStart = currentState.start;\n              break;\n            }\n            default:\n              movingMode = MOVING_RANGE;\n              movingPointerDelta = rect.left + currentState.start * width - x;\n              movingRange = currentState.end - currentState.start;\n          }\n          rulerViewEl.dataset.state = SELECTION_SELECTING;\n          rulerViewEl.setPointerCapture(pointerId);\n          rulerViewEl.addEventListener("pointerup", () => {\n            rulerViewEl.releasePointerCapture(pointerId);\n            rulerViewEl.dataset.state = SELECTION_SELECTED;\n            rulerViewEl.dataset.activeTrigger = "none";\n            movingMode = MOVING_NONE;\n          }, { capture: true, once: true });\n          return;\n        }\n        if (fraction > prevAnchorStart && fraction < prevAnchorEnd) {\n          return;\n        }\n        currentViewEl.dataset.state = SELECTION_HOVERED;\n      }\n      prevAnchorStart = null;\n      prevAnchorEnd = null;\n      startSelectingPointerX = x;\n      startSelectingPointerY = y2;\n      updateRulerSelection(currentViewEl, x);\n      startSelectingRange = () => {\n        const { fraction } = getRulerFractionForPoint(currentViewEl, startSelectingPointerX);\n        const rulerViewEl = currentViewEl;\n        startSelectingRange = null;\n        prevAnchorStart = fraction;\n        rulerViewEl.dataset.state = SELECTION_SELECTING;\n        rulerViewEl.setPointerCapture(pointerId);\n        rulerViewEl.addEventListener("pointerup", () => {\n          rulerViewEl.releasePointerCapture(pointerId);\n          rulerViewEl.dataset.state = SELECTION_SELECTED;\n          rulerViewEl.dataset.activeTrigger = "none";\n        }, { capture: true, once: true });\n      };\n    });\n    utils.pointerXY.subscribe(({ x, y: y2 }) => {\n      if (startSelectingRange !== null) {\n        if (Math.abs(startSelectingPointerX - x) < 2 && Math.abs(startSelectingPointerY - y2) < 2) {\n          return;\n        }\n        startSelectingRange();\n      }\n      if (currentViewEl?.dataset.state === SELECTION_SELECTING) {\n        updateRulerSelection(currentViewEl, x);\n        return;\n      }\n      const elementsFromPoint = discovery.dom.root.elementsFromPoint(x, y2);\n      const candidateEl = elementsFromPoint.find((el) => viewByEl.has(el)) || null;\n      const timeRulerEl = candidateEl?.parentNode.contains(elementsFromPoint[0]) ? candidateEl : null;\n      if (timeRulerEl) {\n        updateRulerSelection(timeRulerEl, x);\n      } else if (currentViewEl) {\n        detailsTooltip.hide();\n        if (currentViewEl.dataset.state !== SELECTION_SELECTED) {\n          currentViewEl.dataset.state = SELECTION_NONE;\n        }\n      }\n      currentViewEl = timeRulerEl;\n    });\n    discovery.view.define("time-ruler", function(el, options2, data, context) {\n      const {\n        duration: duration2,\n        segments: segmentsRaw,\n        selectionStart = null,\n        selectionEnd = null,\n        labels = "top",\n        name = "ruler",\n        details,\n        onInit,\n        onChange: onChange4\n      } = options2;\n      const segments = Number.isFinite(segmentsRaw) ? Math.min(segmentsRaw, duration2) : null;\n      const state = createState(\n        duration2,\n        segments,\n        selectionStart === null ? null : selectionStart / duration2,\n        selectionEnd === null ? null : selectionEnd / duration2\n      );\n      if (state.start !== null) {\n        el.dataset.state = SELECTION_SELECTED;\n        el.style.setProperty("--selection-start", state.start);\n        el.style.setProperty("--selection-end", state.end);\n      } else {\n        el.dataset.state = SELECTION_NONE;\n      }\n      viewByEl.set(el, {\n        data,\n        context,\n        state,\n        render: this.render,\n        duration: duration2,\n        segments,\n        name,\n        details,\n        onChange: onChange4\n      });\n      el.dataset.labels = ["top", "bottom", "both"].includes(labels) ? labels : "none";\n      const timeRulerStep = computeStep(duration2);\n      for (let time = 0; time < duration2 - timeRulerStep / 10; time += timeRulerStep) {\n        const intervalMarkerEl = el.appendChild(document.createElement("div"));\n        intervalMarkerEl.className = "interval-marker";\n        intervalMarkerEl.style.setProperty("--offset", time / duration2);\n        intervalMarkerEl.dataset.title = formatMicrosecondsTime2(time, duration2);\n      }\n      el.appendChild(\n        utils.createElement("div", "view-time-ruler__selection-overlay", [\n          utils.createElement("div", "view-time-ruler__selection-overlay-mover", [\n            utils.createElement("div", {\n              class: "view-time-ruler__selection-overlay-mover-trigger",\n              "data-trigger": "start"\n            }),\n            utils.createElement("div", {\n              class: "view-time-ruler__selection-overlay-mover-trigger",\n              "data-trigger": "finish"\n            })\n          ])\n        ])\n      );\n      if (typeof onInit === "function") {\n        onInit(state, name, el, data, context);\n      }\n    }, { usage });\n  }\n  var init_time_ruler = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/time-ruler.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/timeline-profiles.js\n  var timeline_profiles_exports = {};\n  __export(timeline_profiles_exports, {\n    default: () => timeline_profiles_default\n  });\n  function timeline_profiles_default(discovery) {\n    discovery.view.define("timeline-profiles", function(el, config, data, context) {\n      const profiles = Array.isArray(data) ? data : [];\n      const min2 = discovery.query("startTime.min() or 0", profiles);\n      const max2 = discovery.query("endTime.max() or 0", profiles);\n      const range = max2 - min2;\n      el.style.setProperty("--range", range);\n      for (const profile of profiles) {\n        const barEl = document.createElement("div");\n        barEl.className = "profile";\n        barEl.style.setProperty("--x1", (profile.startTime - min2) / range);\n        barEl.style.setProperty("--x2", (profile.endTime - min2) / range);\n        if (context.data.samples === profile.samples) {\n          barEl.classList.add("selected");\n        }\n        el.append(barEl);\n      }\n    });\n  }\n  var init_timeline_profiles = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/timeline-profiles.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/timeline-segments.js\n  var timeline_segments_exports = {};\n  __export(timeline_segments_exports, {\n    default: () => timeline_segments_default\n  });\n  function timeline_segments_default(discovery) {\n    const { utils } = (init_lib(), __toCommonJS(lib_exports));\n    function generateSmoothPath(points, height) {\n      const chartWidth = points.length;\n      const maxValue = Math.max(...points) || 1;\n      const normalizedY = points.map((point) => height - point / maxValue * height);\n      const stepX = chartWidth / (points.length - 1);\n      const pathData = [];\n      const n = points.length;\n      const tangents = [0];\n      for (let i = 1; i < n - 1; ++i) {\n        const deltaY = normalizedY[i + 1] - normalizedY[i - 1];\n        const deltaX = 2 * stepX;\n        tangents.push(deltaY / deltaX);\n      }\n      tangents.push(0);\n      pathData.push("M", 0, height);\n      pathData.push("L", 0, normalizedY[0]);\n      for (let i = 0; i < n - 1; ++i) {\n        const x0 = i * stepX;\n        const y0 = normalizedY[i];\n        const x1 = (i + 1) * stepX;\n        const y1 = normalizedY[i + 1];\n        const dx = stepX / 3;\n        const t0 = tangents[i];\n        const t1 = tangents[i + 1];\n        pathData.push(\n          "C",\n          x0 + dx,\n          y0 + dx * t0,\n          x1 - dx,\n          y1 - dx * t1,\n          x1,\n          y1\n        );\n      }\n      pathData.push("L", chartWidth, height);\n      pathData.push("Z");\n      return pathData.join(" ");\n    }\n    function generateSquarePath(points, height, maxValue, presence) {\n      const chartWidth = points.length;\n      const stepX = chartWidth / points.length;\n      const pathData = [];\n      const gap = 0.1;\n      const minNonZeroHeight = 1.5;\n      pathData.push("M", 0, height);\n      for (let i = 0; i < points.length; ++i) {\n        const y2 = (points[i] || (presence?.[i] || 0)) / maxValue;\n        if (y2 > 0) {\n          pathData.push(\n            "V",\n            height - Math.max(points[i] / maxValue * height, minNonZeroHeight),\n            "h",\n            stepX - gap,\n            "V",\n            height,\n            "h",\n            gap\n          );\n        } else {\n          pathData.push("h", stepX);\n        }\n      }\n      pathData.push("L", chartWidth, height);\n      pathData.push("Z");\n      return pathData.join(" ");\n    }\n    discovery.view.define("timeline-segments", function(el, config, data, context) {\n      data = ensureArray2(data);\n      const count3 = 500;\n      const totalTime = context.data.totalTime;\n      const step = totalTime / count3;\n      const stat = new Uint32Array(count3);\n      for (const [segStart, segEnd] of data) {\n        let start = Math.floor(segStart * count3 / totalTime);\n        let end = Math.floor(segEnd * count3 / totalTime);\n        if (start === end) {\n          stat[start] += segEnd - segStart;\n        } else {\n          stat[start] += step * (start + 1) - segStart;\n          stat[end] += segEnd - step * end;\n        }\n        for (let i = start + 1; i < end; i++) {\n          stat[i] += step;\n        }\n      }\n      const svgEl = document.createElementNS("http://www.w3.org/2000/svg", "svg");\n      const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");\n      pathEl.setAttribute("d", generateSmoothPath(Array.from(stat), 20));\n      svgEl.setAttribute("viewBox", `0 0 ${stat.length} 20`);\n      svgEl.setAttribute("preserveAspectRatio", "none");\n      svgEl.setAttribute("width", "100%");\n      svgEl.setAttribute("height", 20);\n      svgEl.append(pathEl);\n      el.append(svgEl);\n    });\n    function ensureArray2(value) {\n      return utils.isArray(value) ? value : [];\n    }\n    discovery.view.define("timeline-segments-bin", function(el, config, data) {\n      const presence = config.presence;\n      const bins = ensureArray2(config.bins || data);\n      const height = config.height || 20;\n      const maxValue = Math.max(...bins);\n      el.classList.add("view-timeline-segments");\n      if (config.color) {\n        el.style.setProperty("--color", config.color);\n      }\n      const svgEl = document.createElementNS("http://www.w3.org/2000/svg", "svg");\n      const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");\n      pathEl.setAttribute("d", generateSquarePath(Array.from(bins), height, config.max || maxValue, presence));\n      svgEl.setAttribute("viewBox", `0 0 ${bins.length} ${height}`);\n      svgEl.setAttribute("preserveAspectRatio", "none");\n      svgEl.setAttribute("width", "100%");\n      svgEl.setAttribute("height", height);\n      svgEl.append(pathEl);\n      el.append(svgEl);\n      if (config.binsMax && config.max && maxValue < config.max * 0.9) {\n        const relPathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");\n        relPathEl.classList.add("rel-path");\n        relPathEl.setAttribute("d", generateSquarePath(Array.from(bins), height, maxValue));\n        svgEl.prepend(relPathEl);\n      }\n    });\n  }\n  var init_timeline_segments = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/timeline-segments.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/timing-bar.js\n  var timing_bar_exports = {};\n  __export(timing_bar_exports, {\n    default: () => timing_bar_default\n  });\n  function timing_bar_default(discovery) {\n    discovery.view.define("timing-bar", function(el, config, data, context) {\n      const { limit, segment } = config;\n      if (!Array.isArray(data)) {\n        data = [data];\n      }\n      const entries2 = data.filter((entry) => isFinite(entry.duration) && entry.duration > 0);\n      const total = entries2.reduce((sum2, entry) => sum2 + entry.duration, 0);\n      this.renderList(\n        el,\n        this.composeConfig({ view: "timing-bar-segment", total }, segment),\n        entries2,\n        context,\n        0,\n        this.listLimit(limit, 25)\n      );\n    });\n    discovery.view.define("timing-bar-segment", function(el, config, data) {\n      const { total, content } = config;\n      const { text = "?", duration: duration2, href, color } = data || {};\n      const durationText = `${(duration2 / 1e3).toFixed(1)}ms`;\n      const durationPercentText = `${(100 * duration2 / total).toFixed(1)}%`;\n      const title = `${text} - ${durationText} - ${durationPercentText}`;\n      el.style.setProperty("--fraction", duration2 / total);\n      el.style.setProperty("--color", color);\n      if (href) {\n        el.href = href;\n      }\n      discovery.view.render(el, content || "text-numeric:title", { title });\n    }, { tag: "a" });\n  }\n  var init_timing_bar = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/timing-bar.js"() {\n    }\n  });\n\n  // discovery-wrapper:/Users/antfu/i/cpupro/app/views/update-on-timings-change.js\n  var update_on_timings_change_exports = {};\n  __export(update_on_timings_change_exports, {\n    default: () => update_on_timings_change_default\n  });\n  function update_on_timings_change_default(discovery) {\n    const { utils } = (init_lib(), __toCommonJS(lib_exports));\n    discovery.view.define("update-on-timings-change", function(el, config, data, context) {\n      const { timings = data, debounce: debounce2, content } = config;\n      let scheduledRender = null;\n      const updateRender = () => {\n        if (scheduledRender !== null) {\n          return;\n        }\n        scheduledRender = requestAnimationFrame(() => {\n          scheduledRender = null;\n          el.textContent = "";\n          this.render(el, content, data, context);\n        });\n      };\n      const unsubscribeSource = timings.on(\n        debounce2 ? utils.debounce(updateRender, debounce2 !== true ? debounce2 : { wait: 16, maxWait: 48 }) : updateRender\n      );\n      el.onDestroy = () => {\n        unsubscribeSource();\n      };\n      return this.render(el, content, data, context);\n    }, { tag: "update-on-timings-change" });\n    class UpdateOnTimingsChange extends HTMLElement {\n      connectedCallback() {\n        this.onConnect?.();\n        this.onConnect = null;\n      }\n      disconnectedCallback() {\n        this.onDestroy?.();\n        this.onDestroy = null;\n      }\n    }\n    customElements.define("update-on-timings-change", UpdateOnTimingsChange);\n  }\n  var init_update_on_timings_change = __esm({\n    "discovery-wrapper:/Users/antfu/i/cpupro/app/views/update-on-timings-change.js"() {\n    }\n  });\n\n  // discovery-cli:default/extensions.js\n  var extensions_default;\n  var init_extensions = __esm({\n    "discovery-cli:default/extensions.js"() {\n      extensions_default = [\n        (init_default(), __toCommonJS(default_exports)),\n        (init_category(), __toCommonJS(category_exports)),\n        (init_function(), __toCommonJS(function_exports)),\n        (init_module(), __toCommonJS(module_exports)),\n        (init_package(), __toCommonJS(package_exports)),\n        (init_mode_regexp(), __toCommonJS(mode_regexp_exports)),\n        (init_duration(), __toCommonJS(duration_exports)),\n        (init_flamechart2(), __toCommonJS(flamechart_exports2)),\n        (init_flamechart_expand(), __toCommonJS(flamechart_expand_exports)),\n        (init_loc_badge(), __toCommonJS(loc_badge_exports)),\n        (init_nested_timings_tree(), __toCommonJS(nested_timings_tree_exports)),\n        (init_page_indicator(), __toCommonJS(page_indicator_exports)),\n        (init_page_indicator_timings(), __toCommonJS(page_indicator_timings_exports)),\n        (init_subject_badges(), __toCommonJS(subject_badges_exports)),\n        (init_subject_with_nested_timeline(), __toCommonJS(subject_with_nested_timeline_exports)),\n        (init_text_with_unit(), __toCommonJS(text_with_unit_exports)),\n        (init_time(), __toCommonJS(time_exports)),\n        (init_time_ruler(), __toCommonJS(time_ruler_exports)),\n        (init_timeline_profiles(), __toCommonJS(timeline_profiles_exports)),\n        (init_timeline_segments(), __toCommonJS(timeline_segments_exports)),\n        (init_timing_bar(), __toCommonJS(timing_bar_exports)),\n        (init_update_on_timings_change(), __toCommonJS(update_on_timings_change_exports))\n      ];\n    }\n  });\n\n  // discovery-cli:default/model.js\n  var model_exports = {};\n  __export(model_exports, {\n    default: () => model_default\n  });\n  function model_default(setup5, progressbar, embedState, dataset) {\n    const model = setup5.model;\n    const app = new App({\n      mode: setup5.mode,\n      styles: setup5.styles,\n      darkmode: model.darkmode,\n      darkmodePersistent: model.darkmodePersistent,\n      upload: model.upload,\n      inspector: model.inspector,\n      router: model.router,\n      encodings: encodings_default,\n      extensions: [\n        ...extensions_default,\n        ...model.embed ? [embed_client_default.setup(embedState)] : [],\n        prepare_default2\n      ]\n    });\n    if (false) {\n      app.nav.menu.append({\n        name: "download",\n        data: {\n          text: "Download as single page",\n          href: model.download\n        }\n      });\n    }\n    if (false) {\n      app.nav.menu.append({\n        name: "drop-cache",\n        content: \'text:"Reload with no cache"\',\n        onClick: () => fetch("drop-cache").then(() => location.reload())\n      });\n      progressbar.subscribe(async ({ error }) => {\n        if (error) {\n          const buffer = document.createDocumentFragment();\n          await app.view.render(buffer, {\n            view: "button",\n            content: \'text:"Reload with no cache"\',\n            onClick: () => fetch("drop-cache").then(() => location.reload())\n          });\n          app.dom.loadingOverlay.querySelector(".action-buttons").prepend(buffer);\n        }\n      });\n    }\n    if (setup5.mode === "multi") {\n      app.nav.menu.append({\n        name: "switch-model",\n        onClick: \'=$handler:"openModelIndex".actionHandler(href); $hide: #.hide; $handler and => $hide() or $handler()\',\n        data: {\n          text: "Switch model",\n          href: setup5.indexUrl\n        }\n      });\n    }\n    const context = {\n      model\n    };\n    if (dataset) {\n      return app.setDataProgress(dataset.data, context, {\n        progressbar,\n        dataset\n      });\n    }\n    app.context = context;\n    return app.renderPage();\n  }\n  var init_model = __esm({\n    "discovery-cli:default/model.js"() {\n      init_prepare3();\n      init_encodings();\n      init_extensions();\n      init_lib();\n    }\n  });\n\n  // discovery-cli:default/setup.js\n  var setup = { "name": "Implicit config", "mode": "single", "embed": true, "darkmode": "auto", "darkmodePersistent": true, "model": { "name": "CPUpro", "slug": "default", "url": "report.html", "data": "default/data.json", "cache": false, "cacheReset": false, "upload": false, "download": false, "embed": true, "darkmode": "only", "darkmodePersistent": true, "inspector": true, "router": true, "meta": { "demos": [{ "runtime": "nodejs", "title": "V8 CPU profile", "url": "demo/nodejs.jsonxl" }, { "runtime": "deno", "title": "V8 log (preprocessed)", "url": "demo/deno.jsonxl" }, { "runtime": "chromium", "title": "Chromium Profile", "url": "demo/chromium.jsonxl" }, { "runtime": "edge", "title": "Edge EPT", "url": "demo/edge.jsonxl" }] } }, "indexUrl": "../index.html", "assets": { "model.css": "model.css", "model-loader.css": "model-loader.css" } };\n  if (!location.pathname.endsWith(".html")) {\n    if (setup.model) {\n      setup.indexUrl = setup.indexUrl.replace(/^\\.\\.\\/|index\\.html$/g, "");\n    }\n    if (setup.models) {\n      for (const model of setup.models) {\n        model.url = model.url.replace(/(^|\\/|\\\\)index\\.html$/, "$1");\n      }\n    }\n  }\n  var setup_default = setup;\n\n  // discovery-cli:default/model-loader.js\n  init_encodings();\n\n  // node_modules/@discoveryjs/discovery/src/preloader.js\n  init_progressbar();\n  init_load_data();\n  init_container_styles();\n  init_inject_styles();\n  init_id();\n  function createProgressbar(domReady, title) {\n    return new Progressbar({\n      delay: 300,\n      domReady,\n      title,\n      onTiming: ({ title: title2, duration: duration2 }) => console.log(`[Discovery/preloader] ${title2} \\u2013 ${duration2}ms`)\n    });\n  }\n  function preloader(options2) {\n    options2 = options2 || {};\n    const dataSourceType = options2.dataSource;\n    if (dataSourceType && !dataSource.hasOwnProperty(dataSourceType)) {\n      throw new Error(`dataSource "${dataSourceType}" is not supported`);\n    }\n    const container = options2.container || document.body;\n    const el = document.createElement("div");\n    const shadowRoot = el.attachShadow({ mode: "open" });\n    const darkmode = applyContainerStyles(container, options2);\n    if (darkmode) {\n      el.setAttribute("darkmode", "");\n    }\n    const loadData2 = dataSource[dataSourceType || "url"];\n    const loading = options2.data ? dataSourceType === "push" ? loadData2(options2.loadDataOptions) : loadData2(options2.data, options2.loadDataOptions) : {\n      result: Promise.resolve()\n    };\n    if (loading.push) {\n      window.discoveryLoader = {\n        start: loading.start,\n        push: loading.push,\n        finish(...args) {\n          delete window.discoveryLoader;\n          loading.finish(...args);\n        }\n      };\n    }\n    const domReady = injectStyles(shadowRoot, options2.styles);\n    const progressbar = options2.progressbar || createProgressbar(domReady, loading.title);\n    const disposeEmbed = options2.embed ? initPreloadEmbedApi(loading) : () => {\n    };\n    if (loading.state) {\n      syncLoaderWithProgressbar(loading, progressbar).catch(() => {\n      });\n    }\n    shadowRoot.append(progressbar.el);\n    container.append(el);\n    return Object.assign(\n      loading.result,\n      { el, shadowRoot, progressbar, disposeEmbed }\n    );\n  }\n  function initPreloadEmbedApi(loading) {\n    const hostId = randomId();\n    const parentWindow = window.parent;\n    const postponeMessages = [];\n    const sendMessage = (type, payload = null) => {\n      parentWindow.postMessage({\n        from: "discoveryjs-app",\n        id: hostId,\n        type,\n        payload\n      }, "*");\n    };\n    const sendDestroyMessage = () => sendMessage("destroy");\n    const processIncomingMessage = (event) => {\n      const { id, type } = event.data || {};\n      if (id === hostId) {\n        switch (type) {\n          case "defineAction":\n          case "setPageHash":\n          case "setRouterPreventLocationUpdate": {\n            postponeMessages.push(event.data);\n            break;\n          }\n          default:\n            console.error(`[Discovery/preloader] Unknown preload message type "${type}"`);\n        }\n      }\n    };\n    if (parentWindow === window) {\n      return;\n    }\n    addEventListener("message", processIncomingMessage, false);\n    addEventListener("unload", sendDestroyMessage, false);\n    sendMessage("preinit", {\n      page: {\n        hash: location.hash || "#"\n      }\n    });\n    const unsubscribeLoading = loading.state ? loading.state.subscribeSync(({ stage, progress, error }) => {\n      if (error || stage === "received") {\n        unsubscribeLoading();\n      }\n      return sendMessage("loadingState", { stage, progress, error });\n    }) : () => {\n    };\n    return () => {\n      removeEventListener("message", processIncomingMessage, false);\n      removeEventListener("unload", sendDestroyMessage, false);\n      unsubscribeLoading();\n      sendDestroyMessage();\n      return {\n        hostId,\n        postponeMessages\n      };\n    };\n  }\n\n  // node_modules/@discoveryjs/cli/lib/static/inflate/inflate.wasm\n  var inflate_default = "AGFzbQEAAAABEANgAABgAX8Bf2ADf39/AX8CEwEHaW1wb3J0cwZtZW1vcnkCAAADBgUAAQICAQYMAn8AQbMKC38BQQALBygDC2lucHV0T2Zmc2V0AwAMb3V0cHV0T2Zmc2V0AwEHaW5mbGF0ZQAECAEACuoIBQwAPwBBAXZBEHQkAQvEAQEEfyMAIgEiAiAAaiEEAkADQCAARSAEQQFrLQAAQT1Hcg0BIARBAWshBCAAQQFrIQAMAAsLA0AgAS0AAC0AswhBEnQgAUEBai0AAC0AswhBDHRyIAFBAmotAAAtALMIQQZ0ciABQQNqLQAALQCzCHIhAyACIANBEHY6AAAgAkEBaiADQQh2OgAAIAJBAmogAzoAACABQQRqIQEgAkEDaiECIAEgBEkNAAsCfyAAQQJ2QQNsCwJ/IABBA3FBBmxBA3YLagsrACACIAAgAk8NAANAIAAgAS0AADoAACABQQFqIQEgAEEBaiIAIAJJDQALCxAAIAEgACACIAFr/AsAIAIL1wYBGn8gABABIRMjACEBIwEhAiABQQMiBnQhBQN/An8CQAJ/AkACQAJAAkACfwJAAn8CQAJAAkACQAJAAkACQAJAIAVBA3YoAgAgBUEHcXZBASAGdEEBa3EhByAFIAZqIQUgAw4IAAQJBQcFDgUOCyAHQQFxIQQgB0EBdg4CAAECCyACIAVBB2pBA3YiAUEEaiIJIAIgAS8BACIaahACIQIgCSAaakEDdCEFDA4LQRVBCEEHQQlBCEEAQZABEANBgAIQA0GYAhADQaACIgsQA0HAAhADIQ5BBQwHC0EODA0LIAdBBXZBH3EgB0EfcUGBAmoiC2pBAWohDCAHQQp2QQRqIQ1BACIKQQBBFiIOEANBAwwMCyAIQQF0IAdyIBJBAWoiEi0AgANrIghBAE4NDCASQQF0LwHAAiAIQQF0ai8BoAMhCCADQQNrQQF2DgIABQYLIAhBEEkEQCAIIAogC09BBHRqIREgCkEBagwCCyAIQRBGIBFsIREgCiAIQRVGQQN0aiEPIAhBDmsMCgtBASEGQQMhAyAHIA9qQQNqCyEPIBEgCiAPEAMhCkEAIAogDEkNBiAMIQ5BBQwBCyAKLQCgCCAHOgAAIApBAWoiCiANSQ0IQQMLIQNBAEHAAkGgAxADIA4hCgNAIApBAWsiCi0AACIQIBAtAIADQQFqOgCAAyAKDQALA0AgCiAKLwHAAiAKQQF2LQCAA0EBdGo7AcICIApBAmoiCkE+SQ0AC0EAIQoDQCAKLQAAQQF0IhAvAcACIhEgCjsBoAMgECARQQJqOwHAAiAKQQFqIgogDkkNAAtBACIKDAQLIAhBgAJJBEAgAiAIOgAAIAJBAWohAkEADAQLIAhBgAJGDQRBAyEVQRwhFkECIRcgCEGBAmshCAwBC0EBIhchFUEfIRYgCCALayEICyAVIBVBAWogCCAVcWogCCAXdkEBa0EAIAggFUsiGCAIIBZJIhlxGyIGdEH/ASAZGyAIIBgbaiEUIAYgBg0DGkEAIQcLIBQgB2ohFCADQQdJBH8gFCEaQQchA0EQBSACIAIgFGsgAiAaahACIQJBBSEDQQALCyESQQEhBkEAIQgMAgsgAiMBayAEDQJBAyEGQQAhAwwBCyEGIANBAWohAwwACwsLcAIAQaAICxMQERUACAcJBgoFCwQMAw0CDgEPAEHeCAtQPgAAAD80NTY3ODk6Ozw9AAAAAAAAAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZAAAAAAAAGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM=";\n\n  // node_modules/@discoveryjs/cli/lib/static/inflate/decoder.js\n  var base64alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\n  var base64map = new Uint8Array(256);\n  var encoder = new TextEncoder();\n  var inflateWasmApi = null;\n  for (let i = 0; i < base64alphabet.length; i++) {\n    base64map[base64alphabet.charCodeAt(i)] = i;\n  }\n  function decodeBase64(input) {\n    let inputSize = input.length;\n    while (inputSize > 0 && input[inputSize - 1] === "=") {\n      inputSize--;\n    }\n    let output = new Uint8Array(3 * Math.ceil(inputSize / 4));\n    let enc1;\n    let enc2;\n    let enc3;\n    let enc4;\n    for (let i = 0, j2 = 0; i < inputSize; ) {\n      enc1 = base64map[input.charCodeAt(i++) & 255];\n      enc2 = base64map[input.charCodeAt(i++) & 255];\n      enc3 = base64map[input.charCodeAt(i++) & 255];\n      enc4 = base64map[input.charCodeAt(i++) & 255];\n      output[j2++] = enc1 << 2 | enc2 >> 4;\n      output[j2++] = enc2 << 4 | enc3 >> 2;\n      output[j2++] = enc3 << 6 | enc4;\n    }\n    return output.subarray(\n      0,\n      // output size:\n      // (length / 4) * 3 +\n      (inputSize >> 2) * 3 + // (length % 4) * 6 / 8\n      (inputSize % 4 * 6 >> 3)\n    );\n  }\n  function createWasmModule(source, imports = {}) {\n    const sourceBytes = decodeBase64(source);\n    const importObject = { imports };\n    const module = new WebAssembly.Module(sourceBytes);\n    return new WebAssembly.Instance(module, importObject);\n  }\n  function initInflateWasmApi() {\n    const memory = new WebAssembly.Memory({ initial: 32 });\n    const inflateModule = createWasmModule(inflate_default, { memory });\n    const { inputOffset, outputOffset, inflate: inflate2 } = inflateModule.exports;\n    const inputMem = new Uint8Array(memory.buffer, inputOffset, outputOffset);\n    const outputMem = new Uint8Array(memory.buffer, outputOffset);\n    return function(base64chunk) {\n      const size = inflate2(encoder.encodeInto(base64chunk, inputMem).written);\n      return outputMem.subarray(0, size);\n    };\n  }\n  function inflate(base64chunk) {\n    if (inflateWasmApi === null) {\n      inflateWasmApi = initInflateWasmApi();\n    }\n    return inflateWasmApi(base64chunk);\n  }\n\n  // node_modules/@discoveryjs/cli/lib/static/common.js\n  var loadStyle = true ? (url) => document.querySelector(`style[type="discovery/style"][src=${JSON.stringify(url)}]`).firstChild.nodeValue : (url) => ({ type: "link", href: url });\n  function load(module, styles3, setup5, dataLoaderOptions) {\n    const container = document.body;\n    const dataRequestId = String(Math.random()).slice(2, 18).padStart(16, "0");\n    const loadData2 = preloader({\n      ...dataLoaderOptions,\n      loadDataOptions: {\n        ...dataLoaderOptions.loadDataOptions,\n        encodings: dataLoaderOptions.encodings,\n        fetch: { headers: {\n          // using Cache-Control to prevent stalling requests in Chromium & Safari\n          // see https://stackoverflow.com/questions/27513994/chrome-stalls-when-making-multiple-requests-to-same-resource\n          "Cache-Control": "no-cache, no-transform",\n          "x-data-request-id": dataRequestId\n        } }\n      },\n      container\n    });\n    alterLoaderPush();\n    if (dataLoaderOptions.dataSource === "url" && dataLoaderOptions.data) {\n      awaitingDataStatus(loadData2, dataRequestId);\n    }\n    return Promise.all([\n      module,\n      loadData2\n    ]).then(\n      ([init, dataset]) => init({ ...setup5, styles: styles3 }, loadData2.progressbar, loadData2.disposeEmbed?.(), dataset)\n    ).then(() => {\n      loadData2.el.remove();\n    }, (error) => {\n      const discoveryEl = document.querySelector("body > .discovery");\n      const actionButtonsEl = document.createElement("div");\n      if (false) {\n        const resetBtn = document.createElement("button", "view-button");\n        resetBtn.className = "view-button";\n        resetBtn.innerHTML = "Reload with no cache";\n        resetBtn.onclick = () => fetch("drop-cache").then(() => location.reload());\n        actionButtonsEl.append(resetBtn);\n      }\n      if (actionButtonsEl.firstChild) {\n        actionButtonsEl.className = "action-buttons";\n        loadData2.progressbar.el.before(actionButtonsEl);\n      }\n      if (!error.supressLoadDataError) {\n        const el = document.createElement("pre");\n        const errorText = String(error);\n        let errorStack = String(error.stack || "");\n        if (errorStack.startsWith(errorText)) {\n          errorStack = errorStack.slice(errorText.length);\n        }\n        el.className = "error";\n        el.append(\n          document.createTextNode("[ERROR] " + errorText + (errorStack ? "\\n" + errorStack.replace(/^[\\r\\n]+/, "") : ""))\n        );\n        loadData2.progressbar.el.replaceWith(el);\n      }\n      loadData2.disposeEmbed?.();\n      loadData2.progressbar.dispose();\n      discoveryEl && discoveryEl.remove();\n    });\n  }\n  function alterLoaderPush() {\n    const decoder = new TextDecoder();\n    const { push: origLoaderPush } = window.discoveryLoader || {};\n    if (typeof origLoaderPush === "function") {\n      window.discoveryLoader.push = function(chunk, binary2, compressed) {\n        if (compressed) {\n          chunk = binary2 ? inflate(chunk).slice() : decoder.decode(inflate(chunk));\n        } else if (binary2) {\n          chunk = decodeBase64(chunk);\n        }\n        origLoaderPush(chunk);\n      };\n    }\n  }\n  function awaitingDataStatus(loadData2, dataRequestId) {\n    let supressLoadDataError = false;\n    let allowServerTimeUpdate = true;\n    const dataStatusEl = document.createElement("div");\n    const dataStatusListenInit = setTimeout(() => {\n      if (loadData2.progressbar.lastStage !== "request") {\n        return;\n      }\n      const progressbarOnTiming = loadData2.progressbar.onTiming;\n      const dataStatusEventSource = new EventSource("data-status?data-request-id=" + dataRequestId);\n      let planTreeMap;\n      let startTime;\n      let serverTime;\n      let optimisticServerTimeUpdateTimer;\n      let optimisticServerTimeUpdateFrom;\n      let lastStderrEl;\n      const updateServerTime = (newServerTime) => {\n        if (!allowServerTimeUpdate || !isFinite(newServerTime) || serverTime !== void 0 && newServerTime <= serverTime) {\n          return;\n        }\n        clearTimeout(optimisticServerTimeUpdateTimer);\n        serverTime = Number(newServerTime);\n        if (startTime && serverTime - startTime >= 1e3) {\n          dataStatusEl.querySelector(":scope > .header > .elapsed-time").textContent = duration(serverTime - startTime, supressLoadDataError ? 1 : 0);\n        }\n        if (planTreeMap) {\n          for (const { started, elapsedTimeEl } of planTreeMap.values()) {\n            if (started) {\n              elapsedTimeEl.textContent = duration(serverTime - started, 1);\n            }\n          }\n        }\n        optimisticServerTimeUpdateFrom = Date.now();\n        optimisticServerTimeUpdateTimer = setTimeout(\n          () => updateServerTime(serverTime + (Date.now() - optimisticServerTimeUpdateFrom) - 5),\n          42\n        );\n      };\n      dataStatusEventSource.addEventListener("open", () => {\n        dataStatusEl.classList.remove("init");\n      }, { once: true });\n      dataStatusEventSource.addEventListener("message", (message) => {\n        try {\n          const data = JSON.parse(message.data);\n          switch (data.type) {\n            case "start":\n              startTime = data.timestamp;\n              break;\n            case "finish":\n              break;\n            case "crash":\n              supressLoadDataError = true;\n              if (planTreeMap) {\n                for (const { started, el } of planTreeMap.values()) {\n                  if (started) {\n                    el.classList.add("crashed");\n                    el.classList.remove("started");\n                    el.classList.toggle("collapsed", el !== lastStderrEl);\n                  }\n                }\n              }\n              break;\n            case "stderr":\n            case "stdout": {\n              const frameEl = document.createElement("div");\n              frameEl.className = data.type;\n              frameEl.append(document.createTextNode(data.chunk));\n              if (!planTreeMap) {\n                dataStatusEl.lastChild.append(frameEl);\n                scrollIntoViewIfNeeded(frameEl);\n              } else {\n                const step = planTreeMap.get(data.stepId);\n                if (step) {\n                  step.contentEl.append(frameEl);\n                  step.el.classList.add("has-output");\n                  scrollIntoViewIfNeeded(frameEl);\n                  if (data.type == "stderr") {\n                    lastStderrEl = step.el;\n                  }\n                }\n              }\n              break;\n            }\n            case "plan": {\n              const planTree = createPlanTree(data.plan.steps);\n              planTreeMap = planTree.map;\n              dataStatusEl.lastChild.innerHTML = "";\n              dataStatusEl.lastChild.appendChild(planTree.el);\n              break;\n            }\n            case "plan-step-event": {\n              const step = planTreeMap.get(data.stepId);\n              if (step) {\n                switch (data.stepEvent) {\n                  case "start":\n                    step.started = data.timestamp;\n                    step.el.classList.add("started");\n                    scrollIntoViewIfNeeded(step.el);\n                    break;\n                  case "finish":\n                    step.elapsedTimeEl.textContent = duration(data.timestamp - step.started);\n                    step.started = false;\n                    step.el.classList.remove("started");\n                    step.el.classList.add("finished");\n                    break;\n                  case "summary":\n                    step.summaryEl.innerHTML = numDelim(data.data);\n                    break;\n                  default:\n                    console.warn("Unhandled data status SSE pipeline step event", data);\n                }\n              } else {\n                console.warn("Pipeline step not found", data);\n              }\n              break;\n            }\n            default:\n              console.warn("Unhandled data status SSE event", data);\n          }\n          updateServerTime(data.timestamp);\n        } catch (e) {\n          console.error("SSE message parse error", e);\n        }\n      });\n      dataStatusEventSource.addEventListener("server-time", ({ data }) => {\n        updateServerTime(data);\n      });\n      dataStatusEventSource.addEventListener("done", () => {\n        dataStatusEventSource.close();\n        allowServerTimeUpdate = false;\n      });\n      loadData2.progressbar.onTiming = (timing) => {\n        progressbarOnTiming(timing);\n        if (timing.lastStage !== "request") {\n          dataStatusEl.classList.add("finished");\n          dataStatusEventSource.close();\n          allowServerTimeUpdate = false;\n        }\n      };\n    }, 150);\n    dataStatusEl.className = "data-status init";\n    dataStatusEl.innerHTML = \'<div class="header">Getting data: <span class="elapsed-time"></span></div><div class="output"></div>\';\n    dataStatusEl.firstChild.addEventListener("click", function() {\n      dataStatusEl.classList.toggle("collapsed");\n    }, true);\n    loadData2.progressbar.el.append(dataStatusEl);\n    loadData2.then(\n      () => clearTimeout(dataStatusListenInit),\n      (error) => {\n        allowServerTimeUpdate = false;\n        if (dataStatusEl.classList.contains("init")) {\n          return;\n        }\n        loadData2.progressbar.el.after(dataStatusEl);\n        dataStatusEl.classList.add("crashed");\n        dataStatusEl.firstChild.firstChild.textContent = "Getting data failed in ";\n        if (supressLoadDataError) {\n          error.supressLoadDataError = true;\n          loadData2.el.classList.add("generate-data-crash");\n        } else {\n          dataStatusEl.classList.add("compliment-error", "collapsed");\n        }\n        for (const el of dataStatusEl.querySelectorAll(".plan-step.started")) {\n          el.classList.remove("started");\n        }\n      }\n    );\n  }\n  function scrollIntoViewIfNeeded(el) {\n    try {\n      if (typeof el.scrollIntoViewIfNeeded === "function") {\n        el.scrollIntoViewIfNeeded(false);\n      } else {\n        el.scrollIntoView({ block: "nearest" });\n      }\n    } catch (e) {\n    }\n  }\n  function createPlanTree(steps, level = 0, map2 = /* @__PURE__ */ new Map()) {\n    const listEl = document.createElement("ul");\n    listEl.className = "plan-step-list";\n    listEl.style.setProperty("--level", level);\n    for (const step of steps) {\n      const stepEl = listEl.appendChild(document.createElement("li"));\n      const stepHeaderEl = stepEl.appendChild(document.createElement("div"));\n      const stepHeaderToggleEl = stepHeaderEl.appendChild(document.createElement("span"));\n      const stepHeaderStatusEl = stepHeaderEl.appendChild(document.createElement("span"));\n      const stepHeaderContentEl = stepHeaderEl.appendChild(document.createElement("span"));\n      const stepHeaderSummaryEl = stepHeaderEl.appendChild(document.createElement("span"));\n      const stepHeaderElapsedTimeEl = stepHeaderEl.appendChild(document.createElement("span"));\n      const stepContentEl = stepEl.appendChild(document.createElement("div"));\n      map2.set(step.id, {\n        step,\n        el: stepEl,\n        elapsedTimeEl: stepHeaderElapsedTimeEl,\n        summaryEl: stepHeaderSummaryEl,\n        contentEl: stepContentEl,\n        started: false\n      });\n      stepEl.className = "plan-step collapsed";\n      stepHeaderEl.className = "plan-step__header";\n      stepHeaderEl.addEventListener("click", () => stepEl.classList.toggle("collapsed"));\n      stepHeaderToggleEl.className = "plan-step__header-toggle";\n      stepHeaderStatusEl.className = "plan-step__header-status";\n      stepHeaderContentEl.className = "plan-step__header-content";\n      stepHeaderContentEl.textContent = step.name || "Untitled";\n      stepHeaderSummaryEl.className = "plan-step__header-summary";\n      stepHeaderElapsedTimeEl.className = "plan-step__elapsed-time";\n      stepContentEl.className = "plan-step__content";\n      if (step.steps) {\n        stepEl.append(createPlanTree(step.steps, level + 1, map2).el);\n      }\n    }\n    return { el: listEl, map: map2 };\n  }\n  function escapeHtml(str) {\n    return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");\n  }\n  function numDelim(value, escape2 = true) {\n    const strValue = escape2 && typeof value !== "number" ? escapeHtml(String(value)) : String(value);\n    if (strValue.length > 3) {\n      return strValue.replace(\n        /\\.\\d+(eE[-+]?\\d+)?|\\B(?=(\\d{3})+(\\D|$))/g,\n        (m2) => m2 || \'<span class="num-delim"></span>\'\n      );\n    }\n    return strValue;\n  }\n  function duration(value, prec = 1) {\n    if (value < 1e3) {\n      return value + "ms";\n    }\n    if (value < 1e4) {\n      return (value / 1e3).toFixed(prec) + "s";\n    }\n    if (value < 6e4) {\n      return Math.round(value / 1e3) + "s";\n    }\n    return `${Math.floor(value / 6e4)}:${String(Math.floor(value / 1e3) % 60).padStart(2, "0")}`;\n  }\n\n  // discovery-cli:default/model-loader.js\n  load(\n    Promise.resolve().then(() => (init_model(), model_exports)).then((module) => module.default),\n    [loadStyle(setup_default.assets["model.css"])],\n    setup_default,\n    {\n      styles: [loadStyle(setup_default.assets["model-loader.css"])],\n      embed: setup_default.model.embed,\n      darkmode: setup_default.model.darkmode,\n      darkmodePersistent: setup_default.model.darkmodePersistent,\n      encodings: encodings_default,\n      ...true ? {\n        dataSource: "push",\n        data: Boolean(setup_default.model.data) || null\n      } : {\n        dataSource: "url",\n        data: setup_default.model.data\n      }\n    }\n  );\n})();\n</script>\n</body>\n'
